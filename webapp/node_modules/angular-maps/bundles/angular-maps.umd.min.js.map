{"version":3,"sources":["ng://angular-maps/src/models/info-window.ts","ng://angular-maps/src/models/marker.ts","ng://angular-maps/src/models/layer.ts","ng://angular-maps/src/models/polygon.ts","ng://angular-maps/src/models/polyline.ts","null","ng://angular-maps/src/models/spider-cluster-marker.ts","ng://angular-maps/src/models/canvas-overlay.ts","ng://angular-maps/src/models/bing/bing-layer.ts","ng://angular-maps/src/services/bing/bing-conversions.ts","ng://angular-maps/src/models/bing/bing-marker.ts","ng://angular-maps/src/models/bing/bing-spider-cluster-marker.ts","ng://angular-maps/src/models/bing/bing-cluster-layer.ts","ng://angular-maps/src/models/bing/bing-info-window.ts","ng://angular-maps/src/models/map-label.ts","ng://angular-maps/src/models/extender.ts","ng://angular-maps/src/models/bing/bing-label.ts","ng://angular-maps/src/models/bing/bing-polygon.ts","ng://angular-maps/src/models/bing/bing-polyline.ts","ng://angular-maps/src/models/bing/bing-events-lookup.ts","ng://angular-maps/src/models/bing/bing-canvas-overlay.ts","ng://angular-maps/src/services/google/google-conversions.ts","ng://angular-maps/src/models/google/google-info-window.ts","ng://angular-maps/src/models/google/google-marker.ts","ng://angular-maps/src/models/google/google-label.ts","ng://angular-maps/src/models/google/google-polygon.ts","ng://angular-maps/src/models/google/google-polyline.ts","ng://angular-maps/src/models/google/google-events-lookup.ts","ng://angular-maps/src/models/google/google-canvas-overlay.ts","ng://angular-maps/src/services/mapservicefactory.ts","ng://angular-maps/src/services/map.service.ts","ng://angular-maps/src/services/marker.service.ts","ng://angular-maps/src/services/infobox.service.ts","ng://angular-maps/src/services/layer.service.ts","ng://angular-maps/src/services/polygon.service.ts","ng://angular-maps/src/services/polyline.service.ts","ng://angular-maps/src/services/cluster.service.ts","ng://angular-maps/src/components/infobox-action.ts","ng://angular-maps/src/components/infobox.ts","ng://angular-maps/src/components/map-marker.ts","ng://angular-maps/src/components/map.ts","ng://angular-maps/src/components/map-layer.ts","ng://angular-maps/src/components/cluster-layer.ts","ng://angular-maps/src/components/map-polygon.ts","ng://angular-maps/src/components/map-polyline.ts","ng://angular-maps/src/components/map-marker-layer.ts","ng://angular-maps/src/components/map-polygon-layer.ts","ng://angular-maps/src/components/map-polyline-layer.ts","ng://angular-maps/src/services/mapapiloader.ts","ng://angular-maps/src/services/bing/bing-map.api-loader.service.ts","ng://angular-maps/src/services/bing/bing-infobox.service.ts","ng://angular-maps/src/services/bing/bing-marker.service.ts","ng://angular-maps/src/services/bing/bing-map.service.ts","ng://angular-maps/src/services/bing/bing-layer-base.ts","ng://angular-maps/src/services/bing/bing-layer.service.ts","ng://angular-maps/src/services/bing/bing-cluster.service.ts","ng://angular-maps/src/services/bing/bing-polygon.service.ts","ng://angular-maps/src/services/bing/bing-polyline.service.ts","ng://angular-maps/src/services/bing/bing-map.service.factory.ts","ng://angular-maps/src/services/google/google-layer-base.ts","ng://angular-maps/src/services/google/google-cluster.service.ts","ng://angular-maps/src/services/google/google-infobox.service.ts","ng://angular-maps/src/models/google/google-layer.ts","ng://angular-maps/src/services/google/google-layer.service.ts","ng://angular-maps/src/services/google/google-map-api-loader.service.ts","ng://angular-maps/src/services/google/google-marker.service.ts","ng://angular-maps/src/models/google/google-marker-clusterer.ts","ng://angular-maps/src/services/google/google-map.service.ts","ng://angular-maps/src/services/google/google-polygon.service.ts","ng://angular-maps/src/services/google/google-polyline.service.ts","ng://angular-maps/src/services/google/google-map.service.factory.ts","ng://angular-maps/index.ts"],"names":["InfoWindow","Marker","CreateMarker","iconInfo","markerType","MarkerTypeId","CanvasMarker","CreateCanvasMarker","DynamicCircleMarker","CreateDynamicCircleMarker","FontMarker","CreateFontBasedMarker","RotatedImageMarker","CreateRotatedImageMarker","RoundedImageMarker","CreateRoundedImageMarker","ScaledImageMarker","CreateScaledImageMarker","Custom","Error","GetImageForMarker","icon","img","ImageElementCache","get","document","createElement","src","set","size","points","id","MarkerCache","has","mi","markerSize","markerIconString","c","ctx","getContext","width","height","rotation","translate","rotate","Math","PI","fillStyle","color","beginPath","drawingOffset","moveTo","x","y","forEach","p","lineTo","closePath","fill","stroke","s","toDataURL","strokeWidth","toString","join","fontName","fontSize","font","measureText","text","textBaseline","fillText","url","image","Image","Promise","resolve","reject","crossOrigin","onload","rads","ceil","abs","cos","sin","drawImage","radius","offset","arc","clip","scale","Map","Layer","Polygon","prototype","this","_center","GetBoundingCenter","_centroid","GetPolygonCentroid","latitude","longitude","x1","x2","y1","y2","path","GetPaths","inner","off","twicearea","p1","p2","f","k","length","i","j","Polyline","GetPolylineCentroid","GetPath","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","hasOwnProperty","__extends","__","constructor","create","__read","o","n","m","Symbol","iterator","r","e","call","ar","next","done","push","value","error","__spread","arguments","concat","SpiderClusterMarker","_super","tslib_1.__extends","CanvasOverlay","drawCallback","_this","_readyResolver","_drawCallback","_canvasReady","Delete","SetMap","OnAdd","_canvas","style","position","left","top","SetCanvasElement","OnRemove","RemoveEventHandlers","Redraw","clear","Resize","UpdatePosition","w","h","BingLayer","_layer","_maps","AddListener","eventType","fn","Microsoft","Maps","Events","addHandler","AddEntity","entity","NativePrimitve","GetVisible","add","_pendingEntities","AddEntities","entities","isArray","eachSeries","nextTick","DeleteLayer","GetOptions","Number","getId","getVisible","RemoveEntity","remove","SetEntities","setPrimitives","SetOptions","options","metadata","SetVisible","visible","setVisible","splice","BingConversions","TranslateAction","action","eventHandler","label","TranslateActions","actions","a","TranslateBounds","box","LocationRect","fromEdges","maxLatitude","minLongitude","minLatitude","maxLongitude","TranslateClusterOptions","keys","filter","_clusterOptionsAttributes","indexOf","layerOffset","TranslatePoint","placementMode","ClusterPlacementMode","FirstPin","ClusterPlacementType","FirstLocation","MeanAverage","TranslateInfoBoxOptions","_infoWindowOptionsAttributes","pixelOffset","location","TranslateLocation","TranslateLoadOptions","_mapOptionsAttributes","_viewOptionsAttributes","center","mapTypeId","MapTypeId","hybrid","aerial","labelOverlay","LabelOverlay","hidden","bounds","latlong","Location","TranslateMarkerOptions","_markerOptionsAttributes","anchor","TranslateOptions","TranslatePaths","paths","_p","point","Point","TranslatePolygonOptions","exec","z","substr","parseInt","_polygonOptionsAttributes","strokeThickness","strokeWeight","strokeOpacity","strokeColor","fillOpacity","fillColor","TranslatePolylineOptions","_polylineOptionsAttributes","TranslateViewOptions","centerOffset","BingMarker","_pushpin","_map","_isFirst","val","_isLast","l","getLocation","_metadata","DeleteMarker","GetLabel","getText","SetAnchor","setOptions","SetDraggable","draggable","SetIcon","SetLabel","SetPosition","latLng","setLocation","SetTitle","title","BingSpiderClusterMarker","BingClusterLayer","circleSpiralSwitchover","collapseClusterOnMapChange","collapseClusterOnNthClick","invokeClickOnHover","minCircleLength","minSpiralAngleSeperation","spiralDistanceFactor","stickStyle","stickHoverStyle","markerSelected","markerUnSelected","isMarker","IsFirst","StopClustering","_isClustering","getPushpins","setPushpins","_markers","_pendingMarkers","_markerLookup","IsLast","StartClustering","map","apply","_a","_b","InitializeSpiderClusterSupport","_useSpiderCluster","MapInstance","_spiderLayer","_currentZoom","getZoom","SetSpiderOptions","layers","insert","_events","OnMapClick","OnMapViewChangeStart","OnMapViewChangeEnd","OnLayerClick","OnSpiderMouseOver","OnSpiderMouseOut","MapPromise","then","removeHandler","_spiderMarkers","GetMarkerFromBingMarker","pin","getOptions","gridSize","clusteringEnabled","callback","clusteredPinCallback","zIndex","GetSpiderMarkerFromBingMarker","_spiderMarkerLookup","delete","spiderClusterOptions","GetBasicPushpinOptions","getAnchor","getColor","cursor","getCursor","getIcon","roundClickableArea","getRoundClickableArea","subTitle","getSubTitle","textOffset","getTextOffset","getTitle","HideSpiderCluster","_mapclicks","_currentCluster","_spiderOptions","primitive","ClusterPushpin","showNewCluster","ShowSpiderCluster","isClusterMarker","ParentMarker","ppin","hasHandler","invoke","hasZoomChanged","Pushpin","Stick","cluster","containedPushpins","pins","centerPoint","tryLocationToPixel","PixelReference","control","stick","angle","makeSpiral","legPixelLength","stepAngle","stepLength","len","loc","tryPixelToLocation","spiderMarker","BingInfoWindow","_infoBox","_isOpen","eventName","Close","GetPosition","Open","MapLabel","Set","SetValues","Changed","prop","shouldRunDrawCanvas","shouldRunDraw","DrawCanvas","Draw","minZoom","Get","maxZoom","undefined","GetMap","mapZoom","clearRect","strokeStyle","backgroundColor","textWidth","lineWidth","strokeText","fillRect","marginLeft","GetMarginLeft","marginTop","pointerEvents","parentNode","removeChild","Extender","obj","_obj","_proto","Extend","newObj","property","defineProperty","newProperty","BingMapLabel","_options","beneathLabels","fontFamily","fontColor","key","getMap","visibility","pos","lineJoin","setHtmlElement","OnLoad","BingPolygon","_polygon","_mapService","_originalPath","_maxZoom","ManageLabel","_minZoom","_showLabel","_showTooltip","ManageTooltip","_title","handlerId_1","_editingCompleteEmitter","_label","_tooltip","GetDraggable","GetEditable","_isEditable","getLocations","getRings","SetEditable","editable","isChanged","GetDrawingTools","t","edit","finish","editedPolygon","newPath","originalPath","SetPaths","Click","OriginalPath","NewPath","SetPath","setLocations","setRings","p_1","Centroid","align","_hasToolTipReceiver","_mouseOverListener","_tooltipVisible","_mouseMoveListener","_mouseOutListener","BingPolyline","_polyline","BingMapEventsLookup","click","dblclick","rightclick","resize","boundschanged","centerchanged","zoomchanged","mouseover","mouseout","mousemove","infowindowclose","BingCanvasOverlay","GetCoordinatesFromClick","GetToolTipOverlay","_zoomStart","_centerStart","getCenter","_viewChangeEvent","getMapTypeId","streetside","display","zoomCurrent","centerCurrent","pow","newWidth","getWidth","newHeight","getHeight","pixelPoints","centerOffsetX","centerOffsetY","_viewChangeEndEvent","UpdateCanvas","_mapResizeEvent","el","GoogleConversions","east","north","south","west","TranslateInfoWindowOptions","content","description","lat","lng","TranslateLatLng","latlng","TranslateLocationObject","google","maps","LatLng","TranslateLatLngObject","TranslateLocationObjectArray","latlongArray","TranslateMapTypeId","road","GoogleMapTypes.MapTypeId","roadmap","grayscale","terrain","ordnanceSurvey","satellite","gestureHandling","zoomControl","mapTypeControl","styles","GoogleInfoWindow","_infoWindow","addListener","close","getPosition","open","setPosition","GoogleMarker","_marker","setMap","getLabel","setDraggable","setIcon","setLabel","setTitle","GoogleMapLabel","setValues","projection","getProjection","fromLatLngToDivPixel","panes","getPanes","overlayLayer","appendChild","GooglePolygon","getDraggable","getEditable","getPath","getPaths","previous","setEditable","setPath","setPaths","event","removeListener","GooglePolyline","GoogleMapEventsLookup","GoogleCanvasOverlay","OnDraw","getDiv","offsetWidth","offsetHeight","cc","Injectable","MapService","GetRandonLocations","count","_getRandomLocation","random","crossesDateLine","LayerService","EventEmitter","Directive","args","selector","Input","Output","infoBoxId","InfoBoxComponent","_infoBoxService","_content","nativeElement","innerText","trim","outerHTML","_id","InfoBoxClose","emit","ngAfterViewInit","AddInfoWindow","_infoBoxAddedToManager","HandleEvents","ngOnChanges","changes","Latitude","Longitude","currentValue","SetInfoWindowOptions","ngOnDestroy","DeleteInfoWindow","ToString","CreateEventObservable","subscribe","Title","Description","disableAutoPan","DisableAutoPan","Visible","xOffset","yOffset","Component","template","encapsulation","ViewEncapsulation","None","InfoBoxService","ViewChild","ContentChildren","InfoBoxActionDirective","markerId","MapMarkerDirective","_markerService","_containerRef","_markerAddedToManger","_inClusterLayer","_inCustomLayer","_layerId","LocationToPixel","LocationToPoint","ngAfterContentInit","HostMarker","element","parentElement","parentName","tagName","toLowerCase","attributes","AddMarker","AddEventListeners","UpdateMarkerPosition","UpdateTitle","UpdateLabel","UpdateDraggable","UpdateIcon","UpdateAnchor","UpdateVisible","unsubscribe","_getEventArg","Pixels","GetPixelsFromClick","_clickTimeout","timer","MarkerClick","DblClick","name","handler","ev","Drag","DragEnd","DragStart","MouseDown","MouseMove","MouseOut","MouseOver","MouseUp","RightClick","os","MarkerService","ViewContainerRef","ContentChild","MapComponent","_zone","_box","_longitude","_latitude","ConvertToDecimal","UpdateCenter","_zoom","SetZoom","ngOnInit","InitMapInstance","_container","_mapPromise","SetViewOptions","SetMapOptions","DisposeMap","TriggerResize","setTimeout","TriggerMapEvent","defaultValue","parseFloat","HandleMapClickEvents","SubscribeToMapEvent","MapClick","clearTimeout","MapDblClick","MapRightClick","MapMouseOver","MapMouseOut","MapMouseMove","HandleMapBoundsChange","GetBounds","BoundsChange","HandleMapCenterChange","GetCenter","CenterChange","HandleMapZoomChange","GetZoom","ZoomChange","runOutsideAngular","zoom","CreateMap","SetCenter","providers","provide","deps","MapServiceFactory","useFactory","MapServiceCreator","ClusterService","MarkerServiceFactory","InfoBoxServiceFactory","LayerServiceFactory","ClusterServiceFactory","PolygonService","PolygonServiceFactory","PolylineService","PolylineServiceFactory","changeDetection","ChangeDetectionStrategy","OnPush","NgZone","HostBinding","CreateClusterService","ma","CreateInfoBoxService","CreateLayerService","Create","CreateMarkerService","CreatePolygonService","CreatePolylineService","layerId","MapLayerDirective","_layerService","_visible","AddLayer","_addedToManager","GetNativeLayer","ClusterLayerDirective","MeanValue","ClusterClickAction","ZoomIntoCluster","MAX_SAFE_INTEGER","_clusterClickAction","_clusteringEnabled","_clusterPlacementMode","_iconCreationCallback","_useDynamicSizeMarker","_dynamicMarkerBaseSize","_dynamicMarkerRanges","_gridSize","_iconInfo","_layerOffset","_minimumClusterSize","_spiderClusterOptions","_styles","info","CreateDynamicSizeMarker","_zIndex","_zoomOnClick","baseMarkerSize","ranges","mr","outline","total","log","v","svg","markerOffsetRatio","polygonId","MapPolygonDirective","_polygonService","_addedToService","AddPolygon","GeneratePolygonChangeSet","isFirstChange","UpdatePolygon","DeletePolygon","PathChanged","hasOptions","clickable","Clickable","Draggable","Editable","FillColor","FillOpacity","geodesic","Geodesic","labelMaxZoom","LabelMaxZoom","labelMinZoom","LabelMinZoom","showTooltip","ShowTooltip","showLabel","ShowLabel","StrokeColor","StrokeOpacity","StrokeWeight","polylineId","MapPolylineDirective","_polylineService","AddPolyline","GeneratePolylineChangeSet","UpdatePolyline","DeletePolyline","MapMarkerLayerDirective","_clusterService","_streaming","_markersLast","slice","fakeLayerDirective","Id","EnableClustering","LayerOffset","ZIndex","ClusteringEnabled","GridSize","IconInfo","ClusterIconInfo","CustomMarkerCallback","UseDynamicSizeMarkers","_layerPromise","_service","MarkerOptions","UpdateMarkers","shouldSetOptions","firstChange","zoomOnClick","markers","CreateMarkers","marker","MapPolygonLayerDirective","_polygons","_polygonsLast","all","CreateCanvasOverlay","DrawLabels","values","ShowTooltips","PolygonOptions","UpdatePolygons","_tooltipSubscriptions","PolygonClick","PolygonDblClick","PolygonMouseMove","PolygonMouseOut","PolygonMouseOver","ShowLabels","ctx_1","labels_1","_labels","LocationsToPoints","locs","MapSize","DrawText","lo","LabelOptions","DefaultLabelStyle","_defaultOptions","textAlign","show","asObservable","polygons","CreatePolygons","poly","MapPolylineLayerDirective","_polylines","_polylinesLast","PolylineOptions","UpdatePolylines","PolylineClick","PolylineDblClick","PolylineMouseMove","PolylineMouseOut","PolylineMouseOver","polylines","CreatePolylines","title_1","centroids_1","DocumentRef","GetNativeDocument","WindowRef","GetNativeWindow","window","ScriptProtocol","HTTPS","DEFAULT_CONFIGURATION","BingMapAPILoaderConfig","BingMapAPILoader","_config","_windowRef","_documentRef","Load","_scriptLoadingPromise","script","type","async","defer","callbackName","Date","getMilliseconds","GetScriptSrc","onerror","head","protocol","AUTO","HTTP","hostAndPath","queryParams","branch","decorators","Optional","MapAPILoader","BingInfoBoxService","InfoWindowActions","Label","ActionClicked","HtmlContent","htmlContent","infoPromise","CreateInfoWindow","_boxes","infoComponent","eventNameTranslated","Observable","observer","run","CloseInfoBoxesOnOpen","Modal","IsOpen","BingMarkerService","IconUrl","isFirst","IsFirstInSet","isLast","IsLastInSet","Width","Height","Anchor","Metadata","markerPromise","InClusterLayer","LayerId","InCustomLayer","DynamicMarkerCreated","Subject","GetNativeMarker","target","payload","BingMapService","_loader","_mapResolver","Config","_modules","_mapInstance","overlay","CreateClusterLayer","LoadModule","bl","layer","ClusterLayer","infoBox","Infobox","CreateLayer","mapOptions","CustomOverlay","credentials","apiKey","pushpin","CreatePolygon","CreatePolyline","polyline","pl_1","lines_1","pl","dispose","getBounds","getNorth","crossesInternationalDateLine","getWest","getEast","getSouth","padding","useSharedInstance","LoadModuleInstance","moduleName","loadModule","lastIndexOf","setView","BingLayerBase","GetLayerById","markerIcon","op","mo","_layers","l1","BingLayerService","layerPromise","polygon","line","polyline_1","lines_2","BingClusterService","CreateClusterPushPin","CreateCustomClusterPushPin","SpiderClusterOptions","o_1","payload_1","ico","Spider","bounds_1","locs_1","fromLocations","BingPolygonService","polygonPromise","Paths","GetNativePolygon","BingPolylineService","polylinePromise","Path","GetNativePolyline","index","BingMapServiceFactory","BingMapServiceFactoryFactory","apiLoader","zone","BingMapLoaderFactory","GoogleLayerBase","mp","lp","GoogleClusterService","CreateClusterIcons","pa","MinimumClusterSize","minimumClusterSize","Styles","textColor","textSize","backgroundPosition","resetStyles","clusterer","_layerStyles","setStyles","setCalculator","GoogleInfoBoxService","infoWindowPromise","googleEventName","GoogleLayer","_entities","GoogleLayerService","p1_1","tslib_1.__values","p1_1_1","GoogleMapAPILoaderConfig","GoogleMapAPILoader","GetMapsScriptSrc","enableClustering","clusterScript","GetClusterScriptSrc","onreadystatechange","apiVersion","client","clientId","channel","libraries","region","language","clusterHostAndPath","entry","GoogleMarkerService","getSouthWest","getNorthEast","offsetY","fromLatLngToPoint","offsetX","floor","GoogleMarkerClusterer","addMarker","addMarkers","getMarkers","clearMarkers","GetMarkerFromGoogleMarker","getGridSize","getMaxZoom","getMinClusterSize","isAverageCenter","isZoomOnClick","getStyles","removeMarker","setMinClusterSize","resetViewport","redraw","setGridSize","setMaxZoom","p_2","GoogleMapService","updateOptions","markerClusterer","MarkerClusterer","clusterLayer","infoWindow","OverlayView","fitBounds","max","min","ll","setCenter","setZoom","trigger","GooglePolygonService","GooglePolylineService","GoogleMapServiceFactory","GoogleMapServiceFactoryFactory","GoogleMapLoaderFactory","MapModule","forRoot","mapServiceFactory","loader","ngModule","useValue","forRootBing","forRootGoogle","NgModule","declarations","imports","CommonModule","exports"],"mappings":"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","sourcesContent":["import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\n\r\nexport abstract class InfoWindow {\r\n\r\n    /**\r\n     * Gets whether the info box is currently open.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract get IsOpen(): boolean;\r\n\r\n    /**\r\n     * Get the underlying native primitive of the implementation.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    /**\r\n     * Adds an event listener to the info window.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Closes the info window.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract Close(): void ;\r\n\r\n    /**\r\n     * Gets the position of the info window.\r\n     *\r\n     * @abstract\r\n     * @returns - Returns the geo coordinates of the info window.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract GetPosition(): ILatLong;\r\n\r\n    /**\r\n     * Opens the info window.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract Open(): void;\r\n\r\n    /**\r\n     * Sets the info window options.\r\n     *\r\n     * @abstract\r\n     * @param options - Info window options to set. The options will be merged with any existing options.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract SetOptions(options: IInfoWindowOptions): void;\r\n\r\n    /**\r\n     * Sets the info window position.\r\n     *\r\n     * @abstract\r\n     * @param position - Geo coordinates to move the anchor of the info window to.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract SetPosition(position: ILatLong): void;\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { MarkerTypeId } from '../models/marker-type-id';\r\n\r\n/**\r\n * This interface defines the contract for an icon cache entry.\r\n */\r\ninterface IMarkerIconCacheEntry {\r\n    /**\r\n     * The icon string of the cache entry.\r\n     *\r\n     * @memberof IMarkerIconCacheEntry\r\n     */\r\n    markerIconString: string;\r\n\r\n    /**\r\n     * The Size of the icon.\r\n     *\r\n     * @memberof IMarkerIconCacheEntry\r\n    * */\r\n    markerSize: ISize;\r\n}\r\n\r\n/**\r\n * This class defines the contract for a marker.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Marker {\r\n\r\n    ///\r\n    /// Field definitions\r\n    ///\r\n\r\n    /**\r\n     * Caches concrete img elements for marker icons to accelerate patining.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    private static ImageElementCache: Map<string, HTMLImageElement> = new Map<string, HTMLImageElement>();\r\n\r\n\r\n    /**\r\n     * Used to cache generated markers for performance and reusability.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    private static MarkerCache: Map<string, IMarkerIconCacheEntry> = new Map<string, IMarkerIconCacheEntry>();\r\n\r\n    /**\r\n     * Creates a marker based on the marker info. In turn calls a number of internal members to\r\n     * create the actual marker.\r\n     *\r\n     * @param iconInfo - icon information. Depending on the marker type, various properties\r\n     * need to be present. For performance, it is recommended to use an id for markers that are common to facilitate\r\n     * reuse.\r\n     * @param callback - a callback that is invoked on markers that require asyncronous\r\n     * processing during creation. For markers that do not require async processing, this parameter is ignored.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image.\r\n     * @memberof Marker\r\n     */\r\n    public static CreateMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        switch (iconInfo.markerType) {\r\n            case MarkerTypeId.CanvasMarker: return Marker.CreateCanvasMarker(iconInfo);\r\n            case MarkerTypeId.DynamicCircleMarker: return Marker.CreateDynamicCircleMarker(iconInfo);\r\n            case MarkerTypeId.FontMarker: return Marker.CreateFontBasedMarker(iconInfo);\r\n            case MarkerTypeId.RotatedImageMarker: return Marker.CreateRotatedImageMarker(iconInfo);\r\n            case MarkerTypeId.RoundedImageMarker: return Marker.CreateRoundedImageMarker(iconInfo);\r\n            case MarkerTypeId.ScaledImageMarker: return Marker.CreateScaledImageMarker(iconInfo);\r\n            case MarkerTypeId.Custom: throw Error('Custom Marker Creators are not currently supported.');\r\n        }\r\n        throw Error('Unsupported marker type: ' + iconInfo.markerType);\r\n    }\r\n\r\n    /**\r\n     * Obtains a shared img element for a marker icon to prevent unecessary creation of\r\n     * DOM items. This has sped up large scale makers on Bing Maps by about 70%\r\n     * @param icon - The icon string (url, data url, svg) for which to obtain the image.\r\n     * @returns - The obtained image element.\r\n     * @memberof Marker\r\n     */\r\n    public static GetImageForMarker(icon: string): HTMLImageElement {\r\n        if (icon == null || icon === '' ) { return  null; }\r\n\r\n        let img: HTMLImageElement = null;\r\n        img = Marker.ImageElementCache.get(icon);\r\n        if (img != null) { return img; }\r\n\r\n        if (typeof(document) !== 'undefined' && document != null) {\r\n            img = document.createElement('img');\r\n            img.src = icon;\r\n            Marker.ImageElementCache.set(icon, img);\r\n        }\r\n        return img;\r\n    }\r\n\r\n    /**\r\n     * Creates a canvased based marker using the point collection contained in the iconInfo parameter.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - String with the data url for the marker image.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateCanvasMarker(iconInfo: IMarkerIconInfo): string {\r\n        if (document == null) { throw Error('Document context (window.document) is required for canvas markers.'); }\r\n        if (iconInfo == null || iconInfo.size == null || iconInfo.points == null) {\r\n            throw Error('IMarkerIconInfo.size, and IMarkerIConInfo.points are required for canvas markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const c: HTMLCanvasElement = document.createElement('canvas');\r\n        const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n        c.width = iconInfo.size.width;\r\n        c.height = iconInfo.size.height;\r\n        if (iconInfo.rotation) {\r\n            // Offset the canvas such that we will rotate around the center of our arrow\r\n            ctx.translate(c.width * 0.5, c.height * 0.5);\r\n            // Rotate the canvas by the desired heading\r\n            ctx.rotate(iconInfo.rotation * Math.PI / 180);\r\n            // Return the canvas offset back to it's original position\r\n            ctx.translate(-c.width * 0.5, -c.height * 0.5);\r\n        }\r\n\r\n        ctx.fillStyle = iconInfo.color || 'red';\r\n\r\n        // Draw a path in the shape of an arrow.\r\n        ctx.beginPath();\r\n        if (iconInfo.drawingOffset) { ctx.moveTo(iconInfo.drawingOffset.x, iconInfo.drawingOffset.y); }\r\n        iconInfo.points.forEach((p: IPoint) => { ctx.lineTo(p.x, p.y); });\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.stroke();\r\n\r\n        const s: string = c.toDataURL();\r\n        if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Creates a circle marker image using information contained in the iconInfo parameter.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - String with the data url for the marker image.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateDynamicCircleMarker(iconInfo: IMarkerIconInfo): string {\r\n        if (document == null) { throw Error('Document context (window.document) is required for dynamic circle markers.'); }\r\n        if (iconInfo == null || iconInfo.size == null) { throw Error('IMarkerIconInfo.size is required for dynamic circle markers.'); }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const strokeWidth: number = iconInfo.strokeWidth || 0;\r\n        // Create an SVG string of a circle with the specified radius and color.\r\n        const svg: Array<string> = [\r\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"',\r\n            iconInfo.size.width.toString(),\r\n            '\" height=\"',\r\n            iconInfo.size.width.toString(),\r\n            '\"><circle cx=\"',\r\n            (iconInfo.size.width / 2).toString(),\r\n            '\" cy=\"',\r\n            (iconInfo.size.width / 2).toString(),\r\n            '\" r=\"',\r\n            ((iconInfo.size.width / 2) - strokeWidth).toString(),\r\n            '\" stroke=\"',\r\n            iconInfo.color || 'red',\r\n            '\" stroke-width=\"',\r\n            strokeWidth.toString(),\r\n            '\" fill=\"',\r\n            iconInfo.color || 'red',\r\n            '\"/></svg>'\r\n        ];\r\n\r\n        const s: string = svg.join('');\r\n        if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - String with the data url for the marker image.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateFontBasedMarker(iconInfo: IMarkerIconInfo): string {\r\n        if (document == null) { throw Error('Document context (window.document) is required for font based markers'); }\r\n        if (iconInfo == null || iconInfo.fontName == null || iconInfo.fontSize == null) {\r\n            throw Error('IMarkerIconInfo.fontName, IMarkerIconInfo.fontSize and IMarkerIConInfo.text are required for font based markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const c: HTMLCanvasElement = document.createElement('canvas');\r\n        const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n        const font: string = iconInfo.fontSize + 'px ' + iconInfo.fontName;\r\n        ctx.font = font;\r\n\r\n        // Resize canvas based on sie of text.\r\n        const size: TextMetrics = ctx.measureText(iconInfo.text);\r\n        c.width = size.width;\r\n        c.height = iconInfo.fontSize;\r\n\r\n        if (iconInfo.rotation) {\r\n            // Offset the canvas such that we will rotate around the center of our arrow\r\n            ctx.translate(c.width * 0.5, c.height * 0.5);\r\n            // Rotate the canvas by the desired heading\r\n            ctx.rotate(iconInfo.rotation * Math.PI / 180);\r\n            // Return the canvas offset back to it's original position\r\n            ctx.translate(-c.width * 0.5, -c.height * 0.5);\r\n        }\r\n\r\n        // Reset font as it will be cleared by the resize.\r\n        ctx.font = font;\r\n        ctx.textBaseline = 'top';\r\n        ctx.fillStyle = iconInfo.color || 'red';\r\n\r\n        ctx.fillText(iconInfo.text, 0, 0);\r\n        iconInfo.size = { width: c.width, height: c.height };\r\n        const s: string = c.toDataURL();\r\n        if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Creates an image marker by applying a roation to a supplied image.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateRotatedImageMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        if (document == null) { throw Error('Document context (window.document) is required for rotated image markers'); }\r\n        if (iconInfo == null || iconInfo.rotation == null || iconInfo.url == null) {\r\n            throw Error('IMarkerIconInfo.rotation, IMarkerIconInfo.url are required for rotated image markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const image: HTMLImageElement = new Image();\r\n        const promise: Promise<{icon: string, iconInfo: IMarkerIconInfo}> =\r\n            new Promise<{icon: string, iconInfo: IMarkerIconInfo}>((resolve, reject) => {\r\n            // Allow cross domain image editting.\r\n            image.crossOrigin = 'anonymous';\r\n            image.src = iconInfo.url;\r\n            if (iconInfo.size) {\r\n                image.width = iconInfo.size.width;\r\n                image.height = iconInfo.size.height;\r\n            }\r\n            image.onload = function () {\r\n                const c: HTMLCanvasElement = document.createElement('canvas');\r\n                const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n                const rads: number = iconInfo.rotation * Math.PI / 180;\r\n\r\n                // Calculate rotated image size.\r\n                c.width = Math.ceil(Math.abs(image.width * Math.cos(rads)) + Math.abs(image.height * Math.sin(rads)));\r\n                c.height = Math.ceil(Math.abs(image.width * Math.sin(rads)) + Math.abs(image.height * Math.cos(rads)));\r\n\r\n                // Move to the center of the canvas.\r\n                ctx.translate(c.width / 2, c.height / 2);\r\n                // Rotate the canvas to the specified angle in degrees.\r\n                ctx.rotate(rads);\r\n                // Draw the image, since the context is rotated, the image will be rotated also.\r\n                ctx.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);\r\n                iconInfo.size = { width: c.width, height: c.height };\r\n\r\n                const s: string = c.toDataURL();\r\n                if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n                resolve({icon: s, iconInfo: iconInfo});\r\n            };\r\n        });\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Creates a rounded image marker by applying a circle mask to a supplied image.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @param iconInfo - Callback invoked once marker generation is complete. The callback\r\n     * parameters are the data uri and the IMarkerIconInfo.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateRoundedImageMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        if (document == null) { throw Error('Document context (window.document) is required for rounded image markers'); }\r\n        if (iconInfo == null || iconInfo.size == null || iconInfo.url == null) {\r\n            throw Error('IMarkerIconInfo.size, IMarkerIconInfo.url are required for rounded image markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const promise: Promise<{icon: string, iconInfo: IMarkerIconInfo}> =\r\n            new Promise<{icon: string, iconInfo: IMarkerIconInfo}>((resolve, reject) => {\r\n            const radius: number = iconInfo.size.width / 2;\r\n            const image: HTMLImageElement = new Image();\r\n            const offset: IPoint = iconInfo.drawingOffset || { x: 0, y: 0 };\r\n\r\n            // Allow cross domain image editting.\r\n            image.crossOrigin = 'anonymous';\r\n            image.src = iconInfo.url;\r\n            image.onload = function () {\r\n                const c: HTMLCanvasElement = document.createElement('canvas');\r\n                const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n                c.width = iconInfo.size.width;\r\n                c.height = iconInfo.size.width;\r\n\r\n                // Draw a circle which can be used to clip the image, then draw the image.\r\n                ctx.beginPath();\r\n                ctx.arc(radius, radius, radius, 0, 2 * Math.PI, false);\r\n                ctx.fill();\r\n                ctx.clip();\r\n                ctx.drawImage(image, offset.x, offset.y, iconInfo.size.width, iconInfo.size.width);\r\n                iconInfo.size = { width: c.width, height: c.height };\r\n\r\n                const s: string = c.toDataURL();\r\n                if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n                resolve({icon: s, iconInfo: iconInfo});\r\n            };\r\n        });\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @param iconInfo - Callback invoked once marker generation is complete. The callback\r\n     * parameters are the data uri and the IMarkerIconInfo.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateScaledImageMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        if (document == null) { throw Error('Document context (window.document) is required for scaled image markers'); }\r\n        if (iconInfo == null || iconInfo.scale == null || iconInfo.url == null) {\r\n            throw Error('IMarkerIconInfo.scale, IMarkerIconInfo.url are required for scaled image markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n        const promise: Promise<{icon: string, iconInfo: IMarkerIconInfo}> =\r\n            new Promise<{icon: string, iconInfo: IMarkerIconInfo}>((resolve, reject) => {\r\n            const image: HTMLImageElement = new Image();\r\n\r\n            // Allow cross domain image editting.\r\n            image.crossOrigin = 'anonymous';\r\n            image.src = iconInfo.url;\r\n            image.onload = function () {\r\n                const c: HTMLCanvasElement = document.createElement('canvas');\r\n                const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n                c.width = image.width * iconInfo.scale;\r\n                c.height = image.height * iconInfo.scale;\r\n\r\n                // Draw a circle which can be used to clip the image, then draw the image.\r\n                ctx.drawImage(image, 0, 0, c.width, c.height);\r\n                iconInfo.size = { width: c.width, height: c.height };\r\n\r\n                const s: string = c.toDataURL();\r\n                if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n                resolve({icon: s, iconInfo: iconInfo});\r\n            };\r\n        });\r\n        return promise;\r\n    }\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Indicates that the marker is the first marker in a set.\r\n     *\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get IsFirst(): boolean;\r\n    public abstract set IsFirst(val: boolean);\r\n\r\n    /**\r\n     * Indicates that the marker is the last marker in the set.\r\n     *\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get IsLast(): boolean;\r\n    public abstract set IsLast(val: boolean);\r\n\r\n    /**\r\n     * Gets the Location of the marker\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get Location(): ILatLong;\r\n\r\n    /**\r\n     * Gets the marker metadata.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get Metadata(): Map<string, any>;\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker (e.g. Microsoft.Maps.Pushpin)\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener to the marker.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Deletes the marker.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract DeleteMarker(): void;\r\n\r\n    /**\r\n     * Gets the marker label\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract GetLabel(): string;\r\n\r\n    /**\r\n     * Gets the marker visibility\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n    /**\r\n     * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.\r\n     *\r\n     * @abstract\r\n     * @param anchor - Point coordinates for the marker anchor.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetAnchor(anchor: IPoint): void;\r\n\r\n    /**\r\n     * Sets the draggability of a marker.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to mark the marker as draggable, false otherwise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetDraggable(draggable: boolean): void;\r\n\r\n    /**\r\n     * Sets the icon for the marker.\r\n     *\r\n     * @abstract\r\n     * @param icon - String containing the icon in various forms (url, data url, etc.)\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetIcon(icon: string): void;\r\n\r\n    /**\r\n     * Sets the marker label.\r\n     *\r\n     * @abstract\r\n     * @param label - String containing the label to set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetLabel(label: string): void;\r\n\r\n    /**\r\n     * Sets the marker position.\r\n     *\r\n     * @abstract\r\n     * @param latLng - Geo coordinates to set the marker position to.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetPosition(latLng: ILatLong): void;\r\n\r\n    /**\r\n     * Sets the marker title.\r\n     *\r\n     * @abstract\r\n     * @param title - String containing the title to set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetTitle(title: string): void;\r\n\r\n    /**\r\n     * Sets the marker options.\r\n     *\r\n     * @abstract\r\n     * @param options - {@link IMarkerOptions} object containing the marker options to set. The supplied options are\r\n     * merged with the underlying marker options.\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetOptions(options: IMarkerOptions): void;\r\n\r\n    /**\r\n     * Sets the visiblilty of the marker.\r\n     *\r\n     * @abstract\r\n     * @param visible - Boolean which determines if the marker is visible or not.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n}\r\n","import { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { Marker } from './marker';\r\nimport { Polygon } from './polygon';\r\nimport { Polyline } from './polyline';\r\nimport { InfoWindow } from './info-window';\r\n\r\n/**\r\n * Defines the contract for a map layer implementation. Deriving providers should implements this abstract\r\n * to provide concrete layer functionality for the map.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Layer {\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns - An object representing the native implementation of the layer in the underlying provider (such as\r\n     * Microsoft.Maps.Layer).\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Adds an entity to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * these concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract AddEntity(entity: Marker|InfoWindow|Polygon|Polyline): void;\r\n\r\n    /**\r\n     * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * thise concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract AddEntities(entity: Array<Marker|InfoWindow|Polygon|Polyline>): void;\r\n\r\n    /**\r\n     * Deletes the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract Delete(): void;\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns - The layer options.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract GetOptions(): ILayerOptions;\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns - True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n     /**\r\n     * Removes an entity from the cluster layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * thise concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract RemoveEntity(entity: Marker|InfoWindow|Polygon|Polyline): void;\r\n\r\n     /**\r\n     * Sets the entities for the cluster layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * thise concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.\r\n     * This replaces any existing entities.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract SetEntities(entities: Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline>): void;\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract SetOptions(options: ILayerOptions): void;\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     * @abstract\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\n\r\n/**\r\n * Abstract class defining the contract for a polygon in the architecture specific implementation.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Polygon {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _centroid: ILatLong;\r\n    protected _center: ILatLong;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Gets the polygon's center.\r\n     * @readonly\r\n     * @memberof Polygon\r\n     */\r\n    public get Center(): ILatLong {\r\n        if (this._center == null) {\r\n            this._center = this.GetBoundingCenter();\r\n        }\r\n        return this._center;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon's centroid.\r\n     * @readonly\r\n     * @memberof Polygon\r\n     */\r\n    public get Centroid(): ILatLong {\r\n        if (this._centroid == null) {\r\n            this._centroid = this.GetPolygonCentroid();\r\n        }\r\n        return this._centroid;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get LabelMaxZoom(): number;\r\n    public abstract set LabelMaxZoom(val: number);\r\n\r\n    /**\r\n     * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get LabelMinZoom(): number;\r\n    public abstract set LabelMinZoom(val: number);\r\n\r\n    /**\r\n     * Gets the polygon metadata.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Polygon\r\n     */\r\n    public abstract get Metadata(): Map<string, any>;\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polygon.\r\n     *\r\n     * @readonly\r\n     * @memberof Polygon\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    /**\r\n     * Gets or sets whether to show the label\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get ShowLabel(): boolean;\r\n    public abstract set ShowLabel(val: boolean);\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get ShowTooltip(): boolean;\r\n    public abstract set ShowTooltip(val: boolean);\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get Title(): string;\r\n    public abstract set Title(val: string);\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     * @memberof Polygon\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Deleted the polygon.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract Delete(): void;\r\n\r\n    /**\r\n     * Gets whether the polygon is draggable.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polygon is dragable, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetDraggable(): boolean;\r\n\r\n    /**\r\n     * Gets whether the polygon path can be edited.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetEditable(): boolean;\r\n\r\n    /**\r\n     * Gets the polygon path.\r\n     *\r\n     * @abstract\r\n     * @returns - Array of ILatLong objects describing the polygon path.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetPath(): Array<ILatLong>;\r\n\r\n    /**\r\n     * Gets the polygon paths.\r\n     *\r\n     * @abstract\r\n     * @returns - Array of Array of ILatLong objects describing multiple polygon paths.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetPaths(): Array<Array<ILatLong>>;\r\n\r\n    /**\r\n     * Gets whether the polygon is visible.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polygon is visible, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n    /**\r\n     * Sets whether the polygon is dragable.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to make the polygon dragable, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetDraggable(draggable: boolean): void;\r\n\r\n    /**\r\n     * Sets wether the polygon path is editable.\r\n     *\r\n     * @abstract\r\n     * @param editable - True to make polygon path editable, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetEditable(editable: boolean): void;\r\n\r\n    /**\r\n     * Sets the polygon options\r\n     *\r\n     * @abstract\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetOptions(options: IPolygonOptions): void;\r\n\r\n    /**\r\n     * Sets the polygon path.\r\n     *\r\n     * @abstract\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polygons path.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetPath(path: Array<ILatLong> | Array<ILatLong>): void;\r\n\r\n    /**\r\n     * Set the polygon path or paths.\r\n     *\r\n     * @abstract\r\n     * @param paths An Array of {@link ILatLong}\r\n     * (or array of arrays) describing the polygons path(s).\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetPaths(paths: Array<Array<ILatLong>> | Array<ILatLong>): void;\r\n\r\n    /**\r\n     * Sets whether the polygon is visible.\r\n     *\r\n     * @abstract\r\n     * @param visible - True to set the polygon visible, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the center of the polygons' bounding box.\r\n     *\r\n     * @returns - ILatLong object containing the center of the bounding box.\r\n     * @memberof Polygon\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetBoundingCenter(): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        let x1: number = 90, x2: number = -90, y1: number = 180, y2: number = -180;\r\n        const path: Array<Array<ILatLong>> = this.GetPaths();\r\n        if (path) {\r\n            path.forEach(inner => inner.forEach(p => {\r\n                if (p.latitude < x1) { x1 = p.latitude; }\r\n                if (p.latitude > x2) { x2 = p.latitude; }\r\n                if (p.longitude < y1) { y1 = p.longitude; }\r\n                if (p.longitude > y2) { y2 = p.longitude; }\r\n            }));\r\n            c.latitude = x1 + (x2 - x1) / 2;\r\n            c.longitude = y1 + (y2 - y1) / 2;\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Get the centroid of the polygon based on the polygon path.\r\n     *\r\n     * @returns - The centroid coordinates of the polygon.\r\n     * @memberof Polygon\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetPolygonCentroid(): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        const path: Array<Array<ILatLong>> = this.GetPaths();\r\n        const off = path[0][0];\r\n        if (off != null) {\r\n            let twicearea: number = 0;\r\n            let x: number = 0;\r\n            let y: number = 0;\r\n            let p1: ILatLong, p2: ILatLong;\r\n            let f: number;\r\n            for (let k = 0; k < path.length; k++) {\r\n                for (let i = 0, j = path[k].length - 1; i < path[k].length; j = i++) {\r\n                    p1 = path[k][i];\r\n                    p2 = path[k][j];\r\n                    f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -\r\n                        (p2.latitude - off.latitude) * (p1.longitude - off.longitude);\r\n                    twicearea += f;\r\n                    x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;\r\n                    y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;\r\n                }\r\n            }\r\n            if (twicearea !== 0) {\r\n                f = twicearea * 3;\r\n                c.latitude = x / f + off.latitude;\r\n                c.longitude = y / f + off.longitude;\r\n            }\r\n            else {\r\n                c.latitude = off.latitude;\r\n                c.longitude = off.longitude;\r\n            }\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\n\r\n/**\r\n * Abstract class defining the contract for a polyline in the architecture specific implementation.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Polyline {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _centroid: ILatLong;\r\n    protected _center: ILatLong;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Gets the polyline's center.\r\n     * @readonly\r\n     * @memberof Polyline\r\n     */\r\n    public get Center(): ILatLong {\r\n        if (this._center == null) {\r\n            this._center = this.GetBoundingCenter();\r\n        }\r\n        return this._center;\r\n    }\r\n\r\n    /**\r\n     * Gets the polyline's centroid.\r\n     * @readonly\r\n     * @memberof Polyline\r\n     */\r\n    public get Centroid(): ILatLong {\r\n        if (this._centroid == null) {\r\n            this._centroid = this.GetPolylineCentroid();\r\n        }\r\n        return this._centroid;\r\n    }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polyline.\r\n     *\r\n     * @readonly\r\n     * @memberof Polyline\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    /**\r\n     * Gets the polyline metadata.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Polylin\r\n     */\r\n    public abstract get Metadata(): Map<string, any>;\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof Polyline\r\n     * @property\r\n     */\r\n    public abstract get ShowTooltip(): boolean;\r\n    public abstract set ShowTooltip(val: boolean);\r\n\r\n    /**\r\n     * Gets or sets the title off the polyline\r\n     *\r\n     * @abstract\r\n     * @memberof Polyline\r\n     * @property\r\n     */\r\n    public abstract get Title(): string;\r\n    public abstract set Title(val: string);\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Get the centroid of the polyline based on the a path.\r\n     *\r\n     * @param path - the path for which to generate the centroid\r\n     * @returns - The centroid coordinates of the polyline.\r\n     * @memberof Polyline\r\n     * @method\r\n     */\r\n    public static GetPolylineCentroid(path: Array<ILatLong>): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        const off = path[0];\r\n        if (off != null) {\r\n            let twicearea: number = 0;\r\n            let x: number = 0;\r\n            let y: number = 0;\r\n            let p1: ILatLong, p2: ILatLong;\r\n            let f: number;\r\n\r\n            for (let i = 0, j = path.length - 1; i < path.length; j = i++) {\r\n                p1 = path[i];\r\n                p2 = path[j];\r\n                f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -\r\n                    (p2.latitude - off.latitude) * (p1.longitude - off.longitude);\r\n                twicearea += f;\r\n                x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;\r\n                y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;\r\n            }\r\n            if (twicearea !== 0) {\r\n                f = twicearea * 3;\r\n                c.latitude = x / f + off.latitude;\r\n                c.longitude = y / f + off.longitude;\r\n            }\r\n            else {\r\n                c.latitude = off.latitude;\r\n                c.longitude = off.longitude;\r\n            }\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Deleted the polyline.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract Delete(): void;\r\n\r\n    /**\r\n     * Gets whether the polyline is draggable.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polyline is dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetDraggable(): boolean;\r\n\r\n    /**\r\n     * Gets whether the polyline path can be edited.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetEditable(): boolean;\r\n\r\n    /**\r\n     * Gets the polyline path.\r\n     *\r\n     * @abstract\r\n     * @returns - Array of ILatLong objects describing the polyline path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetPath(): Array<ILatLong>;\r\n\r\n    /**\r\n     * Gets whether the polyline is visible.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polyline is visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n    /**\r\n     * Sets whether the polyline is dragable.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to make the polyline dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetDraggable(draggable: boolean): void;\r\n\r\n    /**\r\n     * Sets wether the polyline path is editable.\r\n     *\r\n     * @abstract\r\n     * @param editable - True to make polyline path editable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetEditable(editable: boolean): void;\r\n\r\n    /**\r\n     * Sets the polyline options\r\n     *\r\n     * @abstract\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetOptions(options: IPolylineOptions): void;\r\n\r\n    /**\r\n     * Sets the polyline path.\r\n     *\r\n     * @abstract\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polylines path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetPath(path: Array<ILatLong> | Array<ILatLong>): void;\r\n\r\n    /**\r\n     * Sets whether the polyline is visible.\r\n     *\r\n     * @abstract\r\n     * @param visible - True to set the polyline visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the center of the polyline' bounding box.\r\n     *\r\n     * @returns - {@link ILatLong} object containing the center of the bounding box.\r\n     * @memberof Polyline\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetBoundingCenter(): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        let x1: number = 90, x2: number = -90, y1: number = 180, y2: number = -180;\r\n        const path: Array<ILatLong> = this.GetPath();\r\n        if (path) {\r\n            path.forEach(p => {\r\n                if (p.latitude < x1) { x1 = p.latitude; }\r\n                if (p.latitude > x2) { x2 = p.latitude; }\r\n                if (p.longitude < y1) { y1 = p.longitude; }\r\n                if (p.longitude > y2) { y2 = p.longitude; }\r\n            });\r\n            c.latitude = x1 + (x2 - x1) / 2;\r\n            c.longitude = y1 + (y2 - y1) / 2;\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Get the centroid of the polyline based on the polyline path.\r\n     *\r\n     * @returns - The centroid coordinates of the polyline.\r\n     * @memberof Polyline\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetPolylineCentroid(): ILatLong {\r\n        const path: Array<ILatLong> = this.GetPath();\r\n        const c: ILatLong  = Polyline.GetPolylineCentroid(path);\r\n        return c;\r\n    }\r\n\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Marker } from './marker';\r\n\r\nexport abstract class SpiderClusterMarker extends Marker {\r\n\r\n    /** The parent pushpin in which the spider pushpin is derived from. */\r\n    public ParentMarker: Marker;\r\n\r\n    /** The stick that connects the spider pushpin to the cluster. */\r\n    public Stick: any;\r\n\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { MapLabel } from './map-label';\r\n\r\nlet id: number = 0;\r\n\r\n/**\r\n * Abstract base implementing a canvas overlay to be placed on the map.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class CanvasOverlay {\r\n\r\n    ///\r\n    /// field declarations\r\n    ///\r\n    protected _readyResolver: (val: boolean) => void;\r\n    protected _canvas: HTMLCanvasElement;\r\n    protected _zoomStart: number;\r\n    protected _centerStart: ILatLong;\r\n    public _canvasReady: Promise<boolean> = new Promise<boolean>((resolve, reject) => { this._readyResolver = resolve; });\r\n\r\n    /**\r\n     * Returns a promise that gets resolved when the canvas overlay is ready for interaction.\r\n     */\r\n    public get CanvasReady(): Promise<boolean> { return this._canvasReady; }\r\n\r\n    /**\r\n    * A callback function that is triggered when the canvas is ready to be rendered for the current map view.\r\n    */\r\n    private _drawCallback: (canvas: HTMLCanvasElement) => void;\r\n\r\n\r\n    /**\r\n     * Creates a new instance of the CanvasOverlay class.\r\n     */\r\n    constructor(drawCallback: (canvas: HTMLCanvasElement) => void) {\r\n        this._drawCallback = drawCallback;\r\n        id++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Deletes the canvas overlay.\r\n     */\r\n    public Delete(): void {\r\n        this.SetMap(null);\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the click location\r\n     */\r\n    public abstract GetCoordinatesFromClick(e: any): ILatLong;\r\n\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     */\r\n    public abstract GetMap(): any;\r\n\r\n    /**\r\n     * Returns a MapLabel instance for the current platform that can be used as a tooltip.\r\n     * This method only generates the map label. Content and placement is the responsibility\r\n     * of the caller.\r\n     */\r\n    public abstract GetToolTipOverlay(): MapLabel;\r\n\r\n    /**\r\n     * CanvasOverlay added to map, load canvas.\r\n     */\r\n    public OnAdd(): void {\r\n        this._canvas = document.createElement('canvas');\r\n        this._canvas.style.position = 'absolute';\r\n        this._canvas.style.left = '0px';\r\n        this._canvas.style.top = '0px';\r\n        this._canvas.id = `xMapOverlay${id}`;\r\n\r\n        // Add the canvas to the overlay.\r\n        this.SetCanvasElement(this._canvas);\r\n    }\r\n\r\n    /**\r\n     * CanvasOverlay loaded, attach map events for updating canvas.\r\n     * @abstract\r\n     * @method\r\n     * @memberof CanvasOverlay\r\n     */\r\n    public abstract OnLoad(): void;\r\n\r\n    /**\r\n     * When the CanvasLayer is removed from the map, release resources.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public OnRemove(): void {\r\n        this.SetCanvasElement(null);\r\n        this.RemoveEventHandlers();\r\n        this._canvas = null;\r\n    }\r\n\r\n    /**\r\n     * Redraws the canvas for the current map view.\r\n     * @param clear - True to clear the canvas before drawing.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public Redraw(clear: boolean): void {\r\n        if (this._canvas == null) { return; }\r\n\r\n        // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.\r\n        if (clear) { this.Resize(); }\r\n\r\n        // Call the drawing callback function if specified.\r\n        if (this._drawCallback) {\r\n            this._drawCallback(this._canvas);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - A native map object for the underlying implementation. Implementing derivatives should return the\r\n     * actual native object.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public abstract SetMap(map: any): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Attaches the canvas to the map.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    protected abstract SetCanvasElement(el: HTMLCanvasElement): void;\r\n\r\n    /**\r\n     * Remove the map event handlers.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @abstract\r\n     * @protected\r\n     */\r\n    protected abstract RemoveEventHandlers(): void;\r\n\r\n    /**\r\n     * Updates the Canvas size based on the map size.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @abstract\r\n     * @protected\r\n     */\r\n    protected abstract Resize(): void;\r\n\r\n    /**\r\n     * Updates the Canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected abstract UpdateCanvas(): void;\r\n\r\n    /**\r\n     * Simple function for updating the CSS position and dimensions of the canvas.\r\n     * @param x The horizontal offset position of the canvas.\r\n     * @param y The vertical offset position of the canvas.\r\n     * @param w The width of the canvas.\r\n     * @param h The height of the canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected UpdatePosition(x: number, y: number, w: number, h: number) {\r\n        // Update CSS position.\r\n        this._canvas.style.left = x + 'px';\r\n        this._canvas.style.top = y + 'px';\r\n\r\n        // Update CSS dimensions.\r\n        this._canvas.style.width = w + 'px';\r\n        this._canvas.style.height = h + 'px';\r\n    }\r\n\r\n}\r\n","import { eachSeries, nextTick } from 'async';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { Polygon } from '../polygon';\r\nimport { Polyline } from '../polyline';\r\nimport { InfoWindow } from '../info-window';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { MapService} from '../../services/map.service';\r\n\r\n/**\r\n * Concrete implementation of a map layer for the Bing Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class BingLayer implements Layer {\r\n\r\n    private _pendingEntities: Array<Marker|InfoWindow|Polygon|Polyline> = new Array<Marker|InfoWindow|Polygon|Polyline>();\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns Microsoft.Maps.Layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public get NativePrimitve(): any {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the BingClusterLayer class.\r\n     *\r\n     * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    constructor(private _layer: Microsoft.Maps.Layer, private _maps: MapService) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._layer, eventType, (e) => {\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer.\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public AddEntity(entity: Marker|InfoWindow|Polygon|Polyline): void {\r\n        if (entity && entity.NativePrimitve) {\r\n            if (this.GetVisible()) {\r\n                this._layer.add(entity.NativePrimitve);\r\n            }\r\n            else {\r\n                this._pendingEntities.push(entity);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..)\r\n     *\r\n     * @param entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public AddEntities(entities: Array<Marker|InfoWindow|Polygon|Polyline>): void {\r\n        //\r\n        // use eachSeries as opposed to _layer.add([]) to provide a non-blocking experience for larger data sets.\r\n        //\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            eachSeries([...entities], (e, next) => {\r\n                if (this.GetVisible()) {\r\n                    this._layer.add(e.NativePrimitve);\r\n                }\r\n                else {\r\n                    this._pendingEntities.push(e);\r\n                }\r\n                nextTick(() => next());\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public Delete(): void {\r\n        this._maps.DeleteLayer(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns IClusterOptions. The layer options.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public GetOptions(): ILayerOptions {\r\n        const o: ILayerOptions = {\r\n            id: Number(this._layer.getId())\r\n        };\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public GetVisible(): boolean  {\r\n        return this._layer.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the cluster layer.\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline to be removed from the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public RemoveEntity(entity: Marker|InfoWindow|Polygon|Polyline): void {\r\n        if (entity.NativePrimitve) {\r\n            this._layer.remove(entity.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.\r\n     * This replaces any existing entities.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public SetEntities(entities: Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline>): void {\r\n        //\r\n        // we are using removal and add as opposed to set as for large number of objects it yields a non-blocking, smoother performance...\r\n        //\r\n        this._layer.setPrimitives([]);\r\n        this.AddEntities(entities);\r\n\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public SetOptions(options: ILayerOptions) {\r\n        this._layer.metadata.id = options.id.toString();\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._layer.setVisible(visible);\r\n        if (visible && this._pendingEntities.length > 0) {\r\n            this.AddEntities(this._pendingEntities.splice(0));\r\n        }\r\n    }\r\n\r\n}\r\n","import { IMapOptions } from '../../interfaces/imap-options';\r\nimport { IBox } from '../../interfaces/ibox';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { IInfoWindowAction } from '../../interfaces/iinfo-window-action';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { MapTypeId } from '../../models/map-type-id';\r\nimport { Marker } from '../../models/marker';\r\nimport { ClusterPlacementMode } from '../../models/cluster-placement-mode';\r\nimport { BingMapService } from './bing-map.service';\r\n\r\n/**\r\n * This class contains helperfunctions to map various interfaces used to represent options and structures into the\r\n * corresponding Bing Maps V8 specific implementations.\r\n *\r\n * @export\r\n */\r\nexport class BingConversions {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    /**\r\n     * Map option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _mapOptionsAttributes: string[] = [\r\n        'backgroundColor',\r\n        'credentials',\r\n        'customizeOverlays',\r\n        'customMapStyle',\r\n        'disableBirdseye',\r\n        'disableKeyboardInput',\r\n        'disableMouseInput',\r\n        'disablePanning',\r\n        'disableTouchInput',\r\n        'disableUserInput',\r\n        'disableZooming',\r\n        'disableStreetside',\r\n        'enableClickableLogo',\r\n        'enableSearchLogo',\r\n        'fixedMapPosition',\r\n        'height',\r\n        'inertiaIntensity',\r\n        'navigationBarMode',\r\n        'showBreadcrumb',\r\n        'showCopyright',\r\n        'showDashboard',\r\n        'showMapTypeSelector',\r\n        'showScalebar',\r\n        'theme',\r\n        'tileBuffer',\r\n        'useInertia',\r\n        'width',\r\n        'center',\r\n        'zoom',\r\n        'mapTypeId',\r\n        'liteMode'\r\n    ];\r\n\r\n    /**\r\n     * View option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _viewOptionsAttributes: string[] = [\r\n        'animate',\r\n        'bounds',\r\n        'center',\r\n        'centerOffset',\r\n        'heading',\r\n        'labelOverlay',\r\n        'mapTypeId',\r\n        'padding',\r\n        'zoom'\r\n    ];\r\n\r\n    /**\r\n     * InfoWindow option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _infoWindowOptionsAttributes: string[] = [\r\n        'actions',\r\n        'description',\r\n        'htmlContent',\r\n        'id',\r\n        'position',\r\n        'pixelOffset',\r\n        'showCloseButton',\r\n        'showPointer',\r\n        'pushpin',\r\n        'title',\r\n        'titleClickHandler',\r\n        'typeName',\r\n        'visible',\r\n        'width',\r\n        'height'\r\n    ];\r\n\r\n    /**\r\n     * Marker option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _markerOptionsAttributes: string[] = [\r\n        'anchor',\r\n        'draggable',\r\n        'height',\r\n        'htmlContent',\r\n        'icon',\r\n        'infobox',\r\n        'state',\r\n        'title',\r\n        'textOffset',\r\n        'typeName',\r\n        'visible',\r\n        'width',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Polygon option attributes that are supported for conversion to Bing Map Polygon properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _polygonOptionsAttributes: string[] = [\r\n        'cursor',\r\n        'fillColor',\r\n        'fillOpacity',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible'\r\n    ];\r\n\r\n    /**\r\n     * Polyline option attributes that are supported for conversion to Bing Map Polyline properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _polylineOptionsAttributes: string[] = [\r\n        'cursor',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible'\r\n    ];\r\n\r\n    /**\r\n     * Cluster option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _clusterOptionsAttributes: string[] = [\r\n        'callback',\r\n        'clusteredPinCallback',\r\n        'clusteringEnabled',\r\n        'gridSize',\r\n        'layerOffset',\r\n        'placementMode',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Maps an IInfoWindowAction to a Microsoft.Maps.IInfoboxActions\r\n     *\r\n     * @param action - Object to be mapped.\r\n     * @returns - Navtive mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateAction(action: IInfoWindowAction): Microsoft.Maps.IInfoboxActions {\r\n        const a: Microsoft.Maps.IInfoboxActions = {\r\n            eventHandler: action.eventHandler,\r\n            label: action.label\r\n        };\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Maps an Array of IInfoWindowAction to an Array of Microsoft.Maps.IInfoboxActions\r\n     *\r\n     * @param actions - Array of objects to be mapped.\r\n     * @returns - Array of mapped objects.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateActions(actions: Array<IInfoWindowAction>): Array<Microsoft.Maps.IInfoboxActions> {\r\n        const a: Array<Microsoft.Maps.IInfoboxActions> = new Array<Microsoft.Maps.IInfoboxActions>();\r\n        actions.forEach(x => a.push(BingConversions.TranslateAction(x)));\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Maps an IBox object to a Microsoft.Maps.LocationRect object.\r\n     *\r\n     * @param box - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateBounds(box: IBox): Microsoft.Maps.LocationRect {\r\n        const r: Microsoft.Maps.LocationRect =\r\n            Microsoft.Maps.LocationRect.fromEdges(box.maxLatitude, box.minLongitude, box.minLatitude, box.maxLongitude);\r\n        return r;\r\n    }\r\n\r\n    /**\r\n     * Maps an IClusterOptions object to a Microsoft.Maps.IClusterLayerOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateClusterOptions(options: IClusterOptions): Microsoft.Maps.IClusterLayerOptions {\r\n        const o: Microsoft.Maps.IClusterLayerOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._clusterOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'layerOffset') {\r\n                    o.layerOffset = BingConversions.TranslatePoint(options.layerOffset);\r\n                }\r\n                if (k === 'placementMode') {\r\n                    if (options.placementMode === ClusterPlacementMode.FirstPin) {\r\n                        o.placementMode = Microsoft.Maps.ClusterPlacementType.FirstLocation;\r\n                    }\r\n                    else {\r\n                        o.placementMode = Microsoft.Maps.ClusterPlacementType.MeanAverage;\r\n                    }\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IInfoWindowOptions object to a Microsoft.Maps.IInfoboxOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateInfoBoxOptions(options: IInfoWindowOptions): Microsoft.Maps.IInfoboxOptions {\r\n        const o: Microsoft.Maps.IInfoboxOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._infoWindowOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'pixelOffset') {\r\n                    o.offset = BingConversions.TranslatePoint(options.pixelOffset);\r\n                }\r\n                else if (k === 'position') {\r\n                    o.location = BingConversions.TranslateLocation(options.position);\r\n                }\r\n                else if (k === 'actions') {\r\n                    o.actions = BingConversions.TranslateActions(options.actions);\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a Microsoft.Maps.IMapLoadOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateLoadOptions(options: IMapOptions): Microsoft.Maps.IMapLoadOptions {\r\n        const o: Microsoft.Maps.IMapLoadOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => {\r\n                return BingConversions._mapOptionsAttributes.indexOf(k) !== -1 || BingConversions._viewOptionsAttributes.indexOf(k) !== -1;\r\n            })\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = BingConversions.TranslateLocation(options.center);\r\n                }\r\n                else if (k === 'mapTypeId') {\r\n                    if (options.mapTypeId === MapTypeId.hybrid) {\r\n                        o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;\r\n                        o.labelOverlay = Microsoft.Maps.LabelOverlay.visible;\r\n                    }\r\n                    else if (options.mapTypeId === MapTypeId.aerial) {\r\n                        o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;\r\n                        o.labelOverlay = Microsoft.Maps.LabelOverlay.hidden;\r\n                    }\r\n                    else {\r\n                        o.mapTypeId = Microsoft.Maps.MapTypeId[(<any>MapTypeId)[options.mapTypeId]];\r\n                    }\r\n                }\r\n                else if (k === 'bounds') {\r\n                    o.bounds = BingConversions.TranslateBounds(options.bounds);\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong object to a Microsoft.Maps.Location object.\r\n     *\r\n     * @param latlong - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateLocation(latlong: ILatLong): Microsoft.Maps.Location {\r\n        const l: Microsoft.Maps.Location = new Microsoft.Maps.Location(latlong.latitude, latlong.longitude);\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMarkerOptions object to a Microsoft.Maps.IPushpinOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - The mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateMarkerOptions(options: IMarkerOptions): Microsoft.Maps.IPushpinOptions {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._markerOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'anchor') {\r\n                    o.anchor = BingConversions.TranslatePoint(options.anchor);\r\n                }\r\n                else {\r\n                    (<any>o)[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a Microsoft.Maps.IMapOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateOptions(options: IMapOptions): Microsoft.Maps.IMapOptions {\r\n        const o: Microsoft.Maps.IMapOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._mapOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = BingConversions.TranslateLocation(options.center);\r\n                }\r\n                else if (k === 'mapTypeId') {\r\n                    o.mapTypeId = Microsoft.Maps.MapTypeId[(<any>MapTypeId)[options.mapTypeId]];\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations\r\n     *\r\n     * @param paths - ILatLong based locations to convert.\r\n     * @returns - converted locations.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePaths(paths: Array<ILatLong> | Array<Array<ILatLong>>): Array<Array<Microsoft.Maps.Location>> {\r\n        const p: Array<Array<Microsoft.Maps.Location>> = new Array<Array<Microsoft.Maps.Location>>();\r\n        if (paths == null || !Array.isArray(paths) || paths.length === 0) {\r\n            p.push(new Array<Microsoft.Maps.Location>());\r\n        }\r\n        else if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            // us for loop for performance\r\n            const p1 = <Array<Array<ILatLong>>>paths;\r\n            for (let i = 0; i < p1.length; i++) {\r\n                const _p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n                for (let j = 0; j < p1[i].length; j++) {\r\n                    _p.push(new Microsoft.Maps.Location(p1[i][j].latitude, p1[i][j].longitude));\r\n                }\r\n                p.push(_p);\r\n            }\r\n        }\r\n        else {\r\n            // parameter is a simple array....\r\n            const y: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n            const p1 = <Array<ILatLong>>paths;\r\n            for (let i = 0; i < p1.length; i++) {\r\n                y.push(new Microsoft.Maps.Location(p1[i].latitude, p1[i].longitude));\r\n            }\r\n            p.push(y);\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPoint object to a Microsoft.Maps.Point object.\r\n     *\r\n     * @param point - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePoint(point: IPoint): Microsoft.Maps.Point {\r\n        const p: Microsoft.Maps.Point = new Microsoft.Maps.Point(point.x, point.y);\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolygonOptions object to a Microsoft.Maps.IPolygonOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePolygonOptions(options: IPolygonOptions): Microsoft.Maps.IPolygonOptions {\r\n        const o: Microsoft.Maps.IPolygonOptions = {};\r\n        const f: (s: string, a: number) => string = (s, a) => {\r\n            const m = /rgba?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*\\d+[\\.\\d+]*)*\\)/g.exec(s);\r\n            if (m && m.length > 3) {\r\n                a = a > 1 ? (a / 100) : a;\r\n                return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';\r\n            }\r\n            else if (s[0] === '#') {\r\n                const x: number = a > 1 ? a : Math.floor(a * 255);\r\n                const z: string = s.substr(1);\r\n                const r: number = parseInt(z.substr(0, 2), 16);\r\n                const g: number = parseInt(z.substr(2, 2), 16);\r\n                const b: number = parseInt(z.substr(4, 2), 16);\r\n                return 'rgba(' + [r , g, b, a].join(',') + ')';\r\n            }\r\n            else {\r\n                return s;\r\n            }\r\n        };\r\n\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._polygonOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'strokeWeight') {\r\n                    o.strokeThickness = options.strokeWeight;\r\n                }\r\n                else if (k === 'strokeColor') {\r\n                    if (options.strokeOpacity) {\r\n                        o.strokeColor = f(options.strokeColor, options.strokeOpacity);\r\n                    }\r\n                    else {\r\n                        o.strokeColor = options.strokeColor;\r\n                    }\r\n                }\r\n                else if (k === 'strokeOpacity') {}\r\n                else if (k === 'fillColor') {\r\n                    if (options.fillOpacity) {\r\n                        o.fillColor = f(options.fillColor, options.fillOpacity);\r\n                    }\r\n                    else {\r\n                        o.fillColor = options.fillColor;\r\n                    }\r\n                }\r\n                else if (k === 'fillOpacity') {}\r\n                else {\r\n                    (<any>o)[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolylineOptions object to a Microsoft.Maps.IPolylineOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePolylineOptions(options: IPolylineOptions): Microsoft.Maps.IPolylineOptions {\r\n        const o: Microsoft.Maps.IPolylineOptions | any = {};\r\n        const f: (s: string, a: number) => string = (s, a) => {\r\n            const m = /rgba?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*\\d+[\\.\\d+]*)*\\)/g.exec(s);\r\n            if (m && m.length > 3) {\r\n                a = a > 1 ? (a / 100) : a;\r\n                return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';\r\n            }\r\n            else if (s[0] === '#') {\r\n                const x: number = a > 1 ? a : Math.floor(a * 255);\r\n                const z: string = s.substr(1);\r\n                const r: number = parseInt(z.substr(0, 2), 16);\r\n                const g: number = parseInt(z.substr(2, 2), 16);\r\n                const b: number = parseInt(z.substr(4, 2), 16);\r\n                return 'rgba(' + [r , g, b, a].join(',') + ')';\r\n            }\r\n            else {\r\n                return s;\r\n            }\r\n        };\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._polylineOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'strokeWeight') {\r\n                    o.strokeThickness = options.strokeWeight;\r\n                } else if (k === 'strokeColor') {\r\n                    if (options.strokeOpacity) {\r\n                        o.strokeColor = f(options.strokeColor, options.strokeOpacity);\r\n                    }\r\n                    else {\r\n                        o.strokeColor = options.strokeColor;\r\n                    }\r\n                }\r\n                else if (k === 'strokeOpacity') {\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a Microsoft.Maps.IViewOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateViewOptions(options: IMapOptions): Microsoft.Maps.IViewOptions {\r\n        const o: Microsoft.Maps.IViewOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._viewOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = BingConversions.TranslateLocation(options.center);\r\n                } else if (k === 'bounds') {\r\n                    o.bounds = BingConversions.TranslateBounds(options.bounds);\r\n                } else if (k === 'centerOffset') {\r\n                    o.centerOffset = BingConversions.TranslatePoint(options.centerOffset);\r\n                } else if (k === 'mapTypeId') {\r\n                    o.mapTypeId = Microsoft.Maps.MapTypeId[(<any>MapTypeId)[options.mapTypeId]];\r\n                } else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { Marker } from '../marker';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\n\r\n/**\r\n * Concrete implementation of the {@link Marker} contract for the Bing Maps V8 map architecture.\r\n *\r\n * @export\r\n */\r\nexport class BingMarker implements Marker {\r\n\r\n    ///\r\n    /// Field definitions\r\n    ///\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _isFirst = false;\r\n    private _isLast = true;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Indicates that the marker is the first marker in a set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsFirst(): boolean { return this._isFirst; }\r\n    public set IsFirst(val: boolean) { this._isFirst = val; }\r\n\r\n    /**\r\n     * Indicates that the marker is the last marker in the set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsLast(): boolean { return this._isLast; }\r\n    public set IsLast(val: boolean) { this._isLast = val; }\r\n\r\n    /**\r\n     * Gets the Location of the marker\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get Location(): ILatLong {\r\n        const l: Microsoft.Maps.Location = this._pushpin.getLocation();\r\n        return {\r\n            latitude: l.latitude,\r\n            longitude: l.longitude\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the marker metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker, in this case {@link Microsoft.Maps.Pushpin}\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get NativePrimitve(): any { return this._pushpin; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMarker.\r\n     * @param _pushpin - The {@link Microsoft.Maps.Pushpin} underlying the model.\r\n     * @param _map - The context map.\r\n     * @param _layer - The context layer.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    constructor(private _pushpin: Microsoft.Maps.Pushpin, protected _map: Microsoft.Maps.Map, protected _layer: Microsoft.Maps.Layer) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener to the marker.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._pushpin, eventType, (e) => {\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes the marker.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public DeleteMarker(): void {\r\n        if (!this._map && !this._layer) { return; }\r\n        if (this._layer) { this._layer.remove(this.NativePrimitve); }\r\n        else {\r\n            this._map.entities.remove(this.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the marker label\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public GetLabel(): string {\r\n        return this._pushpin.getText();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the marker is visible.\r\n     *\r\n     * @returns - True if the marker is visible, false otherwise.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._pushpin.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.\r\n     *\r\n     * @abstract\r\n     * @param anchor - Point coordinates for the marker anchor.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetAnchor(anchor: IPoint): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.anchor = new Microsoft.Maps.Point(anchor.x, anchor.y);\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the draggability of a marker.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to mark the marker as draggable, false otherwise.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.draggable = draggable;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the icon for the marker.\r\n     *\r\n     * @abstract\r\n     * @param icon - String containing the icon in various forms (url, data url, etc.)\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetIcon(icon: string): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.icon = icon;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker label.\r\n     *\r\n     * @abstract\r\n     * @param label - String containing the label to set.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetLabel(label: string): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.text = label;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker position.\r\n     *\r\n     * @abstract\r\n     * @param latLng - Geo coordinates to set the marker position to.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetPosition(latLng: ILatLong): void {\r\n        const p: Microsoft.Maps.Location = BingConversions.TranslateLocation(latLng);\r\n        this._pushpin.setLocation(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker title.\r\n     *\r\n     * @abstract\r\n     * @param title - String containing the title to set.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetTitle(title: string): void {\r\n        const o: Microsoft.Maps.IPushpinOptions | any = {};\r\n        o.title = title;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker options.\r\n     *\r\n     * @abstract\r\n     * @param options - {@link IMarkerOptions} object containing the marker options to set. The supplied options are\r\n     * merged with the underlying marker options.\r\n     * @memberof Marker\r\n     */\r\n    public SetOptions(options: IMarkerOptions): void {\r\n        const o: Microsoft.Maps.IPushpinOptions =  BingConversions.TranslateMarkerOptions(options);\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the marker is visible.\r\n     *\r\n     * @param visible - True to set the marker visible, false otherwise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        const o: Microsoft.Maps.IPushpinOptions | any = {};\r\n        o.visible = visible;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n}\r\n","import { BingMarker } from './bing-marker';\r\nimport { SpiderClusterMarker } from '../spider-cluster-marker';\r\n\r\nexport class BingSpiderClusterMarker extends BingMarker implements SpiderClusterMarker {\r\n\r\n    /** The parent pushpin in which the spider pushpin is derived from. */\r\n    public ParentMarker: BingMarker;\r\n\r\n    /** The stick that connects the spider pushpin to the cluster. */\r\n    public Stick: Microsoft.Maps.Polyline;\r\n\r\n}\r\n","import { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { ISpiderClusterOptions } from '../../interfaces/ispider-cluster-options';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { MapService } from '../../services/map.service';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { InfoWindow } from '../info-window';\r\nimport { BingSpiderClusterMarker } from './bing-spider-cluster-marker';\r\nimport { BingMarker } from './bing-marker';\r\n\r\n/**\r\n * Concrete implementation of a clustering layer for the Bing Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class BingClusterLayer implements Layer {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _isClustering = true;\r\n    private _markers: Array<Marker> = new Array<Marker>();\r\n    private _markerLookup: Map<Microsoft.Maps.Pushpin, Marker> = new Map<Microsoft.Maps.Pushpin, Marker>();\r\n    private _pendingMarkers: Array<Marker> = new Array<Marker>();\r\n    private _spiderMarkers: Array<BingSpiderClusterMarker> = new Array<BingSpiderClusterMarker>();\r\n    private _spiderMarkerLookup: Map<Microsoft.Maps.Pushpin, BingSpiderClusterMarker> =\r\n                     new Map<Microsoft.Maps.Pushpin, BingSpiderClusterMarker>();\r\n    private _useSpiderCluster = false;\r\n    private _mapclicks = 0;\r\n    private _spiderLayer: Microsoft.Maps.Layer;\r\n    private _events: Array<Microsoft.Maps.IHandlerId> = new Array<Microsoft.Maps.IHandlerId>();\r\n    private _currentZoom = 0;\r\n    private _spiderOptions: ISpiderClusterOptions = {\r\n        circleSpiralSwitchover: 9,\r\n        collapseClusterOnMapChange: false,\r\n        collapseClusterOnNthClick: 1,\r\n        invokeClickOnHover: true,\r\n        minCircleLength: 60,\r\n        minSpiralAngleSeperation: 25,\r\n        spiralDistanceFactor: 5,\r\n        stickStyle: {\r\n            strokeColor: 'black',\r\n            strokeThickness: 2\r\n        },\r\n        stickHoverStyle: { strokeColor: 'red' },\r\n        markerSelected: null,\r\n        markerUnSelected: null\r\n    };\r\n    private _currentCluster: Microsoft.Maps.ClusterPushpin = null;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns Microsoft.Maps.ClusterLayer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public get NativePrimitve(): any {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the BingClusterLayer class.\r\n     *\r\n     * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    constructor(private _layer: Microsoft.Maps.ClusterLayer, private _maps: MapService) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._layer, eventType, (e) => {\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer. Use this method with caution as it will\r\n     * trigger a recaluation of the clusters (and associated markers if approprite) for\r\n     * each invocation. If you use this method to add many markers to the cluster, use\r\n     *\r\n     * @param entity Marker. Entity to add to the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public AddEntity(entity: Marker): void {\r\n        let isMarker: boolean = entity instanceof Marker;\r\n        isMarker = entity instanceof BingMarker || isMarker;\r\n        if (isMarker) {\r\n            if (entity.IsFirst) {\r\n                this.StopClustering();\r\n            }\r\n        }\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            if (this._isClustering) {\r\n                const p: Array<Microsoft.Maps.Pushpin> = this._layer.getPushpins();\r\n                p.push(entity.NativePrimitve);\r\n                this._layer.setPushpins(p);\r\n                this._markers.push(entity);\r\n            }\r\n            else {\r\n                this._pendingMarkers.push(entity);\r\n            }\r\n            this._markerLookup.set(entity.NativePrimitve, entity);\r\n        }\r\n        if (isMarker) {\r\n            if (entity.IsLast) {\r\n                this.StartClustering();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of markers to the layer.\r\n     *\r\n     * @param entities Array<Marker>. Entities to add to the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public AddEntities(entities: Array<Marker>): void {\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            const e: Array<Microsoft.Maps.Pushpin> = entities.map(p => {\r\n                this._markerLookup.set(p.NativePrimitve, p);\r\n                return p.NativePrimitve;\r\n            });\r\n            if (this._isClustering) {\r\n                const p: Array<Microsoft.Maps.Pushpin> = this._layer.getPushpins();\r\n                p.push(...e);\r\n                this._layer.setPushpins(p);\r\n                this._markers.push(...entities);\r\n            }\r\n            else {\r\n                this._pendingMarkers.push(...entities);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes spider behavior for the clusering layer (when a cluster maker is clicked, it explodes into a spider of the\r\n     * individual underlying pins.\r\n     *\r\n     * @param options ISpiderClusterOptions. Optional. Options governing the behavior of the spider.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public InitializeSpiderClusterSupport(options?: ISpiderClusterOptions): void {\r\n        if (this._useSpiderCluster) { return; }\r\n        const m: Microsoft.Maps.Map = (<BingMapService>this._maps).MapInstance;\r\n        this._useSpiderCluster = true;\r\n        this._spiderLayer = new Microsoft.Maps.Layer();\r\n        this._currentZoom = m.getZoom();\r\n        this.SetSpiderOptions(options);\r\n        m.layers.insert(this._spiderLayer);\r\n\r\n        ///\r\n        /// Add spider related events....\r\n        ///\r\n        this._events.push(Microsoft.Maps.Events.addHandler(m, 'click', e => this.OnMapClick(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangestart', e => this.OnMapViewChangeStart(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangeend', e => this.OnMapViewChangeEnd(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._layer, 'click', e => this.OnLayerClick(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'click', e => this.OnLayerClick(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseover', e => this.OnSpiderMouseOver(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseout', e => this.OnSpiderMouseOut(e)));\r\n    }\r\n\r\n    /**\r\n     * Deletes the clustering layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public Delete(): void {\r\n        if (this._useSpiderCluster) {\r\n            this._spiderLayer.clear();\r\n            (<BingMapService>this._maps).MapPromise.then(m => {\r\n                m.layers.remove(this._spiderLayer);\r\n                this._spiderLayer = null;\r\n            });\r\n            this._events.forEach(e => Microsoft.Maps.Events.removeHandler(e));\r\n            this._events.splice(0);\r\n            this._useSpiderCluster = false;\r\n        }\r\n        this._markers.splice(0);\r\n        this._spiderMarkers.splice(0);\r\n        this._pendingMarkers.splice(0);\r\n        this._markerLookup.clear();\r\n        this._maps.DeleteLayer(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the abstract marker used to wrap the Bing Pushpin.\r\n     *\r\n     * @returns Marker. The abstract marker object representing the pushpin.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetMarkerFromBingMarker(pin: Microsoft.Maps.Pushpin): Marker {\r\n        const m: Marker = this._markerLookup.get(pin);\r\n        return m;\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns IClusterOptions. The layer options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetOptions(): IClusterOptions {\r\n        const o: Microsoft.Maps.IClusterLayerOptions = this._layer.getOptions();\r\n        const options: IClusterOptions = {\r\n            id: 0,\r\n            gridSize: o.gridSize,\r\n            layerOffset: o.layerOffset,\r\n            clusteringEnabled: o.clusteringEnabled,\r\n            callback: o.callback,\r\n            clusteredPinCallback: o.clusteredPinCallback,\r\n            visible: o.visible,\r\n            zIndex: o.zIndex\r\n        };\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._layer.getOptions().visible;\r\n    }\r\n\r\n    /**\r\n     * Returns the abstract marker used to wrap the Bing Pushpin.\r\n     *\r\n     * @returns - The abstract marker object representing the pushpin.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetSpiderMarkerFromBingMarker(pin: Microsoft.Maps.Pushpin): BingSpiderClusterMarker {\r\n        const m: BingSpiderClusterMarker = this._spiderMarkerLookup.get(pin);\r\n        return m;\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the cluster layer.\r\n     *\r\n     * @param entity Marker - Entity to be removed from the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public RemoveEntity(entity: Marker): void {\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            const j: number = this._markers.indexOf(entity);\r\n            const k: number = this._pendingMarkers.indexOf(entity);\r\n            if (j > -1) { this._markers.splice(j, 1); }\r\n            if (k > -1) { this._pendingMarkers.splice(k, 1); }\r\n            if (this._isClustering) {\r\n                const p: Array<Microsoft.Maps.Pushpin> = this._layer.getPushpins();\r\n                const i: number = p.indexOf(entity.NativePrimitve);\r\n                if (i > -1) {\r\n                    p.splice(i, 1);\r\n                    this._layer.setPushpins(p);\r\n                }\r\n            }\r\n            this._markerLookup.delete(entity.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker> containing\r\n     * the entities to add to the cluster. This replaces any existing entities.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public SetEntities(entities: Array<Marker>): void {\r\n        const p: Array<Microsoft.Maps.Pushpin> = new Array<Microsoft.Maps.Pushpin>();\r\n        this._markers.splice(0);\r\n        this._markerLookup.clear();\r\n        entities.forEach((e: any) => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                this._markers.push(e);\r\n                this._markerLookup.set(e.NativePrimitve, e);\r\n                p.push(<Microsoft.Maps.Pushpin>e.NativePrimitve);\r\n            }\r\n        });\r\n        this._layer.setPushpins(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public SetOptions(options: IClusterOptions): void {\r\n        const o: Microsoft.Maps.IClusterLayerOptions = BingConversions.TranslateClusterOptions(options);\r\n        this._layer.setOptions(o);\r\n        if (options.spiderClusterOptions) { this.SetSpiderOptions(options.spiderClusterOptions); }\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        const o: Microsoft.Maps.IClusterLayerOptions = this._layer.getOptions();\r\n        o.visible = visible;\r\n        this._layer.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public StartClustering(): void {\r\n        if (this._isClustering) { return; }\r\n\r\n        const p: Array<Microsoft.Maps.Pushpin> = new Array<Microsoft.Maps.Pushpin>();\r\n        this._markers.forEach(e => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                p.push(<Microsoft.Maps.Pushpin>e.NativePrimitve);\r\n            }\r\n        });\r\n        this._pendingMarkers.forEach(e => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                p.push(<Microsoft.Maps.Pushpin>e.NativePrimitve);\r\n            }\r\n        });\r\n        this._layer.setPushpins(p);\r\n        this._markers = this._markers.concat(this._pendingMarkers.splice(0));\r\n        this._isClustering = true;\r\n    }\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public StopClustering() {\r\n        if (!this._isClustering) { return; }\r\n        this._isClustering = false;\r\n    }\r\n\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Creates a copy of a pushpins basic options.\r\n     *\r\n     * @param pin Pushpin to copy options from.\r\n     * @returns - A copy of a pushpins basic options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private GetBasicPushpinOptions(pin: Microsoft.Maps.Pushpin): Microsoft.Maps.IPushpinOptions {\r\n        return <Microsoft.Maps.IPushpinOptions>{\r\n            anchor: pin.getAnchor(),\r\n            color: pin.getColor(),\r\n            cursor: pin.getCursor(),\r\n            icon: pin.getIcon(),\r\n            roundClickableArea: pin.getRoundClickableArea(),\r\n            subTitle: pin.getSubTitle(),\r\n            text: pin.getText(),\r\n            textOffset: pin.getTextOffset(),\r\n            title: pin.getTitle()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Hides the spider cluster and resotres the original pin.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private HideSpiderCluster(): void {\r\n        this._mapclicks = 0;\r\n        if (this._currentCluster) {\r\n            this._spiderLayer.clear();\r\n            this._spiderMarkers.splice(0);\r\n            this._spiderMarkerLookup.clear();\r\n            this._currentCluster = null;\r\n            this._mapclicks = -1;\r\n            if (this._spiderOptions.markerUnSelected) { this._spiderOptions.markerUnSelected(); }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Click event handler for when a shape in the cluster layer is clicked.\r\n     *\r\n     * @param e The mouse event argurment from the click event.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnLayerClick(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        if (e.primitive instanceof Microsoft.Maps.ClusterPushpin) {\r\n            const cp: Microsoft.Maps.ClusterPushpin = <Microsoft.Maps.ClusterPushpin>e.primitive;\r\n            const showNewCluster: boolean = cp !== this._currentCluster;\r\n            this.HideSpiderCluster();\r\n            if (showNewCluster) {\r\n                this.ShowSpiderCluster(<Microsoft.Maps.ClusterPushpin>e.primitive);\r\n            }\r\n        } else {\r\n            const pin: Microsoft.Maps.Pushpin = <Microsoft.Maps.Pushpin>e.primitive;\r\n            if (pin.metadata && pin.metadata.isClusterMarker) {\r\n                const m: BingSpiderClusterMarker = this.GetSpiderMarkerFromBingMarker(pin);\r\n                const p: BingMarker = m.ParentMarker;\r\n                const ppin: Microsoft.Maps.Pushpin = p.NativePrimitve;\r\n                if (this._spiderOptions.markerSelected) {\r\n                    this._spiderOptions.markerSelected(p, new BingMarker(this._currentCluster, null, null));\r\n                }\r\n                if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) { Microsoft.Maps.Events.invoke(ppin, 'click', e); }\r\n                this._mapclicks = 0;\r\n            } else {\r\n                if (this._spiderOptions.markerSelected) { this._spiderOptions.markerSelected(this.GetMarkerFromBingMarker(pin), null); }\r\n                if (Microsoft.Maps.Events.hasHandler(pin, 'click')) { Microsoft.Maps.Events.invoke(pin, 'click', e); }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the click event on the map (outside a spider cluster). Depending on the\r\n     * spider options, closes the cluster or increments the click counter.\r\n     *\r\n     * @param e - Mouse event\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnMapClick(e: Microsoft.Maps.IMouseEventArgs | Microsoft.Maps.IMapTypeChangeEventArgs): void {\r\n        if (this._mapclicks === -1) {\r\n            return;\r\n        } else if (++this._mapclicks >= this._spiderOptions.collapseClusterOnNthClick) {\r\n            this.HideSpiderCluster();\r\n        } else {\r\n            // do nothing as this._mapclicks has already been incremented above\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the map view changed end event. Hides the spider cluster if the zoom level has changed.\r\n     *\r\n     * @param e - Mouse event.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnMapViewChangeEnd(e: Microsoft.Maps.IMouseEventArgs | Microsoft.Maps.IMapTypeChangeEventArgs): void {\r\n        const z: number = (<Microsoft.Maps.Map>e.target).getZoom();\r\n        const hasZoomChanged: boolean = (z !== this._currentZoom);\r\n        this._currentZoom = z;\r\n        if (hasZoomChanged) {\r\n            this.HideSpiderCluster();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the map view change start event. Depending on the spider options, hides the\r\n     * the exploded spider or does nothing.\r\n     *\r\n     * @param e - Mouse event.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnMapViewChangeStart(e: Microsoft.Maps.IMouseEventArgs | Microsoft.Maps.IMapTypeChangeEventArgs): void {\r\n        if (this._spiderOptions.collapseClusterOnMapChange) {\r\n            this.HideSpiderCluster();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate invoked on mouse out on an exploded spider marker. Resets the hover style on the stick.\r\n     *\r\n     * @param e - Mouse event.\r\n     */\r\n    private OnSpiderMouseOut(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        const pin: Microsoft.Maps.Pushpin = <Microsoft.Maps.Pushpin>e.primitive;\r\n        if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {\r\n            const m: BingSpiderClusterMarker = this.GetSpiderMarkerFromBingMarker(pin);\r\n            m.Stick.setOptions(this._spiderOptions.stickStyle);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Invoked on mouse over on an exploded spider marker. Sets the hover style on the stick. Also invokes the click event\r\n     * on the underlying original marker dependent on the spider options.\r\n     *\r\n     * @param e - Mouse event.\r\n     */\r\n    private OnSpiderMouseOver(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        const pin: Microsoft.Maps.Pushpin = <Microsoft.Maps.Pushpin>e.primitive;\r\n        if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {\r\n            const m: BingSpiderClusterMarker = this.GetSpiderMarkerFromBingMarker(pin);\r\n            m.Stick.setOptions(this._spiderOptions.stickHoverStyle);\r\n            if (this._spiderOptions.invokeClickOnHover) {\r\n                const p: BingMarker = m.ParentMarker;\r\n                const ppin: Microsoft.Maps.Pushpin = p.NativePrimitve;\r\n                if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) { Microsoft.Maps.Events.invoke(ppin, 'click', e); }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the options for spider behavior.\r\n     *\r\n     * @param options ISpiderClusterOptions containing the options enumeration controlling the spider cluster behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private SetSpiderOptions(options: ISpiderClusterOptions): void {\r\n        if (options) {\r\n            if (typeof options.circleSpiralSwitchover === 'number') {\r\n                this._spiderOptions.circleSpiralSwitchover = options.circleSpiralSwitchover;\r\n            }\r\n            if (typeof options.collapseClusterOnMapChange === 'boolean') {\r\n                this._spiderOptions.collapseClusterOnMapChange = options.collapseClusterOnMapChange;\r\n            }\r\n            if (typeof options.collapseClusterOnNthClick === 'number') {\r\n                this._spiderOptions.collapseClusterOnNthClick = options.collapseClusterOnNthClick;\r\n            }\r\n            if (typeof options.invokeClickOnHover === 'boolean') {\r\n                this._spiderOptions.invokeClickOnHover = options.invokeClickOnHover;\r\n            }\r\n            if (typeof options.minSpiralAngleSeperation === 'number') {\r\n                this._spiderOptions.minSpiralAngleSeperation = options.minSpiralAngleSeperation;\r\n            }\r\n            if (typeof options.spiralDistanceFactor === 'number') {\r\n                this._spiderOptions.spiralDistanceFactor = options.spiralDistanceFactor;\r\n            }\r\n            if (typeof options.minCircleLength === 'number') {\r\n                this._spiderOptions.minCircleLength = options.minCircleLength;\r\n            }\r\n            if (options.stickHoverStyle) {\r\n                this._spiderOptions.stickHoverStyle = options.stickHoverStyle;\r\n            }\r\n            if (options.stickStyle) {\r\n                this._spiderOptions.stickStyle = options.stickStyle;\r\n            }\r\n            if (options.markerSelected) {\r\n                this._spiderOptions.markerSelected = options.markerSelected;\r\n            }\r\n            if (options.markerUnSelected) {\r\n                this._spiderOptions.markerUnSelected = options.markerUnSelected;\r\n            }\r\n            if (typeof options.visible === 'boolean') {\r\n                this._spiderOptions.visible = options.visible;\r\n            }\r\n            this.SetOptions(<IClusterOptions>options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Expands a cluster into it's open spider layout.\r\n     *\r\n     * @param cluster The cluster to show in it's open spider layout..\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private ShowSpiderCluster(cluster: Microsoft.Maps.ClusterPushpin): void {\r\n        this.HideSpiderCluster();\r\n        this._currentCluster = cluster;\r\n\r\n        if (cluster && cluster.containedPushpins) {\r\n            // Create spider data.\r\n            const m: Microsoft.Maps.Map = (<BingMapService>this._maps).MapInstance;\r\n            const pins: Array<Microsoft.Maps.Pushpin> = cluster.containedPushpins;\r\n            const center: Microsoft.Maps.Location = cluster.getLocation();\r\n            const centerPoint: Microsoft.Maps.Point =\r\n                <Microsoft.Maps.Point>m.tryLocationToPixel(center, Microsoft.Maps.PixelReference.control);\r\n            let stick: Microsoft.Maps.Polyline;\r\n            let angle = 0;\r\n            const makeSpiral: boolean = pins.length > this._spiderOptions.circleSpiralSwitchover;\r\n            let legPixelLength: number;\r\n            let stepAngle: number;\r\n            let stepLength: number;\r\n\r\n            if (makeSpiral) {\r\n                legPixelLength = this._spiderOptions.minCircleLength / Math.PI;\r\n                stepLength = 2 * Math.PI * this._spiderOptions.spiralDistanceFactor;\r\n            }\r\n            else {\r\n                stepAngle = 2 * Math.PI / pins.length;\r\n                legPixelLength = (this._spiderOptions.spiralDistanceFactor / stepAngle / Math.PI / 2) * pins.length;\r\n                if (legPixelLength < this._spiderOptions.minCircleLength) { legPixelLength = this._spiderOptions.minCircleLength; }\r\n            }\r\n\r\n            for (let i = 0, len = pins.length; i < len; i++) {\r\n                // Calculate spider pin location.\r\n                if (!makeSpiral) {\r\n                    angle = stepAngle * i;\r\n                }\r\n                else {\r\n                    angle += this._spiderOptions.minSpiralAngleSeperation / legPixelLength + i * 0.0005;\r\n                    legPixelLength += stepLength / angle;\r\n                }\r\n                const point: Microsoft.Maps.Point =\r\n                    new Microsoft.Maps.Point(centerPoint.x + legPixelLength * Math.cos(angle),\r\n                        centerPoint.y + legPixelLength * Math.sin(angle));\r\n                const loc: Microsoft.Maps.Location =\r\n                    <Microsoft.Maps.Location>m.tryPixelToLocation(point, Microsoft.Maps.PixelReference.control);\r\n\r\n                // Create stick to pin.\r\n                stick = new Microsoft.Maps.Polyline([center, loc], this._spiderOptions.stickStyle);\r\n                this._spiderLayer.add(stick);\r\n\r\n                // Create pin in spiral that contains same metadata as parent pin.\r\n                const pin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc);\r\n                pin.metadata = pins[i].metadata || {};\r\n                pin.metadata.isClusterMarker = true;\r\n                pin.setOptions(this.GetBasicPushpinOptions(pins[i]));\r\n                this._spiderLayer.add(pin);\r\n\r\n                const spiderMarker: BingSpiderClusterMarker = new BingSpiderClusterMarker(pin, null, this._spiderLayer);\r\n                spiderMarker.Stick = stick;\r\n                spiderMarker.ParentMarker = <BingMarker>this.GetMarkerFromBingMarker(pins[i]);\r\n                this._spiderMarkers.push(spiderMarker);\r\n                this._spiderMarkerLookup.set(pin, spiderMarker);\r\n\r\n            }\r\n            this._mapclicks = 0;\r\n        }\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { InfoWindow } from '../info-window';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\n\r\n/**\r\n * Concrete implementation of the {@link InfoWindow} contract for the Bing Maps V8 map architecture.\r\n *\r\n * @export\r\n */\r\nexport class BingInfoWindow implements InfoWindow {\r\n\r\n    private _isOpen: boolean;\r\n\r\n    /**\r\n     * Gets whether the info box is currently open.\r\n     *\r\n     * @readonly\r\n     * @memberof BingInfoWindow\r\n     */\r\n    public get IsOpen(): boolean {\r\n        if (this._infoBox && this._infoBox.getOptions().visible === true) { return true; }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets native primitve underlying the model.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @property\r\n     * @readonly\r\n     */\r\n    public get NativePrimitve(): Microsoft.Maps.Infobox {\r\n        return this._infoBox;\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of BingInfoWindow.\r\n     * @param _infoBox - A {@link Microsoft.Maps.Infobox} instance underlying the model\r\n     * @memberof BingInfoWindow\r\n     */\r\n    constructor(private _infoBox: Microsoft.Maps.Infobox) {\r\n        this._isOpen = false;\r\n    }\r\n\r\n    /**\r\n     * Adds an event listener to the InfoWindow.\r\n     *\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._infoBox, eventType, (e) => {\r\n            if (e.eventName === 'infoboxChanged') {\r\n                if (this._infoBox.getOptions().visible === true) { this._isOpen = true; }\r\n                else {\r\n                    if (this._infoBox.getOptions().visible === false && this._isOpen === true) {\r\n                        this._isOpen = false;\r\n                        fn(e);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                fn(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Closes the info window.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public Close(): void {\r\n        const o: Microsoft.Maps.IInfoboxOptions = {};\r\n        o.visible = false;\r\n        this._infoBox.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Gets the position of the info window.\r\n     *\r\n     * @returns - Returns the geo coordinates of the info window.\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public GetPosition(): ILatLong {\r\n        const p: ILatLong = {\r\n            latitude: this._infoBox.getLocation().latitude,\r\n            longitude: this._infoBox.getLocation().longitude\r\n        };\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Opens the info window.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public Open(): void {\r\n        const o: Microsoft.Maps.IInfoboxOptions = {};\r\n        o.visible = true;\r\n        this._infoBox.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options.\r\n     *\r\n     * @param options - Info window options to set. The options will be merged with any existing options.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public SetOptions(options: IInfoWindowOptions): void {\r\n        const o: Microsoft.Maps.IInfoboxOptions = BingConversions.TranslateInfoBoxOptions(options);\r\n        this._infoBox.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the info window position.\r\n     *\r\n     * @param position - Geo coordinates to move the anchor of the info window to.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public SetPosition(position: ILatLong): void {\r\n        const l: Microsoft.Maps.Location = BingConversions.TranslateLocation(position);\r\n        this._infoBox.setLocation(l);\r\n    }\r\n}\r\n","import { ILabelOptions } from '../interfaces/ilabel-options';\r\n\r\n/**\r\n * Abstract base implementing a label to be placed on the map.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class MapLabel {\r\n// export class MapLabel extends Microsoft.Maps.CustomOverlay {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _canvas: HTMLCanvasElement;\r\n\r\n    /**\r\n     * Returns the default label style for the platform\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof MapLabel\r\n     */\r\n    public abstract get DefaultLabelStyle(): ILabelOptions;\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new MapLabel\r\n     * @param options Optional properties to set.\r\n     */\r\n    constructor(options: { [key: string]: any }) {\r\n        this.Set('fontFamily', 'sans-serif');\r\n        this.Set('fontSize', 12);\r\n        this.Set('fontColor', '#ffffff');\r\n        this.Set('strokeWeight', 4);\r\n        this.Set('strokeColor', '#000000');\r\n        this.Set('align', 'center');\r\n        this.SetValues(options);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Deletes the label from the map. This method does not atually delete the label itself, so\r\n     * it can be readded to map later.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Delete(): void {\r\n        this.SetMap(null);\r\n    }\r\n\r\n    /**\r\n     * Delegate called when underlying properties change.\r\n     *\r\n     * @param prop - The property or properties that have changed.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Changed(prop: string | Array<string>): void {\r\n        let shouldRunDrawCanvas = false;\r\n        let shouldRunDraw = false;\r\n        if (!Array.isArray(prop)) { prop = [prop]; }\r\n        prop.forEach(p => {\r\n            switch (p) {\r\n                case 'fontFamily':\r\n                case 'fontSize':\r\n                case 'fontColor':\r\n                case 'strokeWeight':\r\n                case 'strokeColor':\r\n                case 'align':\r\n                case 'text':\r\n                    shouldRunDrawCanvas = true;\r\n                    break;\r\n                case 'maxZoom':\r\n                case 'minZoom':\r\n                case 'offset':\r\n                case 'hidden':\r\n                case 'position':\r\n                    shouldRunDraw = true;\r\n                    break;\r\n            }\r\n        });\r\n        if (shouldRunDrawCanvas) { this.DrawCanvas(); }\r\n        if (shouldRunDraw) { this.Draw(); }\r\n    }\r\n\r\n    /**\r\n     * Gets the value of a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @returns - The value of the setting.\r\n     * @memberof MapLabel\r\n     * @abstract\r\n     * @method\r\n     */\r\n    public abstract Get(key: string): any;\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @returns - A native map object for the underlying implementation. Implementing derivatives should return the\r\n     * actual native object.\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @abstract\r\n     */\r\n    public abstract GetMap(): any;\r\n\r\n    /**\r\n     * Set the value for a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @param val - The value to set.\r\n     * @memberof MapLabel\r\n     * @abstract\r\n     * @method\r\n     */\r\n    public abstract Set(key: string, val: any): void;\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - A native map object for the underlying implementation. Implementing derivatives should return the\r\n     * actual native object.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public abstract SetMap(map: any): void;\r\n\r\n    /**\r\n     * Applies settings to the object\r\n     *\r\n     * @param options - An object containing the settings key value pairs.\r\n     * @memberof MapLabel\r\n     * @abstract\r\n     * @method\r\n     */\r\n    public abstract SetValues(options: { [key: string]: any }): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Get the visibility of the label. Visibility depends on Zoom settings.\r\n     * @returns - blank string if visible, 'hidden' if invisible.\r\n     * @protected\r\n     */\r\n    protected GetVisible() {\r\n        const minZoom: number = this.Get('minZoom');\r\n        const maxZoom: number = this.Get('maxZoom');\r\n        const hidden: boolean = this.Get('hidden');\r\n\r\n        if (hidden) {return 'hidden'; }\r\n        if (minZoom === undefined && maxZoom === undefined) { return ''; }\r\n        if (!this.GetMap()) { return ''; }\r\n\r\n        const mapZoom: number = this.GetMap().getZoom();\r\n        if (mapZoom < minZoom || mapZoom > maxZoom) { return 'hidden'; }\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Draws the label on the map.\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected abstract Draw(): void;\r\n\r\n    /**\r\n     * Draws the label to the canvas 2d context.\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected DrawCanvas () {\r\n        if (!this._canvas) { return; }\r\n\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        style.zIndex = this.Get('zIndex');\r\n\r\n        const ctx: CanvasRenderingContext2D = this._canvas.getContext('2d');\r\n        ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        ctx.strokeStyle = this.Get('strokeColor');\r\n        ctx.font = this.Get('fontSize') + 'px ' + this.Get('fontFamily');\r\n\r\n        const backgroundColor: string = this.Get('backgroundColor');\r\n        const strokeWeight: number = Number(this.Get('strokeWeight'));\r\n        const text: string = this.Get('text');\r\n        const textMeasure: TextMetrics = ctx.measureText(text);\r\n        const textWidth: number = textMeasure.width;\r\n        if (text && strokeWeight && strokeWeight > 0) {\r\n                ctx.lineWidth = strokeWeight;\r\n                ctx.strokeText(text, 4, 4);\r\n        }\r\n        if (backgroundColor && backgroundColor !== '') {\r\n            ctx.fillStyle = backgroundColor;\r\n            ctx.fillRect(0, 0, textWidth + 8, (parseInt(ctx.font, 10) * 2) - 2);\r\n        }\r\n        ctx.fillStyle = this.Get('fontColor');\r\n        ctx.fillText(text, 4, 4);\r\n\r\n        style.marginLeft = this.GetMarginLeft(textWidth) + 'px';\r\n        style.marginTop = '-0.4em';\r\n        style.pointerEvents = 'none';\r\n            // Bring actual text top in line with desired latitude.\r\n            // Cheaper than calculating height of text.\r\n    }\r\n\r\n    /**\r\n     * Gets the appropriate margin-left for the canvas.\r\n     * @param textWidth  - The width of the text, in pixels.\r\n     * @returns - The margin-left, in pixels.\r\n     * @protected\r\n     * @method\r\n     * @memberof MapLabel\r\n     */\r\n    protected GetMarginLeft(textWidth: number): number {\r\n        switch (this.Get('align')) {\r\n            case 'left':    return 0;\r\n            case 'right':   return -textWidth;\r\n        }\r\n        return textWidth / -2;\r\n    }\r\n\r\n    /**\r\n     * Delegate called when the label is added to the map. Generates and configures\r\n     * the canvas.\r\n     *\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @protected\r\n     * @abstract\r\n     */\r\n    protected abstract OnAdd(): void;\r\n\r\n    /**\r\n     * Called when the label is removed from the map.\r\n     * @method\r\n     * @protected\r\n     * @memberof MapLabel\r\n     */\r\n    protected OnRemove() {\r\n        if (this._canvas && this._canvas.parentNode) {\r\n            this._canvas.parentNode.removeChild(this._canvas);\r\n        }\r\n    }\r\n}\r\n\r\n","export class Extender {\r\n\r\n    private _obj: any;\r\n    private _proto: any;\r\n\r\n    constructor(obj: any) {\r\n        this._obj = obj;\r\n        this._proto = obj.prototype;\r\n    }\r\n\r\n    Extend(newObj: any): Extender {\r\n\r\n        this.Set('prototype', newObj, this._obj);\r\n\r\n        for (const y in this._proto) {\r\n            if ((<any>this._proto)[y] != null) {\r\n                this.Set(y, (this._proto)[y], (<any>this._obj.prototype)[y]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    Set(property: string, newObj: any, obj?: any): Extender {\r\n        if (typeof newObj === 'undefined') {\r\n            return this;\r\n        }\r\n\r\n        if (typeof obj === 'undefined') {\r\n            obj = this._proto;\r\n        }\r\n\r\n        Object.defineProperty(obj, property, newObj);\r\n    }\r\n\r\n    Map(property: string, newProperty: string): Extender {\r\n        this.Set(property, this._proto[newProperty], this._obj.prototype);\r\n        return this;\r\n    }\r\n}","import { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { ILabelOptions } from '../../interfaces/ilabel-options';\r\nimport { MapLabel } from '../map-label';\r\nimport { Extender } from '../extender';\r\n\r\nlet id: number = 0;\r\n\r\n/**\r\n * Implements map a labled to be placed on the map.\r\n *\r\n * @export\r\n */\r\nexport class BingMapLabel extends MapLabel {\r\n\r\n    /**\r\n     * Returns the default label style for the platform\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMapLabel\r\n     */\r\n    public get DefaultLabelStyle(): ILabelOptions {\r\n        return {\r\n            fontSize: 12,\r\n            fontFamily: 'sans-serif',\r\n            fontColor: '#ffffff',\r\n            strokeWeight: 2,\r\n            strokeColor: '#000000'\r\n        };\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new MapLabel\r\n     * @param options Optional properties to set.\r\n     */\r\n    constructor(options: { [key: string]: any }) {\r\n        options.fontSize = options.fontSize || 12;\r\n        options.fontColor = options.fontColor || '#ffffff';\r\n        options.strokeWeight = options.strokeWeight || 2;\r\n        options.strokeColor = options.strokeColor || '#000000';\r\n        super(options);\r\n        (<any>this)._options.beneathLabels = false;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the value of a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @returns - The value of the setting.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public Get(key: string): any {\r\n        return (<any>this)[key];\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public GetMap(): Microsoft.Maps.Map {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Set the value for a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @param val - The value to set.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public Set(key: string, val: any): void {\r\n        if (key === 'position' && !val.hasOwnProperty('altitude') && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {\r\n            val = new Microsoft.Maps.Location(val.latitude, val.longitude);\r\n        }\r\n        if (this.Get(key) !== val) {\r\n            (<any>this)[key] = val;\r\n            this.Changed(key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - Map to associated with the label.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public SetMap(map: Microsoft.Maps.Map): void {\r\n        const m: Microsoft.Maps.Map = this.GetMap();\r\n        if (map === m) { return; }\r\n        if (m) {\r\n            m.layers.remove(this);\r\n        }\r\n        if (map != null) {\r\n            map.layers.insert(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies settings to the object\r\n     *\r\n     * @param options - An object containing the settings key value pairs.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public SetValues(options: { [key: string]: any }): void {\r\n        const p: Array<string> = new Array<string>();\r\n        for (const key in options) {\r\n            if (key !== '') {\r\n                if (key === 'position' && !options[key].hasOwnProperty('altitude') &&\r\n                    options[key].hasOwnProperty('latitude') && options[key].hasOwnProperty('longitude')) {\r\n                    options[key] = new Microsoft.Maps.Location(options[key].latitude, options[key].longitude);\r\n                }\r\n                if (this.Get(key) !== options[key]) {\r\n                    (<any>this)[key] = options[key];\r\n                    p.push(key);\r\n                }\r\n            }\r\n        }\r\n        if (p.length > 0) { this.Changed(p); }\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Draws the label on the map.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Draw(): void {\r\n        const visibility: string = this.GetVisible();\r\n        const m: Microsoft.Maps.Map = this.GetMap();\r\n        if (!this._canvas) { return; }\r\n        if (!m) { return; }\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        if (visibility !== '') {\r\n            // label is not visible, don't calculate positions etc.\r\n            style['visibility'] = visibility;\r\n            return;\r\n        }\r\n\r\n        let offset: Microsoft.Maps.Point = this.Get('offset');\r\n        const latLng: Microsoft.Maps.Location = this.Get('position');\r\n        if (!latLng) { return; }\r\n        if (!offset) { offset = new Microsoft.Maps.Point(0, 0); }\r\n\r\n        const pos: Microsoft.Maps.Point = <Microsoft.Maps.Point>m.tryLocationToPixel(\r\n            latLng,\r\n            Microsoft.Maps.PixelReference.control);\r\n        style['top'] = (pos.y + offset.y) + 'px';\r\n        style['left'] = (pos.x + offset.x) + 'px';\r\n        style['visibility'] = visibility;\r\n    }\r\n\r\n    /**\r\n     * Delegate called when the label is added to the map. Generates and configures\r\n     * the canvas.\r\n     *\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected OnAdd() {\r\n        this._canvas = document.createElement('canvas');\r\n        this._canvas.id = `xMapLabel${id++}`;\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        style.position = 'absolute';\r\n\r\n        const ctx: CanvasRenderingContext2D = this._canvas.getContext('2d');\r\n        ctx.lineJoin = 'round';\r\n        ctx.textBaseline = 'top';\r\n\r\n        (<any>this).setHtmlElement(this._canvas);\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Delegate callled when the label is loaded\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    private OnLoad() {\r\n        Microsoft.Maps.Events.addHandler(this.GetMap(), 'viewchange', () => {\r\n            this.Changed('position');\r\n        });\r\n        this.DrawCanvas();\r\n        this.Draw();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the CustomOverlay into the MapLabel\r\n *\r\n * @export\r\n * @method\r\n */\r\nexport function MixinMapLabelWithOverlayView() {\r\n    new Extender(BingMapLabel)\r\n    .Extend(new Microsoft.Maps.CustomOverlay())\r\n    .Map('onAdd', 'OnAdd')\r\n    .Map('onLoad', 'OnLoad')\r\n    .Map('onRemove', 'OnRemove');\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolygonEvent } from '../../interfaces/ipolygon-event';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { Polygon } from '../polygon';\r\nimport { BingMapLabel } from './bing-label';\r\n\r\n/**\r\n * Concrete implementation for a polygon model for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\nexport class BingPolygon extends Polygon implements Polygon {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _map: Microsoft.Maps.Map = null;\r\n    private _isEditable: boolean = false;\r\n    private _title: string = '';\r\n    private _maxZoom: number = -1;\r\n    private _minZoom: number = -1;\r\n    private _showLabel: boolean = false;\r\n    private _showTooltip: boolean = false;\r\n    private _label: BingMapLabel = null;\r\n    private _tooltip: BingMapLabel = null;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _tooltipVisible: boolean = false;\r\n    private _mouseOverListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseMoveListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseOutListener: Microsoft.Maps.IHandlerId;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _originalPath: Array<Array<ILatLong>>;\r\n    private _editingCompleteEmitter: (event: IPolygonEvent) => void;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMaxZoom(): number { return this._maxZoom; }\r\n    public set LabelMaxZoom(val: number) {\r\n        this._maxZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMinZoom(): number { return this._minZoom; }\r\n    public set LabelMinZoom(val: number) {\r\n        this._minZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolygon\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polygon, in this case {@link Microsoft.Maps.Polygon}\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolygon\r\n     */\r\n    public get NativePrimitve(): Microsoft.Maps.Polygon { return this._polygon; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the label\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolygon\r\n     * @property\r\n     */\r\n    public get ShowLabel(): boolean { return this._showLabel; }\r\n    public set ShowLabel(val: boolean) {\r\n        this._showLabel = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolygon\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolygon\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageLabel();\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolygon.\r\n     * @param _polygon - The {@link Microsoft.Maps.Polygon} underlying the model.\r\n     * @param _mapService Instance of the Map Service.\r\n     * @param _layer - The context layer.\r\n     * @memberof BingPolygon\r\n     */\r\n    constructor(\r\n        private _polygon: Microsoft.Maps.Polygon,\r\n        protected _mapService: BingMapService,\r\n        protected _layer: Microsoft.Maps.Layer,\r\n    ) {\r\n        super();\r\n        this._map = this._mapService.MapInstance;\r\n        this._originalPath = this.GetPaths();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n\r\n     * @memberof BingPolygon\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            Microsoft.Maps.Events.addHandler(this._polygon, eventType, (e) => {\r\n                fn(e);\r\n            });\r\n        }\r\n        if (eventType === 'mousemove') {\r\n            let handlerId: Microsoft.Maps.IHandlerId;\r\n            Microsoft.Maps.Events.addHandler(this._polygon, 'mouseover', e => {\r\n                handlerId = Microsoft.Maps.Events.addHandler(this._map, 'mousemove', m => fn(m));\r\n            });\r\n            Microsoft.Maps.Events.addHandler(this._polygon, 'mouseout', e => {\r\n                if (handlerId) { Microsoft.Maps.Events.removeHandler(handlerId); }\r\n            });\r\n        } if (eventType === 'pathchanged') {\r\n            this._editingCompleteEmitter = <(event: IPolygonEvent) => void>fn;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polygon.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public Delete(): void {\r\n        if (this._layer) { this._layer.remove(this.NativePrimitve); }\r\n        else {\r\n            this._map.entities.remove(this.NativePrimitve);\r\n        }\r\n        if (this._label) { this._label.Delete(); }\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is draggable.\r\n     *\r\n     * @returns - True if the polygon is dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetDraggable(): boolean {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8?\r\n        ///     forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._isEditable;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polygon path.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<Microsoft.Maps.Location> = this._polygon.getLocations();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(l => path.push({ latitude: l.latitude, longitude: l.longitude }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon paths.\r\n     *\r\n     * @returns - Array of Array of {@link ILatLong} objects describing multiple polygon paths.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetPaths(): Array<Array<ILatLong>> {\r\n        const p: Array<Array<Microsoft.Maps.Location>> = this._polygon.getRings();\r\n        const paths: Array<Array<ILatLong>> = new Array<Array<ILatLong>>();\r\n        p.forEach(x => {\r\n            const path: Array<ILatLong> = new Array<ILatLong>();\r\n            x.forEach(y => path.push({ latitude: y.latitude, longitude: y.longitude }));\r\n            paths.push(path);\r\n        });\r\n        return paths;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is visible.\r\n     *\r\n     * @returns - True if the polygon is visible, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polygon.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is dragable.\r\n     *\r\n     * @param draggable - True to make the polygon dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8\r\n        //      ?forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        throw (new Error('The bing maps implementation currently does not support draggable polygons.'));\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polygon path is editable.\r\n     *\r\n     * @param editable - True to make polygon path editable, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        const isChanged = this._isEditable !== editable;\r\n        this._isEditable = editable;\r\n        if (!isChanged) {\r\n            return;\r\n        }\r\n\r\n        if (this._isEditable) {\r\n            this._originalPath = this.GetPaths();\r\n            this._mapService.GetDrawingTools().then(t => {\r\n                t.edit(this._polygon);\r\n            });\r\n        }\r\n        else {\r\n            this._mapService.GetDrawingTools().then(t => {\r\n                t.finish((editedPolygon: Microsoft.Maps.Polygon) => {\r\n                    if (editedPolygon !== this._polygon || !this._editingCompleteEmitter) {\r\n                        return;\r\n                    }\r\n                    const newPath: Array<Array<ILatLong>> = this.GetPaths();\r\n                    const originalPath: Array<Array<ILatLong>> = this._originalPath;\r\n                    this.SetPaths(newPath);\r\n                        // this is necessary for the new path to persist it appears.\r\n                    this._editingCompleteEmitter({\r\n                        Click: null,\r\n                        Polygon: this,\r\n                        OriginalPath: originalPath,\r\n                        NewPath: newPath\r\n                    });\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public SetOptions(options: IPolygonOptions): void {\r\n        const o: Microsoft.Maps.IPolygonOptions = BingConversions.TranslatePolygonOptions(options);\r\n        this._polygon.setOptions(o);\r\n        if (options.visible != null && this._showLabel && this._label) { this._label.Set('hidden', !options.visible); }\r\n\r\n        if (typeof options.editable !== 'undefined') {\r\n            this.SetEditable(options.editable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polygons path.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n        path.forEach(x => p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)));\r\n        this._originalPath = [path];\r\n        this._polygon.setLocations(p);\r\n        if (this._label) {\r\n            this._centroid = null;\r\n            this.ManageLabel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the polygon path or paths.\r\n     *\r\n     * @param paths\r\n     * An Array of {@link ILatLong} (or array of arrays) describing the polygons path(s).\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetPaths(paths: Array<Array<ILatLong>> | Array<ILatLong>): void {\r\n        if (paths == null) { return; }\r\n        if (!Array.isArray(paths)) { return; }\r\n        if (paths.length === 0) {\r\n            this._polygon.setRings(new Array<Microsoft.Maps.Location>());\r\n            if (this._label) {\r\n                this._label.Delete();\r\n                this._label = null;\r\n            }\r\n            return;\r\n        }\r\n        if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            const p: Array<Array<Microsoft.Maps.Location>> = new Array<Array<Microsoft.Maps.Location>>();\r\n            (<Array<Array<ILatLong>>>paths).forEach(path => {\r\n                const _p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n                path.forEach(x => _p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)));\r\n                p.push(_p);\r\n            });\r\n            this._originalPath = <Array<Array<ILatLong>>>paths;\r\n            this._polygon.setRings(p);\r\n            if (this._label) {\r\n                this._centroid = null;\r\n                this.ManageLabel();\r\n            }\r\n        }\r\n        else {\r\n            // parameter is a simple array....\r\n            this.SetPath(<Array<ILatLong>>paths);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is visible.\r\n     *\r\n     * @param visible - True to set the polygon visible, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polygon.setOptions(<Microsoft.Maps.IPolygonOptions>{ visible: visible });\r\n        if (this._showLabel && this._label) { this._label.Set('hidden', !visible); }\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Configures the label for the polygon\r\n     * @memberof Polygon\r\n     */\r\n    private ManageLabel(): void {\r\n        if (this.GetPath == null || this.GetPath().length === 0) { return; }\r\n        if (this._showLabel && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                position: BingConversions.TranslateLocation(this.Centroid)\r\n            };\r\n            if (o.position == null) { return; }\r\n            if (this._minZoom !== -1) { o.minZoom = this._minZoom; }\r\n            if (this._maxZoom !== -1) { o.maxZoom = this._maxZoom; }\r\n            if (this._label == null) {\r\n                this._label = new BingMapLabel(o);\r\n                this._label.SetMap(this._map);\r\n            }\r\n            else {\r\n                this._label.SetValues(o);\r\n            }\r\n            this._label.Set('hidden', !this.GetVisible());\r\n        }\r\n        else {\r\n            if (this._label) {\r\n                this._label.SetMap(null);\r\n                this._label = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configures the tooltip for the polygon\r\n     * @memberof Polygon\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new Microsoft.Maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                this._tooltip = new BingMapLabel(o);\r\n                this._tooltip.SetMap(this._map);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = Microsoft.Maps.Events.addHandler(\r\n                    this._polygon, 'mouseover', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                        this._tooltip.Set('position', e.location);\r\n                        if (!this._tooltipVisible) {\r\n                            this._tooltip.Set('hidden', false);\r\n                            this._tooltipVisible = true;\r\n                        }\r\n                        this._mouseMoveListener = Microsoft.Maps.Events.addHandler(\r\n                            this._map, 'mousemove', (m: Microsoft.Maps.IMouseEventArgs) => {\r\n                                if (this._tooltipVisible && m.location && m.primitive === this._polygon) {\r\n                                    this._tooltip.Set('position', m.location);\r\n                                }\r\n                            });\r\n                    });\r\n                this._mouseOutListener = Microsoft.Maps.Events.addHandler(\r\n                    this._polygon, 'mouseout', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                        if (this._tooltipVisible) {\r\n                            this._tooltip.Set('hidden', true);\r\n                            this._tooltipVisible = false;\r\n                        }\r\n                        if (this._mouseMoveListener) { Microsoft.Maps.Events.removeHandler(this._mouseMoveListener); }\r\n                    });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { Microsoft.Maps.Events.removeHandler(this._mouseOutListener); }\r\n                if (this._mouseOverListener) { Microsoft.Maps.Events.removeHandler(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { Microsoft.Maps.Events.removeHandler(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { Polyline } from '../polyline';\r\nimport { BingMapLabel } from './bing-label';\r\n\r\n/**\r\n * Concrete implementation for a polyline model for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\nexport class BingPolyline extends Polyline implements Polyline {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _isEditable: boolean = true;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n    private _title: string = '';\r\n    private _showTooltip: boolean = false;\r\n    private _tooltip: BingMapLabel = null;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _tooltipVisible: boolean = false;\r\n    private _mouseOverListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseMoveListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseOutListener: Microsoft.Maps.IHandlerId;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * Gets the polyline metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolyline\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the Navitve Polyline underlying the model\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolyline\r\n     */\r\n    public get NativePrimitve(): Microsoft.Maps.Polyline { return this._polyline; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolyline\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polyline\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolyline\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolygon.\r\n     * @param _polyline - The {@link Microsoft.Maps.Polyline} underlying the model.\r\n     * @param _map - The context map.\r\n     * @param _layer - The context layer.\r\n     * @memberof BingPolyline\r\n     */\r\n    constructor(private _polyline: Microsoft.Maps.Polyline, protected _map: Microsoft.Maps.Map, protected _layer: Microsoft.Maps.Layer) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     * @memberof BingPolyline\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup' ];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            Microsoft.Maps.Events.addHandler(this._polyline, eventType, (e) => {\r\n                fn(e);\r\n            });\r\n        }\r\n        if (eventType === 'mousemove') {\r\n            let handlerId: Microsoft.Maps.IHandlerId;\r\n            Microsoft.Maps.Events.addHandler(this._polyline, 'mouseover', e => {\r\n                handlerId = Microsoft.Maps.Events.addHandler(this._map, 'mousemove', m => fn(m));\r\n            });\r\n            Microsoft.Maps.Events.addHandler(this._polyline, 'mouseout', e => {\r\n                if (handlerId) { Microsoft.Maps.Events.removeHandler(handlerId); }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polyline.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public Delete(): void {\r\n        if (this._layer) { this._layer.remove(this.NativePrimitve); }\r\n        else {\r\n            this._map.entities.remove(this.NativePrimitve);\r\n        }\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is draggable.\r\n     *\r\n     * @returns - True if the polyline is dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetDraggable(): boolean {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8\r\n        ///     ?forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._isEditable;\r\n    }\r\n\r\n    /**\r\n     * Gets the polyline path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polyline path.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<Microsoft.Maps.Location> = this._polyline.getLocations();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(l => path.push({ latitude: l.latitude, longitude: l.longitude }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is visible.\r\n     *\r\n     * @returns - True if the polyline is visible, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polyline.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is dragable.\r\n     *\r\n     * @param draggable - True to make the polyline dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8\r\n        ///     ?forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        throw(new Error('The bing maps implementation currently does not support draggable polylines.'));\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polyline path is editable.\r\n     *\r\n     * @param editable - True to make polyline path editable, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        this._isEditable = editable;\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetOptions(options: IPolylineOptions): void {\r\n        const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(options);\r\n        this._polyline.setOptions(o);\r\n        if (options.path) {\r\n            this.SetPath(<Array<ILatLong>>options.path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polylines path.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n        path.forEach(x => p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)));\r\n        this._polyline.setLocations(p);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is visible.\r\n     *\r\n     * @param visible - True to set the polyline visible, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polyline.setOptions(<Microsoft.Maps.IPolylineOptions>{ visible: visible });\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Configures the tooltip for the polygon\r\n     * @memberof Polygon\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new Microsoft.Maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                this._tooltip = new BingMapLabel(o);\r\n                this._tooltip.SetMap(this._map);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = Microsoft.Maps.Events.addHandler(\r\n                        this._polyline, 'mouseover', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                    this._tooltip.Set('position', e.location);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                });\r\n                this._mouseMoveListener = Microsoft.Maps.Events.addHandler(\r\n                            this._map, 'mousemove', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                    if (this._tooltipVisible && e.location && e.primitive === this._polyline) {\r\n                        this._tooltip.Set('position', e.location);\r\n                    }\r\n                });\r\n                this._mouseOutListener = Microsoft.Maps.Events.addHandler(\r\n                            this._polyline, 'mouseout', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                    if (this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', true);\r\n                        this._tooltipVisible = false;\r\n                    }\r\n                });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { Microsoft.Maps.Events.removeHandler(this._mouseOutListener) ; }\r\n                if (this._mouseOverListener) { Microsoft.Maps.Events.removeHandler(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { Microsoft.Maps.Events.removeHandler(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { IMapEventLookup } from '../../interfaces/imap-event-lookup';\r\n\r\n/**\r\n * This contstant translates the abstract map events into their corresponding bing map\r\n * equivalents.\r\n */\r\nexport const BingMapEventsLookup: IMapEventLookup = {\r\n    click :             'click',\r\n    dblclick :          'dblclick',\r\n    rightclick :        'rightclick',\r\n    resize :            'resize',\r\n    boundschanged :     'viewchangeend',\r\n    centerchanged :     'viewchangeend',\r\n    zoomchanged :       'viewchangeend',\r\n    mouseover:          'mouseover',\r\n    mouseout :          'mouseout',\r\n    mousemove :         'mousemove',\r\n    infowindowclose:    'infoboxChanged'\r\n};\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { CanvasOverlay } from '../canvas-overlay';\r\nimport { MapLabel } from '../map-label';\r\nimport { BingMapLabel } from './bing-label';\r\nimport { Extender } from '../extender';\r\n\r\n/**\r\n * Concrete implementing a canvas overlay to be placed on the map for Bing Maps.\r\n *\r\n * @export\r\n */\r\nexport class BingCanvasOverlay extends CanvasOverlay {\r\n\r\n    ///\r\n    /// field declarations\r\n    ///\r\n    private _viewChangeEvent: Microsoft.Maps.IHandlerId;\r\n    private _viewChangeEndEvent: Microsoft.Maps.IHandlerId;\r\n    private _mapResizeEvent: Microsoft.Maps.IHandlerId;\r\n\r\n\r\n    /**\r\n     * Creates a new instance of the BingCanvasOverlay class.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @memberof BingCanvasOverlay\r\n     */\r\n    constructor(drawCallback: (canvas: HTMLCanvasElement) => void) {\r\n        super(drawCallback);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Obtains geo coordinates for the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event. Expected to implement {@link Microsoft.Maps.IMouseEventArgs}.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     * @memberof BingCanvasOverlay\r\n     */\r\n    public GetCoordinatesFromClick(e: Microsoft.Maps.IMouseEventArgs): ILatLong {\r\n        return { latitude: e.location.latitude, longitude: e.location.longitude };\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof BingCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetMap(): Microsoft.Maps.Map {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Returns a MapLabel instance for the current platform that can be used as a tooltip.\r\n     * This method only generates the map label. Content and placement is the responsibility\r\n     * of the caller. Note that this method returns null until OnLoad has been called.\r\n     *\r\n     * @returns - The label to be used for the tooltip.\r\n     * @memberof BingCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetToolTipOverlay(): MapLabel {\r\n        const o: { [key: string]: any } = {\r\n            align: 'left',\r\n            offset: new Microsoft.Maps.Point(0, 25),\r\n            backgroundColor: 'bisque',\r\n            hidden: true,\r\n            fontSize: 12,\r\n            fontColor: '#000000',\r\n            strokeWeight: 0\r\n        };\r\n        const label: MapLabel = new BingMapLabel(o);\r\n        label.SetMap(this.GetMap());\r\n        return label;\r\n    }\r\n\r\n    /**\r\n     * CanvasOverlay loaded, attach map events for updating canvas.\r\n     * @abstract\r\n     * @method\r\n     * @memberof BingCanvasOverlay\r\n     */\r\n    public OnLoad() {\r\n        const map: Microsoft.Maps.Map = (<any>this).getMap();\r\n\r\n        // Get the current map view information.\r\n        this._zoomStart = map.getZoom();\r\n        this._centerStart = <ILatLong>map.getCenter();\r\n\r\n        // Redraw the canvas.\r\n        this.Redraw(true);\r\n\r\n        // When the map moves, move the canvas accordingly.\r\n        this._viewChangeEvent = Microsoft.Maps.Events.addHandler(map, 'viewchange', (e) => {\r\n            if (map.getMapTypeId() === Microsoft.Maps.MapTypeId.streetside) {\r\n                // Don't show the canvas if the map is in Streetside mode.\r\n                this._canvas.style.display = 'none';\r\n            }\r\n            else {\r\n                // Re-drawing the canvas as it moves would be too slow. Instead, scale and translate canvas element.\r\n                const zoomCurrent: number = map.getZoom();\r\n                const centerCurrent: Microsoft.Maps.Location = map.getCenter();\r\n\r\n                // Calculate map scale based on zoom level difference.\r\n                const scale: number = Math.pow(2, zoomCurrent - this._zoomStart);\r\n\r\n                // Calculate the scaled dimensions of the canvas.\r\n                const newWidth: number = map.getWidth() * scale;\r\n                const newHeight: number = map.getHeight() * scale;\r\n\r\n                // Calculate offset of canvas based on zoom and center offsets.\r\n                const pixelPoints: Array<Microsoft.Maps.Point> = <Array<Microsoft.Maps.Point>>map.tryLocationToPixel([\r\n                        BingConversions.TranslateLocation(this._centerStart),\r\n                        centerCurrent\r\n                    ], Microsoft.Maps.PixelReference.control);\r\n                const centerOffsetX: number = pixelPoints[1].x - pixelPoints[0].x;\r\n                const centerOffsetY: number = pixelPoints[1].y - pixelPoints[0].y;\r\n                const x: number = (-(newWidth - map.getWidth()) / 2) - centerOffsetX;\r\n                const y: number = (-(newHeight - map.getHeight()) / 2) - centerOffsetY;\r\n\r\n                // Update the canvas CSS position and dimensions.\r\n                this.UpdatePosition(x, y, newWidth, newHeight);\r\n            }\r\n        });\r\n\r\n        // When the map stops moving, render new data on the canvas.\r\n        this._viewChangeEndEvent = Microsoft.Maps.Events.addHandler(map, 'viewchangeend', (e) => {\r\n            this.UpdateCanvas();\r\n        });\r\n\r\n        // Update the position of the overlay when the map is resized.\r\n        this._mapResizeEvent = Microsoft.Maps.Events.addHandler(map, 'mapresize', (e) => {\r\n            this.UpdateCanvas();\r\n        });\r\n\r\n        // set the overlay to ready state\r\n        this._readyResolver(true);\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - Map to associated with the label.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public SetMap(map: Microsoft.Maps.Map): void {\r\n        const m: Microsoft.Maps.Map = this.GetMap();\r\n        if (map === m) { return; }\r\n        if (m) {\r\n            m.layers.remove(this);\r\n        }\r\n        if (map != null) {\r\n            map.layers.insert(this);\r\n        }\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Attaches the canvas to the map.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    protected SetCanvasElement(el: HTMLCanvasElement): void {\r\n        (<any>this).setHtmlElement(el);\r\n    }\r\n\r\n    /**\r\n     * Remove the map event handlers.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected RemoveEventHandlers(): void {\r\n        // Remove all event handlers from the map.\r\n        Microsoft.Maps.Events.removeHandler(this._viewChangeEvent);\r\n        Microsoft.Maps.Events.removeHandler(this._viewChangeEndEvent);\r\n        Microsoft.Maps.Events.removeHandler(this._mapResizeEvent);\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas size based on the map size.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Resize(): void {\r\n        const map: Microsoft.Maps.Map = (<any>this).getMap();\r\n\r\n        // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.\r\n        this._canvas.width = map.getWidth();\r\n        this._canvas.height = map.getHeight();\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected UpdateCanvas(): void {\r\n        const map: Microsoft.Maps.Map = (<any>this).getMap();\r\n\r\n        // Only render the canvas if it isn't in streetside mode.\r\n        if (map.getMapTypeId() !== Microsoft.Maps.MapTypeId.streetside) {\r\n            this._canvas.style.display = '';\r\n\r\n            // Reset CSS position and dimensions of canvas.\r\n            this.UpdatePosition(0, 0, map.getWidth(), map.getHeight());\r\n\r\n            // Redraw the canvas.\r\n            this.Redraw(true);\r\n\r\n            // Get the current map view information.\r\n            this._zoomStart = map.getZoom();\r\n            this._centerStart = <ILatLong>map.getCenter();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the OverlayView into the CanvasOverlay\r\n *\r\n * @export\r\n * @method\r\n */\r\nexport function MixinCanvasOverlay() {\r\n\r\n    new Extender(BingCanvasOverlay)\r\n    .Extend(new Microsoft.Maps.CustomOverlay())\r\n    .Map('onAdd', 'OnAdd')\r\n    .Map('onLoad', 'OnLoad')\r\n    .Map('onRemove', 'OnRemove');\r\n}\r\n","import { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { IBox } from '../../interfaces/ibox';\r\nimport { IMapOptions } from '../../interfaces/imap-options';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport * as GoogleMapTypes from './google-map-types';\r\nimport { MapTypeId } from '../../models/map-type-id';\r\n\r\ndeclare var google: any;\r\n\r\n\r\n/**\r\n * This class contains helperfunctions to map various interfaces used to represent options and structures into the\r\n * corresponding Google Maps specific implementations.\r\n *\r\n * @export\r\n */\r\nexport class GoogleConversions {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    /**\r\n     * Map option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _mapOptionsAttributes: string[] = [\r\n        'backgroundColor',\r\n        'center',\r\n        'clickableIcons',\r\n        'customMapStyleGoogle',\r\n        'disableDefaultUI',\r\n        'disableDoubleClickZoom',\r\n        'draggable',\r\n        'draggableCursor',\r\n        'draggingCursor',\r\n        'disableZooming',\r\n        'fullscreenControl',\r\n        'fullscreenControlOptions',\r\n        'gestureHandling',\r\n        'heading',\r\n        'keyboardShortcuts',\r\n        'mapTypeControl',\r\n        'mapTypeControlOptions',\r\n        'mapTypeId',\r\n        'maxZoom',\r\n        'minZoom',\r\n        'noClear',\r\n        'panControl',\r\n        'panControlOptions',\r\n        'rotateControl',\r\n        'rotateControlOptions',\r\n        'scaleControl',\r\n        'scaleControlOptions',\r\n        'scrollwheel',\r\n        'showMapTypeSelector',\r\n        'streetView',\r\n        'streetViewControl',\r\n        'streetViewControlOptions',\r\n        'styles',\r\n        'tilt',\r\n        'zoom',\r\n        'zoomControl',\r\n        'zoomControlOptions'\r\n    ];\r\n\r\n    /**\r\n     * InfoWindow option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _infoWindowOptionsAttributes: string[] = [\r\n        'actions',\r\n        'description',\r\n        'htmlContent',\r\n        'id',\r\n        'position',\r\n        'pixelOffset',\r\n        'showCloseButton',\r\n        'showPointer',\r\n        'pushpin',\r\n        'title',\r\n        'titleClickHandler',\r\n        'typeName',\r\n        'visible',\r\n        'width',\r\n        'height'\r\n    ];\r\n\r\n    /**\r\n     * Marker option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _markerOptionsAttributes: string[] = [\r\n        'anchor',\r\n        'position',\r\n        'title',\r\n        'text',\r\n        'label',\r\n        'draggable',\r\n        'icon',\r\n        'width',\r\n        'height',\r\n        'iconInfo',\r\n        'metadata',\r\n        'visible'\r\n    ];\r\n\r\n    /**\r\n     * Cluster option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _clusterOptionsAttributes: string[] = [\r\n        'callback',\r\n        'clusteredPinCallback',\r\n        'clusteringEnabled',\r\n        'gridSize',\r\n        'layerOffset',\r\n        'placementMode',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Polygon option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _polygonOptionsAttributes: string[] = [\r\n        'clickable',\r\n        'draggable',\r\n        'editable',\r\n        'fillColor',\r\n        'fillOpacity',\r\n        'geodesic',\r\n        'paths',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Polyline option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _polylineOptionsAttributes: string[] = [\r\n        'clickable',\r\n        'draggable',\r\n        'editable',\r\n        'geodesic',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Maps an IBox object to a GoogleMapTypes.LatLngBoundsLiteral object.\r\n     *\r\n     * @param bounds - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateBounds(bounds: IBox): GoogleMapTypes.LatLngBoundsLiteral {\r\n        const b: GoogleMapTypes.LatLngBoundsLiteral = {\r\n            east: bounds.maxLongitude,\r\n            north: bounds.maxLatitude,\r\n            south: bounds.minLatitude,\r\n            west: bounds.minLongitude,\r\n        };\r\n        return b;\r\n    }\r\n\r\n    /**\r\n     * Maps an IInfoWindowOptions object to a GoogleMapTypes.InfoWindowOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateInfoWindowOptions(options: IInfoWindowOptions): GoogleMapTypes.InfoWindowOptions {\r\n        const o: GoogleMapTypes.InfoWindowOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._infoWindowOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'htmlContent') {\r\n                    o.content = (<any>options)[k];\r\n                } else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        if (o.content == null || o.content === '') {\r\n            if (options.title !== '' && options.description !== '') {\r\n                o.content = `${options.title}: ${options.description}`;\r\n            }\r\n            else if (options.description !== '') { o.content = options.description; }\r\n            else { o.content = options.title; }\r\n        }\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong object to a GoogleMapTypes.LatLngLiteral object.\r\n     *\r\n     * @param latlong - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLocation(latlong: ILatLong): GoogleMapTypes.LatLngLiteral {\r\n        const l: GoogleMapTypes.LatLngLiteral = { lat: latlong.latitude, lng: latlong.longitude };\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an GoogleMapTypes.LatLngLiteral object to a ILatLong object.\r\n     *\r\n     * @param latlng - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLatLng(latlng: GoogleMapTypes.LatLngLiteral): ILatLong {\r\n        const l: ILatLong = { latitude: latlng.lat, longitude: latlng.lng };\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong object to a GoogleMapTypes.LatLng object.\r\n     *\r\n     * @param latlong - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLocationObject(latlong: ILatLong): GoogleMapTypes.LatLng {\r\n        const l: GoogleMapTypes.LatLng = new google.maps.LatLng(latlong.latitude, latlong.longitude);\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an GoogleMapTypes.LatLng object to a ILatLong object.\r\n     *\r\n     * @param latlng - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLatLngObject(latlng: GoogleMapTypes.LatLng): ILatLong {\r\n        const l: ILatLong = { latitude: latlng.lat(), longitude: latlng.lng() };\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong array to a array of GoogleMapTypes.LatLng object.\r\n     *\r\n     * @param latlongArray - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLocationObjectArray(latlongArray: Array<ILatLong>): Array<GoogleMapTypes.LatLng> {\r\n        // use for loop for performance in case we deal with large numbers of points and paths...\r\n        const p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n        for (let i = 0; i < latlongArray.length; i++) {\r\n            p.push(GoogleConversions.TranslateLocationObject(latlongArray[i]));\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Maps a MapTypeId object to a Google maptype string.\r\n     *\r\n     * @param mapTypeId - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateMapTypeId(mapTypeId: MapTypeId): string {\r\n        switch (mapTypeId) {\r\n            case MapTypeId.road: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.roadmap];\r\n            case MapTypeId.grayscale: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.terrain];\r\n            case MapTypeId.hybrid: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.hybrid];\r\n            case MapTypeId.ordnanceSurvey: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.terrain];\r\n            default: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.satellite];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maps an IMarkerOptions object to a GoogleMapTypes.MarkerOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Promise that when resolved contains the mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateMarkerOptions(options: IMarkerOptions): GoogleMapTypes.MarkerOptions {\r\n        const o: GoogleMapTypes.MarkerOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._markerOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'position') {\r\n                    const latlng = GoogleConversions.TranslateLocationObject(options[k]);\r\n                    o.position = latlng;\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a GoogleMapTypes.MapOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateOptions(options: IMapOptions): GoogleMapTypes.MapOptions {\r\n        const o: GoogleMapTypes.MapOptions = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._mapOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = GoogleConversions.TranslateLocation(options.center);\r\n                }\r\n                else if (k === 'mapTypeId') {\r\n                    o.mapTypeId = GoogleConversions.TranslateMapTypeId(options.mapTypeId);\r\n                }\r\n                else if (k === 'disableZooming') {\r\n                    o.gestureHandling = 'none';\r\n                    o.zoomControl =  false;\r\n                }\r\n                else if (k === 'showMapTypeSelector') {\r\n                    o.mapTypeControl = false;\r\n                }\r\n                else if (k === 'customMapStyleGoogle') {\r\n                    o.styles = <GoogleMapTypes.MapTypeStyle[]><any> options.customMapStyleGoogle\r\n                }\r\n                else {\r\n                    (<any>o)[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations\r\n     *\r\n     * @param paths - ILatLong based locations to convert.\r\n     * @returns - converted locations.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslatePaths(paths: Array<ILatLong> | Array<Array<ILatLong>>): Array<Array<GoogleMapTypes.LatLng>> {\r\n        const p: Array<Array<GoogleMapTypes.LatLng>> = new Array<Array<GoogleMapTypes.LatLng>>();\r\n        if (paths == null || !Array.isArray(paths) || paths.length === 0) {\r\n            p.push(new Array<GoogleMapTypes.LatLng>());\r\n        }\r\n        else if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            // use for loop for performance in case we deal with large numbers of points and paths...\r\n            const p1 = <Array<Array<ILatLong>>>paths;\r\n            for (let i = 0; i < p1.length; i++) {\r\n                p.push(GoogleConversions.TranslateLocationObjectArray(p1[i]));\r\n            }\r\n        }\r\n        else {\r\n            // parameter is a simple array....\r\n            p.push(GoogleConversions.TranslateLocationObjectArray(<Array<ILatLong>>paths));\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolygonOptions object to a GoogleMapTypes.PolygonOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslatePolygonOptions(options: IPolygonOptions): GoogleMapTypes.PolygonOptions {\r\n        const o: GoogleMapTypes.PolygonOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._polygonOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'paths') {\r\n                    if (!Array.isArray(options.paths)) { return; }\r\n                    if (options.paths.length === 0) {\r\n                        o.paths = new Array<GoogleMapTypes.LatLng>();\r\n                    }\r\n                    else if (Array.isArray(options.paths[0])) {\r\n                        o.paths = new Array<Array<GoogleMapTypes.LatLngLiteral>>();\r\n                        // use for loop for performance in case we deal with large numbers of points and paths..\r\n                        const p1 = <Array<Array<ILatLong>>>options.paths;\r\n                        for (let i = 0; i < p1.length; i++) {\r\n                            o.paths[i] = new Array<GoogleMapTypes.LatLngLiteral>();\r\n                            for (let j = 0; j < p1[i].length; j++) {\r\n                                o.paths[i][j] = {lat: p1[i][j].latitude, lng: p1[i][j].longitude};\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        o.paths = new Array<GoogleMapTypes.LatLngLiteral>();\r\n                        // use for loop for performance in case we deal with large numbers of points and paths..\r\n                        const p1 = <Array<ILatLong>>options.paths;\r\n                        for (let i = 0; i < p1.length; i++) {\r\n                            o.paths[i] = {lat: p1[i].latitude, lng: p1[i].longitude};\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolylineOptions object to a GoogleMapTypes.PolylineOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslatePolylineOptions(options: IPolylineOptions): GoogleMapTypes.PolylineOptions {\r\n        const o: GoogleMapTypes.PolylineOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._polylineOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                o[k] = (<any>options)[k];\r\n            });\r\n        return o;\r\n    }\r\n}\r\n","import { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { GoogleMapService} from '../../services/google/google-map.service';\r\nimport { InfoWindow } from '../info-window';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementation for a {@link InfoWindow}} model for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GoogleInfoWindow implements InfoWindow {\r\n\r\n    private _isOpen: boolean;\r\n\r\n    /**\r\n     * Gets whether the info box is currently open.\r\n     *\r\n     * @readonly\r\n     * @memberof InfoWGoogleInfoWindowindow\r\n     */\r\n    public get IsOpen(): boolean {\r\n        if (this._isOpen === true) { return true; }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying native object.\r\n     *\r\n     * @property\r\n     * @readonly\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.InfoWindow {\r\n        return this._infoWindow;\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleInfoWindow.\r\n     * @param _infoWindow - A {@link GoogleMapTypes.InfoWindow} instance underlying the model.\r\n     * @param _mapService - An instance of the {@link GoogleMapService}.\r\n     * @memberof GoogleInfoWindow\r\n     */\r\n    constructor(private _infoWindow: GoogleMapTypes.InfoWindow, private _mapService: GoogleMapService) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n   /**\r\n     * Adds an event listener to the InfoWindow.\r\n     *\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        this._infoWindow.addListener(eventType, (e: any) => {\r\n            if (eventType === 'closeclick') { this._isOpen = false; }\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Closes the info window.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public Close() {\r\n        this._isOpen = false;\r\n        this._infoWindow.close();\r\n    }\r\n\r\n    /**\r\n     * Gets the position of the info window\r\n     *\r\n     * @returns - The geo coordinates of the info window.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public GetPosition(): ILatLong {\r\n        return GoogleConversions.TranslateLatLngObject(this._infoWindow.getPosition());\r\n    }\r\n\r\n    /**\r\n     * Opens the info window\r\n     *\r\n     * @param [anchor] - Optional Anchor.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public Open(anchor?: any) {\r\n        this._mapService.MapPromise.then(m => {\r\n            this._isOpen = true;\r\n            this._infoWindow.open(m, anchor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options\r\n     *\r\n     * @param options - The options to set. This object will be merged with the existing options.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public SetOptions(options: IInfoWindowOptions): void {\r\n        const o: GoogleMapTypes.InfoWindowOptions = GoogleConversions.TranslateInfoWindowOptions(options);\r\n        this._infoWindow.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the info window position\r\n     *\r\n     * @param position - Geo coordinates at which to anchor the info window.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public SetPosition(position: ILatLong): void {\r\n        const l: GoogleMapTypes.LatLngLiteral = GoogleConversions.TranslateLocation(position);\r\n        this._infoWindow.setPosition(l);\r\n    }\r\n}\r\n","import { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Marker } from '../marker';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\n/**\r\n * Concrete implementation of the {@link Marker} contract for the Google Maps map architecture.\r\n *\r\n * @export\r\n */\r\nexport class GoogleMarker implements Marker {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _isFirst = false;\r\n    private _isLast = true;\r\n\r\n    ///\r\n    /// Public properties\r\n    ///\r\n\r\n    /**\r\n     * Indicates that the marker is the first marker in a set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsFirst(): boolean { return this._isFirst; }\r\n    public set IsFirst(val: boolean) { this._isFirst = val; }\r\n\r\n    /**\r\n     * Indicates that the marker is the last marker in the set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsLast(): boolean { return this._isLast; }\r\n    public set IsLast(val: boolean) { this._isLast = val; }\r\n\r\n    /**\r\n     * Gets the marker metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker, in this case {@link Microsoft.Maps.Pushpin}\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMarker\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.Marker { return this._marker; }\r\n\r\n    /**\r\n     * Gets the Location of the marker\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMarker\r\n     */\r\n    public get Location(): ILatLong {\r\n        const l: GoogleMapTypes.LatLng = this._marker.getPosition();\r\n        return {\r\n            latitude: l.lat(),\r\n            longitude: l.lng()\r\n        };\r\n    }\r\n\r\n    ///\r\n    /// Constructors\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMarker.\r\n     * @param _marker\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    constructor(private _marker: GoogleMapTypes.Marker) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener to the marker.\r\n     *\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        this._marker.addListener(eventType, fn);\r\n    }\r\n\r\n    /**\r\n     * Deletes the marker.\r\n     *\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public DeleteMarker(): void {\r\n        this._marker.setMap(null);\r\n    }\r\n\r\n    /**\r\n     * Gets the marker label\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public GetLabel(): string {\r\n        return this._marker.getLabel().text;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the marker is visible.\r\n     *\r\n     * @returns - True if the marker is visible, false otherwise.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._marker.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.\r\n     *\r\n     * @param anchor - Point coordinates for the marker anchor.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetAnchor(anchor: any): void {\r\n        // not implemented\r\n        // TODO: we need to switch the model to complex icons for google to\r\n        // support anchors, sizes and origins.\r\n        // https://developers.google.com/maps/documentation/javascript/markers\r\n    }\r\n\r\n    /**\r\n     * Sets the draggability of a marker.\r\n     *\r\n     * @param draggable - True to mark the marker as draggable, false otherwise.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        this._marker.setDraggable(draggable);\r\n    }\r\n\r\n    /**\r\n     * Sets the icon for the marker.\r\n     *\r\n     * @param icon - String containing the icon in various forms (url, data url, etc.)\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetIcon(icon: string): void {\r\n        this._marker.setIcon(icon);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker label.\r\n     *\r\n     * @param label - String containing the label to set.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetLabel(label: string): void {\r\n        this._marker.setLabel(label);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker position.\r\n     *\r\n     * @param latLng - Geo coordinates to set the marker position to.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetPosition(latLng: ILatLong): void {\r\n        const p: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(latLng);\r\n        this._marker.setPosition(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker title.\r\n     *\r\n     * @param title - String containing the title to set.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetTitle(title: string): void {\r\n        this._marker.setTitle(title);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker options.\r\n     *\r\n     * @param options - {@link IMarkerOptions} object containing the marker options to set. The supplied options are\r\n     * merged with the underlying marker options.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetOptions(options: IMarkerOptions): void {\r\n        const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(options);\r\n        this._marker.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the marker is visible.\r\n     *\r\n     * @param visible - True to set the marker visible, false otherwise.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._marker.setVisible(visible);\r\n    }\r\n\r\n}\r\n","import * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { MapLabel } from '../map-label';\r\nimport { ILabelOptions } from '../../interfaces/ilabel-options';\r\nimport { Extender } from '../extender';\r\n\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Implements map a labled to be placed on the map.\r\n *\r\n * @export\r\n */\r\nexport class GoogleMapLabel extends MapLabel {\r\n\r\n    /**\r\n     * Returns the default label style for the platform\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof GoogleMapLabel\r\n     */\r\n    public get DefaultLabelStyle(): ILabelOptions {\r\n        return {\r\n            fontSize: 12,\r\n            fontFamily: 'sans-serif',\r\n            fontColor: '#ffffff',\r\n            strokeWeight: 3,\r\n            strokeColor: '#000000'\r\n        };\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new MapLabel\r\n     * @param options Optional properties to set.\r\n     */\r\n    constructor(options: { [key: string]: any }) {\r\n        options.fontSize = options.fontSize || 12;\r\n        options.fontColor = options.fontColor || '#ffffff';\r\n        options.strokeWeight = options.strokeWeight || 3;\r\n        options.strokeColor = options.strokeColor || '#000000';\r\n        super(options);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the value of a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @returns - The value of the setting.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Get(key: string): any {\r\n        return (<any>this).get(key);\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     */\r\n    public GetMap(): GoogleMapTypes.GoogleMap {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Set the value for a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @param val - The value to set.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Set(key: string, val: any): void {\r\n        if (key === 'position' && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {\r\n            val = new google.maps.LatLng(val.latitude, val.longitude);\r\n        }\r\n        if (this.Get(key) !== val) {\r\n            (<any>this).set(key, val);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - Map to associated with the label.\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     */\r\n    public SetMap(map: GoogleMapTypes.GoogleMap): void {\r\n        (<any>this).setMap(map);\r\n    }\r\n\r\n    /**\r\n     * Applies settings to the object\r\n     *\r\n     * @param options - An object containing the settings key value pairs.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public SetValues(options: { [key: string]: any }): void {\r\n        for (const key in options) {\r\n            if (key !== '') {\r\n                if (key === 'position' &&  options[key].hasOwnProperty('latitude') &&  options[key].hasOwnProperty('longitude')) {\r\n                    options[key] = new google.maps.LatLng( options[key].latitude,  options[key].longitude);\r\n                }\r\n                if (this.Get(key) === options[key]) { delete options[key]; }\r\n            }\r\n        }\r\n        (<any>this).setValues(options);\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Draws the label on the map.\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Draw(): void {\r\n        const projection = (<any>this).getProjection();\r\n        const visibility: string = this.GetVisible();\r\n        if (!projection) {\r\n            // The map projection is not ready yet so do nothing\r\n            return;\r\n        }\r\n        if (!this._canvas) {\r\n            // onAdd has not been called yet.\r\n            return;\r\n        }\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        if (visibility !== '') {\r\n            // label is not visible, don't calculate positions etc.\r\n            style['visibility'] = visibility;\r\n            return;\r\n        }\r\n\r\n        let offset: GoogleMapTypes.Point = this.Get('offset');\r\n        let latLng: GoogleMapTypes.LatLng|GoogleMapTypes.LatLngLiteral = this.Get('position');\r\n        if (!latLng) { return; }\r\n        if (!(latLng instanceof google.maps.LatLng)) { latLng = new google.maps.LatLng(latLng.lat, latLng.lng); }\r\n        if (!offset) { offset = new google.maps.Point(0, 0); }\r\n\r\n        const pos = projection.fromLatLngToDivPixel(latLng);\r\n        style['top'] = (pos.y + offset.y) + 'px';\r\n        style['left'] = (pos.x + offset.x) + 'px';\r\n        style['visibility'] = visibility;\r\n    }\r\n\r\n    /**\r\n     * Delegate called when the label is added to the map. Generates and configures\r\n     * the canvas.\r\n     *\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected OnAdd() {\r\n        this._canvas = document.createElement('canvas');\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        style.position = 'absolute';\r\n\r\n        const ctx: CanvasRenderingContext2D = this._canvas.getContext('2d');\r\n        ctx.lineJoin = 'round';\r\n        ctx.textBaseline = 'top';\r\n\r\n        this.DrawCanvas();\r\n        const panes = (<any>this).getPanes();\r\n        if (panes) {\r\n            panes.overlayLayer.appendChild(this._canvas);\r\n                // 4: floatPane (infowindow)\r\n                // 3: overlayMouseTarget (mouse events)\r\n                // 2: markerLayer (marker images)\r\n                // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)\r\n                // 0: mapPane (lowest pane above the map tiles)\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the OverlayView into the MapLabel\r\n *\r\n * @export\r\n * @method\r\n */\r\n\r\n\r\nexport function MixinMapLabelWithOverlayView() {\r\n\r\n    new Extender(GoogleMapLabel)\r\n        .Extend(new google.maps.OverlayView)\r\n        .Map('changed', 'Changed')\r\n        .Map('onAdd', 'OnAdd')\r\n        .Map('draw', 'Draw')\r\n        .Map('onRemove', 'OnRemove');\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolygonEvent } from '../../interfaces/ipolygon-event';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { Polygon } from '../polygon';\r\nimport { GoogleMapLabel } from './google-label';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementation for a polygon model for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GooglePolygon extends Polygon implements Polygon {\r\n\r\n    private _title: string = '';\r\n    private _showLabel: boolean = false;\r\n    private _showTooltip: boolean = false;\r\n    private _maxZoom: number = -1;\r\n    private _minZoom: number = -1;\r\n    private _label: GoogleMapLabel = null;\r\n    private _tooltip: GoogleMapLabel = null;\r\n    private _tooltipVisible: boolean = false;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _originalPath: Array<Array<ILatLong>>;\r\n    private _mouseOverListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseOutListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseMoveListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _editingCompleteEmitter: (event: IPolygonEvent) => void = null;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMaxZoom(): number { return this._maxZoom; }\r\n    public set LabelMaxZoom(val: number) {\r\n        this._maxZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMinZoom(): number { return this._minZoom; }\r\n    public set LabelMinZoom(val: number) {\r\n        this._minZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof GoolePolygon\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polygon, in this case {@link GoogleMapTypes.Polygon}\r\n     *\r\n     * @readonly\r\n     * @memberof GooglePolygon\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.Polygon { return this._polygon; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the label\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get ShowLabel(): boolean { return this._showLabel; }\r\n    public set ShowLabel(val: boolean) {\r\n        this._showLabel = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageLabel();\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GooglePolygon.\r\n     * @param _polygon - The {@link GoogleMapTypes.Polygon} underlying the model.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    constructor(private _polygon: GoogleMapTypes.Polygon) {\r\n        super();\r\n        this._originalPath = this.GetPaths();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n\r\n     * @memberof GooglePolygon\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = [\r\n            'click',\r\n            'dblclick',\r\n            'drag', 'dragend',\r\n            'dragstart',\r\n            'mousedown',\r\n            'mousemove',\r\n            'mouseout',\r\n            'mouseover',\r\n            'mouseup',\r\n            'rightclick'\r\n        ];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            this._polygon.addListener(eventType, fn);\r\n        }\r\n        if (eventType === 'pathchanged') {\r\n            this._editingCompleteEmitter = <(event: IPolygonEvent) => void>fn;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polygon.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public Delete(): void {\r\n        this._polygon.setMap(null);\r\n        if (this._label) { this._label.Delete(); }\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is draggable.\r\n     *\r\n     * @returns - True if the polygon is dragable, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetDraggable(): boolean {\r\n        return this._polygon.getDraggable();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._polygon.getEditable();\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polygon path.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<GoogleMapTypes.LatLng> = this._polygon.getPath();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(x => path.push({ latitude: x.lat(), longitude: x.lng() }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon paths.\r\n     *\r\n     * @returns - Array of Array of {@link ILatLong} objects describing multiple polygon paths.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetPaths(): Array<Array<ILatLong>> {\r\n        const p: Array<Array<GoogleMapTypes.LatLng>> = this._polygon.getPaths();\r\n        const paths: Array<Array<ILatLong>> = new Array<Array<ILatLong>>();\r\n        p.forEach(x => {\r\n            const path: Array<ILatLong> = new Array<ILatLong>();\r\n            x.forEach(y => path.push({ latitude: y.lat(), longitude: y.lng() }));\r\n            paths.push(path);\r\n        });\r\n        return paths;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is visible.\r\n     *\r\n     * @returns - True if the polygon is visible, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polygon.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is dragable.\r\n     *\r\n     * @param draggable - True to make the polygon dragable, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        this._polygon.setDraggable(draggable);\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polygon path is editable.\r\n     *\r\n     * @param editable - True to make polygon path editable, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        const previous = this._polygon.getEditable();\r\n        this._polygon.setEditable(editable);\r\n        if (previous && !editable && this._editingCompleteEmitter) {\r\n            this._editingCompleteEmitter({\r\n                Click: null,\r\n                Polygon: this,\r\n                OriginalPath: this._originalPath,\r\n                NewPath: this.GetPaths()\r\n            });\r\n            this._originalPath = this.GetPaths();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetOptions(options: IPolygonOptions): void {\r\n        const o: GoogleMapTypes.PolygonOptions = GoogleConversions.TranslatePolygonOptions(options);\r\n\r\n        if (typeof o.editable !== 'undefined') {\r\n            this.SetEditable(o.editable);\r\n            delete o.editable;\r\n        }\r\n\r\n        this._polygon.setOptions(o);\r\n        if (options.visible != null && this._showLabel && this._label) { this._label.Set('hidden', !options.visible); }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polygons path.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n        path.forEach(x => p.push(new google.maps.LatLng(x.latitude, x.longitude)));\r\n        this._polygon.setPath(p);\r\n        this._originalPath = [path];\r\n        if (this._label) {\r\n            this._centroid = null;\r\n            this.ManageLabel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the polygon path or paths.\r\n     *\r\n     * @param paths An Array of {@link ILatLong}\r\n     * (or array of arrays) describing the polygons path(s).\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetPaths(paths: Array<Array<ILatLong>> | Array<ILatLong>): void {\r\n        if (paths == null) { return; }\r\n        if (!Array.isArray(paths)) { return; }\r\n        if (paths.length === 0) {\r\n            this._polygon.setPaths(new Array<GoogleMapTypes.LatLng>());\r\n            if (this._label) {\r\n                this._label.Delete();\r\n                this._label = null;\r\n            }\r\n            return;\r\n        }\r\n        if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            const p: Array<Array<GoogleMapTypes.LatLng>> = new Array<Array<GoogleMapTypes.LatLng>>();\r\n            (<Array<Array<ILatLong>>>paths).forEach(path => {\r\n                const _p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n                path.forEach(x => _p.push(new google.maps.LatLng(x.latitude, x.longitude)));\r\n                p.push(_p);\r\n            });\r\n            this._polygon.setPaths(p);\r\n            this._originalPath = <Array<Array<ILatLong>>>paths;\r\n            if (this._label) {\r\n                this._centroid = null;\r\n                this.ManageLabel();\r\n            }\r\n        } else {\r\n            // parameter is a simple array....\r\n            this.SetPath(<Array<ILatLong>>paths);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is visible.\r\n     *\r\n     * @param visible - True to set the polygon visible, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polygon.setVisible(visible);\r\n        if (this._showLabel && this._label) { this._label.Set('hidden', !visible); }\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Configures the label for the polygon\r\n     * @memberof GooglePolygon\r\n     */\r\n    private ManageLabel(): void {\r\n        if (this.GetPath == null || this.GetPath().length === 0) { return; }\r\n        if (this._showLabel && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                position: GoogleConversions.TranslateLocationObject(this.Centroid)\r\n            };\r\n            if (o.position == null) { return; }\r\n            if (this._minZoom !== -1) { o.minZoom = this._minZoom; }\r\n            if (this._maxZoom !== -1) { o.maxZoom = this._maxZoom; }\r\n            if (this._label == null) {\r\n                o.map = this.NativePrimitve.getMap();\r\n                o.zIndex = this.NativePrimitve.zIndex ? this.NativePrimitve.zIndex + 1 : 100;\r\n                this._label = new GoogleMapLabel(o);\r\n            }\r\n            else {\r\n                this._label.SetValues(o);\r\n            }\r\n            this._label.Set('hidden', !this.GetVisible());\r\n        }\r\n        else {\r\n            if (this._label) {\r\n                this._label.SetMap(null);\r\n                this._label = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configures the tooltip for the polygon\r\n     * @memberof GooglePolygon\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new google.maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                o.map = this.NativePrimitve.getMap();\r\n                o.zIndex = 100000;\r\n                this._tooltip = new GoogleMapLabel(o);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = this.NativePrimitve.addListener('mouseover', (e: GoogleMapTypes.MouseEvent) => {\r\n                    this._tooltip.Set('position', e.latLng);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                });\r\n                this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) { this._tooltip.Set('position', e.latLng); }\r\n                });\r\n                this._mouseOutListener = this.NativePrimitve.addListener('mouseout', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', true);\r\n                        this._tooltipVisible = false;\r\n                    }\r\n                });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { google.maps.event.removeListener(this._mouseOutListener); }\r\n                if (this._mouseOverListener) { google.maps.event.removeListener(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { google.maps.event.removeListener(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { GoogleMapLabel } from './google-label';\r\nimport { Polyline } from '../polyline';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementation for a polyline model for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GooglePolyline extends Polyline implements Polyline {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _title: string = '';\r\n    private _showTooltip: boolean = false;\r\n    private _tooltip: GoogleMapLabel = null;\r\n    private _tooltipVisible: boolean = false;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _mouseOverListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseOutListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseMoveListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the polyline metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof GooglePolyline\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker, in this case {@link GoogleMApTypes.Polyline}\r\n     *\r\n     * @readonly\r\n     * @memberof GooglePolygon\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.Polyline { return this._polyline; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n     /**\r\n     * Creates an instance of GooglePolygon.\r\n     * @param _polyline - The {@link GoogleMApTypes.Polyline} underlying the model.\r\n     *\r\n     * @memberof GooglePolyline\r\n     */\r\n    constructor(private _polyline: GoogleMapTypes.Polyline) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     * @memberof Polyline\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = [\r\n            'click',\r\n            'dblclick',\r\n            'drag', 'dragend',\r\n            'dragstart',\r\n            'mousedown',\r\n            'mousemove',\r\n            'mouseout',\r\n            'mouseover',\r\n            'mouseup',\r\n            'rightclick'\r\n        ];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            this._polyline.addListener(eventType, fn);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polyline.\r\n     *\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public Delete(): void {\r\n        this._polyline.setMap(null);\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is draggable.\r\n     *\r\n     * @returns - True if the polyline is dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetDraggable(): boolean {\r\n        return this._polyline.getDraggable();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._polyline.getEditable();\r\n    }\r\n\r\n    /**\r\n     * Gets the polyline path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polyline path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<GoogleMapTypes.LatLng> = this._polyline.getPath();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(x => path.push({ latitude: x.lat(), longitude: x.lng() }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is visible.\r\n     *\r\n     * @returns - True if the polyline is visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polyline.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is dragable.\r\n     *\r\n     * @param draggable - True to make the polyline dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        this._polyline.setDraggable(draggable);\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polyline path is editable.\r\n     *\r\n     * @param editable - True to make polyline path editable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        this._polyline.setEditable(editable);\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetOptions(options: IPolylineOptions): void {\r\n        const o: GoogleMapTypes.PolylineOptions = GoogleConversions.TranslatePolylineOptions(options);\r\n        this._polyline.setOptions(o);\r\n        if (options.path) {\r\n            this.SetPath(<Array<ILatLong>>options.path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polylines path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n        path.forEach(x => p.push(new google.maps.LatLng(x.latitude, x.longitude)));\r\n        this._polyline.setPath(p);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is visible.\r\n     *\r\n     * @param visible - True to set the polyline visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polyline.setVisible(visible);\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n    /**\r\n     * Configures the tooltip for the polyline\r\n     * @memberof GooglePolyline\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new google.maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                o.map = this.NativePrimitve.getMap();\r\n                o.zIndex = 100000;\r\n                this._tooltip = new GoogleMapLabel(o);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = this.NativePrimitve.addListener('mouseover', (e: GoogleMapTypes.MouseEvent) => {\r\n                    this._tooltip.Set('position', e.latLng);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                });\r\n                this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) { this._tooltip.Set('position', e.latLng); }\r\n                });\r\n                this._mouseOutListener = this.NativePrimitve.addListener('mouseout', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', true);\r\n                        this._tooltipVisible = false;\r\n                    }\r\n                });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { google.maps.event.removeListener(this._mouseOutListener); }\r\n                if (this._mouseOverListener) { google.maps.event.removeListener(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { google.maps.event.removeListener(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import { IMapEventLookup } from '../../interfaces/imap-event-lookup';\r\n\r\n/**\r\n * This contstant translates the abstract map events into their corresponding google map\r\n * equivalents.\r\n */\r\nexport const GoogleMapEventsLookup: IMapEventLookup = {\r\n    click :             'click',\r\n    dblclick :          'dblclick',\r\n    rightclick :        'rightclick',\r\n    resize :            'resize',\r\n    boundschanged :     'bounds_changed',\r\n    centerchanged :     'center_changed',\r\n    zoomchanged :       'zoom_changed',\r\n    mouseover:          'mouseover',\r\n    mouseout :          'mouseout',\r\n    mousemove :         'mousemove',\r\n    infowindowclose:    'closeclick'\r\n};\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { CanvasOverlay } from '../canvas-overlay';\r\nimport { MapLabel } from '../map-label';\r\nimport { GoogleMapLabel } from './google-label';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { Extender } from '../extender';\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementing a canvas overlay to be placed on the map for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GoogleCanvasOverlay extends CanvasOverlay {\r\n\r\n    ///\r\n    /// field declarations\r\n    ///\r\n    private _viewChangeEndEvent: GoogleMapTypes.MapsEventListener;\r\n    private _mapResizeEvent: GoogleMapTypes.MapsEventListener;\r\n\r\n    /**\r\n     * Creates a new instance of the GoogleCanvasOverlay class.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    constructor(drawCallback: (canvas: HTMLCanvasElement) => void) {\r\n        super(drawCallback);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Obtains geo coordinates for the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public GetCoordinatesFromClick(e: GoogleMapTypes.MouseEvent): ILatLong {\r\n        if (!e) { return null; }\r\n        if (!e.latLng) { return null; }\r\n        if (!e.latLng.lat || !e.latLng.lng) { return null; }\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof GoogleCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetMap(): GoogleMapTypes.GoogleMap {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Returns a MapLabel instance for the current platform that can be used as a tooltip.\r\n     * This method only generates the map label. Content and placement is the responsibility\r\n     * of the caller.\r\n     *\r\n     * @returns - The label to be used for the tooltip.\r\n     * @memberof GoogleCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetToolTipOverlay(): MapLabel {\r\n        const o: { [key: string]: any } = {\r\n            align: 'left',\r\n            offset: new google.maps.Point(0, 25),\r\n            backgroundColor: 'bisque',\r\n            hidden: true,\r\n            fontSize: 12,\r\n            fontColor: '#000000',\r\n            strokeWeight: 0\r\n        };\r\n        o.zIndex = 100000;\r\n        const label: MapLabel = new GoogleMapLabel(o);\r\n        label.SetMap(this.GetMap());\r\n        return label;\r\n    }\r\n\r\n    /**\r\n     * Called when the custom overlay is added to the map. Triggers Onload....\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public OnAdd(): void {\r\n        super.OnAdd();\r\n        this.OnLoad();\r\n        this._canvas.style.zIndex = '100';\r\n            // move the canvas above primitives such as polygons.\r\n\r\n        // set the overlay to ready state\r\n        this._readyResolver(true);\r\n    }\r\n\r\n    /**\r\n     * Called whenever the canvas needs to be redrawn. This method does not do the actual\r\n     * update, it simply scales the canvas. The actual redraw happens once the map is idle.\r\n     * @memberof GoogleCanvasOverly\r\n     * @method\r\n     */\r\n    public OnDraw(): void {\r\n        const isStreetView: boolean = false;\r\n        const map: GoogleMapTypes.GoogleMap = this.GetMap();\r\n\r\n        if (isStreetView) {\r\n            // Don't show the canvas if the map is in Streetside mode.\r\n            this._canvas.style.display = 'none';\r\n        }\r\n        else {\r\n            // Re-drawing the canvas as it moves would be too slow. Instead, scale and translate canvas element.\r\n            // Upon idle or drag end, we can then redraw the canvas....\r\n            const zoomCurrent: number = map.getZoom();\r\n            const centerCurrent: GoogleMapTypes.LatLng = map.getCenter();\r\n\r\n            // Calculate map scale based on zoom level difference.\r\n            const scale: number = Math.pow(2, zoomCurrent - this._zoomStart);\r\n\r\n            // Calculate the scaled dimensions of the canvas.\r\n            const el: HTMLDivElement = map.getDiv();\r\n            const w: number = el.offsetWidth;\r\n            const h: number = el.offsetHeight;\r\n            const newWidth: number = w * scale;\r\n            const newHeight: number = h * scale;\r\n\r\n            // Calculate offset of canvas based on zoom and center offsets.\r\n            const projection = (<any>this).getProjection();\r\n            const cc = projection.fromLatLngToDivPixel(centerCurrent);\r\n\r\n            // Update the canvas CSS position and dimensions.\r\n            this.UpdatePosition(cc.x - newWidth / 2, cc.y - newHeight / 2, newWidth, newHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * CanvasOverlay loaded, attach map events for updating canvas.\r\n     * @method\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public OnLoad(): void {\r\n        const isStreetView: boolean = false;\r\n        const map: GoogleMapTypes.GoogleMap = (<any>this).getMap();\r\n\r\n        // Get the current map view information.\r\n        this._zoomStart = map.getZoom();\r\n        const c: GoogleMapTypes.LatLng = map.getCenter();\r\n        this._centerStart = {\r\n            latitude: c.lat(),\r\n            longitude: c.lng()\r\n        };\r\n\r\n        // When the map stops moving, render new data on the canvas.\r\n        this._viewChangeEndEvent = google.maps.event.addListener(map, 'idle', (e: any) => {\r\n            this.UpdateCanvas();\r\n        });\r\n\r\n        // Update the position of the overlay when the map is resized.\r\n        this._mapResizeEvent = google.maps.event.addListener(map, 'resize', (e: any) => {\r\n            this.UpdateCanvas();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Associates the cnavas overlay with a map.\r\n     * @method\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public SetMap(map: GoogleMapTypes.GoogleMap): void {\r\n        (<any>this).setMap(map);\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Attaches the canvas to the map.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    protected SetCanvasElement(el: HTMLCanvasElement): void {\r\n        const panes = (<any>this).getPanes();\r\n        if (panes) {\r\n            if (el != null) {\r\n                panes.overlayLayer.appendChild(el);\r\n                // 4: floatPane (infowindow)\r\n                // 3: overlayMouseTarget (mouse events)\r\n                // 2: markerLayer (marker images)\r\n                // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)\r\n                // 0: mapPane (lowest pane above the map tiles)\r\n            }\r\n            else {\r\n                panes.overlayLayer.removeChild(this._canvas);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove the map event handlers.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected RemoveEventHandlers(): void {\r\n        // Remove all event handlers from the map.\r\n        if (this._viewChangeEndEvent) { google.maps.event.removeListener(this._viewChangeEndEvent); }\r\n        if (this._mapResizeEvent) { google.maps.event.removeListener(this._mapResizeEvent); }\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas size based on the map size.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Resize(): void {\r\n        const map: GoogleMapTypes.GoogleMap = (<any>this).getMap();\r\n\r\n        // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.\r\n        const el: HTMLDivElement = map.getDiv();\r\n        this._canvas.width = el.offsetWidth;\r\n        this._canvas.height = el.offsetHeight;\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected UpdateCanvas(): void {\r\n        const map: GoogleMapTypes.GoogleMap = (<any>this).getMap();\r\n\r\n        // Only render the canvas if it isn't in streetside mode.\r\n        if (true) {\r\n            this._canvas.style.display = '';\r\n\r\n            // Reset CSS position and dimensions of canvas.\r\n            const el: HTMLDivElement = map.getDiv();\r\n            const w: number = el.offsetWidth;\r\n            const h: number = el.offsetHeight;\r\n            const centerPoint = (<any>this).getProjection().fromLatLngToDivPixel(map.getCenter());\r\n            this.UpdatePosition((centerPoint.x - w / 2), (centerPoint.y - h / 2), w, h);\r\n\r\n            // Redraw the canvas.\r\n            this.Redraw(true);\r\n\r\n            // Get the current map view information.\r\n            this._zoomStart = map.getZoom();\r\n            const c: GoogleMapTypes.LatLng = map.getCenter();\r\n            this._centerStart = {\r\n                latitude: c.lat(),\r\n                longitude: c.lng()\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the OverlayView into the CanvasOverlay\r\n *\r\n * @export\r\n * @method\r\n */\r\nexport function MixinCanvasOverlay() {\r\n\r\n    new Extender(GoogleCanvasOverlay)\r\n        .Extend(new google.maps.OverlayView)\r\n        .Map('onAdd', 'OnAdd')\r\n        .Map('draw', 'OnDraw')\r\n        .Map('onRemove', 'OnRemove');\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { MapService } from './map.service';\r\nimport { MarkerService } from './marker.service';\r\nimport { InfoBoxService } from './infobox.service';\r\nimport { LayerService } from './layer.service';\r\nimport { ClusterService } from './cluster.service';\r\nimport { PolygonService } from './polygon.service';\r\nimport { PolylineService } from './polyline.service';\r\n\r\n/**\r\n * Implements a factory to create all the implementation specifc services for a map implementation\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MapServiceFactory {\r\n\r\n    /**\r\n     * Creates the map service.\r\n     *\r\n     * @abstract\r\n     * @returns - {@link MapService} implementing a specific underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract Create(): MapService;\r\n\r\n    /**\r\n     * Creates the cluster service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @returns - {@link ClusterService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateClusterService(map: MapService): ClusterService;\r\n\r\n    /**\r\n     * Creates the info box service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param marker - {@link MarkerService} implementation for thh underlying marker archticture.\r\n     * @returns - {@link InfoBoxService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateInfoBoxService(map: MapService, marker: MarkerService): InfoBoxService;\r\n\r\n    /**\r\n     * Creates the layer service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @returns - {@link LayerService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateLayerService(map: MapService): LayerService;\r\n\r\n    /**\r\n     * Creates the marker service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @param clusters  - {@link ClusterService} implementation for the underlying map architecture.\r\n     * @returns - {@link MarkerService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateMarkerService(map: MapService, layers: LayerService, clusters: ClusterService): MarkerService;\r\n\r\n    /**\r\n     * Creates the polygon service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolygonService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreatePolygonService(map: MapService, layers: LayerService): PolygonService;\r\n\r\n    /**\r\n     * Creates the polyline service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolylineService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreatePolylineService(map: MapService, layers: LayerService): PolylineService;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IMapOptions } from '../interfaces/imap-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { IBox } from '../interfaces/ibox';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\nimport { Marker } from '../models/marker';\r\nimport { Layer } from '../models/layer';\r\nimport { Polygon } from '../models/polygon';\r\nimport { Polyline } from '../models/polyline';\r\nimport { InfoWindow } from '../models/info-window';\r\nimport { CanvasOverlay } from '../models/canvas-overlay';\r\n\r\n/**\r\n * Abstract class to implement map api. A concrete implementation should be created for each\r\n * Map provider supported (e.g. Bing, Goolge, ESRI)\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MapService {\r\n\r\n    ///\r\n    /// Public properties\r\n    ///\r\n\r\n    /**\r\n     * Gets the Map control instance underlying the implementation\r\n     *\r\n     * @readonly\r\n     * @memberof MapService\r\n     */\r\n    abstract get MapInstance(): any;\r\n\r\n    /**\r\n     * Gets a Promise for a Map control instance underlying the implementation. Use this instead of {@link MapInstance} if you\r\n     * are not sure if and when the instance will be created.\r\n     * @readonly\r\n     * @memberof MapService\r\n     */\r\n    abstract get MapPromise(): Promise<any>;\r\n\r\n    /**\r\n     * Gets the maps physical size.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof MapService\r\n     */\r\n    abstract get MapSize(): ISize;\r\n\r\n\r\n    ///\r\n    /// Public methods and MapService interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Gets a random geo locations filling the bounding box.\r\n     *\r\n     * @param count - number of locations to return\r\n     * @param bounds  - bounding box.\r\n     * @returns - Array of geo locations.\r\n     * @memberof MapService\r\n     */\r\n    public static GetRandonLocations(count: number, bounds: IBox): Array<ILatLong> {\r\n        const a: Array<ILatLong> = [];\r\n        const _getRandomLocation = (b: IBox) => {\r\n            const lat: number = Math.random() * (b.maxLatitude - b.minLatitude) + b.minLatitude;\r\n            let lng: number = 0;\r\n            if (crossesDateLine) {\r\n                lng = Math.random() * (b.minLongitude + 360 - b.maxLongitude) + b.maxLongitude;\r\n                if (lng > 180) { lng = lng - 360; }\r\n            }\r\n            else {\r\n                lng = Math.random() * (b.maxLongitude - b.minLongitude) + b.minLongitude;\r\n            }\r\n            const p: ILatLong = { latitude: lat, longitude: lng };\r\n            return p;\r\n        };\r\n        let crossesDateLine: boolean = false;\r\n\r\n        if (bounds == null) { bounds = <IBox>{\r\n                maxLatitude: 360,\r\n                minLatitude: 0,\r\n                maxLongitude: 170,\r\n                minLongitude: 0\r\n            };\r\n        }\r\n        if (bounds.center.longitude < bounds.minLongitude  || bounds.center.longitude > bounds.maxLongitude) { crossesDateLine = true; }\r\n        if (!count || count <= 0) {\r\n            return [_getRandomLocation(bounds)];\r\n        }\r\n        for (let r = 0; r < count; r++) { a.push(_getRandomLocation(bounds)); }\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Creates a canvas overlay layer to perform custom drawing over the map with out\r\n     * some of the overhead associated with going through the Map objects.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @returns - Promise of a {@link CanvasOverlay} object.\r\n     * @memberof MapService\r\n     * @abstract\r\n     */\r\n    public abstract CreateCanvasOverlay(drawCallback: (canvas: HTMLCanvasElement) => void): Promise<CanvasOverlay>;\r\n\r\n    /**\r\n     * Creates a map cluster layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link IClusterOptions}.\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying native layer object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateClusterLayer(options: ILayerOptions): Promise<Layer>;\r\n\r\n    /**\r\n     * Creates an information window for a map position\r\n     *\r\n     * @param [options] - Infowindow options. See {@link IInfoWindowOptions}\r\n     * @returns - Promise of a {@link InfoWindow} object, which models the underlying natvie infobox object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateInfoWindow(options?: IInfoWindowOptions): Promise<InfoWindow>;\r\n\r\n    /**\r\n     * Creates a map layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link ILayerOptions}\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying native layer object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateLayer(options: ILayerOptions): Promise<Layer>;\r\n\r\n    /**\r\n     * Creates a map instance\r\n     *\r\n     * @param el - HTML element to host the map.\r\n     * @param mapOptions - Map options\r\n     * @returns - Promise fullfilled once the map has been created.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateMap(el: HTMLElement, mapOptions: IMapOptions): Promise<void>;\r\n\r\n    /**\r\n     * Creates a map marker within the map context\r\n     *\r\n     * @param [options=<IMarkerOptions>{}] - Options for the marker. See {@link IMarkerOptions}.\r\n     * @returns - Promise of a {@link Marker} object, which models the underlying native pushpin object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateMarker(options: IMarkerOptions): Promise<Marker>;\r\n\r\n    /**\r\n     * Creates a polygon within the map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polygon. See {@link IPolygonOptions}.\r\n     * @returns - Promise of a {@link Polygon} object, which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreatePolygon(options: IPolygonOptions): Promise<Polygon>;\r\n\r\n    /**\r\n     * Creates a polyline within the map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polyline. See {@link IPolylineOptions}.\r\n     * @returns - Promise of a {@link Polyline} object (or an array thereof for complex paths),\r\n     * which models the underlying native polyline.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreatePolyline(options: IPolylineOptions): Promise<Polyline|Array<Polyline>>;\r\n\r\n    /**\r\n     * Deletes a layer from the map.\r\n     *\r\n     * @param layer - Layer to delete. See {@link Layer}.\r\n     * @returns - Promise fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract DeleteLayer(layer: Layer): Promise<void>;\r\n\r\n    /**\r\n     * Dispaose the map and associated resoures.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract DisposeMap(): void;\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map bounds\r\n     *\r\n     * @returns - A promise that when fullfilled contains the bounding box of the screen. See {@link IBox}.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract GetBounds(): Promise<IBox>;\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map center\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the center. See {@link ILatLong}.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract GetCenter(): Promise<ILatLong>;\r\n\r\n    /**\r\n     * Gets the current zoom level of the map.\r\n     *\r\n     * @returns - A promise that when fullfilled contains the zoom level.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract GetZoom(): Promise<number>;\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface representing the pixels. This promise resolves to null\r\n     * if the goe coordinates are not in the view port.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract LocationToPoint(loc: ILatLong): Promise<IPoint>;\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface array representing the pixels.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract LocationsToPoints(locs: Array<ILatLong>): Promise<Array<IPoint>>;\r\n\r\n    /**\r\n     * Centers the map on a geo location.\r\n     *\r\n     * @param latLng - GeoCoordinates around which to center the map. See {@link ILatLong}\r\n     * @returns - Promise that is fullfilled when the center operations has been completed.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetCenter(latLng: ILatLong): Promise<void>;\r\n\r\n    /**\r\n     * Sets the generic map options.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetMapOptions(options: IMapOptions): void;\r\n\r\n    /**\r\n     * Sets the view options of the map.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetViewOptions(options: IMapOptions): void;\r\n\r\n    /**\r\n     * Sets the zoom level of the map.\r\n     *\r\n     * @param zoom - Zoom level to set.\r\n     * @returns - A Promise that is fullfilled once the zoom operation is complete.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetZoom(zoom: number): Promise<void>;\r\n\r\n    /**\r\n     * Creates an event subscription\r\n     *\r\n     * @param eventName - The name of the event (e.g. 'click')\r\n     * @returns - An observable of tpye E that fires when the event occurs.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SubscribeToMapEvent<E>(eventName: string): Observable<E>;\r\n\r\n    /**\r\n     * Triggers the given event name on the map instance.\r\n     *\r\n     * @param eventName - Event to trigger.\r\n     * @returns - A promise that is fullfilled once the event is triggered.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract TriggerMapEvent(eventName: string): Promise<void>;\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { Marker } from '../models/marker';\r\nimport { MapMarkerDirective } from '../components/map-marker';\r\n\r\n/**\r\n * The abstract class represents the contract defintions for a marker service to be implemented by an acutaly underlying\r\n * map architecture.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MarkerService {\r\n\r\n    /**\r\n     * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.\r\n     *\r\n     * @abstract\r\n     * @param marker - The {@link MapMarkerDirective} to be added.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract AddMarker(marker: MapMarkerDirective): void;\r\n\r\n    /**\r\n     * Registers an event delegate for a marker.\r\n     *\r\n     * @abstract\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param marker - The {@link MapMarker} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract CreateEventObservable<T>(eventName: string, marker: MapMarkerDirective): Observable<T>;\r\n\r\n    /**\r\n     * Deletes a marker.\r\n     *\r\n     * @abstract\r\n     * @param marker - {@link MapMarkerDirective} to be deleted.\r\n     * @returns - A promise fullfilled once the marker has been deleted.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract DeleteMarker(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract GetCoordinatesFromClick(e: MouseEvent| any): ILatLong;\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @abstract\r\n     * @param marker - The {@link MapMarkerDirective} for which to obtain the marker model.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} implementation of the underlying platform.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract GetNativeMarker(marker: MapMarkerDirective): Promise<Marker>;\r\n\r\n    /**\r\n     * Obtains the marker pixel location for the marker on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the pixels of the marker on the map canvas.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract GetPixelsFromClick(e: MouseEvent| any): IPoint;\r\n\r\n    /**\r\n     * Converts a geo location to a pixel location relative to the map canvas.\r\n     *\r\n     * @abstract\r\n     * @param target - Either a {@link MapMarkerDirective} or a {@link ILatLong}\r\n     * for the basis of translation.\r\n     * @returns - A promise that when fullfilled contains a {@link IPoint}\r\n     * with the pixel coordinates of the MapMarkerDirective or ILatLong relative to the map canvas.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract LocationToPoint(target: MapMarkerDirective | ILatLong): Promise<IPoint>;\r\n\r\n    /**\r\n     * Updates the anchor position for the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the anchor.\r\n     * Anchor information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the anchor position has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateAnchor(maker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates whether the marker is draggable.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate dragability.\r\n     * Dragability information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the marker has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateDraggable(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the Icon on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the icon.\r\n     * Icon information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the icon information has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateIcon(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the label on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the label.\r\n     * Label information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the label has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateLabel(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the geo coordinates for the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the coordinates.\r\n     * Coordinate information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the position has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateMarkerPosition(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the title on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateTitle(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the visibility on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the visibility.\r\n     * Visibility information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the visibility has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateVisible(marker: MapMarkerDirective): Promise<void>;\r\n\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { InfoBoxComponent } from '../components/infobox';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { InfoWindow } from '../models/info-window';\r\n\r\n/**\r\n * This class defines the contract for an InfoBoxService. Each Map Architecture provider is expected the furnish a concrete implementation.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class InfoBoxService {\r\n\r\n    /**\r\n     * Adds an info window to the map or layer.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract AddInfoWindow(info: InfoBoxComponent): void;\r\n\r\n    /**\r\n     * Closes an infobox that is open.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been closed.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract Close(info: InfoBoxComponent): Promise<void>;\r\n\r\n    /**\r\n     * Subscribe to events on the infowindow.\r\n     *\r\n     * @abstract\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param infoComponent - The {@link InfoBoxComponent} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract CreateEventObservable<T>(event: string, infoBoxComponent: InfoBoxComponent): Observable<T>;\r\n\r\n\r\n    /**\r\n     * Deletes an infobox.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been deleted.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract DeleteInfoWindow(info: InfoBoxComponent): Promise<void>;\r\n\r\n    /**\r\n     * Opens an infobox that is closed.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been opened.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract Open(info: InfoBoxComponent, loc?: ILatLong): Promise<void>;\r\n\r\n    /**\r\n     * Sets the infobox options.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @param options - {@link IInfoWindowOptions} object containing the options to set. Options provided are\r\n     * merged with the existing options of the underlying infobox.\r\n     * @returns - A promise that is fullfilled when the infobox options have been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract SetOptions(info: InfoBoxComponent, options: IInfoWindowOptions): Promise<void>;\r\n\r\n    /**\r\n     * Set the position of the infobox based on the properties set on the InfoBox component.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @param latlng - The position to set\r\n     * @returns - A promise that is fullfilled when the infobox position has been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract SetPosition(info: InfoBoxComponent, latlng?: ILatLong): Promise<void>;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { Marker } from '../models/marker';\r\nimport { Polygon } from '../models/polygon';\r\nimport { Polyline } from '../models/polyline';\r\nimport { Layer } from '../models/layer';\r\nimport { MapLayerDirective } from '../components/map-layer';\r\n\r\n/**\r\n * Abstract class to to define the layer service contract. Must be realized by implementing provider.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class LayerService {\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract AddLayer(layer: MapLayerDirective): void;\r\n\r\n    /**\r\n     * Adds a marker to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the marker.\r\n     * @param options - Marker options defining the marker.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Marker model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker>;\r\n\r\n    /**\r\n     * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk\r\n     * operations.\r\n     *\r\n     * @abstract\r\n     * @param options - Marker options defining the markers.\r\n     * @param markerIcon - Optional information to generate custom markers. This will be applied to all markers.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Marker models.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreateMarkers(options: Array<IMarkerOptions>, markerIcon?: IMarkerIconInfo): Promise<Array<Marker>>;\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polygon options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon>;\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>>;\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the marker.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an\r\n     * array of polylines for complex paths) model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolyline(layer: number, options: IPolygonOptions): Promise<Polyline|Array<Polyline>>;\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>>;\r\n\r\n    /**\r\n     * Deletes the layer\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object for which to retrieve the layer.\r\n     * @returns - A promise that is fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract DeleteLayer(layer: MapLayerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Returns the Layer model represented by this layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object or MapLayerId for which to retrieve the layer model.\r\n     * @returns - A promise that when resolved contains the Layer model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract GetNativeLayer(layer: MapLayerDirective|number): Promise<Layer>;\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { Polygon } from '../models/polygon';\r\nimport { MapPolygonDirective } from '../components/map-polygon';\r\n\r\n/**\r\n * The abstract class represents the contract defintions for a polygon service to be implemented by an acutaly underlying\r\n * map architecture.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class PolygonService {\r\n\r\n  /**\r\n   * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a\r\n   * correcsponding layer.\r\n   *\r\n   * @abstract\r\n   * @param polygon - The {@link MapPolygonDirective} to be added.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract AddPolygon(polygon: MapPolygonDirective): void;\r\n\r\n  /**\r\n    * Registers an event delegate for a marker.\r\n    *\r\n    * @abstract\r\n    * @param eventName - The name of the event to register (e.g. 'click')\r\n    * @param polygon - The {@link MapPolygonDirective} for which to register the event.\r\n    * @returns - Observable emiting an instance of T each time the event occurs.\r\n    *\r\n    * @memberof PolygonService\r\n    */\r\n  public abstract CreateEventObservable<T>(eventName: string, polygon: MapPolygonDirective): Observable<T>;\r\n\r\n  /**\r\n    * Deletes a polygon.\r\n    *\r\n    * @abstract\r\n    * @param polygon - {@link MapPolygonDirective} to be deleted.\r\n    * @returns - A promise fullfilled once the polygon has been deleted.\r\n    *\r\n    * @memberof PolygonService\r\n    */\r\n  public abstract DeletePolygon(polygon: MapPolygonDirective): Promise<void>;\r\n\r\n  /**\r\n   * Obtains geo coordinates for the marker on the click location\r\n   *\r\n   * @abstract\r\n   * @param e - The mouse event.\r\n   * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n   *\r\n   * @memberof MarkerService\r\n   */\r\n  public abstract GetCoordinatesFromClick(e: MouseEvent | any): ILatLong;\r\n\r\n  /**\r\n   * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.\r\n   *\r\n   * @abstract\r\n   * @param polygon - The {@link MapPolygonDirective} for which to obtain the polygon model.\r\n   * @returns - A promise that when fullfilled contains the {@link Polygon} implementation of the underlying platform.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract GetNativePolygon(polygon: MapPolygonDirective): Promise<Polygon>;\r\n\r\n  /**\r\n   * Set the polygon options.\r\n   *\r\n   * @abstract\r\n   * @param polygon - {@link MapPolygonDirective} to be updated.\r\n   * @param options - {@link IPolygonOptions} object containing the options. Options will be merged with the\r\n   * options already on the underlying object.\r\n   * @returns - A promise fullfilled once the polygon options have been set.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract SetOptions(polygon: MapPolygonDirective, options: IPolygonOptions): Promise<void>;\r\n\r\n  /**\r\n   * Updates the Polygon path\r\n   *\r\n   * @abstract\r\n   * @param polygon - {@link MapPolygonDirective} to be updated.\r\n   * @returns - A promise fullfilled once the polygon has been updated.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract UpdatePolygon(polygon: MapPolygonDirective): Promise<void>;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { Polyline } from '../models/polyline';\r\nimport { MapPolylineDirective } from '../components/map-polyline';\r\n\r\n/**\r\n * The abstract class represents the contract defintions for a polyline service to be implemented by an acutaly underlying\r\n * map architecture.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class PolylineService {\r\n\r\n  /**\r\n   * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a\r\n   * correcsponding layer.\r\n   *\r\n   * @abstract\r\n   * @param polyline - The {@link MapPolylineDirective} to be added.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract AddPolyline(polyline: MapPolylineDirective): void;\r\n\r\n  /**\r\n    * Registers an event delegate for a marker.\r\n    *\r\n    * @abstract\r\n    * @param eventName - The name of the event to register (e.g. 'click')\r\n    * @param polyline - The {@link MapPolylineDirective} for which to register the event.\r\n    * @returns - Observable emiting an instance of T each time the event occurs.\r\n    *\r\n    * @memberof PolylineService\r\n    */\r\n  public abstract CreateEventObservable<T>(eventName: string, polyline: MapPolylineDirective): Observable<T>;\r\n\r\n  /**\r\n    * Deletes a polyline.\r\n    *\r\n    * @abstract\r\n    * @param polyline - {@link MapPolylineDirective} to be deleted.\r\n    * @returns - A promise fullfilled once the polyline has been deleted.\r\n    *\r\n    * @memberof PolylineService\r\n    */\r\n  public abstract DeletePolyline(polyline: MapPolylineDirective): Promise<void>;\r\n\r\n  /**\r\n   * Obtains geo coordinates for the marker on the click location\r\n   *\r\n   * @abstract\r\n   * @param e - The mouse event.\r\n   * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n   *\r\n   * @memberof MarkerService\r\n   */\r\n  public abstract GetCoordinatesFromClick(e: MouseEvent | any): ILatLong;\r\n\r\n  /**\r\n   * Obtains the polyline model for the polyline allowing access to native implementation functionatiliy.\r\n   *\r\n   * @abstract\r\n   * @param polyline - The {@link MapPolylineDirective} for which to obtain the polyline model.\r\n   * @returns - A promise that when fullfilled contains the {@link Polyline} implementation (or an\r\n   * array of polylines) for complex paths of the underlying platform.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract GetNativePolyline(polyline: MapPolylineDirective): Promise<Polyline|Array<Polyline>>;\r\n\r\n  /**\r\n   * Set the polyline options.\r\n   *\r\n   * @abstract\r\n   * @param polyline - {@link MapPolylineDirective} to be updated.\r\n   * @param options - {@link IPolylineOptions} object containing the options. Options will be merged with the\r\n   * options already on the underlying object.\r\n   * @returns - A promise fullfilled once the polyline options have been set.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract SetOptions(polyline: MapPolylineDirective, options: IPolylineOptions): Promise<void>;\r\n\r\n  /**\r\n   * Updates the Polyline path\r\n   *\r\n   * @abstract\r\n   * @param polyline - {@link MapPolylineDirective} to be updated.\r\n   * @returns - A promise fullfilled once the polyline has been updated.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract UpdatePolyline(polyline: MapPolylineDirective): Promise<void>;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { Marker } from '../models/marker';\r\nimport { Layer } from '../models/layer';\r\nimport { Polygon } from '../models/polygon';\r\nimport { Polyline } from '../models/polyline';\r\nimport { ClusterLayerDirective } from '../components/cluster-layer';\r\nimport { LayerService } from './layer.service';\r\n\r\n/**\r\n * Abstract class to to define teh cluster layer service contract. Must be realized by implementing provider.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class ClusterService extends LayerService {\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof ClusterService\r\n     */\r\n    public abstract StartClustering(layer: ClusterLayerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof ClusterService\r\n     */\r\n    public abstract StopClustering(layer: ClusterLayerDirective): Promise<void>;\r\n\r\n}\r\n","import { Directive, Input, Output, EventEmitter } from '@angular/core';\r\n\r\n/**\r\n * InfoBoxAction renders an action in an info window {@link InfoBox}\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *    .map-container { height: 300px; }\r\n *  `],\r\n *  template: `\r\n *    <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker [Latitude]=\"lat\" [Longitude]=\"lng\" [Label]=\"'M'\">\r\n *        <x-info-box>\r\n *          <x-info-box-action [Label]=\"actionlabel\" (ActionClicked)=\"actionClicked(this)\"></x-info-box-action>\r\n *        </x-info-box>\r\n *      </x-map-marker>\r\n *    </x-map>\r\n *  `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-info-box-action'\r\n})\r\nexport class InfoBoxActionDirective {\r\n\r\n    /**\r\n     * The label to display on the action\r\n     *\r\n     * @memberof InfoBoxActionDirective\r\n     */\r\n    @Input()\r\n    Label: string;\r\n\r\n    /**\r\n     * Emits an event when the action has been clicked\r\n     *\r\n     * @memberof InfoBoxActionDirective\r\n     */\r\n    @Output()\r\n    ActionClicked: EventEmitter<void> = new EventEmitter<void>();\r\n\r\n}\r\n","import {\r\n    AfterViewInit,\r\n    Component,\r\n    ContentChildren,\r\n    ElementRef,\r\n    EventEmitter,\r\n    Input,\r\n    OnChanges,\r\n    OnDestroy,\r\n    Output,\r\n    QueryList,\r\n    SimpleChange,\r\n    ViewChild,\r\n    ViewEncapsulation\r\n} from '@angular/core';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { InfoBoxService } from '../services/infobox.service';\r\nimport { MapMarkerDirective } from './map-marker';\r\nimport { InfoBoxActionDirective } from './infobox-action';\r\n\r\n/**\r\n * internal counter to use as ids for multiple infoboxes.\r\n */\r\nlet infoBoxId = 0;\r\n\r\n/**\r\n * InfoBox renders a info window inside a {@link MapMarkerDirective} or standalone.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *    .map-container { height: 300px; }\r\n * `],\r\n *  template: `\r\n *    <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker [Latitude]=\"lat\" [Longitude]=\"lng\" [Label]=\"'M'\">\r\n *        <x-info-box [DisableAutoPan]=\"true\">\r\n *          Hi, this is the content of the <strong>info window</strong>\r\n *         </x-info-box>\r\n *       </x-map-marker>\r\n *     </x-map>\r\n *  `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Component({\r\n    selector: 'x-info-box',\r\n    template: `\r\n        <div #infoBoxContent class='info-box-content'>\r\n            <ng-content></ng-content>\r\n        </div>`,\r\n    styles: [`\r\n        x-map .MicrosoftMap .Infobox .infobox-title { padding: 10px 10px 5px 10px }\r\n        x-map .MicrosoftMap .Infobox .infobox-info { padding: 3px 10px 10px 10px }\r\n        x-map .MicrosoftMap .Infobox .infobox-actions { height: auto }\r\n    `],\r\n    encapsulation: ViewEncapsulation.None\r\n})\r\nexport class InfoBoxComponent implements OnDestroy, OnChanges, AfterViewInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _infoBoxAddedToManager = false;\r\n    private _id: string = (infoBoxId++).toString();\r\n\r\n    /**\r\n     * HTML conent of the infobox\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @ViewChild('infoBoxContent') private _content: ElementRef;\r\n\r\n    /**\r\n     * Zero or more actions to show on the info window\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @ContentChildren(InfoBoxActionDirective) public InfoWindowActions: QueryList<InfoBoxActionDirective>;\r\n\r\n\r\n    /**\r\n     * The latitude position of the info window (only usefull if you use it ouside of a {@link MapMarker}).\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Latitude: number;\r\n\r\n    /**\r\n     * The longitude position of the info window (only usefull if you use it ouside of a {@link MapMarker}).\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Longitude: number;\r\n\r\n    /**\r\n     * The title to display in the info window\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * The description to display in the info window.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Description: string;\r\n\r\n    /**\r\n     * Disable auto-pan on open. By default, the info window will pan the map so that it is fully\r\n     * visible when it opens.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public DisableAutoPan: boolean;\r\n\r\n    /**\r\n     *  Maximum width of the infowindow, regardless of content's width. This value is only considered\r\n     *  if it is set before a call to open. To change the maximum width when changing content, call\r\n     *  close, update maxWidth, and then open.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public MaxWidth: number;\r\n\r\n    /**\r\n     * Determine whether only one infobox can be open at a time. Note that ANY info box settings.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Modal = true;\r\n\r\n    /**\r\n     * Holds the marker that is the host of the info window (if available)\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public HostMarker: MapMarkerDirective;\r\n\r\n    /**\r\n     * Determines visibility of infobox\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Visible = false;\r\n\r\n    /**\r\n     * Horizontal offset of the infobox from the host marker lat/long or the sepecified coordinates.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public xOffset: number;\r\n\r\n    /**\r\n     * Vertical offset for the infobox from the host marker lat/long or the specified coordinates.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public yOffset: number;\r\n\r\n    /**\r\n     * Determines if other info boxes should be closed before opening this one\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public CloseInfoBoxesOnOpen = true;\r\n\r\n    ///\r\n    /// Delegate defintions\r\n    ///\r\n\r\n    /**\r\n     * Emits an event when the info window is closed.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Output() public InfoBoxClose: EventEmitter<string> = new EventEmitter<string>();\r\n\r\n    ///\r\n    /// Property declarations.\r\n    ///\r\n\r\n    /**\r\n     * Gets the HTML content of the info box.\r\n     *\r\n     * @readonly\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public get HtmlContent(): string {\r\n        if (this._content.nativeElement && this._content.nativeElement.innerText && this._content.nativeElement.innerText.trim() !== '') {\r\n            return this._content.nativeElement.outerHTML;\r\n        }\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Gets the Id of the info box as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public get Id(): string { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of InfoBoxComponent.\r\n     * @param _infoBoxService - Concrete {@link InfoBoxService} implementation for underlying Map architecture.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    constructor(private _infoBoxService: InfoBoxService) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Closes the Infobox.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public Close(): Promise<void> {\r\n        return this._infoBoxService.Close(this).then(() => {\r\n            this.InfoBoxClose.emit(this._id);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on after component view as been initialized. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof Map\r\n     */\r\n    public ngAfterViewInit() {\r\n        this._infoBoxService.AddInfoWindow(this);\r\n        this._infoBoxAddedToManager = true;\r\n        this.HandleEvents();\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof Map\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (!this._infoBoxAddedToManager) { return; }\r\n        if ((changes['latitude'] || changes['longitude']) && typeof this.Latitude === 'number' &&\r\n            typeof this.Longitude === 'number') {\r\n            this._infoBoxService.SetPosition(this, {\r\n                latitude: changes['latitude'].currentValue,\r\n                longitude: changes['longitude'].currentValue\r\n            });\r\n        }\r\n        this.SetInfoWindowOptions(changes);\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof Map\r\n     */\r\n    public ngOnDestroy() { this._infoBoxService.DeleteInfoWindow(this); }\r\n\r\n    /**\r\n     * Opens a closed info window.\r\n     *\r\n     * @param [loc]  - {@link ILatLong } representing position on which to open the window.\r\n     * @returns - Promise that is fullfilled when the infobox has been opened.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public Open(loc?: ILatLong): Promise<void> {\r\n        return this._infoBoxService.Open(this, loc);\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the info box.\r\n     *\r\n     * @returns - string representation of the info box.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public ToString(): string { return 'InfoBoxComponent-' + this._id; }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Delegate handling the map click events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleEvents(): void {\r\n        this._infoBoxService.CreateEventObservable('infowindowclose', this).subscribe(e => {\r\n            this.InfoBoxClose.emit(this._id);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options\r\n     *\r\n     * @param changes\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    private SetInfoWindowOptions(changes: { [key: string]: SimpleChange }) {\r\n        const options: IInfoWindowOptions = {};\r\n        if (changes['title']) { options.title = this.Title; }\r\n        if (changes['description']) { options.description = this.Description; }\r\n        if (changes['disableAutoPan']) { options.disableAutoPan = this.DisableAutoPan; }\r\n        if (changes['visible']) { options.visible = this.Visible; }\r\n        if (changes['xOffset'] || changes['yOffset']) {\r\n            if (options.pixelOffset == null) { options.pixelOffset = { x: 0, y: 0 }; }\r\n            options.pixelOffset.x = this.xOffset;\r\n            options.pixelOffset.y = this.yOffset;\r\n        }\r\n        this._infoBoxService.SetOptions(this, options);\r\n    }\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef\r\n} from '@angular/core';\r\nimport { Subscription, timer } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IMarkerEvent } from '../interfaces/imarker-event';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { MarkerService } from '../services/marker.service';\r\nimport { InfoBoxComponent } from './infobox';\r\n\r\n/**\r\n * internal counter to use as ids for marker.\r\n */\r\nlet markerId = 0;\r\n\r\n/**\r\n * MapMarkerDirective renders a map marker inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker [Latitude]=\"lat\" [Longitude]=\"lng\" [Label]=\"'M'\"></x-map-marker>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-marker'\r\n})\r\nexport class MapMarkerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _clickTimeout: Subscription = null;\r\n    private _events: Subscription[] = [];\r\n    private _id: string;\r\n    private _inClusterLayer = false;\r\n    private _inCustomLayer = false;\r\n\r\n    /**\r\n     * Any InfoBox that is a direct children of the marker\r\n     *\r\n     * @protected\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @ContentChild(InfoBoxComponent) protected _infoBox: InfoBoxComponent;\r\n\r\n    private _layerId: number;\r\n    private _markerAddedToManger = false;\r\n\r\n    /**\r\n     *  Icon anchor relative to marker root\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Anchor: IPoint;\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() DblClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is repeatedly fired while the user drags the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() Drag: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() DragEnd: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * If true, the marker can be dragged. Default value is false.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Draggable = false;\r\n\r\n    /**\r\n     * This event is fired when the user starts dragging the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() DragStart: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when a marker icon is being created.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() public DynamicMarkerCreated: EventEmitter<IMarkerIconInfo> = new EventEmitter<IMarkerIconInfo>();\r\n\r\n    /**\r\n     * Icon height\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Height: number;\r\n\r\n    /**\r\n     * Information for dynamic, custom created icons.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IconInfo: IMarkerIconInfo;\r\n\r\n    /**\r\n     * Icon (the URL of the image) for the foreground.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IconUrl: string;\r\n\r\n    /**\r\n     * True to indiciate whether this is the first marker in a set.\r\n     * Use this for bulk operations (particularily clustering) to ensure performance.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IsFirstInSet = false;\r\n\r\n    /**\r\n     * True to indiciate whether this is the last marker in a set.\r\n     * Use this for bulk operations (particularily clustering) to ensure performance.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IsLastInSet = true;\r\n\r\n    /**\r\n     * The label (a single uppercase character) for the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Label: string;\r\n\r\n    /**\r\n     * The latitude position of the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Latitude: number;\r\n\r\n    /**\r\n     * The longitude position of the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Longitude: number;\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() public MarkerClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * Arbitary metadata to assign to the Marker. This is useful for events\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousedown event is fired on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseDown: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseMove: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired on marker mouseout.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseOut: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired on marker mouseover.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseOver: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired whe the DOM mouseup event is fired on the marker\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseUp: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This even is fired when the marker is right-clicked on.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() RightClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     *  The title of the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * Sets the visibility of the marker\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Icon Width\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Width: number;\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n\r\n\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Getswhether the marker has already been added to the marker service and is ready for use.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get AddedToManager(): boolean { return this._markerAddedToManger; }\r\n\r\n    /**\r\n     * Gets the id of the marker as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get Id(): string { return this._id; }\r\n\r\n    /**\r\n     * Gets whether the marker is in a cluster layer. See {@link ClusterLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get InClusterLayer(): boolean { return this._inClusterLayer; }\r\n\r\n    /**\r\n     * Gets whether the marker is in a custom layer. See {@link MapLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get InCustomLayer(): boolean { return this._inCustomLayer; }\r\n\r\n    /**\r\n     * gets the id of the Layer the marker belongs to.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get LayerId(): number { return this._layerId; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapMarkerDirective.\r\n     * @param _markerService - Concreate implementation of a {@link MarkerService}.\r\n     * @param _containerRef - View container hosting the marker.\r\n     * Used to determine parent layer through markup.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    constructor(private _markerService: MarkerService, private _containerRef: ViewContainerRef) {\r\n        this._id = (markerId++).toString();\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Translates a marker geo location to a pixel location relative to the map viewport.\r\n     *\r\n     * @param [loc] - {@link ILatLong} containing the geo coordinates. If null, the marker's coordinates are used.\r\n     * @returns - A promise that when fullfilled contains an {@link IPoint} representing the pixel coordinates.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public LocationToPixel(loc?: ILatLong): Promise<IPoint> {\r\n        return this._markerService.LocationToPoint(loc ? loc : this);\r\n    }\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        if (this._infoBox != null) { this._infoBox.HostMarker = this; }\r\n        if (this._containerRef.element.nativeElement.parentElement) {\r\n            const parentName: string = this._containerRef.element.nativeElement.parentElement.tagName;\r\n            if (parentName.toLowerCase() === 'x-cluster-layer') {\r\n                this._inClusterLayer = true;\r\n            } else if (parentName.toLowerCase() === 'x-map-layer') {\r\n                this._inCustomLayer = true;\r\n            }\r\n            this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);\r\n        }\r\n        if (!this._markerAddedToManger) {\r\n            this._markerService.AddMarker(this);\r\n            this._markerAddedToManger = true;\r\n            this.AddEventListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (typeof this.Latitude !== 'number' || typeof this.Longitude !== 'number') {\r\n            return;\r\n        }\r\n        if (!this._markerAddedToManger) { return; }\r\n        if (changes['Latitude'] || changes['Longitude']) {\r\n            this._markerService.UpdateMarkerPosition(this);\r\n        }\r\n        if (changes['Title']) {\r\n            this._markerService.UpdateTitle(this);\r\n        }\r\n        if (changes['Label']) {\r\n            this._markerService.UpdateLabel(this);\r\n        }\r\n        if (changes['Draggable']) {\r\n            this._markerService.UpdateDraggable(this);\r\n        }\r\n        if (changes['IconUrl'] || changes['IconInfo']) {\r\n            this._markerService.UpdateIcon(this);\r\n        }\r\n        if (changes['Anchor']) {\r\n            this._markerService.UpdateAnchor(this);\r\n        }\r\n        if (changes['Visible']) {\r\n            this._markerService.UpdateVisible(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._markerService.DeleteMarker(this);\r\n        this._events.forEach((s) => s.unsubscribe());\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Marker Id.\r\n     * @returns - string representation of the marker id.\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public toString(): string { return 'MapMarker-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    private AddEventListeners(): void {\r\n        const _getEventArg: (e: MouseEvent) => IMarkerEvent = e => {\r\n            return {\r\n                Marker: this,\r\n                Click: e,\r\n                Location: this._markerService.GetCoordinatesFromClick(e),\r\n                Pixels: this._markerService.GetPixelsFromClick(e)\r\n            };\r\n        };\r\n\r\n        this._events.push(this._markerService.CreateEventObservable('click', this).subscribe((e: MouseEvent) => {\r\n            ///\r\n            /// this is necessary since map will treat a doubleclick first as two clicks...'\r\n            ///\r\n            this._clickTimeout = timer(300).subscribe(n => {\r\n                if (this._infoBox != null) {\r\n                    this._infoBox.Open(this._markerService.GetCoordinatesFromClick(e));\r\n                }\r\n                this.MarkerClick.emit(_getEventArg(e));\r\n            });\r\n        }));\r\n\r\n        this._events.push(this._markerService.CreateEventObservable('dblclick', this).subscribe((e: MouseEvent) => {\r\n            if (this._clickTimeout) {\r\n                this._clickTimeout.unsubscribe();\r\n                this._clickTimeout = null;\r\n            }\r\n            this.DblClick.emit(_getEventArg(e));\r\n        }));\r\n\r\n        const handlers = [\r\n            { name: 'drag', handler: (ev: MouseEvent) => this.Drag.emit(_getEventArg(ev)) },\r\n            { name: 'dragend', handler: (ev: MouseEvent) => this.DragEnd.emit(_getEventArg(ev)) },\r\n            { name: 'dragstart', handler: (ev: MouseEvent) => this.DragStart.emit(_getEventArg(ev)) },\r\n            { name: 'mousedown', handler: (ev: MouseEvent) => this.MouseDown.emit(_getEventArg(ev)) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.MouseMove.emit(_getEventArg(ev)) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.MouseOut.emit(_getEventArg(ev)) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.MouseOver.emit(_getEventArg(ev)) },\r\n            { name: 'mouseup', handler: (ev: MouseEvent) => this.MouseUp.emit(_getEventArg(ev)) },\r\n            { name: 'rightclick', handler: (ev: MouseEvent) => this.RightClick.emit(_getEventArg(ev)) },\r\n        ];\r\n        handlers.forEach((obj) => {\r\n            const os = this._markerService.CreateEventObservable(obj.name, this).subscribe(obj.handler);\r\n            this._events.push(os);\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Component,\r\n    EventEmitter,\r\n    OnChanges,\r\n    OnInit,\r\n    OnDestroy,\r\n    SimpleChange,\r\n    ViewChild,\r\n    ContentChildren,\r\n    Input,\r\n    Output,\r\n    ElementRef,\r\n    HostBinding,\r\n    ViewEncapsulation,\r\n    ChangeDetectionStrategy,\r\n    NgZone\r\n} from '@angular/core';\r\nimport { MapServiceFactory } from '../services/mapservicefactory';\r\nimport { MapService } from '../services/map.service';\r\nimport { MarkerService } from '../services/marker.service';\r\nimport { InfoBoxService } from '../services/infobox.service';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { PolygonService } from '../services/polygon.service';\r\nimport { PolylineService } from '../services/polyline.service';\r\nimport { ClusterService } from '../services/cluster.service';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IBox } from '../interfaces/ibox';\r\nimport { IMapOptions } from '../interfaces/imap-options';\r\nimport { MapTypeId } from '../models/map-type-id';\r\nimport { MapMarkerDirective } from './map-marker';\r\n\r\n/**\r\n * Renders a map based on a given provider.\r\n * **Important note**: To be able see a map in the browser, you have to define a height for the CSS\r\n * class `map-container`.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map',\r\n *  styles: [`\r\n *    .map-container { height: 300px; }\r\n * `],\r\n *  template: `\r\n *    <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\"></x-map>\r\n *  `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Component({\r\n    selector: 'x-map',\r\n    providers: [\r\n        { provide: MapService, deps: [MapServiceFactory], useFactory: MapServiceCreator },\r\n        { provide: MarkerService, deps: [MapServiceFactory, MapService, LayerService, ClusterService], useFactory: MarkerServiceFactory },\r\n        {\r\n            provide: InfoBoxService, deps: [MapServiceFactory, MapService,\r\n                MarkerService], useFactory: InfoBoxServiceFactory\r\n        },\r\n        { provide: LayerService, deps: [MapServiceFactory, MapService], useFactory: LayerServiceFactory },\r\n        { provide: ClusterService, deps: [MapServiceFactory, MapService], useFactory: ClusterServiceFactory },\r\n        { provide: PolygonService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolygonServiceFactory },\r\n        { provide: PolylineService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolylineServiceFactory }\r\n    ],\r\n    template: `\r\n        <div #container class='map-container-inner'></div>\r\n        <div class='map-content'>\r\n            <ng-content></ng-content>\r\n        </div>\r\n    `,\r\n    styles: [`\r\n        .map-container-inner { width: inherit; height: inherit; }\r\n        .map-container-inner div { background-repeat: no-repeat; }\r\n        .map-content { display:none; }\r\n    `],\r\n    encapsulation: ViewEncapsulation.None,\r\n    changeDetection: ChangeDetectionStrategy.OnPush\r\n})\r\nexport class MapComponent implements OnChanges, OnInit, OnDestroy {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _longitude = 0;\r\n    private _latitude = 0;\r\n    private _zoom = 0;\r\n    private _clickTimeout: number | NodeJS.Timer;\r\n    private _options: IMapOptions = {};\r\n    private _box: IBox = null;\r\n    private _mapPromise: Promise<void>;\r\n    @HostBinding('class.map-container') public _containerClass: boolean = true;\r\n    @ViewChild('container') private _container: ElementRef;\r\n    @ContentChildren(MapMarkerDirective) private _markers: Array<MapMarkerDirective>;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Get or sets the maximum and minimum bounding box for map.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Box(): IBox { return this._box; }\r\n    public set Box(val: IBox) { this._box = val; }\r\n\r\n    /**\r\n     * Gets or sets the latitude that sets the center of the map.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Latitude(): number | string { return this._longitude; }\r\n    public set Latitude(value: number | string) {\r\n        this._latitude = this.ConvertToDecimal(value);\r\n        this.UpdateCenter();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the longitude that sets the center of the map.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Longitude(): number | string { return this._longitude; }\r\n    public set Longitude(value: number | string) {\r\n        this._longitude = this.ConvertToDecimal(value);\r\n        this.UpdateCenter();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets general map Options\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Options(): IMapOptions { return this._options; }\r\n    public set Options(val: IMapOptions) { this._options = val; }\r\n\r\n    /**\r\n     * Gets or sets the zoom level of the map. The default value is `8`.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Zoom(): number | string { return this._zoom; }\r\n    public set Zoom(value: number | string) {\r\n        this._zoom = this.ConvertToDecimal(value, 8);\r\n        if (typeof this._zoom === 'number') {\r\n            this._mapService.SetZoom(this._zoom);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This event emitter is fired when the map bounding box changes.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    BoundsChange: EventEmitter<IBox> = new EventEmitter<IBox>();\r\n\r\n    /**\r\n     * This event emitter is fired when the map center changes.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    CenterChange: EventEmitter<ILatLong> = new EventEmitter<ILatLong>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks on the map (but not when they click on a\r\n     * marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapClick: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapDblClick: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user right-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapRightClick: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapMouseOver: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapMouseOut: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapMouseMove: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * The event emitter is fired when the map service is available and the maps has been\r\n     * Initialized (but not necessarily created). It contains a Promise that when fullfilled returns\r\n     * the main map object of the underlying platform.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapPromise: EventEmitter<Promise<any>> = new EventEmitter<Promise<any>>();\r\n\r\n    /**\r\n     * This event emiiter is fired when the map zoom changes\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    ZoomChange: EventEmitter<Number> = new EventEmitter<Number>();\r\n\r\n    /**\r\n     * This event emitter is fired when the map service is available and the maps has been\r\n     * Initialized\r\n     * @memberOf MapComponent\r\n     */\r\n    @Output()\r\n    MapService: EventEmitter<MapService> = new EventEmitter<MapService>();\r\n\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapComponent.\r\n     *\r\n     * @param _mapService - Concreted implementation of a map service for the underlying maps implementations.\r\n     *                                   Generally provided via injections.\r\n     * @memberof MapComponent\r\n     */\r\n    constructor(private _mapService: MapService, private _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called on Component initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public ngOnInit(): void {\r\n        this.InitMapInstance(this._container.nativeElement);\r\n        this.MapPromise.emit(this._mapService.MapPromise);\r\n        this.MapService.emit(this._mapService);\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public ngOnChanges(changes: { [propName: string]: SimpleChange }): void {\r\n        if (this._mapPromise) {\r\n            if (changes['Box']) {\r\n                if (this._box != null) {\r\n                    this._mapService.SetViewOptions(<IMapOptions>{\r\n                        bounds: this._box\r\n                    });\r\n                }\r\n            }\r\n            if (changes['Options']) {\r\n                this._mapService.SetMapOptions(this._options);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public ngOnDestroy(): void {\r\n        this._mapService.DisposeMap();\r\n    }\r\n\r\n    /**\r\n     * Triggers a resize event on the map instance.\r\n     *\r\n     * @returns - A promise that gets resolved after the event was triggered.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public TriggerResize(): Promise<void> {\r\n        // Note: When we would trigger the resize event and show the map in the same turn (which is a\r\n        // common case for triggering a resize event), then the resize event would not\r\n        // work (to show the map), so we trigger the event in a timeout.\r\n        return new Promise<void>((resolve) => {\r\n            setTimeout(\r\n                () => { return this._mapService.TriggerMapEvent('resize').then(() => resolve()); });\r\n        });\r\n    }\r\n\r\n    ///\r\n    /// Private methods.\r\n    ///\r\n\r\n    /**\r\n     * Converts a number-ish value to a number.\r\n     *\r\n     * @param value - The value to convert.\r\n     * @param [defaultValue=null] - Default value to use if the conversion cannot be performed.\r\n     * @returns - Converted number of the default.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private ConvertToDecimal(value: string | number, defaultValue: number = null): number {\r\n        if (typeof value === 'string') {\r\n            return parseFloat(value);\r\n        } else if (typeof value === 'number') {\r\n            return <number>value;\r\n        }\r\n        return defaultValue;\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the map click events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapClickEvents(): void {\r\n        this._mapService.SubscribeToMapEvent<any>('click').subscribe(e => {\r\n            //\r\n            // this is necessary since bing will treat a doubleclick first as two clicks...'\r\n            ///\r\n            this._clickTimeout = setTimeout(() => {\r\n                this.MapClick.emit(<MouseEvent>e);\r\n            }, 300);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('dblclick').subscribe(e => {\r\n            if (this._clickTimeout) {\r\n                clearTimeout(<NodeJS.Timer>this._clickTimeout);\r\n            }\r\n            this.MapDblClick.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('rightclick').subscribe(e => {\r\n            this.MapRightClick.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('mouseover').subscribe(e => {\r\n            this.MapMouseOver.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('mouseout').subscribe(e => {\r\n            this.MapMouseOut.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('mousemove').subscribe(e => {\r\n            this.MapMouseMove.emit(<MouseEvent>e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delegate handling map center change events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapBoundsChange(): void {\r\n        this._mapService.SubscribeToMapEvent<void>('boundschanged').subscribe(() => {\r\n            this._mapService.GetBounds().then((bounds: IBox) => {\r\n                this.BoundsChange.emit(bounds);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delegate handling map center change events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapCenterChange(): void {\r\n        this._mapService.SubscribeToMapEvent<void>('centerchanged').subscribe(() => {\r\n            this._mapService.GetCenter().then((center: ILatLong) => {\r\n                if (this._latitude !== center.latitude || this._longitude !== center.longitude) {\r\n                    this._latitude = center.latitude;\r\n                    this._longitude = center.longitude;\r\n                    this.CenterChange.emit(<ILatLong>{ latitude: this._latitude, longitude: this._longitude });\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delegate handling map zoom change events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapZoomChange(): void {\r\n        this._mapService.SubscribeToMapEvent<void>('zoomchanged').subscribe(() => {\r\n            this._mapService.GetZoom().then((z: number) => {\r\n                if (this._zoom !== z) {\r\n                    this._zoom = z;\r\n                    this.ZoomChange.emit(z);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Initializes the map.\r\n     *\r\n     * @param el - Html elements which will host the map canvas.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private InitMapInstance(el: HTMLElement) {\r\n        this._zone.runOutsideAngular(() => {\r\n            if (this._options.center == null) { this._options.center = { latitude: this._latitude, longitude: this._longitude }; }\r\n            if (this._options.zoom == null) { this._options.zoom = this._zoom; }\r\n            if (this._options.mapTypeId == null) { this._options.mapTypeId = MapTypeId.hybrid; }\r\n            if (this._box != null) { this._options.bounds = this._box; }\r\n            this._mapPromise = this._mapService.CreateMap(el, this._options);\r\n            this.HandleMapCenterChange();\r\n            this.HandleMapBoundsChange();\r\n            this.HandleMapZoomChange();\r\n            this.HandleMapClickEvents();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the map center based on the geo properties of the component.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private UpdateCenter(): void {\r\n        if (typeof this._latitude !== 'number' || typeof this._longitude !== 'number') {\r\n            return;\r\n        }\r\n        this._mapService.SetCenter({\r\n            latitude: this._latitude,\r\n            longitude: this._longitude,\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Factory function to generate a cluster service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @returns - A concrete instance of a Cluster Service based on the underlying map architecture\r\n */\r\nexport function ClusterServiceFactory(f: MapServiceFactory, m: MapService): ClusterService { return f.CreateClusterService(m); }\r\n\r\n/**\r\n * Factory function to generate a infobox service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param m - A {@link MarkerService} instance.\r\n * @returns - A concrete instance of a InfoBox Service based on the underlying map architecture.\r\n */\r\nexport function InfoBoxServiceFactory(f: MapServiceFactory, m: MapService,\r\n    ma: MarkerService): InfoBoxService { return f.CreateInfoBoxService(m, ma); }\r\n\r\n/**\r\n * Factory function to generate a layer service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @returns - A concrete instance of a Layer Service based on the underlying map architecture.\r\n */\r\nexport function LayerServiceFactory(f: MapServiceFactory, m: MapService): LayerService { return f.CreateLayerService(m); }\r\n\r\n/**\r\n * Factory function to generate a map service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @returns - A concrete instance of a MapService based on the underlying map architecture.\r\n */\r\nexport function MapServiceCreator(f: MapServiceFactory): MapService { return f.Create(); }\r\n\r\n/**\r\n * Factory function to generate a marker service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param l - A {@link LayerService} instance.\r\n * @param c - A {@link ClusterService} instance.\r\n * @returns - A concrete instance of a Marker Service based on the underlying map architecture.\r\n */\r\nexport function MarkerServiceFactory(f: MapServiceFactory, m: MapService, l: LayerService, c: ClusterService): MarkerService {\r\n    return f.CreateMarkerService(m, l, c);\r\n}\r\n\r\n/**\r\n * Factory function to generate a polygon service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param l - A {@link LayerService} instance.\r\n * @returns - A concrete instance of a Polygon Service based on the underlying map architecture.\r\n */\r\nexport function PolygonServiceFactory(f: MapServiceFactory, m: MapService, l: LayerService): PolygonService {\r\n    return f.CreatePolygonService(m, l);\r\n}\r\n\r\n/**\r\n * Factory function to generate a polyline service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param l - A {@link LayerService} instance.\r\n * @returns - A concrete instance of a Polyline Service based on the underlying map architecture.\r\n */\r\nexport function PolylineServiceFactory(f: MapServiceFactory, m: MapService, l: LayerService): PolylineService {\r\n    return f.CreatePolylineService(m, l);\r\n}\r\n","import { Directive, EventEmitter, OnInit, OnDestroy, OnChanges, AfterContentInit, SimpleChange,\r\n    ContentChildren, Input, ViewContainerRef } from '@angular/core';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { MapMarkerDirective } from './map-marker';\r\n\r\n/**\r\n * internal counter to use as ids for multiple layers.\r\n */\r\nlet layerId = 0;\r\n\r\n/**\r\n * MapLayerDirective creates a layer on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>\r\n *     <x-map-layer [Visible]='visible'>\r\n *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>\r\n *     </x-map-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-layer'\r\n})\r\nexport class MapLayerDirective implements OnInit, OnDestroy, OnChanges {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _visible = true;\r\n    protected _addedToManager = false;\r\n    protected _id: number;\r\n\r\n    @ContentChildren(MapMarkerDirective) protected _markers: Array<MapMarkerDirective>;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the layer visibility.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    @Input()\r\n        public get Visible(): boolean { return this._visible; }\r\n        public set Visible(val: boolean) { this._visible = val; }\r\n\r\n    /**\r\n     * Gets the layer id.\r\n     *\r\n     * @readonly\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapLayerDirective.\r\n     * @param _layerService - Concreted implementation of a layer service for the underlying maps implementations.\r\n     * Generally provided via injections.\r\n     * @param _containerRef - Reference to the container hosting the map canvas. Generally provided via injection.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    constructor(protected _layerService: LayerService, protected _containerRef: ViewContainerRef) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called on Component initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public ngOnInit(): void {\r\n        this._containerRef.element.nativeElement.attributes['layerId'] = this._id.toString();\r\n        this._layerService.AddLayer(this);\r\n        this._addedToManager = true;\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [propName: string]: SimpleChange }): void {\r\n        if (!this._addedToManager) { return; }\r\n        if (changes['Visible']) {\r\n            this._layerService.GetNativeLayer(this).then(l => {\r\n                l.SetVisible(!l.GetVisible());\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public ngOnDestroy(): void {\r\n        this._layerService.DeleteLayer(this);\r\n    }\r\n}\r\n","import { IClusterIconInfo } from '../interfaces/icluster-icon-info';\r\nimport { Directive, EventEmitter, OnInit, OnDestroy, OnChanges, SimpleChange,\r\n    ContentChildren, Input, ViewContainerRef } from '@angular/core';\r\nimport { Marker } from '../models/marker';\r\nimport { Layer } from '../models/layer';\r\nimport { ClusterPlacementMode } from '../models/cluster-placement-mode';\r\nimport { ClusterClickAction } from '../models/cluster-click-action';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { IClusterOptions } from '../interfaces/icluster-options';\r\nimport { IMarkerIconInfo} from '../interfaces/imarker-icon-info';\r\nimport { ClusterService } from '../services/cluster.service';\r\nimport { ISpiderClusterOptions } from '../interfaces/ispider-cluster-options';\r\nimport { MapMarkerDirective } from './map-marker';\r\nimport { MapLayerDirective } from './map-layer';\r\n\r\n/**\r\n *\r\n * Creates a cluster layer on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>\r\n *     <x-cluster-layer [Visible]='visible'>\r\n *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>\r\n *     </x-cluster-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-cluster-layer'\r\n})\r\nexport class ClusterLayerDirective extends MapLayerDirective implements OnInit, OnDestroy, OnChanges {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _clusteringEnabled = true;\r\n    private _clusterPlacementMode: ClusterPlacementMode = ClusterPlacementMode.MeanValue;\r\n    private _clusterClickAction: ClusterClickAction = ClusterClickAction.ZoomIntoCluster;\r\n    private _spiderClusterOptions: ISpiderClusterOptions;\r\n    private _zIndex: number;\r\n    private _gridSize: number;\r\n    private _layerOffset: IPoint;\r\n    private _iconInfo: IMarkerIconInfo;\r\n    private _minimumClusterSize: number;\r\n    private _styles: Array<IClusterIconInfo>;\r\n    private _useDynamicSizeMarker = false;\r\n    private _dynamicMarkerBaseSize = 18;\r\n    private _dynamicMarkerRanges: Map<number, string> = new Map<number, string>([\r\n        [10, 'rgba(20, 180, 20, 0.5)'],\r\n        [100, 'rgba(255, 210, 40, 0.5)'],\r\n        [Number.MAX_SAFE_INTEGER , 'rgba(255, 40, 40, 0.5)']\r\n    ]);\r\n    private _zoomOnClick = true;\r\n    private _iconCreationCallback: (m: Array<Marker>, i: IMarkerIconInfo) => string;\r\n\r\n    ///\r\n    /// Property defintions\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the the Cluster Click Action {@link ClusterClickAction}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ClusterClickAction(): ClusterClickAction  { return this._clusterClickAction; }\r\n        public set ClusterClickAction(val: ClusterClickAction) { this._clusterClickAction = val; }\r\n\r\n    /**\r\n     * Gets or sets whether the clustering layer enables clustering. When set to false, the layer\r\n     * behaves like a generic layer. This is handy if you want to prevent clustering at certain zoom levels.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ClusteringEnabled(): boolean  { return this._clusteringEnabled; }\r\n        public set ClusteringEnabled(val: boolean) { this._clusteringEnabled = val; }\r\n\r\n    /**\r\n     * Gets or sets the cluster placement mode. {@link ClusterPlacementMode}\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ClusterPlacementMode(): ClusterPlacementMode  { return this._clusterPlacementMode; }\r\n        public set ClusterPlacementMode(val: ClusterPlacementMode) { this._clusterPlacementMode = val; }\r\n\r\n    /**\r\n     * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,\r\n     * you cannot set a custom marker callback.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get CustomMarkerCallback(): (m: Array<Marker>, i: IMarkerIconInfo) => string  { return this._iconCreationCallback; }\r\n        public set CustomMarkerCallback(val: (m: Array<Marker>, i: IMarkerIconInfo) => string) {\r\n            if (this._useDynamicSizeMarker) {\r\n                throw(\r\n                    new Error(`You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\r\n                    Set UseDynamicSizeMakers to false.`)\r\n                );\r\n            }\r\n            this._iconCreationCallback = val;\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.\r\n     * See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerBaseSize(): number  { return this._dynamicMarkerBaseSize; }\r\n        public set DynamicMarkerBaseSize(val: number) { this._dynamicMarkerBaseSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.\r\n     * The map contains key/value pairs, with the keys being\r\n     * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerRanges(): Map<number, string>  { return this._dynamicMarkerRanges; }\r\n        public set DynamicMarkerRanges(val: Map<number, string>) { this._dynamicMarkerRanges = val; }\r\n\r\n    /**\r\n     * Gets or sets the grid size to be used for clustering.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get GridSize(): number  { return this._gridSize; }\r\n        public set GridSize(val: number) { this._gridSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.\r\n     * See {@link IMarkerIconInfo}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get IconInfo(): IMarkerIconInfo  { return this._iconInfo; }\r\n        public set IconInfo(val: IMarkerIconInfo) { this._iconInfo = val; }\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get LayerOffset(): IPoint  { return this._layerOffset; }\r\n        public set LayerOffset(val: IPoint) { this._layerOffset = val; }\r\n\r\n    /**\r\n     * Gets or sets the minimum pins required to form a cluster\r\n     *\r\n     * @readonly\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get MinimumClusterSize(): number  { return this._minimumClusterSize; }\r\n        public set MinimumClusterSize(val: number) { this._minimumClusterSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the options for spider clustering behavior. See {@link ISpiderClusterOptions}\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get SpiderClusterOptions(): ISpiderClusterOptions { return this._spiderClusterOptions; }\r\n        public set SpiderClusterOptions(val: ISpiderClusterOptions) { this._spiderClusterOptions = val; }\r\n\r\n    /**\r\n     * Gets or sets the cluster styles\r\n     *\r\n     * @readonly\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get Styles(): Array<IClusterIconInfo> { return this._styles; }\r\n        public set Styles(val: Array<IClusterIconInfo>) { this._styles = val; }\r\n\r\n    /**\r\n     * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of\r\n     * pins in the cluster. If set to true, this will take precendence over any custom marker creation.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get UseDynamicSizeMarkers(): boolean { return this._useDynamicSizeMarker; }\r\n        public set UseDynamicSizeMarkers(val: boolean) {\r\n            this._useDynamicSizeMarker = val;\r\n            if (val) {\r\n                this._iconCreationCallback = (m: Array<Marker>, info: IMarkerIconInfo) => {\r\n                    return ClusterLayerDirective.CreateDynamicSizeMarker(\r\n                        m.length, info, this._dynamicMarkerBaseSize, this._dynamicMarkerRanges);\r\n                };\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ZIndex(): number { return this._zIndex; }\r\n        public set ZIndex(val: number) { this._zIndex = val; }\r\n\r\n    /**\r\n     * Gets or sets whether the cluster should zoom in on click\r\n     *\r\n     * @readonly\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ZoomOnClick(): boolean { return this._zoomOnClick; }\r\n        public set ZoomOnClick(val: boolean) { this._zoomOnClick = val; }\r\n\r\n    /**\r\n     * Creates the dynamic size marker to be used for cluster markers if UseDynamicSizeMarkers is set to true.\r\n     *\r\n     * @param size - The number of markers in the cluster.\r\n     * @param info  - The icon info to be used. This will be hydrated with\r\n     * the actualy dimensions of the created markers and is used by the underlying model/services\r\n     * to correctly offset the marker for correct positioning.\r\n     * @param baseMarkerSize - The base size for dynmic markers.\r\n     * @param ranges - The ranges to use to calculate breakpoints and colors for dynamic markers.\r\n     * The map contains key/value pairs, with the keys being\r\n     * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range.\r\n     * @returns - An string containing the SVG for the marker.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    public static CreateDynamicSizeMarker(size: number, info: IMarkerIconInfo,\r\n                                             baseMarkerSize: number, ranges: Map<number, string>): string {\r\n        const mr: number = baseMarkerSize;\r\n        const outline: number = mr * 0.35;\r\n        const total: number = size;\r\n        const r: number = Math.log(total) / Math.log(10) * 5 + mr;\r\n        const d: number = r * 2;\r\n        let fillColor: string;\r\n        ranges.forEach((v, k) => {\r\n            if (total <= k && !fillColor) { fillColor = v; }\r\n        });\r\n        if (!fillColor) { fillColor = 'rgba(20, 180, 20, 0.5)'; }\r\n\r\n        // Create an SVG string of two circles, one on top of the other, with the specified radius and color.\r\n        const svg: Array<any> = [`<svg xmlns='http://www.w3.org/2000/svg' width='${d}' height='${d}'>`,\r\n            `<circle cx='${r}' cy='${r}' r='${r}' fill='${fillColor}'/>`,\r\n            `<circle cx='${r}' cy='${r}' r='${r - outline}' fill='${fillColor}'/>`,\r\n            `</svg>`];\r\n        info.size = { width: d, height: d };\r\n        info.markerOffsetRatio = { x: 0.5, y: 0.5 };\r\n        info.textOffset = { x: 0, y: r - 8 };\r\n        return svg.join('');\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of ClusterLayerDirective.\r\n     *\r\n     * @param _layerService - Concreted implementation of a cluster layer service for the underlying maps\r\n     * implementations. Generally provided via injections.\r\n     * @param _containerRef - A reference to the view container of the layer. Generally provided via injection.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    constructor(_layerService: ClusterService, _containerRef: ViewContainerRef) {\r\n        super(_layerService, _containerRef);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [propName: string]: SimpleChange }): void {\r\n        if (!this._addedToManager) { return; }\r\n        if (changes['ClusterClickAction']) {\r\n            throw (\r\n                new Error('You cannot change the ClusterClickAction after the layer has been added to the layerservice.')\r\n            );\r\n        }\r\n\r\n        const options: IClusterOptions = { id: this._id };\r\n        if (changes['ClusteringEnabled']) { options.clusteringEnabled = this._clusteringEnabled; }\r\n        if (changes['GridSize']) { options.gridSize = this._gridSize; }\r\n        if (changes['LayerOffset']) { options.layerOffset = this._layerOffset; }\r\n        if (changes['SpiderClusterOptions']) { options.spiderClusterOptions = this._spiderClusterOptions; }\r\n        if (changes['ZIndex']) { options.zIndex = this._zIndex; }\r\n        if (changes['Visible']) { options.visible = this._visible; }\r\n\r\n        this._layerService.GetNativeLayer(this).then((l: Layer) => {\r\n            l.SetOptions(options);\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, Input, Output, OnDestroy, OnChanges, ViewContainerRef,\r\n    EventEmitter, ContentChild, AfterContentInit, SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { IPolygonEvent } from '../interfaces/ipolygon-event';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { PolygonService } from '../services/polygon.service';\r\nimport { InfoBoxComponent } from './infobox';\r\n\r\nlet polygonId = 0;\r\n\r\n/**\r\n *\r\n * MapPolygonDirective renders a polygon inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapPolygonDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map,\r\n *  styles: [`\r\n *   .map-container { height: 300px; }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polygon [Paths]=\"path\"></x-map-polygon>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polygon'\r\n})\r\nexport class MapPolygonDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _inCustomLayer = false;\r\n    private _id: number;\r\n    private _layerId: number;\r\n    private _addedToService = false;\r\n    private _events: Subscription[] = [];\r\n\r\n    ///\r\n    /// Any InfoBox that is a direct children of the polygon\r\n    ///\r\n    @ContentChild(InfoBoxComponent) protected _infoBox: InfoBoxComponent;\r\n\r\n\r\n    /**\r\n     * Gets or sets whether this Polygon handles mouse events.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Clickable = true;\r\n\r\n    /**\r\n     * If set to true, the user can drag this shape over the map.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Draggable = false;\r\n\r\n    /**\r\n     * If set to true, the user can edit this shape by dragging the control\r\n     * points shown at the vertices and on each segment.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Editable = false;\r\n\r\n    /**\r\n     * The fill color of the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public FillColor: string;\r\n\r\n    /**\r\n     * The fill opacity between 0.0 and 1.0\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public FillOpacity: number;\r\n\r\n    /**\r\n     * When true, edges of the polygon are interpreted as geodesic and will\r\n     * follow the curvature of the Earth. When false, edges of the polygon are\r\n     * rendered as straight lines in screen space. Note that the shape of a\r\n     * geodesic polygon may appear to change when dragged, as the dimensions\r\n     * are maintained relative to the surface of the earth. Defaults to false.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Geodesic = false;\r\n\r\n    /**\r\n     * Set the maximum zoom at which the polygon lable is visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public LabelMaxZoom: number;\r\n\r\n    /**\r\n     * Set the minimum zoom at which the polygon lable is visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public LabelMinZoom: number;\r\n\r\n    /**\r\n     * Arbitary metadata to assign to the Polygon. This is useful for events\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * The ordered sequence of coordinates that designates a closed loop.\r\n     * Unlike polylines, a polygon may consist of one or more paths.\r\n     * As a result, the paths property may specify one or more arrays of\r\n     * LatLng coordinates. Paths are closed automatically; do not repeat the\r\n     * first vertex of the path as the last vertex. Simple polygons may be\r\n     * defined using a single array of LatLngs. More complex polygons may\r\n     * specify an array of arrays (for inner loops ). Any simple arrays are converted into Arrays.\r\n     * Inserting or removing LatLngs from the Array will automatically update\r\n     * the polygon on the map.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Paths: Array<ILatLong> | Array<Array<ILatLong>> = [];\r\n\r\n    /**\r\n     * Whether to show the title as the label on the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public ShowLabel: boolean;\r\n\r\n    /**\r\n     * Whether to show the title of the polygon as the tooltip on the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public ShowTooltip: boolean = true;\r\n\r\n    /**\r\n     * The stroke color.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public StrokeColor: string;\r\n\r\n    /**\r\n     * The stroke opacity between 0.0 and 1.0\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public StrokeOpacity: number;\r\n\r\n    /**\r\n     * The stroke width in pixels.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public StrokeWeight: number;\r\n\r\n    /**\r\n     * The title of the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * Whether this polygon is visible on the map. Defaults to true.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * The zIndex compared to other polys.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public zIndex: number;\r\n\r\n    ///\r\n    /// Delegate definitions\r\n    ///\r\n\r\n    /**\r\n     * This event is fired when the DOM click event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() Click: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() DblClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is repeatedly fired while the user drags the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() Drag: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() DragEnd: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user starts dragging the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() DragStart: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousedown event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseDown: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseMove: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polygon mouseout.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseOut: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polygon mouseover.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseOver: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired whe the DOM mouseup event is fired on the Polygon\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseUp: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n\r\n    /**\r\n     * This event is fired when the Polygon is right-clicked on.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() RightClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when editing has completed.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() PathChanged: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets whether the polygon has been registered with the service.\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get AddedToService(): boolean { return this._addedToService; }\r\n\r\n    /**\r\n     * Get the id of the polygon.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    /**\r\n     * Gets the id of the polygon as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get IdAsString(): string { return this._id.toString(); }\r\n\r\n    /**\r\n     * Gets whether the polygon is in a custom layer. See {@link MapLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get InCustomLayer(): boolean { return this._inCustomLayer; }\r\n\r\n    /**\r\n     * gets the id of the Layer the polygon belongs to.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get LayerId(): number { return this._layerId; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolygonDirective.\r\n     * @param _polygonManager\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    constructor(private _polygonService: PolygonService, private _containerRef: ViewContainerRef) {\r\n        this._id = polygonId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    ngAfterContentInit(): void {\r\n        if (this._containerRef.element.nativeElement.parentElement) {\r\n            const parentName: string = this._containerRef.element.nativeElement.parentElement.tagName;\r\n            if (parentName.toLowerCase() === 'x-map-layer') {\r\n                this._inCustomLayer = true;\r\n                this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);\r\n            }\r\n        }\r\n        if (!this._addedToService) {\r\n            this._polygonService.AddPolygon(this);\r\n            this._addedToService = true;\r\n            this.AddEventListeners();\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): any {\r\n        if (!this._addedToService) { return; }\r\n\r\n        const o: IPolygonOptions = this.GeneratePolygonChangeSet(changes);\r\n        if (o != null) { this._polygonService.SetOptions(this, o); }\r\n        if (changes['Paths'] && !changes['Paths'].isFirstChange()) {\r\n            this._polygonService.UpdatePolygon(this);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.\r\n     *\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    ngOnDestroy() {\r\n        this._polygonService.DeletePolygon(this);\r\n        this._events.forEach((s) => s.unsubscribe());\r\n        ///\r\n        /// remove event subscriptions\r\n        ///\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Wires up the event receivers.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    private AddEventListeners() {\r\n        const _getEventArg: (e: MouseEvent) => IPolygonEvent = e => {\r\n            return {\r\n                Polygon: this,\r\n                Click: e\r\n            };\r\n        };\r\n        this._events.push(this._polygonService.CreateEventObservable('click', this).subscribe((ev: MouseEvent) => {\r\n            const t: MapPolygonDirective = this;\r\n            if (this._infoBox != null) {\r\n                this._infoBox.Open(this._polygonService.GetCoordinatesFromClick(ev));\r\n            }\r\n            this.Click.emit(_getEventArg(ev));\r\n        }));\r\n        const handlers = [\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.DblClick.emit(_getEventArg(ev)) },\r\n            { name: 'drag', handler: (ev: MouseEvent) => this.Drag.emit(_getEventArg(ev)) },\r\n            { name: 'dragend', handler: (ev: MouseEvent) => this.DragEnd.emit(_getEventArg(ev)) },\r\n            { name: 'dragstart', handler: (ev: MouseEvent) => this.DragStart.emit(_getEventArg(ev)) },\r\n            { name: 'mousedown', handler: (ev: MouseEvent) => this.MouseDown.emit(_getEventArg(ev)) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.MouseMove.emit(_getEventArg(ev)) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.MouseOut.emit(_getEventArg(ev)) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.MouseOver.emit(_getEventArg(ev)) },\r\n            { name: 'mouseup', handler: (ev: MouseEvent) => this.MouseUp.emit(_getEventArg(ev)) },\r\n            { name: 'rightclick', handler: (ev: MouseEvent) => this.RightClick.emit(_getEventArg(ev)) },\r\n            { name: 'pathchanged', handler: (ev: IPolygonEvent) => this.PathChanged.emit(ev) }\r\n        ];\r\n        handlers.forEach((obj) => {\r\n            const os = this._polygonService.CreateEventObservable(obj.name, this).subscribe(obj.handler);\r\n            this._events.push(os);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Generates IPolygon option changeset from directive settings.\r\n     *\r\n     * @param changes - {@link SimpleChanges} identifying the changes that occured.\r\n     * @returns - {@link IPolygonOptions} containing the polygon options.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    private GeneratePolygonChangeSet(changes: SimpleChanges): IPolygonOptions {\r\n        const options: IPolygonOptions = { id: this._id };\r\n        let hasOptions: boolean = false;\r\n        if (changes['Clickable']) { options.clickable = this.Clickable; hasOptions = true; }\r\n        if (changes['Draggable']) { options.draggable = this.Draggable; hasOptions = true; }\r\n        if (changes['Editable']) { options.editable = this.Editable; hasOptions = true; }\r\n        if (changes['FillColor'] || changes['FillOpacity']) {\r\n            options.fillColor = this.FillColor;\r\n            options.fillOpacity = this.FillOpacity;\r\n            hasOptions = true;\r\n        }\r\n        if (changes['Geodesic']) { options.geodesic = this.Geodesic; hasOptions = true; }\r\n        if (changes['LabelMaxZoom']) { options.labelMaxZoom = this.LabelMaxZoom; hasOptions = true; }\r\n        if (changes['LabelMinZoom']) { options.labelMinZoom = this.LabelMinZoom; hasOptions = true; }\r\n        if (changes['ShowTooltip']) { options.showTooltip = this.ShowTooltip; hasOptions = true; }\r\n        if (changes['ShowLabel']) { options.showLabel = this.ShowLabel; hasOptions = true; }\r\n        if (changes['StrokeColor'] || changes['StrokeOpacity']) {\r\n            options.strokeColor = this.StrokeColor;\r\n            options.strokeOpacity = this.StrokeOpacity;\r\n            hasOptions = true;\r\n        }\r\n        if (changes['StrokeWeight']) { options.strokeWeight = this.StrokeWeight; hasOptions = true; }\r\n        if (changes['Title']) { options.title = this.Title; hasOptions = true; }\r\n        if (changes['Visible']) { options.visible = this.Visible; hasOptions = true; }\r\n        if (changes['zIndex']) { options.zIndex = this.zIndex; hasOptions = true; }\r\n        return hasOptions ? options : null;\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, Input, Output, OnDestroy, OnChanges, ViewContainerRef,\r\n    EventEmitter, ContentChild, AfterContentInit, SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { PolylineService } from '../services/polyline.service';\r\nimport { IPolylineEvent } from '../interfaces/ipolyline-event';\r\nimport { InfoBoxComponent } from './infobox';\r\n\r\nlet polylineId = 0;\r\n\r\n/**\r\n *\r\n * MapPolylineDirective renders a polyline inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapPolylineDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map,\r\n *  styles: [`\r\n *   .map-container { height: 300px; }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polyline [Paths]=\"path\"></x-map-polyline>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polyline'\r\n})\r\nexport class MapPolylineDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _inCustomLayer = false;\r\n    private _id: number;\r\n    private _layerId: number;\r\n    private _addedToService = false;\r\n    private _events: Subscription[] = [];\r\n\r\n    ///\r\n    /// Any InfoBox that is a direct children of the polyline\r\n    ///\r\n    @ContentChild(InfoBoxComponent) protected _infoBox: InfoBoxComponent;\r\n\r\n\r\n    /**\r\n     * Gets or sets whether this Polyline handles mouse events.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Clickable = true;\r\n\r\n    /**\r\n     * If set to true, the user can drag this shape over the map.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Draggable = false;\r\n\r\n    /**\r\n     * If set to true, the user can edit this shape by dragging the control\r\n     * points shown at the vertices and on each segment.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Editable = false;\r\n\r\n    /**\r\n     * When true, edges of the polyline are interpreted as geodesic and will\r\n     * follow the curvature of the Earth. When false, edges of the polyline are\r\n     * rendered as straight lines in screen space. Note that the shape of a\r\n     * geodesic polyline may appear to change when dragged, as the dimensions\r\n     * are maintained relative to the surface of the earth. Defaults to false.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Geodesic = false;\r\n\r\n    /**\r\n     * Arbitary metadata to assign to the Polyline. This is useful for events\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * The ordered sequence of coordinates that designates a polyline.\r\n     * Simple polylines may be defined using a single array of LatLngs. More\r\n     * complex polylines may specify an array of arrays.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Path: Array<ILatLong> | Array<Array<ILatLong>> = [];\r\n\r\n    /**\r\n     * Whether to show the title of the polyline as the tooltip on the polygon.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public ShowTooltip: boolean = true;\r\n\r\n    /**\r\n     * The stroke color.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public StrokeColor: string;\r\n\r\n    /**\r\n     * The stroke opacity between 0.0 and 1.0\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public StrokeOpacity: number;\r\n\r\n    /**\r\n     * The stroke width in pixels.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public StrokeWeight: number;\r\n\r\n    /**\r\n     * The title of the polygon.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * Whether this polyline is visible on the map. Defaults to true.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * The zIndex compared to other polys.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public zIndex: number;\r\n\r\n    ///\r\n    /// Delegate definitions\r\n    ///\r\n\r\n    /**\r\n     * This event is fired when the DOM click event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() Click: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() DblClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is repeatedly fired while the user drags the polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() Drag: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging the polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() DragEnd: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user starts dragging the polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() DragStart: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousedown event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseDown: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseMove: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polyline mouseout.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseOut: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polyline mouseover.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseOver: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired whe the DOM mouseup event is fired on the Polyline\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseUp: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This even is fired when the Polyline is right-clicked on.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() RightClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets whether the polyline has been registered with the service.\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get AddedToService(): boolean { return this._addedToService; }\r\n\r\n    /**\r\n     * Get the id of the polyline.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    /**\r\n     * Gets the id of the polyline as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get IdAsString(): string { return this._id.toString(); }\r\n\r\n    /**\r\n     * Gets whether the polyline is in a custom layer. See {@link MapLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get InCustomLayer(): boolean { return this._inCustomLayer; }\r\n\r\n    /**\r\n     * gets the id of the Layer the polyline belongs to.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get LayerId(): number { return this._layerId; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolylineDirective.\r\n     * @param _polylineManager\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    constructor(private _polylineService: PolylineService, private _containerRef: ViewContainerRef) {\r\n        this._id = polylineId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    ngAfterContentInit(): void {\r\n        if (this._containerRef.element.nativeElement.parentElement) {\r\n            const parentName: string = this._containerRef.element.nativeElement.parentElement.tagName;\r\n            if (parentName.toLowerCase() === 'x-map-layer') {\r\n                this._inCustomLayer = true;\r\n                this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);\r\n            }\r\n        }\r\n        if (!this._addedToService) {\r\n            this._polylineService.AddPolyline(this);\r\n            this._addedToService = true;\r\n            this.AddEventListeners();\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): any {\r\n        if (!this._addedToService) { return; }\r\n\r\n        const o: IPolylineOptions = this.GeneratePolylineChangeSet(changes);\r\n        if (o != null) {\r\n            this._polylineService.SetOptions(this, o);\r\n        }\r\n        if (changes['Path'] && !changes['Path'].isFirstChange()) {\r\n            this._polylineService.UpdatePolyline(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.\r\n     *\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    ngOnDestroy() {\r\n        this._polylineService.DeletePolyline(this);\r\n        this._events.forEach((s) => s.unsubscribe());\r\n            ///\r\n            /// remove event subscriptions\r\n            ///\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Wires up the event receivers.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    private AddEventListeners() {\r\n        const _getEventArg: (e: MouseEvent) => IPolylineEvent = e => {\r\n            return {\r\n                Polyline: this,\r\n                Click: e\r\n            };\r\n        };\r\n        this._polylineService.CreateEventObservable('click', this).subscribe((ev: MouseEvent) => {\r\n            if (this._infoBox != null) {\r\n                this._infoBox.Open(this._polylineService.GetCoordinatesFromClick(ev));\r\n            }\r\n            this.Click.emit(_getEventArg(ev));\r\n        });\r\n        const handlers = [\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.DblClick.emit(_getEventArg(ev)) },\r\n            { name: 'drag', handler: (ev: MouseEvent) => this.Drag.emit(_getEventArg(ev)) },\r\n            { name: 'dragend', handler: (ev: MouseEvent) => this.DragEnd.emit(_getEventArg(ev)) },\r\n            { name: 'dragstart', handler: (ev: MouseEvent) => this.DragStart.emit(_getEventArg(ev)) },\r\n            { name: 'mousedown', handler: (ev: MouseEvent) => this.MouseDown.emit(_getEventArg(ev)) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.MouseMove.emit(_getEventArg(ev)) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.MouseOut.emit(_getEventArg(ev)) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.MouseOver.emit(_getEventArg(ev)) },\r\n            { name: 'mouseup', handler: (ev: MouseEvent) => this.MouseUp.emit(_getEventArg(ev)) },\r\n            { name: 'rightclick', handler: (ev: MouseEvent) => this.RightClick.emit(_getEventArg(ev)) },\r\n        ];\r\n        handlers.forEach((obj) => {\r\n            const os = this._polylineService.CreateEventObservable(obj.name, this).subscribe(obj.handler);\r\n            this._events.push(os);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Generates IPolyline option changeset from directive settings.\r\n     *\r\n     * @param changes - {@link SimpleChanges} identifying the changes that occured.\r\n     * @returns - {@link IPolylineOptions} containing the polyline options.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    private GeneratePolylineChangeSet(changes: SimpleChanges): IPolylineOptions {\r\n        const options: IPolylineOptions = { id: this._id };\r\n        let hasOptions: boolean = false;\r\n        if (changes['Clickable']) { options.clickable = this.Clickable; hasOptions = true; }\r\n        if (changes['Draggable']) { options.draggable = this.Draggable; hasOptions = true; }\r\n        if (changes['Editable']) { options.editable = this.Editable; hasOptions = true; }\r\n        if (changes['Geodesic']) { options.geodesic = this.Geodesic; hasOptions = true; }\r\n        if (changes['ShowTooltip']) { options.showTooltip = this.ShowTooltip; hasOptions = true; }\r\n        if (changes['StrokeColor']) { options.strokeColor = this.StrokeColor; hasOptions = true; }\r\n        if (changes['StrokeOpacity']) { options.strokeOpacity = this.StrokeOpacity; hasOptions = true; }\r\n        if (changes['StrokeWeight']) { options.strokeWeight = this.StrokeWeight; hasOptions = true; }\r\n        if (changes['Title']) { options.title = this.Title; hasOptions = true; }\r\n        if (changes['Visible']) { options.visible = this.Visible; hasOptions = true; }\r\n        if (changes['zIndex']) { options.zIndex = this.zIndex; hasOptions = true; }\r\n        return hasOptions ? options : null;\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef, NgZone\r\n} from '@angular/core';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IMarkerEvent } from '../interfaces/imarker-event';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { IClusterIconInfo } from '../interfaces/icluster-icon-info';\r\nimport { IClusterOptions } from '../interfaces/icluster-options';\r\nimport { MarkerService } from '../services/marker.service';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { ClusterService } from '../services/cluster.service';\r\nimport { MapService } from '../services/map.service';\r\nimport { Layer } from '../models/layer';\r\nimport { Marker } from '../models/marker';\r\nimport { ClusterClickAction } from '../models/cluster-click-action';\r\nimport { ClusterPlacementMode } from '../models/cluster-placement-mode';\r\nimport { ClusterLayerDirective } from './cluster-layer';\r\n\r\n/**\r\n * internal counter to use as ids for marker.\r\n */\r\nlet layerId = 1000000;\r\n\r\n/**\r\n * MapMarkerLayerDirective performantly renders a large set of map marker inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker-layer [MarkerOptions]=\"_markers\"></x-map-marker-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-marker-layer'\r\n})\r\nexport class MapMarkerLayerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _id: number;\r\n    private _layerPromise: Promise<Layer>;\r\n    private _service: LayerService;\r\n    private _styles: Array<IClusterIconInfo>;\r\n    private _useDynamicSizeMarker = false;\r\n    private _dynamicMarkerBaseSize = 18;\r\n    private _dynamicMarkerRanges: Map<number, string> = new Map<number, string>([\r\n        [10, 'rgba(20, 180, 20, 0.5)'],\r\n        [100, 'rgba(255, 210, 40, 0.5)'],\r\n        [Number.MAX_SAFE_INTEGER , 'rgba(255, 40, 40, 0.5)']\r\n    ]);\r\n    private _iconCreationCallback: (m: Array<Marker>, i: IMarkerIconInfo) => string;\r\n    private _streaming: boolean = false;\r\n    private _markers: Array<IMarkerOptions> = new Array<IMarkerOptions>();\r\n    private _markersLast: Array<IMarkerOptions> = new Array<IMarkerOptions>();\r\n\r\n\r\n    /**\r\n     * Gets or sets the the Cluster Click Action {@link ClusterClickAction}.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ClusterClickAction: ClusterClickAction =  ClusterClickAction.ZoomIntoCluster;\r\n\r\n    /**\r\n     * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.\r\n     * See {@link IMarkerIconInfo}.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ClusterIconInfo: IMarkerIconInfo;\r\n\r\n    /**\r\n     * Gets or sets the cluster placement mode. {@link ClusterPlacementMode}\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()  public ClusterPlacementMode: ClusterPlacementMode = ClusterPlacementMode.MeanValue;\r\n\r\n    /**\r\n     * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,\r\n     * you cannot set a custom marker callback.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get CustomMarkerCallback(): (m: Array<Marker>, i: IMarkerIconInfo) => string  { return this._iconCreationCallback; }\r\n        public set CustomMarkerCallback(val: (m: Array<Marker>, i: IMarkerIconInfo) => string) {\r\n            if (this._useDynamicSizeMarker) {\r\n                throw(\r\n                    new Error(`You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\r\n                    Set UseDynamicSizeMakers to false.`)\r\n                );\r\n            }\r\n            this._iconCreationCallback = val;\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.\r\n     * See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerBaseSize(): number  { return this._dynamicMarkerBaseSize; }\r\n        public set DynamicMarkerBaseSize(val: number) { this._dynamicMarkerBaseSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.\r\n     * The map contains key/value pairs, with the keys being\r\n     * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerRanges(): Map<number, string>  { return this._dynamicMarkerRanges; }\r\n        public set DynamicMarkerRanges(val: Map<number, string>) { this._dynamicMarkerRanges = val; }\r\n\r\n    /**\r\n     * Determines whether the layer clusters. This property can only be set on creation of the layer.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public EnableClustering: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the grid size to be used for clustering.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public GridSize: number = 150;\r\n\r\n    /**\r\n     * Gets or sets the IconInfo to be used to create a custom marker images. Supports font-based, SVG, graphics and more.\r\n     * See {@link IMarkerIconInfo}.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public IconInfo: IMarkerIconInfo;\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public LayerOffset: IPoint = null;\r\n\r\n    /**\r\n     *  IMarkerOptions array holding the marker info.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get MarkerOptions(): Array<IMarkerOptions> { return this._markers; }\r\n        public set MarkerOptions(val: Array<IMarkerOptions>) {\r\n            if (this._streaming) {\r\n                this._markersLast.push(...val.slice(0));\r\n                this._markers.push(...val);\r\n            }\r\n            else {\r\n                this._markers = val.slice(0);\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the cluster styles\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get Styles(): Array<IClusterIconInfo> { return this._styles; }\r\n        public set Styles(val: Array<IClusterIconInfo>) { this._styles = val; }\r\n\r\n    /**\r\n     * Sets whether to treat changes in the MarkerOptions as streams of new markers. In thsi mode, changing the\r\n     * Array supplied in MarkerOptions will be incrementally drawn on the map as opposed to replace the markers on the map.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get TreatNewMarkerOptionsAsStream(): boolean { return this._streaming; }\r\n        public set TreatNewMarkerOptionsAsStream(val: boolean) { this._streaming = val; }\r\n\r\n    /**\r\n     * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of\r\n     * pins in the cluster. If set to true, this will take precendence over any custom marker creation.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get UseDynamicSizeMarkers(): boolean { return this._useDynamicSizeMarker; }\r\n        public set UseDynamicSizeMarkers(val: boolean) {\r\n            this._useDynamicSizeMarker = val;\r\n            if (val) {\r\n                this._iconCreationCallback = (m: Array<Marker>, info: IMarkerIconInfo) => {\r\n                    return ClusterLayerDirective.CreateDynamicSizeMarker(\r\n                        m.length, info, this._dynamicMarkerBaseSize, this._dynamicMarkerRanges);\r\n                };\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Sets the visibility of the marker layer\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ZIndex: number = 0;\r\n\r\n    /**\r\n     * Gets or sets whether the cluster should zoom in on click\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ZoomOnClick: boolean = true;\r\n\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n    /**\r\n     * This event emitter gets emitted when the dynamic icon for a marker is being created.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Output() public DynamicMarkerCreated: EventEmitter<IMarkerIconInfo> = new EventEmitter<IMarkerIconInfo>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks a marker in the layer.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Output() public MarkerClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging a marker.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Output() public DragEnd: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the id of the marker layer.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapMarkerLayerDirective.\r\n     * @param _markerService - Concreate implementation of a {@link MarkerService}.\r\n     * @param _layerService - Concreate implementation of a {@link LayerService}.\r\n     * @param _clusterService - Concreate implementation of a {@link ClusterService}.\r\n     * @param _mapService - Concreate implementation of a {@link MapService}.\r\n     * @param _zone - Concreate implementation of a {@link NgZone} service.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    constructor(\r\n        private _markerService: MarkerService,\r\n        private _layerService: LayerService,\r\n        private _clusterService: ClusterService,\r\n        private _mapService: MapService,\r\n        private _zone: NgZone) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Translates a geo location to a pixel location relative to the map viewport.\r\n     *\r\n     * @param [loc] - {@link ILatLong} containing the geo coordinates.\r\n     * @returns - A promise that when fullfilled contains an {@link IPoint} representing the pixel coordinates.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public LocationToPixel(loc: ILatLong): Promise<IPoint> {\r\n        return this._markerService.LocationToPoint(loc);\r\n    }\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        const layerOptions: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        this._zone.runOutsideAngular(() => {\r\n            const fakeLayerDirective: any = {\r\n                Id : this._id,\r\n                Visible: this.Visible\r\n            };\r\n            if (!this.EnableClustering) {\r\n                this._layerService.AddLayer(fakeLayerDirective);\r\n                this._layerPromise = this._layerService.GetNativeLayer(fakeLayerDirective);\r\n                this._service = this._layerService;\r\n            }\r\n            else {\r\n                fakeLayerDirective.LayerOffset = this.LayerOffset;\r\n                fakeLayerDirective.ZIndex = this.ZIndex;\r\n                fakeLayerDirective.ClusteringEnabled = this.EnableClustering;\r\n                fakeLayerDirective.ClusterPlacementMode = this.ClusterPlacementMode;\r\n                fakeLayerDirective.GridSize = this.GridSize;\r\n                fakeLayerDirective.ClusterClickAction = this.ClusterClickAction;\r\n                fakeLayerDirective.IconInfo = this.ClusterIconInfo;\r\n                fakeLayerDirective.CustomMarkerCallback = this.CustomMarkerCallback;\r\n                fakeLayerDirective.UseDynamicSizeMarkers = this.UseDynamicSizeMarkers;\r\n                this._clusterService.AddLayer(fakeLayerDirective);\r\n                this._layerPromise = this._clusterService.GetNativeLayer(fakeLayerDirective);\r\n                this._service = this._clusterService;\r\n            }\r\n            this._layerPromise.then(l => {\r\n                l.SetVisible(this.Visible);\r\n                if (this.MarkerOptions) {\r\n                    this._zone.runOutsideAngular(() => this.UpdateMarkers());\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._layerPromise.then(l => {\r\n            l.Delete();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        let shouldSetOptions: boolean = false;\r\n        const o: IClusterOptions = {\r\n            id: this._id\r\n        };\r\n        if (changes['MarkerOptions']) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this.UpdateMarkers();\r\n            });\r\n        }\r\n        if (changes['Visible'] && !changes['Visible'].firstChange) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this._layerPromise.then(l => l.SetVisible(this.Visible));\r\n            });\r\n        }\r\n        if (changes['EnableClustering'] && !changes['EnableClustering'].firstChange) {\r\n            if ('StopClustering' in this._service) {\r\n                o.clusteringEnabled = this.EnableClustering;\r\n                shouldSetOptions = true;\r\n            }\r\n            else {\r\n                throw (new Error('You cannot change EnableClustering after the layer has been created.'));\r\n            }\r\n        }\r\n        if (changes['ClusterPlacementMode'] && !changes['ClusterPlacementMode'].firstChange && 'StopClustering' in this._service) {\r\n            o.placementMode = this.ClusterPlacementMode;\r\n            shouldSetOptions = true;\r\n        }\r\n        if (changes['GridSize'] && !changes['GridSize'].firstChange && 'StopClustering' in this._service) {\r\n            o.gridSize = this.GridSize;\r\n            shouldSetOptions = true;\r\n        }\r\n        if (changes['ClusterClickAction'] && !changes['ClusterClickAction'].firstChange && 'StopClustering' in this._service) {\r\n            o.zoomOnClick = this.ClusterClickAction === ClusterClickAction.ZoomIntoCluster;\r\n            shouldSetOptions = true;\r\n        }\r\n        if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||\r\n            (changes['LayerOffset'] && !changes['LayerOffset'].firstChange) ||\r\n            (changes['IconInfo'] && !changes['IconInfo'].firstChange)\r\n        ) {\r\n            throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));\r\n        }\r\n\r\n        if (shouldSetOptions) {\r\n            this._zone.runOutsideAngular(() => {\r\n                const fakeLayerDirective: any = {Id : this._id};\r\n                this._layerPromise.then(l => l.SetOptions(o));\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Marker Id.\r\n     * @returns - string representation of the marker id.\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public toString(): string { return 'MapMarkerLayer-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the marker.\r\n     *\r\n     * @param m - the marker for which to add the event.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    private AddEventListeners(m: Marker): void {\r\n        m.AddListener('click', (e: MouseEvent) => this.MarkerClick.emit({\r\n                Marker: m,\r\n                Click: e,\r\n                Location: this._markerService.GetCoordinatesFromClick(e),\r\n                Pixels: this._markerService.GetPixelsFromClick(e)\r\n            }));\r\n        m.AddListener('dragend', (e: MouseEvent) => this.DragEnd.emit({\r\n                Marker: m,\r\n                Click: e,\r\n                Location: this._markerService.GetCoordinatesFromClick(e),\r\n                Pixels: this._markerService.GetPixelsFromClick(e)\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Sets or updates the markers based on the marker options. This will place the markers on the map\r\n     * and register the associated events.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     * @method\r\n     */\r\n    private UpdateMarkers(): void {\r\n        if (this._layerPromise == null) { return; }\r\n        this._layerPromise.then(l => {\r\n            const markers: Array<IMarkerOptions> = this._streaming ? this._markersLast.splice(0) : this._markers;\r\n\r\n            // generate the promise for the markers\r\n            const mp: Promise<Array<Marker>> = this._service.CreateMarkers(markers, this.IconInfo);\r\n\r\n            // set markers once promises are fullfilled.\r\n            mp.then(m => {\r\n                m.forEach(marker => {\r\n                     this.AddEventListeners(marker);\r\n                });\r\n                this._streaming ? l.AddEntities(m) : l.SetEntities(m);\r\n            });\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef, NgZone,\r\n    SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolygonEvent } from '../interfaces/ipolygon-event';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { ILabelOptions } from '../interfaces/ilabel-options';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { MapService } from '../services/map.service';\r\nimport { Layer } from '../models/layer';\r\nimport { Polygon } from '../models/polygon';\r\nimport { MapLabel } from '../models/map-label';\r\nimport { CanvasOverlay } from '../models/canvas-overlay';\r\n\r\n/**\r\n * internal counter to use as ids for polygons.\r\n */\r\nlet layerId = 1000000;\r\n\r\n/**\r\n * MapPolygonLayerDirective performantly renders a large set of polygons on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polygon-layer [PolygonOptions]=\"_polygons\"></x-map-polygon-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polygon-layer'\r\n})\r\nexport class MapPolygonLayerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _id: number;\r\n    private _layerPromise: Promise<Layer>;\r\n    private _service: LayerService;\r\n    private _canvas: CanvasOverlay;\r\n    private _labels: Array<{loc: ILatLong, title: string}> = new Array<{loc: ILatLong, title: string}>();\r\n    private _tooltip: MapLabel;\r\n    private _tooltipSubscriptions: Array<Subscription> = new Array<Subscription>();\r\n    private _tooltipVisible: boolean = false;\r\n    private _defaultOptions: ILabelOptions = {\r\n        fontSize: 11,\r\n        fontFamily: 'sans-serif',\r\n        strokeWeight: 2,\r\n        strokeColor: '#000000',\r\n        fontColor: '#ffffff'\r\n    };\r\n    private _streaming: boolean = false;\r\n    private _polygons: Array<IPolygonOptions> = new Array<IPolygonOptions>();\r\n    private _polygonsLast: Array<IPolygonOptions> = new Array<IPolygonOptions>();\r\n\r\n    /**\r\n     * Set the maximum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LabelMaxZoom: number = Number.MAX_SAFE_INTEGER;\r\n\r\n    /**\r\n     * Set the minimum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LabelMinZoom: number = -1;\r\n\r\n    /**\r\n     * Sepcifies styleing options for on-map polygon labels.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LabelOptions: ILabelOptions;\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LayerOffset: IPoint = null;\r\n\r\n    /**\r\n     * An array of polygon options representing the polygons in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input()\r\n        public get PolygonOptions(): Array<IPolygonOptions> { return this._polygons; }\r\n        public set PolygonOptions(val: Array<IPolygonOptions>) {\r\n            if (this._streaming) {\r\n                this._polygonsLast.push(...val.slice(0));\r\n                this._polygons.push(...val);\r\n            }\r\n            else {\r\n                this._polygons = val.slice(0);\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Whether to show the polygon titles as the labels on the polygons.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public ShowLabels: boolean = false;\r\n\r\n    /**\r\n     * Whether to show the titles of the polygosn as the tooltips on the polygons.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public ShowTooltips: boolean = true;\r\n\r\n    /**\r\n     * Sets whether to treat changes in the PolygonOptions as streams of new markers. In this mode, changing the\r\n     * Array supplied in PolygonOptions will be incrementally drawn on the map as opposed to replace the polygons on the map.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input()\r\n        public get TreatNewPolygonOptionsAsStream(): boolean { return this._streaming; }\r\n        public set TreatNewPolygonOptionsAsStream(val: boolean) { this._streaming = val; }\r\n\r\n    /**\r\n     * Sets the visibility of the marker layer\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public ZIndex: number = 0;\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() public PolygonClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonDblClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonMouseMove: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseout on a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonMouseOut: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseover on a polygon in a layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonMouseOver: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the id of the marker layer.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolygonLayerDirective.\r\n     * @param _layerService - Concreate implementation of a {@link LayerService}.\r\n     * @param _mapService - Concreate implementation of a {@link MapService}.\r\n     * @param _zone - Concreate implementation of a {@link NgZone} service.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    constructor(\r\n        private _layerService: LayerService,\r\n        private _mapService: MapService,\r\n        private _zone: NgZone) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        const layerOptions: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        this._zone.runOutsideAngular(() => {\r\n            const fakeLayerDirective: any = {\r\n                Id : this._id,\r\n                Visible: this.Visible,\r\n                LayerOffset: this.LayerOffset,\r\n                ZIndex: this.ZIndex\r\n            };\r\n            this._layerService.AddLayer(fakeLayerDirective);\r\n            this._layerPromise = this._layerService.GetNativeLayer(fakeLayerDirective);\r\n\r\n            Promise.all([\r\n                this._layerPromise,\r\n                this._mapService.CreateCanvasOverlay(el => this.DrawLabels(el))\r\n            ]).then(values => {\r\n                values[0].SetVisible(this.Visible);\r\n                this._canvas = values[1];\r\n                this._canvas._canvasReady.then(b => {\r\n                    this._tooltip = this._canvas.GetToolTipOverlay();\r\n                    this.ManageTooltip(this.ShowTooltips);\r\n                });\r\n                if (this.PolygonOptions) {\r\n                    this._zone.runOutsideAngular(() => this.UpdatePolygons());\r\n                }\r\n            });\r\n            this._service = this._layerService;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n        this._layerPromise.then(l => {\r\n            l.Delete();\r\n        });\r\n        if (this._canvas) { this._canvas.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (changes['PolygonOptions']) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this.UpdatePolygons();\r\n            });\r\n        }\r\n        if (changes['Visible'] && !changes['Visible'].firstChange) {\r\n            this._layerPromise.then(l => l.SetVisible(this.Visible));\r\n        }\r\n        if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||\r\n            (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)\r\n        ) {\r\n            throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));\r\n        }\r\n        if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||\r\n            (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||\r\n            (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)\r\n        ) {\r\n            if (this._canvas) {\r\n                this._canvas.Redraw(true);\r\n            }\r\n        }\r\n        if (changes['ShowTooltips'] && this._tooltip) {\r\n            this.ManageTooltip(changes['ShowTooltips'].currentValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Marker Id.\r\n     * @returns - string representation of the marker id.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public toString(): string { return 'MapPolygonLayer-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the marker.\r\n     *\r\n     * @param p - the polygon for which to add the event.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private AddEventListeners(p: Polygon): void {\r\n        const handlers = [\r\n            { name: 'click', handler: (ev: MouseEvent) => this.PolygonClick.emit({Polygon: p, Click: ev}) },\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.PolygonDblClick.emit({Polygon: p, Click: ev}) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.PolygonMouseMove.emit({Polygon: p, Click: ev}) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.PolygonMouseOut.emit({Polygon: p, Click: ev}) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.PolygonMouseOver.emit({Polygon: p, Click: ev}) }\r\n        ];\r\n        handlers.forEach((obj) => p.AddListener(obj.name, obj.handler));\r\n    }\r\n\r\n    /**\r\n     * Draws the polygon labels. Called by the Canvas overlay.\r\n     *\r\n     * @param el - The canvas on which to draw the labels.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private DrawLabels(el: HTMLCanvasElement): void {\r\n        if (this.ShowLabels) {\r\n            this._mapService.GetZoom().then(z => {\r\n                if (this.LabelMinZoom <= z && this.LabelMaxZoom >= z) {\r\n                    const ctx: CanvasRenderingContext2D = el.getContext('2d');\r\n                    const labels = this._labels.map(x => x.title);\r\n                    this._mapService.LocationsToPoints(this._labels.map(x => x.loc)).then(locs => {\r\n                        const size: ISize = this._mapService.MapSize;\r\n                        for (let i = 0, len = locs.length; i < len; i++) {\r\n                            // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.\r\n                            if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {\r\n                                this.DrawText(ctx, locs[i], labels[i]);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the label text at the appropriate place on the canvas.\r\n     * @param ctx - Canvas drawing context.\r\n     * @param loc - Pixel location on the canvas where to center the text.\r\n     * @param text - Text to draw.\r\n     */\r\n    private DrawText(ctx: CanvasRenderingContext2D, loc: IPoint, text: string) {\r\n        let lo: ILabelOptions = this.LabelOptions;\r\n        if (lo == null && this._tooltip) { lo = this._tooltip.DefaultLabelStyle; }\r\n        if (lo == null) { lo = this._defaultOptions; }\r\n\r\n        ctx.strokeStyle = lo.strokeColor;\r\n        ctx.font = `${lo.fontSize}px ${lo.fontFamily}`;\r\n        ctx.textAlign = 'center';\r\n        const strokeWeight: number = lo.strokeWeight;\r\n        if (text && strokeWeight && strokeWeight > 0) {\r\n                ctx.lineWidth = strokeWeight;\r\n                ctx.strokeText(text, loc.x, loc.y);\r\n        }\r\n        ctx.fillStyle = lo.fontColor;\r\n        ctx.fillText(text, loc.x, loc.y);\r\n    }\r\n\r\n    /**\r\n     * Manages the tooltip and the attachment of the associated events.\r\n     *\r\n     * @param show - True to enable the tooltip, false to disable.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private ManageTooltip(show: boolean): void {\r\n        if (show && this._canvas) {\r\n            // add tooltip subscriptions\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n            this._tooltipSubscriptions.push(this.PolygonMouseMove.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('position', loc);\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolygonMouseOver.asObservable().subscribe(e => {\r\n                if (e.Polygon.Title && e.Polygon.Title.length > 0) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('text', e.Polygon.Title);\r\n                    this._tooltip.Set('position', loc);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolygonMouseOut.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    this._tooltip.Set('hidden', true);\r\n                    this._tooltipVisible = false;\r\n                }\r\n            }));\r\n        }\r\n        else {\r\n            // remove tooltip subscriptions\r\n            this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n            this._tooltipSubscriptions.splice(0);\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets or updates the polygons based on the polygon options. This will place the polygons on the map\r\n     * and register the associated events.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     * @method\r\n     */\r\n    private UpdatePolygons(): void {\r\n        if (this._layerPromise == null) {\r\n            return;\r\n        }\r\n        this._layerPromise.then(l => {\r\n            const polygons: Array<IPolygonOptions> = this._streaming ? this._polygonsLast.splice(0) : this._polygons;\r\n            if (!this._streaming) { this._labels.splice(0); }\r\n\r\n            // generate the promise for the markers\r\n            const lp: Promise<Array<Polygon>> = this._service.CreatePolygons(l.GetOptions().id, polygons);\r\n\r\n            // set markers once promises are fullfilled.\r\n            lp.then(p => {\r\n                p.forEach(poly => {\r\n                    if (poly.Title != null && poly.Title.length > 0) { this._labels.push({loc: poly.Centroid, title: poly.Title}); }\r\n                    this.AddEventListeners(poly);\r\n                });\r\n                this._streaming ? l.AddEntities(p) : l.SetEntities(p);\r\n                if (this._canvas) { this._canvas.Redraw(!this._streaming); }\r\n            });\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef, NgZone,\r\n    SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolylineEvent } from '../interfaces/ipolyline-event';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { ILabelOptions } from '../interfaces/ilabel-options';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { MapService } from '../services/map.service';\r\nimport { Layer } from '../models/layer';\r\nimport { Polyline } from '../models/polyline';\r\nimport { MapLabel } from '../models/map-label';\r\nimport { CanvasOverlay } from '../models/canvas-overlay';\r\n\r\n/**\r\n * internal counter to use as ids for polylines.\r\n */\r\nlet layerId = 1000000;\r\n\r\n/**\r\n * MapPolylineLayerDirective performantly renders a large set of polyline on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polyline-layer [PolygonOptions]=\"_polyline\"></x-map-polyline-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polyline-layer'\r\n})\r\nexport class MapPolylineLayerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _id: number;\r\n    private _layerPromise: Promise<Layer>;\r\n    private _service: LayerService;\r\n    private _canvas: CanvasOverlay;\r\n    private _labels: Array<{loc: ILatLong, title: string}> = new Array<{loc: ILatLong, title: string}>();\r\n    private _tooltip: MapLabel;\r\n    private _tooltipSubscriptions: Array<Subscription> = new Array<Subscription>();\r\n    private _tooltipVisible: boolean = false;\r\n    private _defaultOptions: ILabelOptions = {\r\n        fontSize: 11,\r\n        fontFamily: 'sans-serif',\r\n        strokeWeight: 2,\r\n        strokeColor: '#000000',\r\n        fontColor: '#ffffff'\r\n    };\r\n    private _streaming: boolean = false;\r\n    private _polylines: Array<IPolylineOptions> = new Array<IPolylineOptions>();\r\n    private _polylinesLast: Array<IPolylineOptions> = new Array<IPolylineOptions>();\r\n\r\n    /**\r\n     * Set the maximum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LabelMaxZoom: number = Number.MAX_SAFE_INTEGER;\r\n\r\n    /**\r\n     * Set the minimum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LabelMinZoom: number = -1;\r\n\r\n    /**\r\n     * Sepcifies styleing options for on-map polyline labels.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LabelOptions: ILabelOptions;\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LayerOffset: IPoint = null;\r\n\r\n    /**\r\n     * An array of polyline options representing the polylines in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input()\r\n        public get PolylineOptions(): Array<IPolylineOptions> { return this._polylines; }\r\n        public set PolylineOptions(val: Array<IPolylineOptions>) {\r\n            if (this._streaming) {\r\n                this._polylinesLast.push(...val.slice(0));\r\n                this._polylines.push(...val);\r\n            }\r\n            else {\r\n                this._polylines = val.slice(0);\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Whether to show the polylines titles as the labels on the polylines.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public ShowLabels: boolean = false;\r\n\r\n    /**\r\n     * Whether to show the titles of the polylines as the tooltips on the polylines.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public ShowTooltips: boolean = true;\r\n\r\n    /**\r\n     * Sets whether to treat changes in the PolylineOptions as streams of new markers. In this mode, changing the\r\n     * Array supplied in PolylineOptions will be incrementally drawn on the map as opposed to replace the polylines on the map.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input()\r\n        public get TreatNewPolylineOptionsAsStream(): boolean { return this._streaming; }\r\n        public set TreatNewPolylineOptionsAsStream(val: boolean) { this._streaming = val; }\r\n\r\n    /**\r\n     * Sets the visibility of the marker layer\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public ZIndex: number = 0;\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() public PolylineClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineDblClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineMouseMove: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseout on a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineMouseOut: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseover on a polyline in a layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineMouseOver: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the id of the polyline layer.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolylineLayerDirective.\r\n     * @param _layerService - Concreate implementation of a {@link LayerService}.\r\n     * @param _mapService - Concreate implementation of a {@link MapService}.\r\n     * @param _zone - Concreate implementation of a {@link NgZone} service.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    constructor(\r\n        private _layerService: LayerService,\r\n        private _mapService: MapService,\r\n        private _zone: NgZone) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        const layerOptions: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        this._zone.runOutsideAngular(() => {\r\n            const fakeLayerDirective: any = {\r\n                Id : this._id,\r\n                Visible: this.Visible,\r\n                LayerOffset: this.LayerOffset,\r\n                ZIndex: this.ZIndex\r\n            };\r\n            this._layerService.AddLayer(fakeLayerDirective);\r\n            this._layerPromise = this._layerService.GetNativeLayer(fakeLayerDirective);\r\n\r\n            Promise.all([\r\n                    this._layerPromise,\r\n                    this._mapService.CreateCanvasOverlay(el => this.DrawLabels(el))\r\n                ]).then(values => {\r\n                    values[0].SetVisible(this.Visible);\r\n                    this._canvas = values[1];\r\n                    this._canvas._canvasReady.then(b => {\r\n                        this._tooltip = this._canvas.GetToolTipOverlay();\r\n                        this.ManageTooltip(this.ShowTooltips);\r\n                    });\r\n                    if (this.PolylineOptions) {\r\n                        this._zone.runOutsideAngular(() => this.UpdatePolylines());\r\n                    }\r\n                });\r\n            this._service = this._layerService;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n        this._layerPromise.then(l => {\r\n            l.Delete();\r\n        });\r\n        if (this._canvas) { this._canvas.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (changes['PolylineOptions']) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this.UpdatePolylines();\r\n            });\r\n        }\r\n        if (changes['Visible'] && !changes['Visible'].firstChange) {\r\n            this._layerPromise.then(l => l.SetVisible(this.Visible));\r\n        }\r\n        if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||\r\n            (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)\r\n        ) {\r\n            throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));\r\n        }\r\n        if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||\r\n            (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||\r\n            (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)\r\n        ) {\r\n            if (this._canvas) {\r\n                this._canvas.Redraw(true);\r\n            }\r\n        }\r\n        if (changes['ShowTooltips'] && this._tooltip) {\r\n            this.ManageTooltip(changes['ShowTooltips'].currentValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Layer Id.\r\n     * @returns - string representation of the layer id.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public toString(): string { return 'MapPolylineLayer-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the polylines.\r\n     *\r\n     * @param p - the polyline for which to add the event.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    private AddEventListeners(p: Polyline): void {\r\n        const handlers = [\r\n            { name: 'click', handler: (ev: MouseEvent) => this.PolylineClick.emit({Polyline: p, Click: ev}) },\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.PolylineDblClick.emit({Polyline: p, Click: ev}) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.PolylineMouseMove.emit({Polyline: p, Click: ev}) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.PolylineMouseOut.emit({Polyline: p, Click: ev}) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.PolylineMouseOver.emit({Polyline: p, Click: ev}) }\r\n        ];\r\n        handlers.forEach((obj) => p.AddListener(obj.name, obj.handler));\r\n    }\r\n\r\n    /**\r\n     * Draws the polyline labels. Called by the Canvas overlay.\r\n     *\r\n     * @param el - The canvas on which to draw the labels.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    private DrawLabels(el: HTMLCanvasElement): void {\r\n        if (this.ShowLabels) {\r\n            this._mapService.GetZoom().then(z => {\r\n                if (this.LabelMinZoom <= z && this.LabelMaxZoom >= z) {\r\n                    const ctx: CanvasRenderingContext2D = el.getContext('2d');\r\n                    const labels = this._labels.map(x => x.title);\r\n                    this._mapService.LocationsToPoints(this._labels.map(x => x.loc)).then(locs => {\r\n                        const size: ISize = this._mapService.MapSize;\r\n                        for (let i = 0, len = locs.length; i < len; i++) {\r\n                            // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.\r\n                            if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {\r\n                                this.DrawText(ctx, locs[i], labels[i]);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the label text at the appropriate place on the canvas.\r\n     * @param ctx - Canvas drawing context.\r\n     * @param loc - Pixel location on the canvas where to center the text.\r\n     * @param text - Text to draw.\r\n     */\r\n    private DrawText(ctx: CanvasRenderingContext2D, loc: IPoint, text: string) {\r\n        let lo: ILabelOptions = this.LabelOptions;\r\n        if (lo == null && this._tooltip) { lo = this._tooltip.DefaultLabelStyle; }\r\n        if (lo == null) { lo = this._defaultOptions; }\r\n\r\n        ctx.strokeStyle = lo.strokeColor;\r\n        ctx.font = `${lo.fontSize}px ${lo.fontFamily}`;\r\n        ctx.textAlign = 'center';\r\n        const strokeWeight: number = lo.strokeWeight;\r\n        if (text && strokeWeight && strokeWeight > 0) {\r\n                ctx.lineWidth = strokeWeight;\r\n                ctx.strokeText(text, loc.x, loc.y);\r\n        }\r\n        ctx.fillStyle = lo.fontColor;\r\n        ctx.fillText(text, loc.x, loc.y);\r\n    }\r\n\r\n    /**\r\n     * Manages the tooltip and the attachment of the associated events.\r\n     *\r\n     * @param show - True to enable the tooltip, false to disable.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private ManageTooltip(show: boolean): void {\r\n        if (show && this._canvas) {\r\n            // add tooltip subscriptions\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n            this._tooltipSubscriptions.push(this.PolylineMouseMove.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('position', loc);\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolylineMouseOver.asObservable().subscribe(e => {\r\n                if (e.Polyline.Title && e.Polyline.Title.length > 0) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('text', e.Polyline.Title);\r\n                    this._tooltip.Set('position', loc);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolylineMouseOut.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    this._tooltip.Set('hidden', true);\r\n                    this._tooltipVisible = false;\r\n                }\r\n            }));\r\n        }\r\n        else {\r\n            // remove tooltip subscriptions\r\n            this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n            this._tooltipSubscriptions.splice(0);\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets or updates the polyliness based on the polyline options. This will place the polylines on the map\r\n     * and register the associated events.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     * @method\r\n     */\r\n    private UpdatePolylines(): void {\r\n        if (this._layerPromise == null) {\r\n            return;\r\n        }\r\n        this._layerPromise.then(l => {\r\n            const polylines: Array<IPolylineOptions> = this._streaming ? this._polylinesLast.splice(0) : this._polylines;\r\n            if (!this._streaming) { this._labels.splice(0); }\r\n\r\n            // generate the promise for the polylines\r\n            const lp: Promise<Array<Polyline|Array<Polyline>>> = this._service.CreatePolylines(l.GetOptions().id, polylines);\r\n\r\n            // set polylines once promises are fullfilled.\r\n            lp.then(p => {\r\n                const y: Array<Polyline> = new Array<Polyline>();\r\n                p.forEach(poly => {\r\n                    if (Array.isArray(poly)) {\r\n                        let title: string = '';\r\n                        const centroids: Array<ILatLong> = new Array<ILatLong>();\r\n                        poly.forEach(x => {\r\n                            y.push(x);\r\n                            this.AddEventListeners(x);\r\n                            centroids.push(x.Centroid);\r\n                            if (x.Title != null && x.Title.length > 0 && title.length === 0) { title = x.Title; }\r\n                        });\r\n                        this._labels.push({loc: Polyline.GetPolylineCentroid(centroids), title: title});\r\n                    }\r\n                    else {\r\n                        y.push(poly);\r\n                        if (poly.Title != null && poly.Title.length > 0) { this._labels.push({loc: poly.Centroid, title: poly.Title}); }\r\n                        this.AddEventListeners(poly);\r\n                    }\r\n                });\r\n                this._streaming ? l.AddEntities(y) : l.SetEntities(y);\r\n                if (this._canvas) { this._canvas.Redraw(!this._streaming); }\r\n            });\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable } from '@angular/core';\r\n\r\n/**\r\n * Abstract implementation. USed for defintion only and as a base to implement your\r\n * own provider.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MapAPILoader {\r\n\r\n    /**\r\n     * Loads the necessary resources for a given map architecture.\r\n     *\r\n     * @abstract\r\n     * @returns - Promise fullfilled when the resources have been loaded.\r\n     *\r\n     * @memberof MapAPILoader\r\n     */\r\n    abstract Load(): Promise<void>;\r\n\r\n}\r\n\r\n/**\r\n * Document Reference service to assist with abstracting the availability of document. Needed for AOT and\r\n * Server Side rendering\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class DocumentRef {\r\n\r\n    /**\r\n     * Gets whether a document implementation is available. Generally will be true in the browser and false otherwise, unless there\r\n     * there is a browser-less implementation in the current non-browser environment.\r\n     *\r\n     * @readonly\r\n     * @memberof DocumentRef\r\n     */\r\n    public get IsAvailable(): boolean {\r\n        return !(typeof (document) === 'undefined');\r\n    }\r\n\r\n    /**\r\n     * Returns the document object of the current environment.\r\n     *\r\n     * @returns - The document object.\r\n     *\r\n     * @memberof DocumentRef\r\n     */\r\n    public GetNativeDocument(): any {\r\n        if (typeof (document) === 'undefined') {\r\n            return null;\r\n        }\r\n        return document;\r\n    }\r\n}\r\n\r\n/**\r\n * Window Reference service to assist with abstracting the availability of window. Needed for AOT and\r\n * Server Side rendering\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class WindowRef {\r\n\r\n    /**\r\n     * Gets whether a window implementation is available. Generally will be true in the browser and false otherwise, unless there\r\n     * there is a browser-less implementation in the current non-browser environment.\r\n     *\r\n     * @readonly\r\n     * @memberof WindowRef\r\n     */\r\n    public get IsAvailable(): boolean {\r\n        return !(typeof (window) === 'undefined');\r\n    }\r\n\r\n    /**\r\n     * Returns the window object of the current environment.\r\n     *\r\n     * @returns - The window object.\r\n     *\r\n     * @memberof WindowRef\r\n     */\r\n    public GetNativeWindow(): any {\r\n        if (typeof (window) === 'undefined') {\r\n            return null;\r\n        }\r\n        return window;\r\n    }\r\n}\r\n\r\n","import { Injectable, Optional } from '@angular/core';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\n\r\n/**\r\n * Protocol enumeration\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum ScriptProtocol {\r\n    HTTP,\r\n    HTTPS,\r\n    AUTO\r\n}\r\n\r\n/**\r\n * Bing Maps V8 specific loader configuration to be used with the {@link BingMapAPILoader}\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapAPILoaderConfig  {\r\n\r\n    ///\r\n    /// API key for bing maps\r\n    ///\r\n    apiKey = '';\r\n\r\n    ///\r\n    /// Host and Path used for the `<script>` tag.\r\n    ///\r\n    hostAndPath = 'www.bing.com/api/maps/mapcontrol';\r\n\r\n    ///\r\n    /// Protocol used for the `<script>` tag.\r\n    ///\r\n    protocol: ScriptProtocol = ScriptProtocol.HTTPS;\r\n\r\n    ///\r\n    /// The branch to be used. Leave empty for production. Use experimental\r\n    ///\r\n    branch = '';\r\n}\r\n\r\n/**\r\n * Default loader configuration.\r\n */\r\nconst DEFAULT_CONFIGURATION = new BingMapAPILoaderConfig();\r\n\r\n/**\r\n * Bing Maps V8 implementation for the {@link MapAPILoader} service.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapAPILoader extends MapAPILoader {\r\n\r\n    ///\r\n    /// Field defintitions.\r\n    ///\r\n    private _scriptLoadingPromise: Promise<void>;\r\n\r\n    ///\r\n    /// Property declarations.\r\n    ///\r\n\r\n    /**\r\n     * Gets the loader configuration.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    public get Config(): BingMapAPILoaderConfig { return this._config; }\r\n\r\n    /**\r\n     * Creates an instance of BingMapAPILoader.\r\n     * @param _config  - The loader configuration.\r\n     * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.\r\n     * @param _documentRef - An instance of {@link DocumentRef}.\r\n     * Necessary because Bing Map V8 interacts with the document object.\r\n     *\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    constructor( @Optional() private _config: BingMapAPILoaderConfig, private _windowRef: WindowRef, private _documentRef: DocumentRef) {\r\n        super();\r\n        if (this._config === null || this._config === undefined) {\r\n            this._config = DEFAULT_CONFIGURATION;\r\n        }\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapAPILoader implementation.\r\n    ///\r\n\r\n    /**\r\n     * Loads the necessary resources for Bing Maps V8.\r\n     *\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    public Load(): Promise<void> {\r\n        if (this._scriptLoadingPromise) {\r\n            return this._scriptLoadingPromise;\r\n        }\r\n\r\n        const script = this._documentRef.GetNativeDocument().createElement('script');\r\n        script.type = 'text/javascript';\r\n        script.async = true;\r\n        script.defer = true;\r\n        const callbackName = `angular2bingmaps${new Date().getMilliseconds()}`;\r\n        script.src = this.GetScriptSrc(callbackName);\r\n\r\n        this._scriptLoadingPromise = new Promise<void>((resolve: Function, reject: Function) => {\r\n            (<any>this._windowRef.GetNativeWindow())[callbackName] = () => {\r\n                resolve();\r\n            };\r\n            script.onerror = (error: Event) => { reject(error); };\r\n        });\r\n        this._documentRef.GetNativeDocument().head.appendChild(script);\r\n        return this._scriptLoadingPromise;\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the Bing Map V8 scripts url for injections into the header.\r\n     *\r\n     * @param callbackName - Name of the function to be called when the Bing Maps V8 scripts are loaded.\r\n     * @returns - The url to be used to load the Bing Map scripts.\r\n     *\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    private GetScriptSrc(callbackName: string): string {\r\n        const protocolType: ScriptProtocol = (this._config && this._config.protocol) || DEFAULT_CONFIGURATION.protocol;\r\n        let protocol: string;\r\n\r\n        switch (protocolType) {\r\n            case ScriptProtocol.AUTO:\r\n                protocol = '';\r\n                break;\r\n            case ScriptProtocol.HTTP:\r\n                protocol = 'http:';\r\n                break;\r\n            case ScriptProtocol.HTTPS:\r\n                protocol = 'https:';\r\n                break;\r\n        }\r\n\r\n        const hostAndPath: string = this._config.hostAndPath || DEFAULT_CONFIGURATION.hostAndPath;\r\n        const queryParams: { [key: string]: string } = {\r\n            callback: callbackName\r\n        };\r\n        if (this._config.branch !== '') {\r\n            queryParams['branch'] = this._config.branch;\r\n        }\r\n        const params: string = Object.keys(queryParams)\r\n            .map((k: string, i: number) => {\r\n                let param = (i === 0) ? '?' : '&';\r\n                return param += `${k}=${queryParams[k]}`;\r\n            })\r\n            .join('');\r\n        return `${protocol}//${hostAndPath}${params}`;\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { InfoBoxActionDirective } from '../../components/infobox-action';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { MapService } from '../../services/map.service';\r\nimport { InfoBoxComponent } from '../../components/infobox';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingInfoWindow } from '../../models/bing/bing-info-window';\r\nimport { BingMapEventsLookup } from '../../models/bing/bing-events-lookup';\r\n\r\n/**\r\n * Concrete implementation of the {@link InfoBoxService} contract for the Bing Maps V8 architecture.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingInfoBoxService implements InfoBoxService {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _boxes: Map<InfoBoxComponent, Promise<InfoWindow>> = new Map<InfoBoxComponent, Promise<InfoWindow>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingInfoBoxService.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.\r\n     * @param _zone - An instance of NgZone to provide zone aware promises.\r\n     *\r\n     * @memberof BingInfoBoxService\r\n     */\r\n    constructor(private _mapService: MapService, private _zone: NgZone) { }\r\n\r\n    /**\r\n     * Adds an info window to the map or layer.\r\n     *\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     *\r\n     * @memberof BingInfoBoxService\r\n     */\r\n    public AddInfoWindow(info: InfoBoxComponent): void {\r\n        const options: IInfoWindowOptions = {};\r\n        if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {\r\n            options.position = {\r\n                latitude: info.Latitude,\r\n                longitude: info.Longitude\r\n            };\r\n        }\r\n        if (typeof info.InfoWindowActions !== 'undefined' && info.InfoWindowActions.length > 0) {\r\n            options.actions = [];\r\n            info.InfoWindowActions.forEach((action: InfoBoxActionDirective) => {\r\n                options.actions.push({\r\n                    label: action.Label,\r\n                    eventHandler: () => { action.ActionClicked.emit(null); }\r\n                });\r\n            });\r\n        }\r\n        if (info.HtmlContent !== '') {\r\n            options.htmlContent = info.HtmlContent;\r\n        }\r\n        else {\r\n            options.title = info.Title;\r\n            options.description = info.Description;\r\n        }\r\n        if (info.xOffset || info.yOffset) {\r\n            if (options.pixelOffset == null) { options.pixelOffset = { x: 0, y: 0 }; }\r\n            if (info.xOffset) { options.pixelOffset.x = info.xOffset; }\r\n            if (info.yOffset) { options.pixelOffset.y = info.yOffset; }\r\n        }\r\n\r\n        options.visible = info.Visible;\r\n        const infoPromise = this._mapService.CreateInfoWindow(options);\r\n        this._boxes.set(info, infoPromise);\r\n    }\r\n\r\n    /**\r\n     * Closes an InfoBoxComponent that is open.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been closed.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public Close(info: InfoBoxComponent): Promise<void> {\r\n        return this._boxes.get(info).then((w) => w.Close());\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for an info window.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param infoComponent - The {@link InfoBoxComponent} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, infoComponent: InfoBoxComponent): Observable<T> {\r\n        const eventNameTranslated = BingMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._boxes.get(infoComponent).then((b: InfoWindow) => {\r\n                b.AddListener(eventNameTranslated, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes an infobox.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been deleted.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public DeleteInfoWindow(info: InfoBoxComponent): Promise<void> {\r\n        const w = this._boxes.get(info);\r\n        if (w == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return w.then((i: InfoWindow) => {\r\n            return this._zone.run(() => {\r\n                i.Close();\r\n                this._boxes.delete(info);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Opens an infobox that is closed.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been opened.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public Open(info: InfoBoxComponent, loc?: ILatLong): Promise<void> {\r\n        if (info.CloseInfoBoxesOnOpen || info.Modal) {\r\n            // close all open info boxes.\r\n            this._boxes.forEach((v: Promise<InfoWindow>, i: InfoBoxComponent) => {\r\n                if (info.Id !== i.Id) {\r\n                    v.then(w => {\r\n                        if (w.IsOpen) {\r\n                            w.Close();\r\n                            i.Close();\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        return this._boxes.get(info).then((w) => {\r\n            const options: IInfoWindowOptions = {};\r\n            if (info.HtmlContent !== '') {\r\n                options.htmlContent = info.HtmlContent;\r\n            }\r\n            else {\r\n                options.title = info.Title;\r\n                options.description = info.Description;\r\n            }\r\n            w.SetOptions(options);\r\n\r\n            if (info.Latitude && info.Longitude) {\r\n                w.SetPosition({ latitude: info.Latitude, longitude: info.Longitude });\r\n            }\r\n            else if (loc) {\r\n                ///\r\n                /// this situation is specifically used for cluster layers that use spidering.\r\n                ///\r\n                w.SetPosition(loc);\r\n            }\r\n            else if (info.HostMarker) {\r\n                w.SetPosition({ latitude: info.HostMarker.Latitude, longitude: info.HostMarker.Longitude });\r\n            }\r\n            w.Open();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the infobox options.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @param options - {@link IInfoWindowOptions} object containing the options to set. Options provided are\r\n     * merged with the existing options of the underlying infobox.\r\n     * @returns - A promise that is fullfilled when the infobox options have been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public SetOptions(info: InfoBoxComponent, options: IInfoWindowOptions): Promise<void> {\r\n        return this._boxes.get(info).then((i: InfoWindow) => i.SetOptions(options));\r\n    }\r\n\r\n    /**\r\n     * Set the position of the infobox based on the properties set on the InfoBox component.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox position has been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public SetPosition(info: InfoBoxComponent): Promise<void> {\r\n        return this._boxes.get(info).then((i: InfoWindow) => i.SetPosition({\r\n            latitude: info.Latitude,\r\n            longitude: info.Longitude\r\n        }));\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer, Subject } from 'rxjs';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { MapMarkerDirective } from '../../components/map-marker';\r\nimport { MarkerService } from '../../services/marker.service';\r\nimport { MapService } from '../../services/map.service';\r\nimport { LayerService } from '../../services/layer.service';\r\nimport { ClusterService } from '../../services/cluster.service';\r\nimport { Marker } from '../../models/marker';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * Concrete implementation of the MarkerService abstract class for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMarkerService implements MarkerService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _markers: Map<MapMarkerDirective, Promise<Marker>> = new Map<MapMarkerDirective, Promise<Marker>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMarkerService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link BingLayerService} implementation is expected.\r\n     * @param _clusterService - {@link ClusterService} instance.\r\n     * The concrete {@link BingClusterService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n                private _layerService: LayerService,\r\n                private _clusterService: ClusterService,\r\n                private _zone: NgZone) {\r\n    }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.\r\n     *\r\n     * @param marker - The {@link MapMarkerDirective} to be added.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public AddMarker(marker: MapMarkerDirective): void {\r\n        const o: IMarkerOptions = {\r\n            position: { latitude: marker.Latitude, longitude: marker.Longitude },\r\n            title: marker.Title,\r\n            label: marker.Label,\r\n            draggable: marker.Draggable,\r\n            icon: marker.IconUrl,\r\n            iconInfo: marker.IconInfo,\r\n            isFirst: marker.IsFirstInSet,\r\n            isLast: marker.IsLastInSet\r\n        };\r\n        if (marker.Width) { o.width = marker.Width; }\r\n        if (marker.Height) { o.height = marker.Height; }\r\n        if (marker.Anchor) { o.anchor = marker.Anchor; }\r\n        if (marker.Metadata) { o.metadata = marker.Metadata; }\r\n\r\n        // create marker via promise.\r\n        let markerPromise: Promise<Marker> = null;\r\n        if (marker.InClusterLayer) {\r\n            markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else if (marker.InCustomLayer) {\r\n            markerPromise = this._layerService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else {\r\n            markerPromise = this._mapService.CreateMarker(o);\r\n        }\r\n\r\n        this._markers.set(marker, markerPromise);\r\n        if (marker.IconInfo) {\r\n            markerPromise.then((m: Marker) => {\r\n                // update iconInfo to provide hook to do post icon creation activities and\r\n                // also re-anchor the marker\r\n                marker.DynamicMarkerCreated.emit(o.iconInfo);\r\n                const p: IPoint = {\r\n                    x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,\r\n                    y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,\r\n                };\r\n                m.SetAnchor(p);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for a marker.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param marker - The {@link MapMarker} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, marker: MapMarkerDirective): Observable<T> {\r\n        const b: Subject<T> = new Subject<T>();\r\n        if (eventName === 'mousemove') {\r\n            return b.asObservable();\r\n        }\r\n        if (eventName === 'rightclick') {\r\n            return b.asObservable();\r\n        }\r\n        ///\r\n        /// mousemove and rightclick are not supported by bing polygons.\r\n        ///\r\n\r\n\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._markers.get(marker).then((m: Marker) => {\r\n                m.AddListener(eventName, (e: T) => this._zone.run(() =>\r\n                    observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a marker.\r\n     *\r\n     * @param marker - {@link MapMarker} to be deleted.\r\n     * @returns - A promise fullfilled once the marker has been deleted.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public DeleteMarker(marker: MapMarkerDirective): Promise<void> {\r\n        const m = this._markers.get(marker);\r\n        let p: Promise<void> = Promise.resolve();\r\n        if (m != null) {\r\n            p = m.then((ma: Marker) => {\r\n                if (marker.InClusterLayer) {\r\n                    this._clusterService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n                }\r\n                if (marker.InCustomLayer) {\r\n                    this._layerService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n                }\r\n                return this._zone.run(() => {\r\n                    ma.DeleteMarker();\r\n                    this._markers.delete(marker);\r\n                });\r\n            });\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        if (!e) {\r\n            return null;\r\n        }\r\n        if (!e.primitive) {\r\n            return null;\r\n        }\r\n        if (!(e.primitive instanceof Microsoft.Maps.Pushpin)) {\r\n            return null;\r\n        }\r\n        const p: Microsoft.Maps.Pushpin = e.primitive;\r\n        const loc: Microsoft.Maps.Location = p.getLocation();\r\n        return { latitude: loc.latitude, longitude: loc.longitude };\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param marker - The {@link MapMarker} for which to obtain the marker model.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} implementation of the underlying platform.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public GetNativeMarker(marker: MapMarkerDirective): Promise<Marker> {\r\n        return this._markers.get(marker);\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker pixel location for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the pixels of the marker on the map canvas.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public GetPixelsFromClick(e: MouseEvent | any): IPoint {\r\n        const loc: ILatLong = this.GetCoordinatesFromClick(e);\r\n        if (loc == null) {\r\n            return null;\r\n        }\r\n        const l: Microsoft.Maps.Location = BingConversions.TranslateLocation(loc);\r\n        const p: Microsoft.Maps.Point = <Microsoft.Maps.Point>(<BingMapService>\r\n            this._mapService).MapInstance.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control);\r\n        if (p == null) { return null; }\r\n        return { x: p.x, y: p.y };\r\n    }\r\n\r\n    /**\r\n     * Converts a geo location to a pixel location relative to the map canvas.\r\n     *\r\n     * @param target - Either a {@link MapMarker} or a {@link ILatLong} for the basis of translation.\r\n     * @returns - A promise that when fullfilled contains a {@link IPoint}\r\n     * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public LocationToPoint(target: MapMarkerDirective | ILatLong): Promise<IPoint> {\r\n        if (target == null) {\r\n            return Promise.resolve(null);\r\n        }\r\n        if (target instanceof MapMarkerDirective) {\r\n            return this._markers.get(target).then((m: Marker) => {\r\n                const l: ILatLong = m.Location;\r\n                const p: Promise<IPoint> = this._mapService.LocationToPoint(l);\r\n                return p;\r\n            });\r\n        }\r\n        return this._mapService.LocationToPoint(target);\r\n    }\r\n\r\n    /**\r\n     * Updates the anchor position for the marker.\r\n     *\r\n     * @param - The {@link MapMarker} object for which to upate the anchor.\r\n     * Anchor information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the anchor position has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateAnchor(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            m.SetAnchor(marker.Anchor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates whether the marker is draggable.\r\n     *\r\n     * @param - The {@link MapMarker} object for which to upate dragability.\r\n     * Dragability information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the marker has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateDraggable(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetDraggable(marker.Draggable));\r\n    }\r\n\r\n    /**\r\n     * Updates the Icon on the marker.\r\n     *\r\n     * @param - The {@link MapMarker} object for which to upate the icon.\r\n     * Icon information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the icon information has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateIcon(marker: MapMarkerDirective): Promise<void> {\r\n        const payload = (m: Marker, icon: string, iconInfo: IMarkerIconInfo) => {\r\n            if (icon && icon !== '') {\r\n                m.SetIcon(icon);\r\n                marker.DynamicMarkerCreated.emit(iconInfo);\r\n            }\r\n        };\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            if (marker.IconInfo) {\r\n                const s = Marker.CreateMarker(marker.IconInfo);\r\n                if (typeof(s) === 'string') { return(payload(m, s, marker.IconInfo)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        return(payload(m, x.icon, x.iconInfo));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return(m.SetIcon(marker.IconUrl));\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the label on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the label.\r\n     * Label information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the label has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateLabel(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => { m.SetLabel(marker.Label); });\r\n    }\r\n\r\n    /**\r\n     * Updates the geo coordinates for the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the coordinates.\r\n     * Coordinate information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the position has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateMarkerPosition(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then(\r\n            (m: Marker) => m.SetPosition({\r\n                latitude: marker.Latitude,\r\n                longitude: marker.Longitude\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Updates the title on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateTitle(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetTitle(marker.Title));\r\n    }\r\n\r\n    /**\r\n     * Updates the visibility on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the visiblity.\r\n     * Visibility information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the visibility has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateVisible(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetVisible(marker.Visible));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observer, Observable } from 'rxjs';\r\n\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader } from '../mapapiloader';\r\nimport { BingMapAPILoader, BingMapAPILoaderConfig } from './bing-map.api-loader.service';\r\nimport { BingConversions } from './bing-conversions';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { BingLayer } from '../../models/bing/bing-layer';\r\nimport { BingClusterLayer } from '../../models/bing/bing-cluster-layer';\r\nimport { BingInfoWindow } from '../../models/bing/bing-info-window';\r\nimport { BingPolygon } from '../../models/bing/bing-polygon';\r\nimport { BingPolyline } from '../../models/bing/bing-polyline';\r\nimport { MixinMapLabelWithOverlayView } from '../../models/bing/bing-label';\r\nimport { MixinCanvasOverlay } from '../../models/bing/bing-canvas-overlay';\r\nimport { BingCanvasOverlay } from '../../models/bing/bing-canvas-overlay';\r\nimport { CanvasOverlay } from '../../models/canvas-overlay';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IMapOptions } from '../../interfaces/imap-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { ISize } from '../../interfaces/isize';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IBox } from '../../interfaces/ibox';\r\n\r\nimport { BingMapEventsLookup } from '../../models/bing/bing-events-lookup';\r\n\r\n/**\r\n * Concrete implementation of the MapService abstract implementing a Bin Map V8 provider\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapService implements MapService {\r\n    ///\r\n    /// Field Declarations\r\n    ///\r\n\r\n    private _map: Promise<Microsoft.Maps.Map>;\r\n    private _mapInstance: Microsoft.Maps.Map;\r\n    private _mapResolver: (value?: Microsoft.Maps.Map) => void;\r\n    private _config: BingMapAPILoaderConfig;\r\n    private _modules: Map<string, Object> = new Map<string, Object>();\r\n\r\n    ///\r\n    /// Property Definitions\r\n    ///\r\n\r\n    /**\r\n     * Gets an array of loaded Bong modules.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMapService\r\n     */\r\n    public get LoadedModules(): Map<string, Object> { return this._modules; }\r\n\r\n    /**\r\n     * Gets the Bing Map control instance underlying the implementation\r\n     *\r\n     * @readonly\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapInstance(): Microsoft.Maps.Map { return this._mapInstance; }\r\n\r\n    /**\r\n     * Gets a Promise for a Bing Map control instance underlying the implementation. Use this instead of {@link MapInstance} if you\r\n     * are not sure if and when the instance will be created.\r\n     * @readonly\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapPromise(): Promise<Microsoft.Maps.Map> { return this._map; }\r\n\r\n    /**\r\n     * Gets the maps physical size.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapSize(): ISize {\r\n        if (this.MapInstance) {\r\n            const s: ISize = { width: this.MapInstance.getWidth(), height: this.MapInstance.getHeight() };\r\n            return s;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMapService.\r\n     * @param _loader MapAPILoader instance implemented for Bing Maps. This instance will generally be injected.\r\n     * @param _zone NgZone object to enable zone aware promises. This will generally be injected.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) {\r\n        this._map = new Promise<Microsoft.Maps.Map>((resolve: () => void) => { this._mapResolver = resolve; });\r\n        this._config = (<BingMapAPILoader>this._loader).Config;\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapService interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Creates a canvas overlay layer to perform custom drawing over the map with out\r\n     * some of the overhead associated with going through the Map objects.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @returns - Promise of a {@link CanvasOverlay} object.\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateCanvasOverlay(drawCallback: (canvas: HTMLCanvasElement) => void): Promise<CanvasOverlay> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const overlay: BingCanvasOverlay = new BingCanvasOverlay(drawCallback);\r\n            map.layers.insert(overlay);\r\n            return overlay;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a Bing map cluster layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link IClusterOptions}.\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateClusterLayer(options: IClusterOptions): Promise<Layer> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const p: Promise<Layer> = new Promise<Layer>(resolve => {\r\n                this.LoadModule('Microsoft.Maps.Clustering', () => {\r\n                    const o: Microsoft.Maps.IClusterLayerOptions = BingConversions.TranslateClusterOptions(options);\r\n                    const layer: Microsoft.Maps.ClusterLayer = new Microsoft.Maps.ClusterLayer(new Array<Microsoft.Maps.Pushpin>(), o);\r\n                    let bl: BingClusterLayer;\r\n                    map.layers.insert(layer);\r\n                    bl = new BingClusterLayer(layer, this);\r\n                    bl.SetOptions(options);\r\n                    resolve(bl);\r\n                });\r\n            });\r\n            return p;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an information window for a map position\r\n     *\r\n     * @param [options] - Infowindow options. See {@link IInfoWindowOptions}\r\n     * @returns - Promise of a {@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateInfoWindow(options?: IInfoWindowOptions): Promise<InfoWindow> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            let loc: Microsoft.Maps.Location;\r\n            if (options.position == null) {\r\n                loc = map.getCenter();\r\n            } else {\r\n                loc = new Microsoft.Maps.Location(options.position.latitude, options.position.longitude);\r\n            }\r\n            const infoBox: Microsoft.Maps.Infobox = new Microsoft.Maps.Infobox(loc, BingConversions.TranslateInfoBoxOptions(options));\r\n            infoBox.setMap(map);\r\n            return new BingInfoWindow(infoBox);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link ILayerOptions}\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.Layer object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateLayer(options: ILayerOptions): Promise<Layer> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const layer: Microsoft.Maps.Layer = new Microsoft.Maps.Layer(options.id.toString());\r\n            map.layers.insert(layer);\r\n            return new BingLayer(layer, this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map instance\r\n     *\r\n     * @param el - HTML element to host the map.\r\n     * @param mapOptions - Map options\r\n     * @returns - Promise fullfilled once the map has been created.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateMap(el: HTMLElement, mapOptions: IMapOptions): Promise<void> {\r\n        return this._loader.Load().then(() => {\r\n            // apply mixins\r\n            MixinMapLabelWithOverlayView();\r\n            MixinCanvasOverlay();\r\n\r\n            // map startup...\r\n            if (this._mapInstance != null) {\r\n                this.DisposeMap();\r\n            }\r\n            const o: Microsoft.Maps.IMapLoadOptions = BingConversions.TranslateLoadOptions(mapOptions);\r\n            if (!o.credentials) {\r\n                o.credentials = this._config.apiKey;\r\n            }\r\n            const map = new Microsoft.Maps.Map(el, o);\r\n            this._mapInstance = map;\r\n            this._mapResolver(map);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a Bing map marker within the map context\r\n     *\r\n     * @param [options=<IMarkerOptions>{}] - Options for the marker. See {@link IMarkerOptions}.\r\n     * @returns - Promise of a {@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateMarker(options: IMarkerOptions = <IMarkerOptions>{}): Promise<Marker> {\r\n        const payload = (icon: string, map: Microsoft.Maps.Map): BingMarker => {\r\n            const loc: Microsoft.Maps.Location = BingConversions.TranslateLocation(options.position);\r\n            const o: Microsoft.Maps.IPushpinOptions = BingConversions.TranslateMarkerOptions(options);\r\n            if (icon && icon !== '') { o.icon = icon; }\r\n            const pushpin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc, o);\r\n            const marker: BingMarker = new BingMarker(pushpin, map, null);\r\n            if (options.metadata) { options.metadata.forEach((v, k) => marker.Metadata.set(k, v)); }\r\n            map.entities.push(pushpin);\r\n            return marker;\r\n        };\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof (s) === 'string') { return (payload(s, map)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        return (payload(x.icon, map));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return (payload(null, map));\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon within the Bing Maps V8 map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polygon. See {@link IPolygonOptions}.\r\n     * @returns - Promise of a {@link Polygon} object, which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolygon(options: IPolygonOptions): Promise<Polygon> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.paths);\r\n            const o: Microsoft.Maps.IPolygonOptions = BingConversions.TranslatePolygonOptions(options);\r\n            const poly: Microsoft.Maps.Polygon = new Microsoft.Maps.Polygon(locs, o);\r\n            map.entities.push(poly);\r\n\r\n            const p = new BingPolygon(poly, this, null);\r\n            if (options.metadata) { options.metadata.forEach((v, k) => p.Metadata.set(k, v)); }\r\n            if (options.title && options.title !== '') { p.Title = options.title; }\r\n            if (options.showLabel != null) { p.ShowLabel = options.showLabel; }\r\n            if (options.showTooltip != null) { p.ShowTooltip = options.showTooltip; }\r\n            if (options.labelMaxZoom != null) { p.LabelMaxZoom = options.labelMaxZoom; }\r\n            if (options.labelMinZoom != null) { p.LabelMinZoom = options.labelMinZoom; }\r\n            if (options.editable) { p.SetEditable(options.editable); }\r\n            return p;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polyline within the Bing Maps V8 map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polyline. See {@link IPolylineOptions}.\r\n     * @returns - Promise of a {@link Polyline} object (or an array thereof for complex paths),\r\n     * which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolyline(options: IPolylineOptions): Promise<Polyline | Array<Polyline>> {\r\n        let polyline: Microsoft.Maps.Polyline;\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(options);\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.path);\r\n            if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {\r\n                polyline = new Microsoft.Maps.Polyline(locs[0], o);\r\n                map.entities.push(polyline);\r\n\r\n                const pl = new BingPolyline(polyline, map, null);\r\n                if (options.metadata) { options.metadata.forEach((v, k) => pl.Metadata.set(k, v)); }\r\n                if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                return pl;\r\n            }\r\n            else {\r\n                const lines: Array<Polyline> = new Array<Polyline>();\r\n                locs.forEach(p => {\r\n                    polyline = new Microsoft.Maps.Polyline(p, o);\r\n                    map.entities.push(polyline);\r\n\r\n                    const pl = new BingPolyline(polyline, map, null);\r\n                    if (options.metadata) { options.metadata.forEach((v, k) => pl.Metadata.set(k, v)); }\r\n                    if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                    if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                    lines.push(pl);\r\n                });\r\n                return lines;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a layer from the map.\r\n     *\r\n     * @param layer - Layer to delete. See {@link Layer}. This method expects the Bing specific Layer model implementation.\r\n     * @returns - Promise fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public DeleteLayer(layer: Layer): Promise<void> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            map.layers.remove(layer.NativePrimitve);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispaose the map and associated resoures.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public DisposeMap(): void {\r\n        if (this._map == null && this._mapInstance == null) {\r\n            return;\r\n        }\r\n        if (this._mapInstance != null) {\r\n            this._mapInstance.dispose();\r\n            this._mapInstance = null;\r\n            this._map = new Promise<Microsoft.Maps.Map>((resolve: () => void) => { this._mapResolver = resolve; });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map center\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the center. See {@link ILatLong}.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public GetCenter(): Promise<ILatLong> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const center = map.getCenter();\r\n            return <ILatLong>{\r\n                latitude: center.latitude,\r\n                longitude: center.longitude\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map bounding box\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the bounding box. See {@link IBox}.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public GetBounds(): Promise<IBox> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const box = map.getBounds();\r\n            return <IBox>{\r\n                maxLatitude: box.getNorth(),\r\n                maxLongitude: box.crossesInternationalDateLine() ? box.getWest() : box.getEast(),\r\n                minLatitude: box.getSouth(),\r\n                minLongitude: box.crossesInternationalDateLine() ? box.getEast() : box.getWest(),\r\n                center: { latitude: box.center.latitude, longitude: box.center.longitude },\r\n                padding: 0\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a shared or private instance of the map drawing tools.\r\n     *\r\n     * @param [useSharedInstance=true] - Set to false to create a private instance.\r\n     * @returns - Promise that when resolved containst an instance of the drawing tools.\r\n     * @memberof BingMapService\r\n     */\r\n    public GetDrawingTools (useSharedInstance: boolean = true): Promise<Microsoft.Maps.DrawingTools> {\r\n        return new Promise<Microsoft.Maps.DrawingTools>((resolve, reject) => {\r\n            this.LoadModuleInstance('Microsoft.Maps.DrawingTools', useSharedInstance).then((o: Microsoft.Maps.DrawingTools) => {\r\n                resolve(o);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current zoom level of the map.\r\n     *\r\n     * @returns - A promise that when fullfilled contains the zoom level.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public GetZoom(): Promise<number> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => map.getZoom());\r\n    }\r\n\r\n    /**\r\n     * Loads a module into the Map.\r\n     *\r\n     * @param moduleName - The module to load.\r\n     * @param callback - Callback to call once loading is complete.\r\n     * @method\r\n     * @memberof BingMapService\r\n     */\r\n    public LoadModule(moduleName: string, callback: () => void) {\r\n        if (this._modules.has(moduleName)) {\r\n            callback();\r\n        }\r\n        else {\r\n            Microsoft.Maps.loadModule(moduleName, () => {\r\n                this._modules.set(moduleName, null);\r\n                callback();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a module into the Map and delivers and instance of the module payload.\r\n     *\r\n     * @param moduleName - The module to load.\r\n     * @param useSharedInstance- Use a shared instance if true, create a new instance if false.\r\n     * @method\r\n     * @memberof BingMapService\r\n     */\r\n    public LoadModuleInstance(moduleName: string, useSharedInstance: boolean = true): Promise<Object> {\r\n        const s: string = moduleName.substr(moduleName.lastIndexOf('.') + 1);\r\n        if (this._modules.has(moduleName)) {\r\n            let o: any = null;\r\n            if (!useSharedInstance)  {\r\n                o = new (<any>Microsoft.Maps)[s](this._mapInstance);\r\n            }\r\n            else if (this._modules.get(moduleName) != null) {\r\n                o = this._modules.get(moduleName);\r\n            }\r\n            else {\r\n                o = new (<any>Microsoft.Maps)[s](this._mapInstance);\r\n                this._modules.set(moduleName, o);\r\n            }\r\n            return Promise.resolve(o);\r\n        }\r\n        else {\r\n            return new Promise<Object>((resolve, reject) => {\r\n                try {\r\n                Microsoft.Maps.loadModule(moduleName, () => {\r\n                    const o = new (<any>Microsoft.Maps)[s](this._mapInstance);\r\n                    if (useSharedInstance) {\r\n                        this._modules.set(moduleName, o);\r\n                    }\r\n                    else {\r\n                        this._modules.set(moduleName, null);\r\n                    }\r\n                    resolve(o);\r\n                });\r\n                } catch (e) {\r\n                    reject('Could not load module or create instance.');\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface representing the pixels. This promise resolves to null\r\n     * if the goe coordinates are not in the view port.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public LocationToPoint(loc: ILatLong): Promise<IPoint> {\r\n        return this._map.then((m: Microsoft.Maps.Map) => {\r\n            const l: Microsoft.Maps.Location = BingConversions.TranslateLocation(loc);\r\n            const p: Microsoft.Maps.Point = <Microsoft.Maps.Point>m.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control);\r\n            if (p != null) {\r\n                return { x: p.x, y: p.y };\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface array representing the pixels.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public LocationsToPoints(locs: Array<ILatLong>): Promise<Array<IPoint>> {\r\n        return this._map.then((m: Microsoft.Maps.Map) => {\r\n            const l = locs.map(loc => BingConversions.TranslateLocation(loc));\r\n            const p: Array<Microsoft.Maps.Point> = <Array<Microsoft.Maps.Point>>m.tryLocationToPixel(l,\r\n                Microsoft.Maps.PixelReference.control);\r\n            return p ? p : new Array<IPoint>();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Centers the map on a geo location.\r\n     *\r\n     * @param latLng - GeoCoordinates around which to center the map. See {@link ILatLong}\r\n     * @returns - Promise that is fullfilled when the center operations has been completed.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetCenter(latLng: ILatLong): Promise<void> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => map.setView({\r\n            center: BingConversions.TranslateLocation(latLng)\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Sets the generic map options.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetMapOptions(options: IMapOptions) {\r\n        this._map.then((m: Microsoft.Maps.Map) => {\r\n            const o: Microsoft.Maps.IMapOptions = BingConversions.TranslateOptions(options);\r\n            m.setOptions(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the view options of the map.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetViewOptions(options: IMapOptions) {\r\n        this._map.then((m: Microsoft.Maps.Map) => {\r\n            const o: Microsoft.Maps.IViewOptions = BingConversions.TranslateViewOptions(options);\r\n            m.setView(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the zoom level of the map.\r\n     *\r\n     * @param zoom - Zoom level to set.\r\n     * @returns - A Promise that is fullfilled once the zoom operation is complete.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetZoom(zoom: number): Promise<void> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => map.setView({\r\n            zoom: zoom\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Creates an event subscription\r\n     *\r\n     * @param eventName - The name of the event (e.g. 'click')\r\n     * @returns - An observable of tpye E that fires when the event occurs.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SubscribeToMapEvent<E>(eventName: string): Observable<E> {\r\n        const eventNameTranslated = BingMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<E>) => {\r\n            this._map.then((m: Microsoft.Maps.Map) => {\r\n                Microsoft.Maps.Events.addHandler(m, eventNameTranslated, (e: any) => {\r\n                    this._zone.run(() => observer.next(e));\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Triggers the given event name on the map instance.\r\n     *\r\n     * @param eventName - Event to trigger.\r\n     * @returns - A promise that is fullfilled once the event is triggered.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public TriggerMapEvent(eventName: string): Promise<void> {\r\n        return this._map.then((m) => Microsoft.Maps.Events.invoke(m, eventName, null));\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { MapService } from '../map.service';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * This abstract partially implements the contract for the {@link LayerService}\r\n * and {@link ClusterService} for the Bing Maps V8 archtiecture. It serves\r\n * as the base class for basic layer ({@link BingLayerService}) and cluster layer ({@link BingClusterLayer}).\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class BingLayerBase {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    protected _layers: Map<number, Promise<Layer>> = new Map<number, Promise<Layer>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingLayerBase.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    constructor(protected _mapService: MapService, protected _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public abstract AddLayer(layer: MapLayerDirective): void;\r\n\r\n    /**\r\n     * Creates a marker in the layer.\r\n     *\r\n     * @param layer - The Id of the layer in which to create the marker.\r\n     * @param options - {@link IMarkerOptions} object containing the marker properties.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} model for the created marker.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker> {\r\n        const payload = (icon: string, l: Layer): BingMarker => {\r\n            const loc: Microsoft.Maps.Location = BingConversions.TranslateLocation(options.position);\r\n            const o: Microsoft.Maps.IPushpinOptions = BingConversions.TranslateMarkerOptions(options);\r\n            if (icon && icon !== '') { o.icon = icon; }\r\n            const pushpin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc, o);\r\n            const marker: BingMarker = new BingMarker(pushpin, null, l.NativePrimitve);\r\n            marker.IsFirst = options.isFirst;\r\n            marker.IsLast = options.isLast;\r\n            if (options.metadata) { options.metadata.forEach((v, k) => marker.Metadata.set(k, v)); }\r\n            l.AddEntity(marker);\r\n            return marker;\r\n        };\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof(s) === 'string') { return(payload(s, l)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        return(payload(x.icon, l));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return (payload(null, l));\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param options - Marker options defining the markers.\r\n     * @param markerIcon - Optional information to generate custom markers. This will be applied to all markers.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Marker models.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public CreateMarkers(options: Array<IMarkerOptions>, markerIcon?: IMarkerIconInfo): Promise<Array<Marker>> {\r\n        const payload = (icon: string, op: Array<IMarkerOptions>): Array<BingMarker> => {\r\n            const markers: Array<BingMarker> = op.map(mo => {\r\n                let s: string;\r\n                const o: Microsoft.Maps.IPushpinOptions = BingConversions.TranslateMarkerOptions(mo);\r\n                if (icon && icon !== '' ) { s = icon; }\r\n                else if (o.icon) {\r\n                    s = o.icon;\r\n                }\r\n                if (o.icon) { delete o.icon; }\r\n                const loc: Microsoft.Maps.Location = BingConversions.TranslateLocation(mo.position);\r\n                const pushpin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc, o);\r\n                const img = Marker.GetImageForMarker(s);\r\n                if (img != null) { (<any>pushpin).image = img; }\r\n\r\n                const marker: BingMarker = new BingMarker(pushpin, null, null);\r\n                marker.IsFirst = mo.isFirst;\r\n                marker.IsLast = mo.isLast;\r\n                if (mo.metadata) { mo.metadata.forEach((v, k) => marker.Metadata.set(k, v)); }\r\n                return marker;\r\n            });\r\n            return markers;\r\n        };\r\n        const p: Promise<Array<Marker>> = new Promise<Array<Marker>>((resolve, reject) => {\r\n            if (markerIcon && markerIcon.markerType) {\r\n                const s = Marker.CreateMarker(markerIcon);\r\n                if (typeof(s) === 'string') { resolve(payload(s, options)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        resolve(payload(x.icon, options));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                resolve(payload(null, options));\r\n            }\r\n        });\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Deletes the layer\r\n     *\r\n     * @param layer - MapLayerDirective component object for which to retrieve the layer.\r\n     * @returns - A promise that is fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public DeleteLayer(layer: MapLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: Layer) => {\r\n            return this._zone.run(() => {\r\n                l1.Delete();\r\n                this._layers.delete(layer.Id);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the Layer model represented by this layer.\r\n     *\r\n     * @param layer - MapLayerDirective component object or Layer Id for which to retrieve the layer model.\r\n     * @returns - A promise that when resolved contains the Layer model.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public GetNativeLayer(layer: MapLayerDirective|number): Promise<Layer> {\r\n        let p: Promise<Layer> = null;\r\n        if (typeof(layer) === 'number') {\r\n            p = this._layers.get(layer);\r\n        }\r\n        else {\r\n            p = this._layers.get((<MapLayerDirective>layer).Id);\r\n        }\r\n        return p;\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the layer based on its id.\r\n     *\r\n     * @protected\r\n     * @param id - Layer Id.\r\n     * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    protected GetLayerById(id: number): Promise<Layer> {\r\n        let p: Promise<Layer>;\r\n        this._layers.forEach((l: Promise<Layer>, k: number) => { if (k === id) { p = l; } });\r\n        return p;\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { BingPolygon } from '../../models/bing/bing-polygon';\r\nimport { BingPolyline } from '../../models/bing/bing-polyline';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { MapService } from '../map.service';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingLayerBase } from './bing-layer-base';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * Implements the {@link LayerService} contract for a  Bing Maps V8 specific implementation.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingLayerService extends BingLayerBase implements LayerService {\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingLayerService.\r\n     * @param _mapService - Instance of the Bing Maps Service. Will generally be injected.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public AddLayer(layer: MapLayerDirective): void {\r\n        const layerPromise = this._mapService.CreateLayer({ id: layer.Id });\r\n        this._layers.set(layer.Id, layerPromise);\r\n        layerPromise.then(l => l.SetVisible(layer.Visible));\r\n    }\r\n\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.paths);\r\n            const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolygonOptions(options);\r\n            const poly: Microsoft.Maps.Polygon = new Microsoft.Maps.Polygon(locs, o);\r\n            const polygon: Polygon = new BingPolygon(poly, <BingMapService>this._mapService, l.NativePrimitve);\r\n\r\n            if (options.metadata) { options.metadata.forEach((v, k) => polygon.Metadata.set(k, v)); }\r\n            if (options.title && options.title !== '') {polygon.Title = options.title; }\r\n            if (options.showLabel != null) { polygon.ShowLabel = options.showLabel; }\r\n            if (options.showTooltip != null) { polygon.ShowTooltip = options.showTooltip; }\r\n            if (options.labelMaxZoom != null) { polygon.LabelMaxZoom = options.labelMaxZoom; }\r\n            if (options.labelMinZoom != null) { polygon.LabelMinZoom = options.labelMinZoom; }\r\n            l.AddEntity(polygon);\r\n            return polygon;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polygons: Promise<Array<Polygon>> = new Promise<Array<Polygon>>((resolve, reject) => {\r\n                const polys: Array<BingPolygon> = options.map(o => {\r\n                    const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(o.paths);\r\n                    const op: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolygonOptions(o);\r\n                    const poly: Microsoft.Maps.Polygon = new Microsoft.Maps.Polygon(locs, op);\r\n                    const polygon: BingPolygon = new BingPolygon(poly, <BingMapService>this._mapService, l.NativePrimitve);\r\n                    if (o.title && o.title !== '') { polygon.Title = o.title; }\r\n                    if (o.metadata) { o.metadata.forEach((v, k) => polygon.Metadata.set(k, v)); }\r\n                    return polygon;\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polygons;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an array\r\n     * of polygons for complex paths) model.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        let polyline: Microsoft.Maps.Polyline;\r\n        let line: Polyline;\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.path);\r\n            const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(options);\r\n            if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {\r\n                polyline = new Microsoft.Maps.Polyline(locs[0], o);\r\n                line = new BingPolyline(polyline, this._mapService.MapInstance, l.NativePrimitve);\r\n                l.AddEntity(line);\r\n\r\n                if (options.metadata) { options.metadata.forEach((v, k) => line.Metadata.set(k, v)); }\r\n                if (options.title && options.title !== '') {line.Title = options.title; }\r\n                if (options.showTooltip != null) { line.ShowTooltip = options.showTooltip; }\r\n                return line;\r\n            }\r\n            else {\r\n                const lines: Array<Polyline> = new Array<Polyline>();\r\n                locs.forEach(x => {\r\n                    polyline = new Microsoft.Maps.Polyline(x, o);\r\n                    line = new BingPolyline(polyline, this._mapService.MapInstance, l.NativePrimitve);\r\n                    l.AddEntity(line);\r\n\r\n                    if (options.metadata) { options.metadata.forEach((v, k) => line.Metadata.set(k, v)); }\r\n                    if (options.title && options.title !== '') {line.Title = options.title; }\r\n                    if (options.showTooltip != null) { line.ShowTooltip = options.showTooltip; }\r\n                    lines.push(line);\r\n                });\r\n                return lines;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polylines: Promise<Array<Polyline|Array<Polyline>>> = new Promise<Array<Polyline|Array<Polyline>>>((resolve, reject) => {\r\n                const polys: Array<Polyline|Array<Polyline>> = options.map(o => {\r\n                    const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(o.path);\r\n                    const op: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(o);\r\n                    if (locs && locs.length > 0 && !Array.isArray(locs[0])) {\r\n                        const poly: Microsoft.Maps.Polyline = new Microsoft.Maps.Polyline(locs[0], op);\r\n                        const polyline: BingPolyline = new BingPolyline(poly, this._mapService.MapInstance, l.NativePrimitve);\r\n                        if (o.title && o.title !== '') { polyline.Title = o.title; }\r\n                        if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                        return polyline;\r\n                    }\r\n                    else {\r\n                        const lines: Array<Polyline> = new Array<Polyline>();\r\n                        locs.forEach(x => {\r\n                            const poly = new Microsoft.Maps.Polyline(x, op);\r\n                            const polyline: BingPolyline = new BingPolyline(poly, this._mapService.MapInstance, l.NativePrimitve);\r\n                            if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                            if (o.title && o.title !== '') {polyline.Title = o.title; }\r\n                            lines.push(polyline);\r\n                        });\r\n                        return lines;\r\n                    }\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polylines;\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { BingClusterLayer } from '../../models/bing/bing-cluster-layer';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { ClusterClickAction } from '../../models/cluster-click-action';\r\nimport { MapService } from '../map.service';\r\nimport { ClusterLayerDirective } from '../../components/cluster-layer';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { BingLayerBase } from './bing-layer-base';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * Implements the {@link ClusterService} contract for a  Bing Maps V8 specific implementation.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingClusterService extends BingLayerBase implements ClusterService {\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingClusterService.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - ClusterLayerDirective component object.\r\n     * Generally, MapLayer will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public AddLayer(layer: ClusterLayerDirective): void {\r\n        const options: IClusterOptions = {\r\n            id: layer.Id,\r\n            visible: layer.Visible,\r\n            clusteringEnabled: layer.ClusteringEnabled,\r\n            placementMode: layer.ClusterPlacementMode\r\n        };\r\n        if (layer.GridSize) { options.gridSize = layer.GridSize; }\r\n        if (layer.LayerOffset) { options.layerOffset = layer.LayerOffset; }\r\n        if (layer.ZIndex) { options.zIndex = layer.ZIndex; }\r\n        if (layer.IconInfo) {\r\n            options.clusteredPinCallback = (pin: Microsoft.Maps.ClusterPushpin) => { this.CreateClusterPushPin(pin, layer); };\r\n        }\r\n        if (layer.CustomMarkerCallback) {\r\n            options.clusteredPinCallback = (pin: Microsoft.Maps.ClusterPushpin) => { this.CreateCustomClusterPushPin(pin, layer); };\r\n        }\r\n        if (layer.SpiderClusterOptions) { options.spiderClusterOptions = layer.SpiderClusterOptions; }\r\n\r\n        const layerPromise: Promise<Layer> = this._mapService.CreateClusterLayer(options);\r\n        (<BingMapService>this._mapService).MapPromise.then(m => {\r\n            Microsoft.Maps.Events.addHandler(m, 'viewchangeend', (e) => {\r\n                if (layer.ClusteringEnabled && m.getZoom() === 19) {\r\n                    layerPromise.then((l: BingClusterLayer) => {\r\n                        l.SetOptions({ id: layer.Id, clusteringEnabled: false });\r\n                    });\r\n                }\r\n                if (layer.ClusteringEnabled && m.getZoom() < 19) {\r\n                    layerPromise.then((l: BingClusterLayer) => {\r\n                        if (!l.GetOptions().clusteringEnabled) {\r\n                            l.SetOptions({ id: layer.Id, clusteringEnabled: true });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n        this._layers.set(layer.Id, layerPromise);\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an array\r\n     * of polygons for complex paths) model.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public StartClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: BingClusterLayer) => {\r\n            return this._zone.run(() => {\r\n                l1.StartClustering();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public StopClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: BingClusterLayer) => {\r\n            return this._zone.run(() => {\r\n                l1.StopClustering();\r\n            });\r\n        });\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Creates the default cluster pushpin as a callback from BingMaps when clustering occurs. The {@link ClusterLayerDirective} model\r\n     * can provide an IconInfo property that would govern the apparenace of the pin. This method will assign the same pin to all\r\n     * clusters in the layer.\r\n     *\r\n     * @param cluster - The cluster for which to create the pushpin.\r\n     * @param layer - The {@link ClusterLayerDirective} component representing the layer.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    private CreateClusterPushPin(cluster: Microsoft.Maps.ClusterPushpin, layer: ClusterLayerDirective): void {\r\n        this._layers.get(layer.Id).then((l: BingClusterLayer) => {\r\n            if (layer.IconInfo) {\r\n                const o: Microsoft.Maps.IPushpinOptions = {};\r\n                const payload: (ico: string, info: IMarkerIconInfo) => void = (ico, info) => {\r\n                        o.icon = ico;\r\n                        o.anchor = new Microsoft.Maps.Point(\r\n                            (info.size && info.markerOffsetRatio) ? (info.size.width * info.markerOffsetRatio.x) : 0,\r\n                            (info.size && info.markerOffsetRatio) ? (info.size.height * info.markerOffsetRatio.y) : 0\r\n                        );\r\n                        cluster.setOptions(o);\r\n                };\r\n                const icon: string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> = Marker.CreateMarker(layer.IconInfo);\r\n                if (typeof(icon) === 'string') {\r\n                    payload(icon, layer.IconInfo);\r\n                }\r\n                else {\r\n                    icon.then(x => {\r\n                        payload(x.icon, x.iconInfo);\r\n                    });\r\n                }\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'click', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.Spider) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'dblclick', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n                l.InitializeSpiderClusterSupport();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Provides a hook for consumers to provide a custom function to create cluster bins for a cluster. This is particuarily useful\r\n     * in situation where the pin should differ to represent information about the pins in the cluster.\r\n     *\r\n     * @param cluster - The cluster for which to create the pushpin.\r\n     * @param layer - The {@link ClusterLayerDirective} component\r\n     * representing the layer. Set the {@link ClusterLayerDirective.CustomMarkerCallback}\r\n     * property to define the callback generating the pin.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    private CreateCustomClusterPushPin(cluster: Microsoft.Maps.ClusterPushpin, layer: ClusterLayerDirective): void {\r\n        this._layers.get(layer.Id).then((l: BingClusterLayer) => {\r\n            // assemble markers for callback\r\n            const m: Array<Marker> = new Array<Marker>();\r\n            cluster.containedPushpins.forEach(p => {\r\n                const marker: Marker = l.GetMarkerFromBingMarker(p);\r\n                if (marker) { m.push(marker); }\r\n            });\r\n            const iconInfo: IMarkerIconInfo = { markerType: MarkerTypeId.None };\r\n            const o: Microsoft.Maps.IPushpinOptions = {};\r\n            o.icon = layer.CustomMarkerCallback(m, iconInfo);\r\n            if (o.icon !== '') {\r\n                o.anchor = new Microsoft.Maps.Point(\r\n                    (iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.width * iconInfo.markerOffsetRatio.x) : 0,\r\n                    (iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.height * iconInfo.markerOffsetRatio.y) : 0\r\n                );\r\n                if (iconInfo.textOffset) { o.textOffset = new Microsoft.Maps.Point(iconInfo.textOffset.x, iconInfo.textOffset.y); }\r\n                cluster.setOptions(o);\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'click', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.Spider) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'dblclick', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n                l.InitializeSpiderClusterSupport();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Zooms into the cluster on click so that the members of the cluster comfortable fit into the zommed area.\r\n     *\r\n     * @param e - Mouse Event.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    private ZoomIntoCluster(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        const pin: Microsoft.Maps.ClusterPushpin = <Microsoft.Maps.ClusterPushpin>e.target;\r\n        if (pin && pin.containedPushpins) {\r\n            let bounds: Microsoft.Maps.LocationRect;\r\n            const locs: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n            pin.containedPushpins.forEach(p => locs.push(p.getLocation()));\r\n            bounds = Microsoft.Maps.LocationRect.fromLocations(locs);\r\n\r\n            // Zoom into the bounding box of the cluster.\r\n            // Add a padding to compensate for the pixel area of the pushpins.\r\n            (<BingMapService>this._mapService).MapPromise.then((m: Microsoft.Maps.Map) => {\r\n                m.setView({ bounds: bounds, padding: 75 });\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer, Subject } from 'rxjs';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { MapPolygonDirective } from '../../components/map-polygon';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n\r\n/**\r\n * Concrete implementation of the Polygon Service abstract class for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingPolygonService implements PolygonService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polygons: Map<MapPolygonDirective, Promise<Polygon>> = new Map<MapPolygonDirective, Promise<Polygon>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolygonService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.\r\n     * @param _layerService - {@link BingLayerService} instance.\r\n     * The concrete {@link BingLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a\r\n     * correcsponding layer.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} to be added.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public AddPolygon(polygon: MapPolygonDirective): void {\r\n        const o: IPolygonOptions = {\r\n            id: polygon.Id,\r\n            clickable: polygon.Clickable,\r\n            draggable: polygon.Draggable,\r\n            editable: polygon.Editable,\r\n            fillColor: polygon.FillColor,\r\n            fillOpacity: polygon.FillOpacity,\r\n            geodesic: polygon.Geodesic,\r\n            labelMaxZoom: polygon.LabelMaxZoom,\r\n            labelMinZoom: polygon.LabelMinZoom,\r\n            paths: polygon.Paths,\r\n            showLabel: polygon.ShowLabel,\r\n            showTooltip: polygon.ShowTooltip,\r\n            strokeColor: polygon.StrokeColor,\r\n            strokeOpacity: polygon.StrokeOpacity,\r\n            strokeWeight: polygon.StrokeWeight,\r\n            title: polygon.Title,\r\n            visible: polygon.Visible,\r\n            zIndex: polygon.zIndex,\r\n        };\r\n        let polygonPromise: Promise<Polygon>;\r\n        if (polygon.InCustomLayer) {\r\n            polygonPromise = this._layerService.CreatePolygon(polygon.LayerId, o);\r\n        }\r\n        else {\r\n            polygonPromise = this._mapService.CreatePolygon(o);\r\n        }\r\n        this._polygons.set(polygon, polygonPromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a polygon.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polygon - The {@link MapPolygonDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof BingPolygonService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polygon: MapPolygonDirective): Observable<T> {\r\n        const b: Subject<T> = new Subject<T>();\r\n        if (eventName === 'mousemove') {\r\n            return b.asObservable();\r\n        }\r\n        if (eventName === 'rightclick') {\r\n            return b.asObservable();\r\n        }\r\n        ///\r\n        /// mousemove and rightclick are not supported by bing polygons.\r\n        ///\r\n\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polygons.get(polygon).then((p: Polygon) => {\r\n                p.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polygon.\r\n      *\r\n      * @param polygon - {@link MapPolygonDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polygon has been deleted.\r\n      *\r\n      * @memberof BingPolygonService\r\n      */\r\n    public DeletePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) => {\r\n            return this._zone.run(() => {\r\n                l.Delete();\r\n                this._polygons.delete(polygon);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the polygon on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event. Expected to implement {@link Microsoft.Maps.IMouseEventArgs}.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        const x: Microsoft.Maps.IMouseEventArgs = <Microsoft.Maps.IMouseEventArgs>e;\r\n        return { latitude: x.location.latitude, longitude: x.location.longitude };\r\n    }\r\n\r\n    /**\r\n     * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} for which to obtain the polygon model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polygon} implementation of the underlying platform.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public GetNativePolygon(polygon: MapPolygonDirective): Promise<Polygon> {\r\n        return this._polygons.get(polygon);\r\n    }\r\n\r\n    /**\r\n     * Set the polygon options.\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @param options - {@link IPolygonOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polygon options have been set.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public SetOptions(polygon: MapPolygonDirective, options: IPolygonOptions): Promise<void> {\r\n        return this._polygons.get(polygon).then((l: Polygon) => { l.SetOptions(options); });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polygon path\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polygon has been updated.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public UpdatePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) =>  {\r\n            if (Array.isArray(polygon.Paths[0])) {\r\n                l.SetPaths(polygon.Paths);\r\n            }\r\n            else {\r\n                l.SetPath(<Array<ILatLong>>polygon.Paths);\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer, Subject } from 'rxjs';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MapPolylineDirective } from '../../components/map-polyline';\r\nimport { PolylineService } from '../polyline.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n\r\n/**\r\n * Concrete implementation of the Polyline Service abstract class for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingPolylineService implements PolylineService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polylines: Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>> =\r\n    new Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolylineService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link BingLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a\r\n     * corresponding layer.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} to be added.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public AddPolyline(polyline: MapPolylineDirective): void {\r\n        const o: IPolylineOptions = {\r\n            id: polyline.Id,\r\n            clickable: polyline.Clickable,\r\n            draggable: polyline.Draggable,\r\n            editable: polyline.Editable,\r\n            geodesic: polyline.Geodesic,\r\n            path: polyline.Path,\r\n            showTooltip: polyline.ShowTooltip,\r\n            strokeColor: polyline.StrokeColor,\r\n            strokeOpacity: polyline.StrokeOpacity,\r\n            strokeWeight: polyline.StrokeWeight,\r\n            title: polyline.Title,\r\n            visible: polyline.Visible,\r\n            zIndex: polyline.zIndex,\r\n        };\r\n        let polylinePromise: Promise<Polyline|Array<Polyline>>;\r\n        if (polyline.InCustomLayer) {\r\n            polylinePromise = this._layerService.CreatePolyline(polyline.LayerId, o);\r\n        } else {\r\n            polylinePromise = this._mapService.CreatePolyline(o);\r\n        }\r\n        this._polylines.set(polyline, polylinePromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a line.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polyline - The {@link MapPolylineDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof BingPolylineService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polyline: MapPolylineDirective): Observable<T> {\r\n        const b: Subject<T> = new Subject<T>();\r\n        if (eventName === 'mousemove') {\r\n            return b.asObservable();\r\n        }\r\n        if (eventName === 'rightclick') {\r\n            return b.asObservable();\r\n        }\r\n        ///\r\n        /// mousemove and rightclick are not supported by bing polygons.\r\n        ///\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polylines.get(polyline).then(p => {\r\n                const x: Array<Polyline> = Array.isArray(p) ? p : [p];\r\n                x.forEach(line => line.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e))));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polyline.\r\n      *\r\n      * @param polyline - {@link MapPolylineDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polyline has been deleted.\r\n      *\r\n      * @memberof BingPolylineService\r\n      */\r\n    public DeletePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polyline) => {\r\n            return this._zone.run(() => {\r\n                const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n                x.forEach(line =>  line.Delete());\r\n                this._polylines.delete(polyline);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public GetCoordinatesFromClick(e: Microsoft.Maps.IMouseEventArgs): ILatLong {\r\n        if (!e) { return null; }\r\n        if (!e.location) { return null; }\r\n        return { latitude: e.location.latitude, longitude: e.location.longitude };\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} for which to obtain the polyline model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polyline}\r\n     * implementation of the underlying platform. For complex paths, returns an array of polylines.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public GetNativePolyline(polyline: MapPolylineDirective): Promise<Polyline|Array<Polyline>> {\r\n        return this._polylines.get(polyline);\r\n    }\r\n\r\n    /**\r\n     * Set the polyline options.\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @param options - {@link IPolylineOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polyline options have been set.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public SetOptions(polyline: MapPolylineDirective, options: IPolylineOptions): Promise<void> {\r\n        return this._polylines.get(polyline).then(l => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            x.forEach(line => line.SetOptions(options));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polyline path\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polyline has been updated.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public UpdatePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then(l => this._zone.run(() => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            const p: Array<Array<ILatLong>> =\r\n                polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? <Array<Array<ILatLong>>>polyline.Path :\r\n                <Array<Array<ILatLong>>>[polyline.Path];\r\n             x.forEach((line, index) => {\r\n                 if (p.length > index) { line.SetPath(p[index]); }\r\n            });\r\n            if (Array.isArray(l) && l.length > p.length) {\r\n                l.splice(p.length - 1).forEach(line => line.Delete());\r\n            }\r\n        }));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { MapServiceFactory } from '../mapservicefactory';\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\nimport { MarkerService } from '../marker.service';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { LayerService } from '../layer.service';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { PolylineService } from '../polyline.service';\r\nimport { BingMapAPILoader, BingMapAPILoaderConfig } from './bing-map.api-loader.service';\r\nimport { BingInfoBoxService } from './bing-infobox.service';\r\nimport { BingMarkerService } from './bing-marker.service';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingLayerService } from './bing-layer.service';\r\nimport { BingClusterService } from './bing-cluster.service';\r\nimport { BingPolygonService } from './bing-polygon.service';\r\nimport { BingPolylineService } from './bing-polyline.service';\r\n\r\n/**\r\n * Implements a factory to create thre necessary Bing Maps V8 specific service instances.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapServiceFactory implements MapServiceFactory {\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMapServiceFactory.\r\n     * @param _loader - {@link MapAPILoader} implementation for the Bing Map V8 provider.\r\n     * @param _zone - NgZone object to implement zone aware promises.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods and MapServiceFactory implementation.\r\n    ///\r\n\r\n    /**\r\n     * Creates the map service for the Bing Maps V8 implementation.\r\n     *\r\n     * @returns - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public Create(): MapService {\r\n        return new BingMapService(this._loader, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the cluster service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @returns - {@link ClusterService}. A concreted instance of the {@link BingClusterService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateClusterService(_mapService: BingMapService): ClusterService {\r\n        return new BingClusterService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates thh info box service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @returns - {@link InfoBoxService}. A concreted instance of the {@link BingInfoBoxService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateInfoBoxService(_mapService: BingMapService): InfoBoxService {\r\n        return new BingInfoBoxService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the layer service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @returns - {@link LayerService}. A concreted instance of the {@link BingLayerService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateLayerService(_mapService: BingMapService): LayerService {\r\n        return new BingLayerService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the marker service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @param layers - {@link LayerService}. A concreted instance of the {@link BingLayerService}.\r\n     * @param clusters  - {@link ClusterService}. A concreted instance of the {@link BingClusterService}.\r\n     * @returns - {@link MarkerService}. A concreted instance of the {@link BingMarkerService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateMarkerService(_mapService: BingMapService,\r\n        _layerService: BingLayerService, _clusterService: BingClusterService): MarkerService {\r\n        return new BingMarkerService(_mapService, _layerService, _clusterService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolygonService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolygonService(map: MapService, layers: LayerService): PolygonService {\r\n        return new BingPolygonService(map, layers, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polyline service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolylineService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolylineService(map: MapService, layers: LayerService): PolylineService {\r\n        return new BingPolylineService(map, layers, this._zone);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Creates a new instance of a plaform specific MapServiceFactory.\r\n *\r\n * @export\r\n * @param apiLoader - An {@link MapAPILoader} instance. This is expected to the a {@link BingMapAPILoader}.\r\n * @param zone - An NgZone instance to provide zone aware promises.\r\n *\r\n * @returns -  A {@link MapServiceFactory} instance.\r\n */\r\nexport function BingMapServiceFactoryFactory(apiLoader: MapAPILoader, zone: NgZone): MapServiceFactory {\r\n    return new BingMapServiceFactory(apiLoader, zone);\r\n}\r\n\r\n/**\r\n * Creates a new instance of a plaform specific MapLoaderFactory.\r\n *\r\n * @export\r\n * @returns - A {@link MapAPILoader} instance.\r\n */\r\nexport function BingMapLoaderFactory(): MapAPILoader {\r\n    return new BingMapAPILoader(new BingMapAPILoaderConfig(), new WindowRef(), new DocumentRef());\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { MapService } from '../map.service';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { GoogleMapService } from './google-map.service';\r\nimport { GoogleConversions } from './google-conversions';\r\nimport { GoogleMarker } from '../../models/google/google-marker';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * This abstract partially implements the contract for the {@link LayerService}\r\n * and {@link ClusterService} for the Google Maps archtiecture. It serves\r\n * as the base class for basic layer ({@link GoogleLayerService}) and cluster layer ({@link GoogleClusterLayer}).\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class GoogleLayerBase {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected abstract _layers: Map<number, Promise<Layer>>;\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleLayerBase.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Google Maps.\r\n     * An instance of {@link GoogleMapService}.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    constructor(protected _mapService: MapService, protected _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public abstract AddLayer(layer: MapLayerDirective): void;\r\n\r\n    /**\r\n     * Deletes the layer\r\n     *\r\n     * @param layer - MapLayerDirective component object for which to retrieve the layer.\r\n     * @returns - A promise that is fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public DeleteLayer(layer: MapLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: Layer) => {\r\n            return this._zone.run(() => {\r\n                l1.Delete();\r\n                this._layers.delete(layer.Id);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the Layer model represented by this layer.\r\n     *\r\n     * @param layer - MapLayerDirective component object or layer id for which to retrieve the layer model.\r\n     * @returns - A promise that when resolved contains the Layer model.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public GetNativeLayer(layer: MapLayerDirective|number): Promise<Layer> {\r\n        let p: Promise<Layer> = null;\r\n        if (typeof(layer) === 'number') {\r\n            p = this._layers.get(layer);\r\n        }\r\n        else {\r\n            p = this._layers.get((<MapLayerDirective>layer).Id);\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Creates a marker in the layer.\r\n     *\r\n     * @param layer - The Id of the layer in which to create the marker.\r\n     * @param options - {@link IMarkerOptions} object containing the marker properties.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} model for the created marker.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker> {\r\n        const mp: Promise<GoogleMapTypes.GoogleMap> = this._mapService.MapPromise;\r\n        const lp: Promise<Layer> = this._layers.get(layer);\r\n\r\n        return Promise.all([mp, lp]).then(([map, l]) => {\r\n            const payload = (x: GoogleMapTypes.MarkerOptions): GoogleMarker => {\r\n                const marker = new google.maps.Marker(x);\r\n                if (options.metadata) { options.metadata.forEach((val: any, key: string) => marker.Metadata.set(key, val)); }\r\n                marker.setMap(map);\r\n                const m = new GoogleMarker(marker);\r\n                m.IsFirst = options.isFirst;\r\n                m.IsLast = options.isLast;\r\n                if (options.metadata) { options.metadata.forEach((val: any, key: string) => m.Metadata.set(key, val)); }\r\n                l.AddEntity(m);\r\n                return m;\r\n            };\r\n            const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(options);\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof(s) === 'string') {\r\n                    o.icon = s;\r\n                    return payload(o);\r\n                }\r\n                else {\r\n                    return s.then(x => {\r\n                        o.icon = x.icon;\r\n                        return payload(o);\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return payload(o);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param options - Marker options defining the markers.\r\n     * @param markerIcon - Optional information to generate custom markers. This will be applied to all markers.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Marker models.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public CreateMarkers(options: Array<IMarkerOptions>, markerIcon?: IMarkerIconInfo): Promise<Array<Marker>> {\r\n        const payload = (icon: string): Array<GoogleMarker> => {\r\n            const markers: Array<GoogleMarker> = options.map(mo => {\r\n                const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(mo);\r\n                if (icon && icon !== '') { o.icon = icon; }\r\n                const pushpin = new google.maps.Marker(o);\r\n                const marker: GoogleMarker = new GoogleMarker(pushpin);\r\n                marker.IsFirst = mo.isFirst;\r\n                marker.IsLast = mo.isLast;\r\n                if (mo.metadata) { mo.metadata.forEach((val: any, key: string) => marker.Metadata.set(key, val)); }\r\n                return marker;\r\n            });\r\n            return markers;\r\n        };\r\n        const p: Promise<Array<Marker>> = new Promise<Array<Marker>>((resolve, reject) => {\r\n            if (markerIcon && markerIcon.markerType) {\r\n                const s = Marker.CreateMarker(markerIcon);\r\n                if (typeof(s) === 'string') { resolve(payload(s)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        resolve(payload(x.icon));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                resolve (payload(null));\r\n            }\r\n        });\r\n        return p;\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the layer based on its id.\r\n     *\r\n     * @protected\r\n     * @param id - Layer Id.\r\n     * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    protected GetLayerById(id: number): Promise<Layer> {\r\n        let p: Promise<Layer>;\r\n        this._layers.forEach((l: Promise<Layer>, k: number) => { if (k === id) { p = l; } });\r\n        return p;\r\n    }\r\n\r\n}\r\n","ï»¿import { IClusterIconInfo } from '../../interfaces/icluster-icon-info';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { MarkerService } from '../marker.service';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { Marker } from '../../models/marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { ClusterClickAction } from '../../models/cluster-click-action';\r\nimport { ClusterLayerDirective } from '../../components/cluster-layer';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { MapService } from '../map.service';\r\nimport { GoogleLayerBase } from './google-layer-base';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\n@Injectable()\r\nexport class GoogleClusterService extends GoogleLayerBase implements ClusterService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _layers: Map<number, Promise<Layer>> = new Map<number, Promise<Layer>>();\r\n    protected _layerStyles: Map<number, Array<GoogleMapTypes.ClusterStyle>> = new Map<number, Array<GoogleMapTypes.ClusterStyle>>();\r\n\r\n    ///\r\n    /// Static methods\r\n    ///\r\n\r\n    /**\r\n     * Creates the cluster icon from the styles\r\n     *\r\n     * @param styles\r\n     * @returns - Promise that when resolved contains an Array of IClusterIconInfo objects\r\n     * containing the hydrated cluster icons.\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public static CreateClusterIcons(styles: Array<IClusterIconInfo>): Promise<Array<IClusterIconInfo>> {\r\n        const i: Promise<Array<IClusterIconInfo>> = new Promise<Array<IClusterIconInfo>>((resolve, reject) => {\r\n            const pa = new Array<Promise<{icon: string, iconInfo: IMarkerIconInfo}>>();\r\n            styles.forEach((style, index) => {\r\n                if (style.iconInfo) {\r\n                    const s: string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> = Marker.CreateMarker(style.iconInfo);\r\n                    if (typeof(s) === 'string') {\r\n                        style.url = s;\r\n                        if (style.width == null) {\r\n                            style.width = style.iconInfo.size.width;\r\n                            style.height = style.iconInfo.size.height;\r\n                        }\r\n                        if (style.iconInfo.markerOffsetRatio && style.iconInfo.size && style.anchor == null) {\r\n                            const o: IMarkerIconInfo = style.iconInfo;\r\n                            style.anchor = [\r\n                                o.size.width * o.markerOffsetRatio.x,\r\n                                o.size.height * o.markerOffsetRatio.y\r\n                            ];\r\n                        }\r\n                        delete style.iconInfo;\r\n                    }\r\n                    else {\r\n                        s.then(x => {\r\n                            style.url = x.icon;\r\n                            if (style.width == null) {\r\n                                style.width = x.iconInfo.size.width;\r\n                                style.height = x.iconInfo.size.height;\r\n                            }\r\n                            if (x.iconInfo.markerOffsetRatio && x.iconInfo.size && style.anchor == null) {\r\n                                const o: IMarkerIconInfo = x.iconInfo;\r\n                                style.anchor = [\r\n                                    o.size.width * o.markerOffsetRatio.x,\r\n                                    o.size.height * o.markerOffsetRatio.y\r\n                                ];\r\n                            }\r\n                            delete style.iconInfo;\r\n                        });\r\n                        pa.push(s);\r\n                    }\r\n                }\r\n            });\r\n            if (pa.length === 0) { resolve(styles); }\r\n            else {\r\n                Promise.all(pa).then(() => {\r\n                    resolve(styles);\r\n                });\r\n            }\r\n        });\r\n        return i;\r\n    }\r\n\r\n    ///\r\n    /// Constructors\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleClusterService.\r\n     * @param _mapService\r\n     * @param _zone\r\n     * @memberof GoogleClusterService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    /**\r\n     * Adds the cluster layer to the map\r\n     *\r\n     * @param layer\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public AddLayer(layer: ClusterLayerDirective): void {\r\n        const options: IClusterOptions = {\r\n            id: layer.Id,\r\n            visible: layer.Visible,\r\n            clusteringEnabled: layer.ClusteringEnabled,\r\n            zoomOnClick: layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster\r\n        };\r\n        if (layer.GridSize) { options.gridSize = layer.GridSize; }\r\n        if (layer.MinimumClusterSize) { options.minimumClusterSize = layer.MinimumClusterSize; }\r\n        if (layer.Styles) { options.styles = layer.Styles; }\r\n        if (layer.UseDynamicSizeMarkers) {\r\n            options.styles = null;\r\n            // do not to attempt to setup styles here as the dynamic call back will generate them.\r\n        }\r\n        else {\r\n            options.styles = [{\r\n                height: 30,\r\n                width: 35,\r\n                textColor: 'white',\r\n                textSize: 11,\r\n                backgroundPosition: 'center',\r\n                iconInfo: {\r\n                    markerType: MarkerTypeId.FontMarker,\r\n                    fontName: 'FontAwesome',\r\n                    fontSize: 30,\r\n                    color: 'green',\r\n                    text: '\\uF111'\r\n                }\r\n            }];\r\n        }\r\n        const dynamicClusterCallback = (markers: Array<GoogleMapTypes.Marker>, numStyles: number,\r\n            clusterer: GoogleMapTypes.MarkerClusterer) => {\r\n            // dynamically ensure that the necessary style for this cluster icon exists and\r\n            // the clusterer is already hooked up to the styles array via pointer, so we only\r\n            // need to update the style. Since the clusterer re-renders a cluster icon is the\r\n            // the marker count changes, we will only need to retain the current icon as opposed\r\n            // to all cluster icon.\r\n            const styles: Array<GoogleMapTypes.ClusterStyle> = this._layerStyles.get(layer.Id);\r\n            const iconInfo: IMarkerIconInfo = {\r\n                markerType: MarkerTypeId.None\r\n            };\r\n            const icon: string = layer.CustomMarkerCallback(<any>markers, iconInfo);\r\n            styles[0] = {\r\n                url: `\\\"data:image/svg+xml;utf8,${icon}\\\"`,\r\n                height: iconInfo.size.height,\r\n                width: iconInfo.size.width,\r\n                textColor: 'white',\r\n                textSize: 11,\r\n                backgroundPosition: 'center',\r\n            };\r\n            return {\r\n                text: markers.length.toString(),\r\n                index: 1\r\n            };\r\n        };\r\n        const resetStyles = (clusterer: GoogleMapTypes.MarkerClusterer) => {\r\n            if (this._layerStyles.has(layer.Id)) { this._layerStyles.get(layer.Id).splice(0); }\r\n            else {\r\n                const styles: Array<GoogleMapTypes.ClusterStyle> = new Array<GoogleMapTypes.ClusterStyle>();\r\n                styles.push({});\r\n                this._layerStyles.set(layer.Id, styles);\r\n                clusterer.setStyles(styles);\r\n                    // this is important for dynamic styles as the pointer to this array gets passed\r\n                    // around key objects in the clusterer. Therefore, it must be initialized here in order for\r\n                    // updates to the styles to be visible.\r\n                    // also, we need to add at least one style to prevent the default styles from being picked up.\r\n            }\r\n        };\r\n\r\n        const layerPromise = this._mapService.CreateClusterLayer(options);\r\n        this._layers.set(layer.Id, layerPromise);\r\n        layerPromise.then(l => {\r\n            const clusterer: GoogleMapTypes.MarkerClusterer = <GoogleMapTypes.MarkerClusterer>l.NativePrimitve;\r\n            if (options.styles) {\r\n                const s  = GoogleClusterService.CreateClusterIcons(options.styles);\r\n                s.then(x => {\r\n                    clusterer.setStyles(<Array<GoogleMapTypes.ClusterStyle>>x);\r\n                });\r\n            }\r\n            else {\r\n                resetStyles(clusterer);\r\n                this._mapService.MapPromise.then((m: GoogleMapTypes.GoogleMap) => {\r\n                    m.addListener('zoom_changed', () => {\r\n                        resetStyles(clusterer);\r\n                    });\r\n                });\r\n                clusterer.setCalculator((m, n) => {\r\n                    return dynamicClusterCallback(m, n, clusterer);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a marker in the cluster\r\n     *\r\n     * @param layer\r\n     * @param options\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n\r\n        return p.then((l: Layer) => {\r\n            return this._mapService.CreateMarker(options)\r\n                .then((marker: Marker) => {\r\n                    marker.IsFirst = options.isFirst;\r\n                    marker.IsLast = options.isLast;\r\n                    l.AddEntity(marker);\r\n                    return marker;\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Starts the clustering\r\n     *\r\n     * @param layer\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public StartClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Stops the clustering\r\n     *\r\n     * @param layer\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public StopClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an\r\n     * array of polygons for complex paths) model.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { InfoBoxComponent } from '../../components/infobox';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { MarkerService } from '../marker.service';\r\nimport { MapService } from '../map.service';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { GoogleInfoWindow } from '../../models/google/google-info-window';\r\nimport { GoogleMarker } from '../../models/google/google-marker';\r\nimport { GoogleMapEventsLookup } from '../../models/google/google-events-lookup';\r\n\r\n@Injectable()\r\nexport class GoogleInfoBoxService extends InfoBoxService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    private _boxes: Map<InfoBoxComponent, Promise<InfoWindow>> = new Map<InfoBoxComponent, Promise<GoogleInfoWindow>>();\r\n\r\n    ///\r\n    /// Constructors\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleInfoBoxService.\r\n     * @param _mapService\r\n     * @param _markerService\r\n     * @param _zone\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _markerService: MarkerService,\r\n        private _zone: NgZone) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of an info window\r\n     *\r\n     * @param info\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public AddInfoWindow(info: InfoBoxComponent): void {\r\n        const options: IInfoWindowOptions = {};\r\n        if (info.HtmlContent !== '') {\r\n            options.htmlContent = info.HtmlContent;\r\n        }\r\n        else {\r\n            options.title = info.Title;\r\n            options.description = info.Description;\r\n        }\r\n        if (info.xOffset || info.yOffset) {\r\n            if (options.pixelOffset == null) { options.pixelOffset = { x: 0, y: 0 }; }\r\n            if (info.xOffset) { options.pixelOffset.x = info.xOffset; }\r\n            if (info.yOffset) { options.pixelOffset.y = info.yOffset; }\r\n        }\r\n        options.disableAutoPan = info.DisableAutoPan;\r\n        options.visible = info.Visible;\r\n\r\n        if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {\r\n            options.position = { latitude: info.Latitude, longitude: info.Longitude };\r\n        }\r\n        const infoWindowPromise = this._mapService.CreateInfoWindow(options);\r\n        this._boxes.set(info, infoWindowPromise);\r\n    }\r\n\r\n    /**\r\n     * Closes the info window\r\n     *\r\n     * @param info\r\n     * @returns -  A promise that is resolved when the info box is closed.\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public Close(info: InfoBoxComponent): Promise<void> {\r\n        return this._boxes.get(info).then(w => {\r\n            w.Close();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for an info window.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param infoComponent - The {@link InfoBoxComponent} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, infoComponent: InfoBoxComponent): Observable<T> {\r\n        const googleEventName: string = GoogleMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._boxes.get(infoComponent).then((b: InfoWindow) => {\r\n                b.AddListener(googleEventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes the info window\r\n     *\r\n     * @param info\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public DeleteInfoWindow(info: InfoBoxComponent): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Opens the info window. Window opens on a marker, if supplied, or a specific location if given\r\n     *\r\n     * @param info\r\n     * @param [loc]\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public Open(info: InfoBoxComponent, loc?: ILatLong): Promise<void> {\r\n        if (info.CloseInfoBoxesOnOpen || info.Modal) {\r\n            // close all open info boxes\r\n            this._boxes.forEach((box: Promise<InfoWindow>, i: InfoBoxComponent) => {\r\n                if (info.Id !== i.Id) {\r\n                    box.then((w) => {\r\n                        if (w.IsOpen) {\r\n                            w.Close();\r\n                            i.Close();\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        return this._boxes.get(info).then((w: GoogleInfoWindow) => {\r\n            const options: IInfoWindowOptions = {};\r\n            if (info.HtmlContent !== '') {\r\n                options.htmlContent = info.HtmlContent;\r\n            }\r\n            else {\r\n                options.title = info.Title;\r\n                options.description = info.Description;\r\n            }\r\n            w.SetOptions(options);\r\n            if (info.HostMarker != null) {\r\n                return this._markerService.GetNativeMarker(info.HostMarker).then((marker) => {\r\n                    return this._mapService.MapPromise.then((map) => (<GoogleInfoWindow>w).Open((<GoogleMarker>marker).NativePrimitve));\r\n                });\r\n            }\r\n            return this._mapService.MapPromise.then((map) => {\r\n                if (loc) { w.SetPosition(loc); }\r\n                w.Open();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options\r\n     *\r\n     * @param info\r\n     * @param options\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public SetOptions(info: InfoBoxComponent, options: IInfoWindowOptions): Promise<void> {\r\n        return this._boxes.get(info).then((w: GoogleInfoWindow) => {\r\n            w.SetOptions(options);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window position\r\n     *\r\n     * @param info\r\n     * @param latlng\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public SetPosition(info: InfoBoxComponent, latlng: ILatLong): Promise<void> {\r\n        this._boxes.get(info).then((w) => {\r\n            w.SetPosition(latlng);\r\n        });\r\n        return Promise.resolve();\r\n    }\r\n\r\n}\r\n","import { eachSeries, nextTick } from 'async';\r\nimport { GoogleMarker } from './google-marker';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { MapService } from '../../services/map.service';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { InfoWindow } from '../info-window';\r\nimport { Polygon } from '../polygon';\r\nimport { Polyline } from '../polyline';\r\nimport { ClusterPlacementMode } from '../cluster-placement-mode';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\n/**\r\n * Concrete implementation of a layer for the Google Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class GoogleLayer implements Layer {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _entities: Array<Marker|InfoWindow|Polygon|Polyline> = new Array<Marker|InfoWindow|Polygon|Polyline>();\r\n    private _visible: boolean = true;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer. Google does not have the concept of a custom layer,\r\n     * so we are returning the Map as the native object because it hosts all the markers.\r\n     *\r\n     * @returns GoogleMapTypes.GoogleMap.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.GoogleMap {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the GoogleMarkerClusterer class.\r\n     *\r\n     * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    constructor(private _layer: GoogleMapTypes.GoogleMap, private _maps: MapService, private _id: number) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        throw (new Error('Events are not supported on Google Layers. You can still add events to individual markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer. Use this method with caution as it will\r\n     * trigger a recaluation of the clusters (and associated markers if approprite) for\r\n     * each invocation. If you use this method to add many markers to the cluster, use\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.\r\n     *\r\n     * @memberof GoogleLAyer\r\n     */\r\n    public AddEntity(entity: Marker | InfoWindow | Polygon | Polyline): void {\r\n        if (entity.NativePrimitve) {\r\n            this._entities.push(entity);\r\n            entity.NativePrimitve.setVisible(this._visible);\r\n            entity.NativePrimitve.setMap(this.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..)\r\n     *\r\n     * @param entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.\r\n     *\r\n     * @memberof GoogleLAyer\r\n     */\r\n    public AddEntities(entities: Array<Marker|InfoWindow|Polygon|Polyline>): void {\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            this._entities.push(...entities);\r\n            eachSeries([...entities], (e, next) => {\r\n                e.NativePrimitve.setVisible(this._visible);\r\n                e.NativePrimitve.setMap(this.NativePrimitve);\r\n                nextTick(() => next());\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes the layer anbd the markers in it.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public Delete(): void {\r\n        eachSeries(this._entities.splice(0), (e, next) => {\r\n            e.NativePrimitve.setMap(null);\r\n            nextTick(() => next());\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns ILayerOptions. The layer options.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public GetOptions(): ILayerOptions {\r\n        const options: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._visible;\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the layer.\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public RemoveEntity(entity: Marker | InfoWindow | Polygon | Polyline): void {\r\n        if (entity.NativePrimitve) {\r\n            const j: number = this._entities.indexOf(entity);\r\n            if (j > -1) { this._entities.splice(j, 1); }\r\n            entity.NativePrimitve.setMap(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing\r\n     * the entities to add to the cluster. This replaces any existing entities.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public SetEntities(entities: Array<Marker> | Array<InfoWindow> | Array<Polygon> | Array<Polyline>): void {\r\n        this.Delete();\r\n        this.AddEntities(entities);\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options ILayerOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public SetOptions(options: ILayerOptions): void {\r\n        this._id = options.id;\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        eachSeries([...this._entities], (e, next) => {\r\n            e.NativePrimitve.setVisible(visible);\r\n            nextTick(() => next());\r\n        });\r\n        this._visible = visible;\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { Layer } from '../../models/layer';\r\nimport { GoogleLayer } from '../../models/google/google-layer';\r\nimport { GooglePolygon } from '../../models/google/google-polygon';\r\nimport { GooglePolyline } from '../../models/google/google-polyline';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { GoogleLayerBase } from './google-layer-base';\r\nimport { MapService } from '../map.service';\r\nimport { GoogleConversions } from './google-conversions';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Implements the {@link LayerService} contract for a Google Maps specific implementation.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleLayerService extends GoogleLayerBase implements LayerService  {\r\n\r\n    ///\r\n    /// Field Declarations.\r\n    ///\r\n    protected _layers: Map<number, Promise<Layer>> = new Map<number, Promise<Layer>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleLayerService.\r\n     * @param _mapService - Instance of the Google Maps Service. Will generally be injected.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public AddLayer(layer: MapLayerDirective): void {\r\n        const p: Promise<Layer> = new Promise<Layer>((resolve, reject) => {\r\n            this._mapService.MapPromise.then(m => {\r\n                const l: GoogleLayer = new GoogleLayer(m, this._mapService, layer.Id);\r\n                l.SetVisible(layer.Visible);\r\n                resolve(l);\r\n            });\r\n        });\r\n        this._layers.set(layer.Id, p);\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        const p: Promise<Polygon> = this._mapService.CreatePolygon(options);\r\n        const l: Promise<Layer> = this._layers.get(layer);\r\n        Promise.all([p, l]).then(x => x[1].AddEntity(x[0]));\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        //\r\n        // Note: we attempted using data.Polygons in an attempt to improve performance, but either data.Polygon\r\n        // or data.MultiPolygon actually operate significantly slower than generating the polygons this way.\r\n        // the slowness in google as opposed to bing probably comes from the point reduction algorithm uses.\r\n        // Signigicant performance improvements might be possible in google when using a pixel based reduction algorithm\r\n        // prior to setting the polygon path. This will lower to processing overhead of the google algorithm (with is Douglas-Peucker\r\n        // and rather compute intensive)\r\n        //\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polygons: Promise<Array<Polygon>> = new Promise<Array<Polygon>>((resolve, reject) => {\r\n                const polys: Array<GooglePolygon> = options.map(o => {\r\n                    const op: GoogleMapTypes.PolygonOptions = GoogleConversions.TranslatePolygonOptions(o);\r\n                    const poly: GoogleMapTypes.Polygon = new google.maps.Polygon(op);\r\n                    const polygon: GooglePolygon = new GooglePolygon(poly);\r\n                    if (o.title && o.title !== '') { polygon.Title = o.title; }\r\n                    if (o.metadata) { o.metadata.forEach((val: any, key: string) => polygon.Metadata.set(key, val)); }\r\n                    return polygon;\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polygons;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polyline.\r\n     * @param options - Polyline options defining the polyline.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an array\r\n     * of polygons for complex paths) model.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        const p: Promise<Polyline|Array<Polyline>> = this._mapService.CreatePolyline(options);\r\n        const l: Promise<Layer> = this._layers.get(layer);\r\n        Promise.all([p, l]).then(x => {\r\n            const p1: Array<Polyline> =  Array.isArray(x[0]) ? <Array<Polyline>>x[0] : [<Polyline>x[0]];\r\n            for (const p2 of p1) {x[1].AddEntity(p2); }\r\n        });\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polylines: Promise<Array<Polyline|Array<Polyline>>> = new Promise<Array<Polyline|Array<Polyline>>>((resolve, reject) => {\r\n                const polys: Array<Polyline|Array<Polyline>> = options.map(o => {\r\n                    const op: GoogleMapTypes.PolylineOptions = GoogleConversions.TranslatePolylineOptions(o);\r\n                    if (o.path && o.path.length > 0 && !Array.isArray(o.path[0])) {\r\n                        op.path = GoogleConversions.TranslatePaths(o.path)[0];\r\n                        const poly: GoogleMapTypes.Polyline = new google.maps.Polyline(op);\r\n                        const polyline: GooglePolyline = new GooglePolyline(poly);\r\n                        if (o.title && o.title !== '') { polyline.Title = o.title; }\r\n                        if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                        return polyline;\r\n                    }\r\n                    else {\r\n                        const paths: Array<Array<GoogleMapTypes.LatLng>> = GoogleConversions.TranslatePaths(o.path);\r\n                        const lines: Array<Polyline> = new Array<Polyline>();\r\n                        paths.forEach(x => {\r\n                            op.path = x;\r\n                            const poly = new google.maps.Polyline(op);\r\n                            const polyline: GooglePolyline = new GooglePolyline(poly);\r\n                            if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                            if (o.title && o.title !== '') {polyline.Title = o.title; }\r\n                            lines.push(polyline);\r\n                        });\r\n                        return lines;\r\n                    }\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polylines;\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable, Optional } from '@angular/core';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\n\r\n/**\r\n * Protocol enumeration\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum ScriptProtocol {\r\n    HTTP,\r\n    HTTPS,\r\n    AUTO\r\n}\r\n\r\n/**\r\n * Bing Maps V8 specific loader configuration to be used with the {@link GoogleMapAPILoader}\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapAPILoaderConfig {\r\n    /**\r\n       * The Google Maps API Key (see:\r\n       * https://developers.google.com/maps/documentation/javascript/get-api-key)\r\n       */\r\n    apiKey?: string;\r\n\r\n    /**\r\n     * The Google Maps client ID (for premium plans).\r\n     * When you have a Google Maps APIs Premium Plan license, you must authenticate\r\n     * your application with either an API key or a client ID.\r\n     * The Google Maps API will fail to load if both a client ID and an API key are included.\r\n     */\r\n    clientId?: string;\r\n\r\n    /**\r\n     * The Google Maps channel name (for premium plans).\r\n     * A channel parameter is an optional parameter that allows you to track usage under your client\r\n     * ID by assigning a distinct channel to each of your applications.\r\n     */\r\n    channel?: string;\r\n\r\n    /**\r\n     * Google Maps API version.\r\n     */\r\n    apiVersion?: string;\r\n\r\n    /**\r\n     * Host and Path used for the `<script>` tag.\r\n     */\r\n    hostAndPath?: string;\r\n\r\n    /**\r\n     * Protocol used for the `<script>` tag.\r\n     */\r\n    protocol?: ScriptProtocol;\r\n\r\n    /**\r\n     * Defines which Google Maps libraries should get loaded.\r\n     */\r\n    libraries?: string[];\r\n\r\n    /**\r\n     * The default bias for the map behavior is US.\r\n     * If you wish to alter your application to serve different map tiles or bias the\r\n     * application, you can overwrite the default behavior (US) by defining a `region`.\r\n     * See https://developers.google.com/maps/documentation/javascript/basics#Region\r\n     */\r\n    region?: string;\r\n\r\n    /**\r\n     * The Google Maps API uses the browser's preferred language when displaying\r\n     * textual information. If you wish to overwrite this behavior and force the API\r\n     * to use a given language, you can use this setting.\r\n     * See https://developers.google.com/maps/documentation/javascript/basics#Language\r\n     */\r\n    language?: string;\r\n\r\n    /**\r\n     * The Google Maps API requires a separate library for clustering. Set the property\r\n     * to true in order to load this library.\r\n     * See https://developers.google.com/maps/documentation/javascript/marker-clustering\r\n     */\r\n    enableClustering?: boolean;\r\n\r\n    /**\r\n     * Host and Path used for the cluster library `<script>` tag.\r\n     */\r\n    clusterHostAndPath?: string;\r\n}\r\n\r\n/**\r\n * Default loader configuration.\r\n */\r\nconst DEFAULT_CONFIGURATION = new GoogleMapAPILoaderConfig();\r\n\r\n/**\r\n * Bing Maps V8 implementation for the {@link MapAPILoader} service.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapAPILoader extends MapAPILoader {\r\n\r\n    ///\r\n    /// Field defintitions.\r\n    ///\r\n    private _scriptLoadingPromise: Promise<void>;\r\n\r\n    ///\r\n    /// Property declarations.\r\n    ///\r\n\r\n    /**\r\n     * Gets the loader configuration.\r\n     *\r\n     * @readonly\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    public get Config(): GoogleMapAPILoaderConfig { return this._config; }\r\n\r\n    /**\r\n     * Creates an instance of GoogleMapAPILoader.\r\n     * @param _config - The loader configuration.\r\n     * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.\r\n     * @param _documentRef - An instance of {@link DocumentRef}.\r\n     *                                     Necessary because Bing Map V8 interacts with the document object.\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    constructor( @Optional() private _config: GoogleMapAPILoaderConfig, private _windowRef: WindowRef, private _documentRef: DocumentRef) {\r\n        super();\r\n        if (this._config === null || this._config === undefined) {\r\n            this._config = DEFAULT_CONFIGURATION;\r\n        }\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapAPILoader implementation.\r\n    ///\r\n\r\n    /**\r\n     * Loads the necessary resources for Bing Maps V8.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    public Load(): Promise<void> {\r\n        if (this._scriptLoadingPromise) {\r\n            return this._scriptLoadingPromise;\r\n        }\r\n\r\n        const script = this._documentRef.GetNativeDocument().createElement('script');\r\n        script.type = 'text/javascript';\r\n        script.async = true;\r\n        script.defer = true;\r\n        const callbackName = `Create`;\r\n        script.src = this.GetMapsScriptSrc(callbackName);\r\n\r\n        this._scriptLoadingPromise = new Promise<void>((resolve: Function, reject: Function) => {\r\n            (<any>this._windowRef.GetNativeWindow())[callbackName] = () => {\r\n                if (this._config.enableClustering) {\r\n                    // if clustering is enabled then delay the loading until after the cluster library is loaded\r\n                    const clusterScript = this._documentRef.GetNativeDocument().createElement('script');\r\n                    clusterScript.type = 'text/javascript';\r\n                    clusterScript.src = this.GetClusterScriptSrc();\r\n                    clusterScript.onload = clusterScript.onreadystatechange = () => {\r\n                        resolve();\r\n                    };\r\n                    this._documentRef.GetNativeDocument().head.appendChild(clusterScript);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n            script.onerror = (error: Event) => { reject(error); };\r\n        });\r\n        this._documentRef.GetNativeDocument().head.appendChild(script);\r\n\r\n        return this._scriptLoadingPromise;\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the Google Maps scripts url for injections into the header.\r\n     *\r\n     * @param callbackName - Name of the function to be called when the Google Maps scripts are loaded.\r\n     * @returns - The url to be used to load the Google Map scripts.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    private GetMapsScriptSrc(callbackName: string) {\r\n        const hostAndPath: string = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';\r\n        const queryParams: { [key: string]: string | Array<string> } = {\r\n            v: this._config.apiVersion,\r\n            callback: callbackName,\r\n            key: this._config.apiKey,\r\n            client: this._config.clientId,\r\n            channel: this._config.channel,\r\n            libraries: this._config.libraries,\r\n            region: this._config.region,\r\n            language: this._config.language\r\n        };\r\n        return this.GetScriptSrc(hostAndPath, queryParams);\r\n    }\r\n\r\n    /**\r\n     * Gets the Google Maps Cluster library url for injections into the header.\r\n     *\r\n     * @returns - The url to be used to load the Google Map Cluster library.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    private GetClusterScriptSrc() {\r\n        const hostAndPath: string = this._config.clusterHostAndPath ||\r\n            'developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js';\r\n        return this.GetScriptSrc(hostAndPath, {});\r\n    }\r\n\r\n    /**\r\n     * Gets a scripts url for injections into the header.\r\n     *\r\n     * @param hostAndPath - Host and path name of the script to load.\r\n     * @param queryParams - Url query parameters.\r\n     * @returns - The url with correct protocol, path, and query parameters.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    private GetScriptSrc(hostAndPath: string, queryParams: { [key: string]: string | Array<string> }): string {\r\n        const protocolType: ScriptProtocol =\r\n            <ScriptProtocol>((this._config && this._config.protocol) || ScriptProtocol.HTTPS);\r\n        let protocol: string;\r\n\r\n        switch (protocolType) {\r\n            case ScriptProtocol.AUTO:\r\n                protocol = '';\r\n                break;\r\n            case ScriptProtocol.HTTP:\r\n                protocol = 'http:';\r\n                break;\r\n            case ScriptProtocol.HTTPS:\r\n                protocol = 'https:';\r\n                break;\r\n        }\r\n\r\n        const params: string =\r\n            Object.keys(queryParams)\r\n                .filter((k: string) => queryParams[k] != null)\r\n                .filter((k: string) => {\r\n                    // remove empty arrays\r\n                    return !Array.isArray(queryParams[k]) ||\r\n                        (Array.isArray(queryParams[k]) && queryParams[k].length > 0);\r\n                })\r\n                .map((k: string) => {\r\n                    // join arrays as comma seperated strings\r\n                    const i = queryParams[k];\r\n                    if (Array.isArray(i)) {\r\n                        return { key: k, value: i.join(',') };\r\n                    }\r\n                    return { key: k, value: queryParams[k] };\r\n                })\r\n                .map((entry: { key: string, value: string }) => { return `${entry.key}=${entry.value}`; })\r\n                .join('&');\r\n        return `${protocol}//${hostAndPath}?${params}`;\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { BehaviorSubject, Observable, Observer } from 'rxjs';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { Marker } from '../../models/marker';\r\nimport { MapMarkerDirective } from '../../components/map-marker';\r\nimport { MarkerService } from '../marker.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\nimport { ClusterService } from '../cluster.service';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { GoogleConversions } from './google-conversions';\r\n\r\n/**\r\n * Concrete implementation of the MarkerService abstract class for Google.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMarkerService implements MarkerService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _markers: Map<MapMarkerDirective, Promise<Marker>> = new Map<MapMarkerDirective, Promise<Marker>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMarkerService.\r\n     * @param _mapService - {@link MapService} instance.\r\n     * The concrete {@link GoogleMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link GoogleLayerService} implementation is expected.\r\n     * @param _clusterService - {@link ClusterService} instance.\r\n     * The concrete {@link GoogleClusterService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _clusterService: ClusterService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    /**\r\n     * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.\r\n     *\r\n     * @param marker - The {@link MapMarkerDirective} to be added.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public AddMarker(marker: MapMarkerDirective): void {\r\n        const o: IMarkerOptions = {\r\n            anchor: marker.Anchor,\r\n            position: { latitude: marker.Latitude, longitude: marker.Longitude },\r\n            title: marker.Title,\r\n            label: marker.Label,\r\n            draggable: marker.Draggable,\r\n            icon: marker.IconUrl,\r\n            iconInfo: marker.IconInfo,\r\n            width: marker.Width,\r\n            height: marker.Height,\r\n            isFirst: marker.IsFirstInSet,\r\n            isLast: marker.IsLastInSet\r\n        };\r\n\r\n        // create marker via promise.\r\n        let markerPromise: Promise<Marker> = null;\r\n        if (marker.InClusterLayer) {\r\n            markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else if (marker.InCustomLayer) {\r\n            markerPromise = this._layerService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else {\r\n            markerPromise = this._mapService.CreateMarker(o);\r\n        }\r\n\r\n        this._markers.set(marker, markerPromise);\r\n        if (marker.IconInfo) {\r\n            markerPromise.then((m: Marker) => {\r\n                // update iconInfo to provide hook to do post icon creation activities and\r\n                // also re-anchor the marker\r\n                marker.DynamicMarkerCreated.emit(o.iconInfo);\r\n                const p: IPoint = {\r\n                    x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,\r\n                    y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,\r\n                };\r\n                m.SetAnchor(p);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for a marker.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param marker - The {@link MapMarkerDirective} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, marker: MapMarkerDirective): Observable<T> {\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._markers.get(marker).then((m: Marker) => {\r\n                m.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a marker.\r\n     *\r\n     * @param marker - {@link MapMarkerDirective} to be deleted.\r\n     * @returns - A promise fullfilled once the marker has been deleted.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public DeleteMarker(marker: MapMarkerDirective): Promise<void> {\r\n        const m = this._markers.get(marker);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((ma: Marker) => {\r\n            if (marker.InClusterLayer) {\r\n                this._clusterService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n            }\r\n            if (marker.InCustomLayer) {\r\n                this._layerService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n            }\r\n            return this._zone.run(() => {\r\n                ma.DeleteMarker();\r\n                this._markers.delete(marker);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        if (!e) {\r\n            return null;\r\n        }\r\n        if (!e.latLng) {\r\n            return null;\r\n        }\r\n        if (!e.latLng.lat || !e.latLng.lng) {\r\n            return null;\r\n        }\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param marker - The {@link MapMarkerDirective} for which to obtain the marker model.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} implementation of the underlying platform.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public GetNativeMarker(marker: MapMarkerDirective): Promise<Marker> {\r\n        return this._markers.get(marker);\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker pixel location for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the pixels of the marker on the map canvas.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public GetPixelsFromClick(e: MouseEvent | any): IPoint {\r\n        if (!e || !e.latLng || !e.latLng.lat || !e.latLng.lng) {\r\n            return null;\r\n        }\r\n        if (this._mapService.MapInstance == null) {\r\n            return null;\r\n        }\r\n\r\n        let crossesDateLine: boolean = false;\r\n        const m = this._mapService.MapInstance;\r\n        const p = m.getProjection();\r\n        const s: number = Math.pow(2, m.getZoom());\r\n        const b: GoogleMapTypes.LatLngBounds = m.getBounds();\r\n        if (b.getCenter().lng() < b.getSouthWest().lng()  ||\r\n            b.getCenter().lng() > b.getNorthEast().lng()) { crossesDateLine = true; }\r\n\r\n        const offsetY: number = p.fromLatLngToPoint(b.getNorthEast()).y;\r\n        const offsetX: number = p.fromLatLngToPoint(b.getSouthWest()).x;\r\n        const point: GoogleMapTypes.Point = p.fromLatLngToPoint(e.latLng);\r\n        return {\r\n            x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),\r\n            y: Math.floor((point.y - offsetY) * s)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts a geo location to a pixel location relative to the map canvas.\r\n     *\r\n     * @param target - Either a {@link MapMarkerDirective}\r\n     * or a {@link ILatLong} for the basis of translation.\r\n     * @returns - A promise that when fullfilled contains a {@link IPoint}\r\n     * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public LocationToPoint(target: MapMarkerDirective | ILatLong): Promise<IPoint> {\r\n        if (target == null) {\r\n            return Promise.resolve(null);\r\n        }\r\n        if (target instanceof MapMarkerDirective) {\r\n            return this._markers.get(target).then((m: Marker) => {\r\n                const l: ILatLong = m.Location;\r\n                const p: Promise<IPoint> = this._mapService.LocationToPoint(l);\r\n                return p;\r\n            });\r\n        }\r\n        return this._mapService.LocationToPoint(target);\r\n    }\r\n\r\n    /**\r\n     * Updates the anchor position for the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the anchor.\r\n     * Anchor information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the anchor position has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateAnchor(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            m.SetAnchor(marker.Anchor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates whether the marker is draggable.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate dragability.\r\n     * Dragability information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the marker has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateDraggable(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetDraggable(marker.Draggable));\r\n    }\r\n\r\n    /**\r\n     * Updates the Icon on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the icon. Icon information is present\r\n     * in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the icon information has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateIcon(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            if (marker.IconInfo) {\r\n                const x: IMarkerOptions = {\r\n                    position: { latitude: marker.Latitude, longitude: marker.Longitude },\r\n                    iconInfo: marker.IconInfo\r\n                };\r\n                const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(x);\r\n                m.SetIcon(o.icon);\r\n                marker.DynamicMarkerCreated.emit(x.iconInfo);\r\n            } else {\r\n                m.SetIcon(marker.IconUrl);\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the label on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the label.\r\n     * Label information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the label has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateLabel(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => { m.SetLabel(marker.Label); });\r\n    }\r\n\r\n    /**\r\n     * Updates the geo coordinates for the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the coordinates.\r\n     * Coordinate information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the position has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateMarkerPosition(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then(\r\n            (m: Marker) => m.SetPosition({\r\n                latitude: marker.Latitude,\r\n                longitude: marker.Longitude\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Updates the title on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateTitle(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetTitle(marker.Title));\r\n    }\r\n\r\n    /**\r\n     * Updates the visibility on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateVisible(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetVisible(marker.Visible));\r\n    }\r\n\r\n}\r\n","import { GoogleMarker } from './google-marker';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { MapService } from '../../services/map.service';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { InfoWindow } from '../info-window';\r\nimport { ClusterPlacementMode } from '../cluster-placement-mode';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { timer } from 'rxjs';\r\n\r\n/**\r\n * Concrete implementation of a clustering layer for the Google Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class GoogleMarkerClusterer implements Layer {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _isClustering = true;\r\n    private _markerLookup: Map<GoogleMapTypes.Marker, Marker> = new Map<GoogleMapTypes.Marker, Marker>();\r\n    private _markers: Array<Marker> = new Array<Marker>();\r\n    private _pendingMarkers: Array<Marker> = new Array<Marker>();\r\n    private _mapclicks: number = 0;\r\n    private _currentZoom: number = 0;\r\n    private _visible: boolean = true;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns GoogleMapTypes.MarkerClusterer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.MarkerClusterer {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the GoogleMarkerClusterer class.\r\n     *\r\n     * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    constructor(private _layer: GoogleMapTypes.MarkerClusterer) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        throw (new Error('Events are not supported on Google Cluster Layers. You can still add events to individual markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer. Use this method with caution as it will\r\n     * trigger a recaluation of the clusters (and associated markers if approprite) for\r\n     * each invocation. If you use this method to add many markers to the cluster, use\r\n     *\r\n     * @param entity Marker. Entity to add to the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public AddEntity(entity: Marker): void {\r\n        let isMarker: boolean = entity instanceof Marker;\r\n        isMarker = entity instanceof GoogleMarker || isMarker;\r\n        if (isMarker) {\r\n            entity.NativePrimitve.setMap(null);\r\n                // remove the marker from the map as the clusterer will control marker visibility.\r\n            if (entity.IsFirst) {\r\n                this.StopClustering();\r\n            }\r\n        }\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            if (this._isClustering && this._visible) {\r\n                this._layer.addMarker(entity.NativePrimitve);\r\n                this._markers.push(entity);\r\n            }\r\n            else {\r\n                this._pendingMarkers.push(entity);\r\n            }\r\n            this._markerLookup.set(entity.NativePrimitve, entity);\r\n        }\r\n        if (isMarker) {\r\n            if (entity.IsLast) {\r\n                this.StartClustering();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of markers to the layer.\r\n     *\r\n     * @param entities Array<Marker>. Entities to add to the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public AddEntities(entities: Array<Marker>): void {\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            const e: Array<GoogleMapTypes.Marker> = entities.map(p => {\r\n                this._markerLookup.set(p.NativePrimitve, p);\r\n                p.NativePrimitve.setMap(null);\r\n                    // remove the marker from the map as the clusterer will control marker visibility.\r\n                return p.NativePrimitve;\r\n            });\r\n            if (this._isClustering && this._visible) {\r\n                this._layer.addMarkers(e);\r\n                this._markers.push(...entities);\r\n            }\r\n            else {\r\n                // if layer is not visible, always add to pendingMarkers. Setting the layer to visible later\r\n                // will render the markers appropriately\r\n                this._pendingMarkers.push(...entities);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes the clustering layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public Delete(): void {\r\n        this._layer.getMarkers().forEach(m => {\r\n            m.setMap(null);\r\n                // remove the marker from the map as the clusterer will control marker visibility.\r\n        });\r\n        this._layer.clearMarkers();\r\n        this._markers.splice(0);\r\n        this._pendingMarkers.splice(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the abstract marker used to wrap the Google Marker.\r\n     *\r\n     * @returns Marker. The abstract marker object representing the pushpin.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public GetMarkerFromGoogleMarker(pin: GoogleMapTypes.Marker): Marker {\r\n        const m: Marker = this._markerLookup.get(pin);\r\n        return m;\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns IClusterOptions. The layer options.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public GetOptions(): IClusterOptions {\r\n        const options: IClusterOptions = {\r\n            id: 0,\r\n            gridSize: this._layer.getGridSize(),\r\n            clusteringEnabled: this._layer.getGridSize() === 0,\r\n            maxZoom: this._layer.getMaxZoom(),\r\n            minimumClusterSize: this._layer.getMinClusterSize(),\r\n            placementMode: this._layer.isAverageCenter() ? ClusterPlacementMode.MeanValue : ClusterPlacementMode.FirstPin,\r\n            visible: this._visible,\r\n            zoomOnClick: this._layer.isZoomOnClick(),\r\n            styles: this._layer.getStyles()\r\n        };\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._visible;\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the cluster layer.\r\n     *\r\n     * @param entity Marker Entity to be removed from the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public RemoveEntity(entity: Marker): void {\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            const j: number = this._markers.indexOf(entity);\r\n            const k: number = this._pendingMarkers.indexOf(entity);\r\n            if (j > -1) { this._markers.splice(j, 1); }\r\n            if (k > -1) { this._pendingMarkers.splice(k, 1); }\r\n            if (this._isClustering) {\r\n                this._layer.removeMarker(entity.NativePrimitve);\r\n            }\r\n            this._markerLookup.delete(entity.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker> containing\r\n     * the entities to add to the cluster. This replaces any existing entities.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetEntities(entities: Array<Marker>): void {\r\n        this._layer.getMarkers().forEach(m => {\r\n            m.setMap(null);\r\n        });\r\n        this._layer.clearMarkers();\r\n        this._markers.splice(0);\r\n        this._pendingMarkers.splice(0);\r\n        this._markerLookup.clear();\r\n\r\n        const p: Array<GoogleMapTypes.Marker> = new Array<GoogleMapTypes.Marker>();\r\n        entities.forEach((e: any) => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                e.NativePrimitve.setMap(null);\r\n                this._markerLookup.set(e.NativePrimitve, e);\r\n                if (this._visible) {\r\n                    this._markers.push(e);\r\n                    p.push(e.NativePrimitve);\r\n                }\r\n                else {\r\n                    this._pendingMarkers.push(e);\r\n                }\r\n            }\r\n        });\r\n        this._layer.addMarkers(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetOptions(options: IClusterOptions): void {\r\n        if (options.placementMode != null) {\r\n            throw(new Error('GoogleMarkerClusterer: PlacementMode option cannot be set after initial creation.'));\r\n        }\r\n        if (options.zoomOnClick != null) {\r\n            throw(new Error('GoogleMarkerClusterer: ZoomOnClick option cannot be set after initial creation.'));\r\n        }\r\n        if (options.callback != null) {}\r\n        if (options.clusteringEnabled != null) {\r\n            this._layer.setMinClusterSize(options.clusteringEnabled ? 1 : 10000000);\r\n            this._layer.resetViewport();\r\n            this._layer.redraw();\r\n        }\r\n        if (options.gridSize != null && (options.clusteringEnabled == null || options.clusteringEnabled)) {\r\n            this._layer.setGridSize(options.gridSize);\r\n            this._layer.resetViewport();\r\n            this._layer.redraw();\r\n        }\r\n        if (options.maxZoom != null) { this._layer.setMaxZoom(options.maxZoom); }\r\n        if (options.minimumClusterSize != null) { this._layer.setMinClusterSize(options.minimumClusterSize); }\r\n        if (options.styles != null) { this._layer.setStyles(options.styles); }\r\n        if (options.visible != null) { this.SetVisible(options.visible); }\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        const map: GoogleMapTypes.GoogleMap = visible ? this._layer.getMap() : null;\r\n        if (!visible) {\r\n            this._layer.resetViewport(true);\r\n        }\r\n        else {\r\n            const p: Array<GoogleMapTypes.Marker> = new Array<GoogleMapTypes.Marker>();\r\n            if (this._pendingMarkers.length > 0) {\r\n                this._pendingMarkers.forEach(e => {\r\n                    if (e.NativePrimitve && e.Location) {\r\n                        p.push(<GoogleMapTypes.Marker>e.NativePrimitve);\r\n                    }\r\n                });\r\n                this._layer.addMarkers(p);\r\n                this._markers = this._markers.concat(this._pendingMarkers.splice(0));\r\n            }\r\n            else {\r\n                this._layer.redraw();\r\n            }\r\n        }\r\n        this._visible = visible;\r\n    }\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public StartClustering(): void {\r\n        if (this._isClustering) { return; }\r\n\r\n        if (this._visible) {\r\n            const p: Array<GoogleMapTypes.Marker> = new Array<GoogleMapTypes.Marker>();\r\n            this._markers.forEach(e => {\r\n                if (e.NativePrimitve && e.Location) {\r\n                    p.push(<GoogleMapTypes.Marker>e.NativePrimitve);\r\n                }\r\n            });\r\n            this._pendingMarkers.forEach(e => {\r\n                if (e.NativePrimitve && e.Location) {\r\n                    p.push(<GoogleMapTypes.Marker>e.NativePrimitve);\r\n                }\r\n            });\r\n            this._layer.addMarkers(p);\r\n            this._markers = this._markers.concat(this._pendingMarkers.splice(0));\r\n        }\r\n\r\n        if (!this._visible) {\r\n            // only add the markers if the layer is visible. Otherwise, keep them pending. They would be added once the\r\n            // layer is set to visible.\r\n            timer(0).subscribe(() => {\r\n                this._layer.resetViewport(true);\r\n            });\r\n        }\r\n        this._isClustering = true;\r\n    }\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @returns\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public StopClustering() {\r\n        if (!this._isClustering) { return; }\r\n        this._isClustering = false;\r\n    }\r\n}\r\n","import { GoogleMarkerClusterer } from '../../models/google/google-marker-clusterer';\r\nimport { GoogleInfoWindow } from '../../models/google/google-info-window';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader } from '../mapapiloader';\r\nimport { GoogleMapAPILoader, GoogleMapAPILoaderConfig } from './google-map-api-loader.service';\r\nimport { GoogleClusterService } from './google-cluster.service';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IMapOptions } from '../../interfaces/imap-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { ISize } from '../../interfaces/isize';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { MapTypeId } from '../../models/map-type-id';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MixinMapLabelWithOverlayView } from '../../models/google/google-label';\r\nimport { MixinCanvasOverlay } from '../../models/google/google-canvas-overlay';\r\nimport { GoogleCanvasOverlay } from '../../models/google/google-canvas-overlay';\r\nimport { CanvasOverlay } from '../../models/canvas-overlay';\r\nimport { Layer } from '../../models/layer';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { GooglePolygon } from '../../models/google/google-polygon';\r\nimport { GooglePolyline } from '../../models/google/google-polyline';\r\nimport { GoogleConversions } from './google-conversions';\r\nimport { GoogleMarker } from '../../models/google/google-marker';\r\nimport { GoogleLayer } from '../../models/google/google-layer';\r\nimport { IBox } from '../../interfaces/ibox';\r\nimport { GoogleMapEventsLookup } from '../../models/google/google-events-lookup';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\ndeclare const google: any;\r\ndeclare const MarkerClusterer: any;\r\n\r\n/**\r\n * Concrete implementation of the MapService abstract implementing a Google Maps provider\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapService implements MapService {\r\n\r\n    ///\r\n    /// Field Declarations\r\n    ///\r\n\r\n    private _map: Promise<GoogleMapTypes.GoogleMap>;\r\n    private _mapInstance: GoogleMapTypes.GoogleMap;\r\n    private _mapResolver: (value?: GoogleMapTypes.GoogleMap) => void;\r\n    private _config: GoogleMapAPILoaderConfig;\r\n\r\n    ///\r\n    /// Property Definitions\r\n    ///\r\n\r\n\r\n    /**\r\n     * Gets the Google Map control instance underlying the implementation\r\n     *\r\n     * @readonly\r\n     * @memberof GoogleMapService\r\n     */\r\n    public get MapInstance(): GoogleMapTypes.GoogleMap { return this._mapInstance; }\r\n\r\n    /**\r\n     * Gets a Promise for a Google Map control instance underlying the implementation. Use this instead of {@link MapInstance} if you\r\n     * are not sure if and when the instance will be created.\r\n     * @readonly\r\n     * @memberof GoogleMapService\r\n     */\r\n    public get MapPromise(): Promise<GoogleMapTypes.GoogleMap> { return this._map; }\r\n\r\n    /**\r\n     * Gets the maps physical size.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapSize(): ISize {\r\n        if (this.MapInstance) {\r\n            const el: HTMLDivElement = this.MapInstance.getDiv();\r\n            const s: ISize = { width: el.offsetWidth, height: el.offsetHeight };\r\n            return s;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMapService.\r\n     * @param _loader MapAPILoader instance implemented for Google Maps. This instance will generally be injected.\r\n     * @param _zone NgZone object to enable zone aware promises. This will generally be injected.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) {\r\n        this._map = new Promise<GoogleMapTypes.GoogleMap>(\r\n            (resolve: (map: GoogleMapTypes.GoogleMap) => void) => { this._mapResolver = resolve; }\r\n        );\r\n        this._config = (<GoogleMapAPILoader>this._loader).Config;\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapService interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Creates a canvas overlay layer to perform custom drawing over the map with out\r\n     * some of the overhead associated with going through the Map objects.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @returns - Promise of a {@link CanvasOverlay} object.\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateCanvasOverlay(drawCallback: (canvas: HTMLCanvasElement) => void): Promise<CanvasOverlay> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const overlay: GoogleCanvasOverlay = new GoogleCanvasOverlay(drawCallback);\r\n            overlay.SetMap(map);\r\n            return overlay;\r\n        });\r\n    }\r\n\r\n    /*\r\n     * Creates a Google map cluster layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link IClusterOptions}.\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateClusterLayer(options: IClusterOptions): Promise<Layer> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            let updateOptions: boolean = false;\r\n            const markerClusterer: GoogleMapTypes.MarkerClusterer = new MarkerClusterer(map, [], options);\r\n            const clusterLayer = new GoogleMarkerClusterer(markerClusterer);\r\n            const o: IClusterOptions = {\r\n                id: options.id\r\n            };\r\n            if (!options.visible) {\r\n                o.visible = false;\r\n                updateOptions = true;\r\n            }\r\n            if (!options.clusteringEnabled) {\r\n                o.clusteringEnabled = false;\r\n                updateOptions = true;\r\n            }\r\n            if (updateOptions) {\r\n                clusterLayer.SetOptions(o);\r\n            }\r\n            return clusterLayer;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an information window for a map position\r\n     *\r\n     * @param [options] - Infowindow options. See {@link IInfoWindowOptions}\r\n     * @returns - Promise of a {@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateInfoWindow(options?: IInfoWindowOptions): Promise<GoogleInfoWindow> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.InfoWindowOptions = GoogleConversions.TranslateInfoWindowOptions(options);\r\n            const infoWindow: GoogleMapTypes.InfoWindow = new google.maps.InfoWindow(o);\r\n            return new GoogleInfoWindow(infoWindow, this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link ILayerOptions}\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.Layer object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateLayer(options: ILayerOptions): Promise<Layer> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n             return new GoogleLayer(map, this, options.id);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map instance\r\n     *\r\n     * @param el - HTML element to host the map.\r\n     * @param mapOptions - Map options\r\n     * @returns - Promise fullfilled once the map has been created.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateMap(el: HTMLElement, mapOptions: IMapOptions): Promise<void> {\r\n        return this._loader.Load().then(() => {\r\n            // apply mixins\r\n            MixinMapLabelWithOverlayView();\r\n            MixinCanvasOverlay();\r\n\r\n            // execute map startup\r\n            if (!mapOptions.mapTypeId == null) { mapOptions.mapTypeId = MapTypeId.hybrid; }\r\n            if (this._mapInstance != null) {\r\n                this.DisposeMap();\r\n            }\r\n            const o: GoogleMapTypes.MapOptions = GoogleConversions.TranslateOptions(mapOptions);\r\n            const map: GoogleMapTypes.GoogleMap = new google.maps.Map(el, o);\r\n            if (mapOptions.bounds) {\r\n                map.fitBounds(GoogleConversions.TranslateBounds(mapOptions.bounds));\r\n            }\r\n            this._mapInstance = map;\r\n            this._mapResolver(map);\r\n            return;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a Google map marker within the map context\r\n     *\r\n     * @param [options=<IMarkerOptions>{}] - Options for the marker. See {@link IMarkerOptions}.\r\n     * @returns - Promise of a {@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateMarker(options: IMarkerOptions = <IMarkerOptions>{}): Promise<Marker> {\r\n        const payload = (x: GoogleMapTypes.MarkerOptions, map: GoogleMapTypes.GoogleMap): GoogleMarker => {\r\n            const marker = new google.maps.Marker(x);\r\n            const m = new GoogleMarker(marker);\r\n            m.IsFirst = options.isFirst;\r\n            m.IsLast = options.isLast;\r\n            if (options.metadata) { options.metadata.forEach((val: any, key: string) => m.Metadata.set(key, val)); }\r\n            marker.setMap(map);\r\n            return m;\r\n        };\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(options);\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof(s) === 'string') {\r\n                    o.icon = s;\r\n                    return payload(o, map);\r\n                }\r\n                else {\r\n                    return s.then(x => {\r\n                        o.icon = x.icon;\r\n                        return payload(o, map);\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return payload(o, map);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon within the Google Map map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polygon. See {@link IPolygonOptions}.\r\n     * @returns - Promise of a {@link Polygon} object, which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolygon(options: IPolygonOptions): Promise<Polygon> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.PolygonOptions = GoogleConversions.TranslatePolygonOptions(options);\r\n            const polygon: GoogleMapTypes.Polygon = new google.maps.Polygon(o);\r\n            polygon.setMap(map);\r\n\r\n            const p: GooglePolygon = new GooglePolygon(polygon);\r\n            if (options.metadata) { options.metadata.forEach((val: any, key: string) => p.Metadata.set(key, val)); }\r\n            if (options.title && options.title !== '') { p.Title = options.title; }\r\n            if (options.showLabel != null) { p.ShowLabel = options.showLabel; }\r\n            if (options.showTooltip != null) { p.ShowTooltip = options.showTooltip; }\r\n            if (options.labelMaxZoom != null) { p.LabelMaxZoom = options.labelMaxZoom; }\r\n            if (options.labelMinZoom != null) { p.LabelMinZoom = options.labelMinZoom; }\r\n            return p;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polyline within the Google Map map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polyline. See {@link IPolylineOptions}.\r\n     * @returns - Promise of a {@link Polyline} object (or an array therefore for complex paths)\r\n     * which models the underlying native polyline.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolyline(options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        let polyline: GoogleMapTypes.Polyline;\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.PolylineOptions = GoogleConversions.TranslatePolylineOptions(options);\r\n            if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {\r\n                o.path = GoogleConversions.TranslatePaths(options.path)[0];\r\n                polyline = new google.maps.Polyline(o);\r\n                polyline.setMap(map);\r\n\r\n                const pl = new GooglePolyline(polyline);\r\n                if (options.metadata) { options.metadata.forEach((val: any, key: string) => pl.Metadata.set(key, val)); }\r\n                if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                return pl;\r\n            }\r\n            else {\r\n                const paths: Array<Array<GoogleMapTypes.LatLng>> = GoogleConversions.TranslatePaths(options.path);\r\n                const lines: Array<Polyline> = new Array<Polyline>();\r\n                paths.forEach(p => {\r\n                    o.path = p;\r\n                    polyline = new google.maps.Polyline(o);\r\n                    polyline.setMap(map);\r\n\r\n                    const pl = new GooglePolyline(polyline);\r\n                    if (options.metadata) { options.metadata.forEach((val: any, key: string) => pl.Metadata.set(key, val)); }\r\n                    if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                    if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                    lines.push(pl);\r\n                });\r\n                return lines;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a layer from the map.\r\n     *\r\n     * @param layer - Layer to delete. See {@link Layer}. This method expects the Google specific Layer model implementation.\r\n     * @returns - Promise fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public DeleteLayer(layer: Layer): Promise<void> {\r\n        // return resolved promise as there is no conept of a custom layer in Google.\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Dispaose the map and associated resoures.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public DisposeMap(): void {\r\n        if (this._map == null && this._mapInstance == null) { return; }\r\n        if (this._mapInstance != null) {\r\n            this._mapInstance = null;\r\n            this._map = new Promise<GoogleMapTypes.GoogleMap>((resolve: () => void) => { this._mapResolver = resolve; });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map center\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the center. See {@link ILatLong}.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public GetCenter(): Promise<ILatLong> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const center: GoogleMapTypes.LatLng = map.getCenter();\r\n            return <ILatLong>{\r\n                latitude: center.lat(),\r\n                longitude: center.lng()\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map bounding box\r\n     *\r\n     * @returns - A promise that when fullfilled contains the geo location of the bounding box. See {@link IBox}.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public GetBounds(): Promise<IBox> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const box = map.getBounds();\r\n            return <IBox>{\r\n                maxLatitude: box.getNorthEast().lat(),\r\n                maxLongitude: Math.max(box.getNorthEast().lng(), box.getSouthWest().lng()),\r\n                minLatitude: box.getSouthWest().lat(),\r\n                minLongitude: Math.min(box.getNorthEast().lng(), box.getSouthWest().lng()),\r\n                center: { latitude: box.getCenter().lat(), longitude: box.getCenter().lng() },\r\n                padding: 0\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current zoom level of the map.\r\n     *\r\n     * @returns - A promise that when fullfilled contains the zoom level.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public GetZoom(): Promise<number> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => map.getZoom());\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface representing the pixels. This promise resolves to null\r\n     * if the goe coordinates are not in the view port.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public LocationToPoint(loc: ILatLong): Promise<IPoint> {\r\n        return this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            let crossesDateLine: boolean = false;\r\n            const l: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(loc);\r\n            const p = m.getProjection();\r\n            const s: number = Math.pow(2, m.getZoom());\r\n            const b: GoogleMapTypes.LatLngBounds = m.getBounds();\r\n            if (b.getCenter().lng() < b.getSouthWest().lng()  ||\r\n                b.getCenter().lng() > b.getNorthEast().lng()) { crossesDateLine = true; }\r\n\r\n\r\n            const offsetY: number = p.fromLatLngToPoint(b.getNorthEast()).y;\r\n            const offsetX: number = p.fromLatLngToPoint(b.getSouthWest()).x;\r\n            const point: GoogleMapTypes.Point = p.fromLatLngToPoint(l);\r\n            return {\r\n                x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),\r\n                y: Math.floor((point.y - offsetY) * s)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface array representing the pixels.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public LocationsToPoints(locs: Array<ILatLong>): Promise<Array<IPoint>> {\r\n        return this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            let crossesDateLine: boolean = false;\r\n            const p = m.getProjection();\r\n            const s: number = Math.pow(2, m.getZoom());\r\n            const b: GoogleMapTypes.LatLngBounds = m.getBounds();\r\n            if (b.getCenter().lng() < b.getSouthWest().lng()  ||\r\n                b.getCenter().lng() > b.getNorthEast().lng()) { crossesDateLine = true; }\r\n\r\n            const offsetX: number = p.fromLatLngToPoint(b.getSouthWest()).x;\r\n            const offsetY: number = p.fromLatLngToPoint(b.getNorthEast()).y;\r\n            const l = locs.map(ll => {\r\n                const l1: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(ll);\r\n                const point: GoogleMapTypes.Point = p.fromLatLngToPoint(l1);\r\n                return {\r\n                    x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),\r\n                    y: Math.floor((point.y - offsetY) * s)\r\n                };\r\n            });\r\n            return l;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Centers the map on a geo location.\r\n     *\r\n     * @param latLng - GeoCoordinates around which to center the map. See {@link ILatLong}\r\n     * @returns - Promise that is fullfilled when the center operations has been completed.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetCenter(latLng: ILatLong): Promise<void> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const center: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(latLng);\r\n            map.setCenter(center);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the generic map options.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetMapOptions(options: IMapOptions) {\r\n        this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.MapOptions = GoogleConversions.TranslateOptions(options);\r\n            m.setOptions(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the view options of the map.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetViewOptions(options: IMapOptions) {\r\n        this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            if (options.bounds) {\r\n                m.fitBounds(GoogleConversions.TranslateBounds(options.bounds));\r\n            }\r\n            const o: GoogleMapTypes.MapOptions = GoogleConversions.TranslateOptions(options);\r\n            m.setOptions(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the zoom level of the map.\r\n     *\r\n     * @param zoom - Zoom level to set.\r\n     * @returns - A Promise that is fullfilled once the zoom operation is complete.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetZoom(zoom: number): Promise<void> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => map.setZoom(zoom));\r\n    }\r\n\r\n    /**\r\n     * Creates an event subscription\r\n     *\r\n     * @param eventName - The name of the event (e.g. 'click')\r\n     * @returns - An observable of type E that fires when the event occurs.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SubscribeToMapEvent<E>(eventName: string): Observable<E> {\r\n        const googleEventName: string = GoogleMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<E>) => {\r\n            this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n                m.addListener(googleEventName, (e: any) => {\r\n                    this._zone.run(() => observer.next(e));\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Triggers the given event name on the map instance.\r\n     *\r\n     * @param eventName - Event to trigger.\r\n     * @returns - A promise that is fullfilled once the event is triggered.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public TriggerMapEvent(eventName: string): Promise<void> {\r\n        return this._map.then((m) => google.maps.event.trigger(m, eventName, null));\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { MapPolygonDirective } from '../../components/map-polygon';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n/**\r\n * Concrete implementation of the Polygon Service abstract class for Google Maps.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GooglePolygonService implements PolygonService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polygons: Map<MapPolygonDirective, Promise<Polygon>> = new Map<MapPolygonDirective, Promise<Polygon>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GooglePolygonService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.\r\n     * @param _layerService - {@link GoogleLayerService} instance.\r\n     * The concrete {@link GoogleLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a\r\n     * correcsponding layer.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} to be added.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public AddPolygon(polygon: MapPolygonDirective): void {\r\n        const o: IPolygonOptions = {\r\n            id: polygon.Id,\r\n            clickable: polygon.Clickable,\r\n            draggable: polygon.Draggable,\r\n            editable: polygon.Editable,\r\n            fillColor: polygon.FillColor,\r\n            fillOpacity: polygon.FillOpacity,\r\n            geodesic: polygon.Geodesic,\r\n            labelMaxZoom: polygon.LabelMaxZoom,\r\n            labelMinZoom: polygon.LabelMinZoom,\r\n            paths: polygon.Paths,\r\n            showLabel: polygon.ShowLabel,\r\n            showTooltip: polygon.ShowTooltip,\r\n            strokeColor: polygon.StrokeColor,\r\n            strokeOpacity: polygon.StrokeOpacity,\r\n            strokeWeight: polygon.StrokeWeight,\r\n            title: polygon.Title,\r\n            visible: polygon.Visible,\r\n            zIndex: polygon.zIndex,\r\n        };\r\n        const polygonPromise: Promise<Polygon> = this._mapService.CreatePolygon(o);\r\n        this._polygons.set(polygon, polygonPromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a polygon.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polygon - The {@link MapPolygonDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof GooglePolygonService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polygon: MapPolygonDirective): Observable<T> {\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polygons.get(polygon).then((p: Polygon) => {\r\n                p.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polygon.\r\n      *\r\n      * @param polygon - {@link MapPolygonDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polygon has been deleted.\r\n      *\r\n      * @memberof GooglePolygonService\r\n      */\r\n    public DeletePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) => {\r\n            return this._zone.run(() => {\r\n                l.Delete();\r\n                this._polygons.delete(polygon);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the polygon on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} for which to obtain the polygon model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polygon} implementation of the underlying platform.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public GetNativePolygon(polygon: MapPolygonDirective): Promise<Polygon> {\r\n        return this._polygons.get(polygon);\r\n    }\r\n\r\n    /**\r\n     * Set the polygon options.\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @param options - {@link IPolygonOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polygon options have been set.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public SetOptions(polygon: MapPolygonDirective, options: IPolygonOptions): Promise<void> {\r\n        return this._polygons.get(polygon).then((l: Polygon) => { l.SetOptions(options); });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polygon path\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polygon has been updated.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public UpdatePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) => {\r\n            if (Array.isArray(polygon.Paths[0])) {\r\n                l.SetPaths(polygon.Paths);\r\n            }\r\n            else {\r\n                l.SetPath(<Array<ILatLong>>polygon.Paths);\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MapPolylineDirective } from '../../components/map-polyline';\r\nimport { PolylineService } from '../polyline.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n\r\n/**\r\n * Concrete implementation of the Polyline Service abstract class for Google Maps.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GooglePolylineService implements PolylineService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polylines: Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>> =\r\n        new Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GooglePolylineService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link GoogleLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a\r\n     * correcsponding layer.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} to be added.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public AddPolyline(polyline: MapPolylineDirective): void {\r\n        const o: IPolylineOptions = {\r\n            id: polyline.Id,\r\n            clickable: polyline.Clickable,\r\n            draggable: polyline.Draggable,\r\n            editable: polyline.Editable,\r\n            geodesic: polyline.Geodesic,\r\n            path: polyline.Path,\r\n            showTooltip: polyline.ShowTooltip,\r\n            strokeColor: polyline.StrokeColor,\r\n            strokeOpacity: polyline.StrokeOpacity,\r\n            strokeWeight: polyline.StrokeWeight,\r\n            title: polyline.Title,\r\n            visible: polyline.Visible,\r\n            zIndex: polyline.zIndex,\r\n        };\r\n        const polylinePromise: Promise<Polyline|Array<Polyline>> = this._mapService.CreatePolyline(o);\r\n        this._polylines.set(polyline, polylinePromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a line.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polyline - The {@link MapPolylineDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof GooglePolylineService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polyline: MapPolylineDirective): Observable<T> {\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polylines.get(polyline).then(p => {\r\n                const x: Array<Polyline> = Array.isArray(p) ? p : [p];\r\n                x.forEach(line => line.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e))));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polyline.\r\n      *\r\n      * @param polyline - {@link MapPolylineDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polyline has been deleted.\r\n      *\r\n      * @memberof GooglePolylineService\r\n      */\r\n    public DeletePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then(l => {\r\n            return this._zone.run(() => {\r\n                const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n                x.forEach(line =>  line.Delete());\r\n                this._polylines.delete(polyline);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the line on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked line.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        if (!e) {\r\n            return null;\r\n        }\r\n        if (!e.latLng) {\r\n            return null;\r\n        }\r\n        if (!e.latLng.lat || !e.latLng.lng) {\r\n            return null;\r\n        }\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Obtains the polyline model for the line allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} for which to obtain the polyline model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polyline}\r\n     * implementation of the underlying platform. For complex paths, returns an array of polylines.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public GetNativePolyline(polyline: MapPolylineDirective): Promise<Polyline|Array<Polyline>> {\r\n        return this._polylines.get(polyline);\r\n    }\r\n\r\n    /**\r\n     * Set the polyline options.\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @param options - {@link IPolylineOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polyline options have been set.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public SetOptions(polyline: MapPolylineDirective, options: IPolylineOptions): Promise<void> {\r\n        return this._polylines.get(polyline).then(l => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            x.forEach(line => line.SetOptions(options));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polyline path\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polyline has been updated.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public UpdatePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then(l => this._zone.run(() => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            const p: Array<Array<ILatLong>> =\r\n                polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? <Array<Array<ILatLong>>>polyline.Path :\r\n                <Array<Array<ILatLong>>>[polyline.Path];\r\n            x.forEach((line, index) => {\r\n                if (p.length > index) { line.SetPath(p[index]); }\r\n            });\r\n            if (Array.isArray(l) && l.length > p.length) {\r\n                l.splice(p.length - 1).forEach(line => line.Delete());\r\n            }\r\n        }));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { MapServiceFactory } from '../mapservicefactory';\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\nimport { MarkerService } from '../marker.service';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { LayerService } from '../layer.service';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { PolylineService } from '../polyline.service';\r\n\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\nimport { GoogleMapAPILoader, GoogleMapAPILoaderConfig } from './google-map-api-loader.service';\r\nimport { GoogleInfoBoxService } from './google-infobox.service';\r\nimport { GoogleMarkerService } from './google-marker.service';\r\nimport { GoogleMapService } from './google-map.service';\r\nimport { GoogleLayerService } from './google-layer.service';\r\nimport { GoogleClusterService } from './google-cluster.service';\r\nimport { GooglePolygonService } from './google-polygon.service';\r\nimport { GooglePolylineService } from './google-polyline.service';\r\n\r\n/**\r\n * Implements a factory to create three necessary Google Maps specific service instances.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapServiceFactory implements MapServiceFactory {\r\n    private _map: Promise<GoogleMapTypes.GoogleMap>;\r\n    private _mapResolver: (value?: GoogleMapTypes.GoogleMap) => void;\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMapServiceFactory.\r\n     * @param _loader - {@link MapAPILoader} implementation for the Google Map provider.\r\n     * @param _zone - NgZone object to implement zone aware promises.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) {\r\n        this._map =\r\n            new Promise<GoogleMapTypes.GoogleMap>((resolve: () => void) => { this._mapResolver = resolve; });\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapServiceFactory implementation.\r\n    ///\r\n\r\n    /**\r\n     * Creates the map service for the Google Maps implementation.\r\n     *\r\n     * @returns - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public Create(): MapService {\r\n        return new GoogleMapService(this._loader, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the cluster service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @returns - {@link ClusterService}. A concreted instance of the {@link GoogleClusterService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateClusterService(_mapService: MapService): ClusterService {\r\n        return new GoogleClusterService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates thh info box service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @param map - {@link MarkerService}. A concreted instance of the {@link GoogleMarkerService}.\r\n     * @returns - {@link InfoBoxService}. A concreted instance of the {@link GoogleInfoBoxService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateInfoBoxService(_mapService: MapService, _markerService: MarkerService) {\r\n        return new GoogleInfoBoxService(_mapService, _markerService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the layer service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @returns - {@link LayerService}. A concreted instance of the {@link GoogleLayerService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateLayerService(_mapService: MapService) {\r\n        return new GoogleLayerService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the marker service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @param layers - {@link LayerService}. A concreted instance of the {@link GoogleLayerService}.\r\n     * @param clusters  - {@link ClusterService}. A concreted instance of the {@link GoogleClusterService}.\r\n     * @returns - {@link MarkerService}. A concreted instance of the {@link GoogleMarkerService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateMarkerService(_mapService: MapService, _layerService: GoogleLayerService, _clusterService: GoogleClusterService) {\r\n        return new GoogleMarkerService(_mapService, _layerService, _clusterService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolygonService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolygonService(map: MapService, layers: LayerService): PolygonService {\r\n        return new GooglePolygonService(map, layers, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polyline service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolylineService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolylineService(map: MapService, layers: LayerService): PolylineService {\r\n        return new GooglePolylineService(map, layers, this._zone);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *  Creates a new instance of a plaform specific MapServiceFactory.\r\n *\r\n * @param apiLoader - An {@link MapAPILoader} instance. This is expected to the a {@link GoogleMapAPILoader}.\r\n * @param zone - An NgZone instance to provide zone aware promises.\r\n *\r\n * @returns - A {@link MapServiceFactory} instance.\r\n */\r\nexport function GoogleMapServiceFactoryFactory(apiLoader: MapAPILoader, zone: NgZone): MapServiceFactory {\r\n    return new GoogleMapServiceFactory(apiLoader, zone);\r\n}\r\n\r\n/**\r\n * Creates a new instance of a plaform specific MapLoaderFactory.\r\n *\r\n * @export\r\n * @returns - A {@link MapAPILoader} instance.\r\n */\r\nexport function GoogleMapLoaderFactory(): MapAPILoader {\r\n    return new GoogleMapAPILoader(new GoogleMapAPILoaderConfig(), new WindowRef(), new DocumentRef());\r\n}\r\n","import { NgModule, ModuleWithProviders, NgZone } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport 'bingmaps';\r\n\r\n///\r\n/// import module interfaces\r\n///\r\nimport { ILatLong } from './src/interfaces/ilatlong';\r\nimport { IInfoWindowOptions } from './src/interfaces/iinfo-window-options';\r\nimport { IInfoWindowAction } from './src/interfaces/iinfo-window-action';\r\nimport { IMarkerOptions } from './src/interfaces/imarker-options';\r\nimport { IMapOptions } from './src/interfaces/imap-options';\r\nimport { ISize } from './src/interfaces/isize';\r\nimport { IPoint } from './src/interfaces/ipoint';\r\nimport { IBox } from './src/interfaces/ibox';\r\nimport { IMarkerEvent } from './src/interfaces/imarker-event';\r\nimport { IMarkerIconInfo } from './src/interfaces/imarker-icon-info';\r\nimport { ILayerOptions } from './src/interfaces/ilayer-options';\r\nimport { IClusterOptions } from './src/interfaces/icluster-options';\r\nimport { ISpiderClusterOptions } from './src/interfaces/ispider-cluster-options';\r\nimport { ILineOptions } from './src/interfaces/iline-options';\r\nimport { IPolygonOptions } from './src/interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from './src/interfaces/ipolyline-options';\r\nimport { IPolygonEvent } from './src/interfaces/ipolygon-event';\r\nimport { IPolylineEvent } from './src/interfaces/ipolyline-event';\r\nimport { IMapEventLookup } from './src/interfaces/imap-event-lookup';\r\nimport { ILabelOptions } from './src/interfaces/ilabel-options';\r\nimport { ICustomMapStyle} from './src/interfaces/icustom-map-style';\r\n\r\n///\r\n/// import module models\r\n///\r\nimport { InfoWindow } from './src/models/info-window';\r\nimport { Marker } from './src/models/marker';\r\nimport { MarkerTypeId } from './src/models/marker-type-id';\r\nimport { MapTypeId } from './src/models/map-type-id';\r\nimport { Layer } from './src/models/layer';\r\nimport { Polygon } from './src/models/polygon';\r\nimport { Polyline } from './src/models/polyline';\r\nimport { SpiderClusterMarker } from './src/models/spider-cluster-marker';\r\nimport { ClusterPlacementMode } from './src/models/cluster-placement-mode';\r\nimport { ClusterClickAction } from './src/models/cluster-click-action';\r\nimport { CanvasOverlay} from './src/models/canvas-overlay';\r\nimport { BingLayer } from './src/models/bing/bing-layer';\r\nimport { BingClusterLayer } from './src/models/bing/bing-cluster-layer';\r\nimport { BingSpiderClusterMarker } from './src/models/bing/bing-spider-cluster-marker';\r\nimport { BingInfoWindow } from './src/models/bing/bing-info-window';\r\nimport { BingMarker } from './src/models/bing/bing-marker';\r\nimport { BingPolygon } from './src/models/bing/bing-polygon';\r\nimport { BingPolyline } from './src/models/bing/bing-polyline';\r\nimport { BingMapEventsLookup } from './src/models/bing/bing-events-lookup';\r\nimport { BingCanvasOverlay } from './src/models/bing/bing-canvas-overlay';\r\nimport { GoogleInfoWindow } from './src/models/google/google-info-window';\r\nimport { GoogleMarker } from './src/models/google/google-marker';\r\nimport { GooglePolygon } from './src/models/google/google-polygon';\r\nimport { GooglePolyline } from './src/models/google/google-polyline';\r\nimport { GoogleMapEventsLookup } from './src/models/google/google-events-lookup';\r\nimport { GoogleCanvasOverlay } from './src/models/google/google-canvas-overlay';\r\n\r\n///\r\n/// import module components\r\n///\r\nimport { MapComponent } from './src/components/map';\r\nimport { MapMarkerDirective } from './src/components/map-marker';\r\nimport { InfoBoxComponent } from './src/components/infobox';\r\nimport { InfoBoxActionDirective } from './src/components/infobox-action';\r\nimport { MapLayerDirective } from './src/components/map-layer';\r\nimport { ClusterLayerDirective } from './src/components/cluster-layer';\r\nimport { MapPolygonDirective } from './src/components/map-polygon';\r\nimport { MapPolylineDirective } from './src/components/map-polyline';\r\nimport { MapMarkerLayerDirective } from './src/components/map-marker-layer';\r\nimport { MapPolygonLayerDirective } from './src/components/map-polygon-layer';\r\nimport { MapPolylineLayerDirective } from './src/components/map-polyline-layer';\r\n\r\n///\r\n/// import module services\r\n///\r\nimport { MapServiceFactory } from './src/services/mapservicefactory';\r\nimport { MapService } from './src/services/map.service';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from './src/services/mapapiloader';\r\nimport { InfoBoxService } from './src/services/infobox.service';\r\nimport { LayerService } from './src/services/layer.service';\r\nimport { MarkerService } from './src/services/marker.service';\r\nimport { ClusterService } from './src/services/cluster.service';\r\nimport { PolygonService } from './src/services/polygon.service';\r\nimport { PolylineService } from './src/services/polyline.service';\r\nimport { BingMapServiceFactory,\r\n    BingMapServiceFactoryFactory, BingMapLoaderFactory } from './src/services/bing/bing-map.service.factory';\r\nimport { BingMapService } from './src/services/bing/bing-map.service';\r\nimport { BingMapAPILoader, BingMapAPILoaderConfig } from './src/services/bing/bing-map.api-loader.service';\r\nimport { BingInfoBoxService } from './src/services/bing/bing-infobox.service';\r\nimport { BingMarkerService } from './src/services/bing/bing-marker.service';\r\nimport { BingLayerService } from './src/services/bing/bing-layer.service';\r\nimport { BingClusterService } from './src/services/bing/bing-cluster.service';\r\nimport { BingPolygonService } from './src/services/bing/bing-polygon.service';\r\nimport { BingPolylineService } from './src/services/bing/bing-polyline.service';\r\nimport { GoogleClusterService } from './src/services/google/google-cluster.service';\r\nimport { GoogleInfoBoxService } from './src/services/google/google-infobox.service';\r\nimport { GoogleLayerService } from './src/services/google/google-layer.service';\r\nimport { GoogleMapAPILoader, GoogleMapAPILoaderConfig } from './src/services/google/google-map-api-loader.service';\r\nimport {\r\n    GoogleMapServiceFactory, GoogleMapServiceFactoryFactory,\r\n    GoogleMapLoaderFactory\r\n} from './src/services/google/google-map.service.factory';\r\nimport { GoogleMapService } from './src/services/google/google-map.service';\r\nimport { GoogleMarkerService } from './src/services/google/google-marker.service';\r\nimport { GooglePolygonService } from './src/services/google/google-polygon.service';\r\nimport { GooglePolylineService } from './src/services/google/google-polyline.service';\r\n\r\n///\r\n/// export publics components, models, interfaces etc for external reuse.\r\n///\r\nexport {\r\n    ILatLong, IInfoWindowOptions, IInfoWindowAction, ISize, IMarkerOptions, IBox, IMapOptions, IPoint, IMarkerEvent, IPolygonEvent,\r\n    IPolylineEvent, IMapEventLookup, IMarkerIconInfo, ILayerOptions, IClusterOptions, ISpiderClusterOptions, ILineOptions,\r\n    IPolygonOptions, IPolylineOptions, ILabelOptions, ICustomMapStyle, MapComponent, InfoBoxComponent, MapMarkerDirective, MapPolygonDirective,\r\n    MapPolylineDirective, InfoBoxActionDirective, MapMarkerLayerDirective, MapPolygonLayerDirective, MapLayerDirective,\r\n    ClusterLayerDirective, MapPolylineLayerDirective, MapTypeId, Marker, MarkerTypeId, InfoWindow, Layer, ClusterPlacementMode,\r\n    ClusterClickAction, SpiderClusterMarker, Polygon, Polyline, CanvasOverlay, MapService, MapServiceFactory, MarkerService,\r\n    InfoBoxService, MapAPILoader, WindowRef, DocumentRef, LayerService, PolygonService, PolylineService, ClusterService\r\n};\r\nexport {\r\n    BingMapServiceFactory, BingMapAPILoaderConfig, BingMapService, BingInfoBoxService,\r\n    BingMarkerService, BingPolygonService, BingPolylineService, BingMapAPILoader,\r\n    BingLayerService, BingClusterService, BingLayer, BingMarker, BingPolyline, BingMapEventsLookup, BingPolygon,\r\n    BingInfoWindow, BingClusterLayer, BingSpiderClusterMarker, BingCanvasOverlay\r\n};\r\nexport {\r\n    GoogleClusterService, GoogleInfoBoxService, GoogleLayerService, GoogleMapAPILoader, GoogleMapAPILoaderConfig,\r\n    GoogleMapServiceFactory, GoogleMapService, GoogleMarkerService, GooglePolygonService, GooglePolylineService,\r\n    GoogleMarker, GoogleInfoWindow, GooglePolygon, GooglePolyline, GoogleMapEventsLookup, GoogleCanvasOverlay\r\n};\r\n\r\n///\r\n/// define module\r\n///\r\n@NgModule({\r\n    declarations: [\r\n        MapLayerDirective,\r\n        MapComponent,\r\n        MapMarkerDirective,\r\n        InfoBoxComponent,\r\n        InfoBoxActionDirective,\r\n        MapPolygonDirective,\r\n        MapPolylineDirective,\r\n        ClusterLayerDirective,\r\n        MapMarkerLayerDirective,\r\n        MapPolygonLayerDirective,\r\n        MapPolylineLayerDirective\r\n    ],\r\n    imports: [CommonModule],\r\n    exports: [\r\n        CommonModule,\r\n        MapComponent,\r\n        MapMarkerDirective,\r\n        MapPolygonDirective,\r\n        MapPolylineDirective,\r\n        InfoBoxComponent,\r\n        InfoBoxActionDirective,\r\n        MapLayerDirective,\r\n        ClusterLayerDirective,\r\n        MapMarkerLayerDirective,\r\n        MapPolygonLayerDirective,\r\n        MapPolylineLayerDirective\r\n    ]\r\n})\r\nexport class MapModule {\r\n\r\n    static forRoot(mapServiceFactory?: MapServiceFactory, loader?: MapAPILoader): ModuleWithProviders {\r\n        return {\r\n            ngModule: MapModule,\r\n            providers: [\r\n                mapServiceFactory ? { provide: MapServiceFactory, useValue: mapServiceFactory } :\r\n                    { provide: MapServiceFactory, deps: [MapAPILoader, NgZone], useFactory: BingMapServiceFactoryFactory },\r\n                loader ? { provide: MapAPILoader, useValue: loader } : { provide: MapAPILoader, useFactory: BingMapLoaderFactory },\r\n                DocumentRef,\r\n                WindowRef\r\n            ]\r\n        };\r\n    }\r\n\r\n    static forRootBing(): ModuleWithProviders {\r\n        return {\r\n            ngModule: MapModule,\r\n            providers: [\r\n                { provide: MapServiceFactory, deps: [MapAPILoader, NgZone], useFactory: BingMapServiceFactoryFactory },\r\n                { provide: MapAPILoader, useFactory: BingMapLoaderFactory },\r\n                DocumentRef,\r\n                WindowRef\r\n            ]\r\n        };\r\n    }\r\n\r\n    static forRootGoogle(): ModuleWithProviders {\r\n        return {\r\n            ngModule: MapModule,\r\n            providers: [\r\n                { provide: MapServiceFactory, deps: [MapAPILoader, NgZone], useFactory: GoogleMapServiceFactoryFactory },\r\n                { provide: MapAPILoader, useFactory: GoogleMapLoaderFactory },\r\n                DocumentRef,\r\n                WindowRef\r\n            ]\r\n        };\r\n    }\r\n}\r\n"]}