(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('async'), require('@angular/core'), require('rxjs'), require('@angular/common'), require('bingmaps')) :
    typeof define === 'function' && define.amd ? define('angular-maps', ['exports', 'async', '@angular/core', 'rxjs', '@angular/common', 'bingmaps'], factory) :
    (factory((global['angular-maps'] = {}),null,global.ng.core,global.rxjs,global.ng.common));
}(this, (function (exports,async,core,rxjs,common) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ InfoWindow = (function () {
        function InfoWindow() {
        }
        return InfoWindow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var MarkerTypeId = {
        None: 0,
        FontMarker: 1,
        CanvasMarker: 2,
        DynamicCircleMarker: 3,
        RotatedImageMarker: 4,
        RoundedImageMarker: 5,
        ScaledImageMarker: 6,
        Custom: 7,
    };
    MarkerTypeId[MarkerTypeId.None] = "None";
    MarkerTypeId[MarkerTypeId.FontMarker] = "FontMarker";
    MarkerTypeId[MarkerTypeId.CanvasMarker] = "CanvasMarker";
    MarkerTypeId[MarkerTypeId.DynamicCircleMarker] = "DynamicCircleMarker";
    MarkerTypeId[MarkerTypeId.RotatedImageMarker] = "RotatedImageMarker";
    MarkerTypeId[MarkerTypeId.RoundedImageMarker] = "RoundedImageMarker";
    MarkerTypeId[MarkerTypeId.ScaledImageMarker] = "ScaledImageMarker";
    MarkerTypeId[MarkerTypeId.Custom] = "Custom";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This class defines the contract for a marker.
     *
     * @export
     * @abstract
     * @abstract
     */
    var Marker = (function () {
        function Marker() {
        }
        /**
         * Creates a marker based on the marker info. In turn calls a number of internal members to
         * create the actual marker.
         *
         * \@memberof Marker
         * @param {?} iconInfo - icon information. Depending on the marker type, various properties
         * need to be present. For performance, it is recommended to use an id for markers that are common to facilitate
         * reuse.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image.
         */
        Marker.CreateMarker = /**
         * Creates a marker based on the marker info. In turn calls a number of internal members to
         * create the actual marker.
         *
         * \@memberof Marker
         * @param {?} iconInfo - icon information. Depending on the marker type, various properties
         * need to be present. For performance, it is recommended to use an id for markers that are common to facilitate
         * reuse.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image.
         */
            function (iconInfo) {
                switch (iconInfo.markerType) {
                    case MarkerTypeId.CanvasMarker: return Marker.CreateCanvasMarker(iconInfo);
                    case MarkerTypeId.DynamicCircleMarker: return Marker.CreateDynamicCircleMarker(iconInfo);
                    case MarkerTypeId.FontMarker: return Marker.CreateFontBasedMarker(iconInfo);
                    case MarkerTypeId.RotatedImageMarker: return Marker.CreateRotatedImageMarker(iconInfo);
                    case MarkerTypeId.RoundedImageMarker: return Marker.CreateRoundedImageMarker(iconInfo);
                    case MarkerTypeId.ScaledImageMarker: return Marker.CreateScaledImageMarker(iconInfo);
                    case MarkerTypeId.Custom: throw Error('Custom Marker Creators are not currently supported.');
                }
                throw Error('Unsupported marker type: ' + iconInfo.markerType);
            };
        /**
         * Obtains a shared img element for a marker icon to prevent unecessary creation of
         * DOM items. This has sped up large scale makers on Bing Maps by about 70%
         * \@memberof Marker
         * @param {?} icon - The icon string (url, data url, svg) for which to obtain the image.
         * @return {?} - The obtained image element.
         */
        Marker.GetImageForMarker = /**
         * Obtains a shared img element for a marker icon to prevent unecessary creation of
         * DOM items. This has sped up large scale makers on Bing Maps by about 70%
         * \@memberof Marker
         * @param {?} icon - The icon string (url, data url, svg) for which to obtain the image.
         * @return {?} - The obtained image element.
         */
            function (icon) {
                if (icon == null || icon === '') {
                    return null;
                }
                var /** @type {?} */ img = null;
                img = Marker.ImageElementCache.get(icon);
                if (img != null) {
                    return img;
                }
                if (typeof (document) !== 'undefined' && document != null) {
                    img = document.createElement('img');
                    img.src = icon;
                    Marker.ImageElementCache.set(icon, img);
                }
                return img;
            };
        /**
         * Creates a canvased based marker using the point collection contained in the iconInfo parameter.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - String with the data url for the marker image.
         *
         * @memberof Marker
         */
        /**
         * Creates a canvased based marker using the point collection contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
        Marker.CreateCanvasMarker = /**
         * Creates a canvased based marker using the point collection contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for canvas markers.');
                }
                if (iconInfo == null || iconInfo.size == null || iconInfo.points == null) {
                    throw Error('IMarkerIconInfo.size, and IMarkerIConInfo.points are required for canvas markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ c = document.createElement('canvas');
                var /** @type {?} */ ctx = c.getContext('2d');
                c.width = iconInfo.size.width;
                c.height = iconInfo.size.height;
                if (iconInfo.rotation) {
                    // Offset the canvas such that we will rotate around the center of our arrow
                    ctx.translate(c.width * 0.5, c.height * 0.5);
                    // Rotate the canvas by the desired heading
                    ctx.rotate(iconInfo.rotation * Math.PI / 180);
                    // Return the canvas offset back to it's original position
                    ctx.translate(-c.width * 0.5, -c.height * 0.5);
                }
                ctx.fillStyle = iconInfo.color || 'red';
                // Draw a path in the shape of an arrow.
                ctx.beginPath();
                if (iconInfo.drawingOffset) {
                    ctx.moveTo(iconInfo.drawingOffset.x, iconInfo.drawingOffset.y);
                }
                iconInfo.points.forEach(function (p) { ctx.lineTo(p.x, p.y); });
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                var /** @type {?} */ s = c.toDataURL();
                if (iconInfo.id != null) {
                    Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                }
                return s;
            };
        /**
         * Creates a circle marker image using information contained in the iconInfo parameter.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - String with the data url for the marker image.
         *
         * @memberof Marker
         */
        /**
         * Creates a circle marker image using information contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
        Marker.CreateDynamicCircleMarker = /**
         * Creates a circle marker image using information contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for dynamic circle markers.');
                }
                if (iconInfo == null || iconInfo.size == null) {
                    throw Error('IMarkerIconInfo.size is required for dynamic circle markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ strokeWidth = iconInfo.strokeWidth || 0;
                // Create an SVG string of a circle with the specified radius and color.
                var /** @type {?} */ svg = [
                    '<svg xmlns="http://www.w3.org/2000/svg" width="',
                    iconInfo.size.width.toString(),
                    '" height="',
                    iconInfo.size.width.toString(),
                    '"><circle cx="',
                    (iconInfo.size.width / 2).toString(),
                    '" cy="',
                    (iconInfo.size.width / 2).toString(),
                    '" r="',
                    ((iconInfo.size.width / 2) - strokeWidth).toString(),
                    '" stroke="',
                    iconInfo.color || 'red',
                    '" stroke-width="',
                    strokeWidth.toString(),
                    '" fill="',
                    iconInfo.color || 'red',
                    '"/></svg>'
                ];
                var /** @type {?} */ s = svg.join('');
                if (iconInfo.id != null) {
                    Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                }
                return s;
            };
        /**
         * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - String with the data url for the marker image.
         *
         * @memberof Marker
         */
        /**
         * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
        Marker.CreateFontBasedMarker = /**
         * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for font based markers');
                }
                if (iconInfo == null || iconInfo.fontName == null || iconInfo.fontSize == null) {
                    throw Error('IMarkerIconInfo.fontName, IMarkerIconInfo.fontSize and IMarkerIConInfo.text are required for font based markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ c = document.createElement('canvas');
                var /** @type {?} */ ctx = c.getContext('2d');
                var /** @type {?} */ font = iconInfo.fontSize + 'px ' + iconInfo.fontName;
                ctx.font = font;
                // Resize canvas based on sie of text.
                var /** @type {?} */ size = ctx.measureText(iconInfo.text);
                c.width = size.width;
                c.height = iconInfo.fontSize;
                if (iconInfo.rotation) {
                    // Offset the canvas such that we will rotate around the center of our arrow
                    ctx.translate(c.width * 0.5, c.height * 0.5);
                    // Rotate the canvas by the desired heading
                    ctx.rotate(iconInfo.rotation * Math.PI / 180);
                    // Return the canvas offset back to it's original position
                    ctx.translate(-c.width * 0.5, -c.height * 0.5);
                }
                // Reset font as it will be cleared by the resize.
                ctx.font = font;
                ctx.textBaseline = 'top';
                ctx.fillStyle = iconInfo.color || 'red';
                ctx.fillText(iconInfo.text, 0, 0);
                iconInfo.size = { width: c.width, height: c.height };
                var /** @type {?} */ s = c.toDataURL();
                if (iconInfo.id != null) {
                    Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                }
                return s;
            };
        /**
         * Creates an image marker by applying a roation to a supplied image.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         * @memberof Marker
         */
        /**
         * Creates an image marker by applying a roation to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
        Marker.CreateRotatedImageMarker = /**
         * Creates an image marker by applying a roation to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for rotated image markers');
                }
                if (iconInfo == null || iconInfo.rotation == null || iconInfo.url == null) {
                    throw Error('IMarkerIconInfo.rotation, IMarkerIconInfo.url are required for rotated image markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ image = new Image();
                var /** @type {?} */ promise = new Promise(function (resolve, reject) {
                    // Allow cross domain image editting.
                    image.crossOrigin = 'anonymous';
                    image.src = iconInfo.url;
                    if (iconInfo.size) {
                        image.width = iconInfo.size.width;
                        image.height = iconInfo.size.height;
                    }
                    image.onload = function () {
                        var /** @type {?} */ c = document.createElement('canvas');
                        var /** @type {?} */ ctx = c.getContext('2d');
                        var /** @type {?} */ rads = iconInfo.rotation * Math.PI / 180;
                        // Calculate rotated image size.
                        c.width = Math.ceil(Math.abs(image.width * Math.cos(rads)) + Math.abs(image.height * Math.sin(rads)));
                        c.height = Math.ceil(Math.abs(image.width * Math.sin(rads)) + Math.abs(image.height * Math.cos(rads)));
                        // Move to the center of the canvas.
                        ctx.translate(c.width / 2, c.height / 2);
                        // Rotate the canvas to the specified angle in degrees.
                        ctx.rotate(rads);
                        // Draw the image, since the context is rotated, the image will be rotated also.
                        ctx.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
                        iconInfo.size = { width: c.width, height: c.height };
                        var /** @type {?} */ s = c.toDataURL();
                        if (iconInfo.id != null) {
                            Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                        }
                        resolve({ icon: s, iconInfo: iconInfo });
                    };
                });
                return promise;
            };
        /**
         * Creates a rounded image marker by applying a circle mask to a supplied image.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @param iconInfo - Callback invoked once marker generation is complete. The callback
         * parameters are the data uri and the IMarkerIconInfo.
         * @returns - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         * @memberof Marker
         */
        /**
         * Creates a rounded image marker by applying a circle mask to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
        Marker.CreateRoundedImageMarker = /**
         * Creates a rounded image marker by applying a circle mask to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for rounded image markers');
                }
                if (iconInfo == null || iconInfo.size == null || iconInfo.url == null) {
                    throw Error('IMarkerIconInfo.size, IMarkerIconInfo.url are required for rounded image markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ promise = new Promise(function (resolve, reject) {
                    var /** @type {?} */ radius = iconInfo.size.width / 2;
                    var /** @type {?} */ image = new Image();
                    var /** @type {?} */ offset = iconInfo.drawingOffset || { x: 0, y: 0 };
                    // Allow cross domain image editting.
                    image.crossOrigin = 'anonymous';
                    image.src = iconInfo.url;
                    image.onload = function () {
                        var /** @type {?} */ c = document.createElement('canvas');
                        var /** @type {?} */ ctx = c.getContext('2d');
                        c.width = iconInfo.size.width;
                        c.height = iconInfo.size.width;
                        // Draw a circle which can be used to clip the image, then draw the image.
                        ctx.beginPath();
                        ctx.arc(radius, radius, radius, 0, 2 * Math.PI, false);
                        ctx.fill();
                        ctx.clip();
                        ctx.drawImage(image, offset.x, offset.y, iconInfo.size.width, iconInfo.size.width);
                        iconInfo.size = { width: c.width, height: c.height };
                        var /** @type {?} */ s = c.toDataURL();
                        if (iconInfo.id != null) {
                            Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                        }
                        resolve({ icon: s, iconInfo: iconInfo });
                    };
                });
                return promise;
            };
        /**
         * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @param iconInfo - Callback invoked once marker generation is complete. The callback
         * parameters are the data uri and the IMarkerIconInfo.
         * @returns - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         * @memberof Marker
         */
        /**
         * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
        Marker.CreateScaledImageMarker = /**
         * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for scaled image markers');
                }
                if (iconInfo == null || iconInfo.scale == null || iconInfo.url == null) {
                    throw Error('IMarkerIconInfo.scale, IMarkerIconInfo.url are required for scaled image markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ promise = new Promise(function (resolve, reject) {
                    var /** @type {?} */ image = new Image();
                    // Allow cross domain image editting.
                    image.crossOrigin = 'anonymous';
                    image.src = iconInfo.url;
                    image.onload = function () {
                        var /** @type {?} */ c = document.createElement('canvas');
                        var /** @type {?} */ ctx = c.getContext('2d');
                        c.width = image.width * iconInfo.scale;
                        c.height = image.height * iconInfo.scale;
                        // Draw a circle which can be used to clip the image, then draw the image.
                        ctx.drawImage(image, 0, 0, c.width, c.height);
                        iconInfo.size = { width: c.width, height: c.height };
                        var /** @type {?} */ s = c.toDataURL();
                        if (iconInfo.id != null) {
                            Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                        }
                        resolve({ icon: s, iconInfo: iconInfo });
                    };
                });
                return promise;
            };
        /**
         * Caches concrete img elements for marker icons to accelerate patining.
         *
         * \@memberof Marker
         */
        Marker.ImageElementCache = new Map();
        /**
         * Used to cache generated markers for performance and reusability.
         *
         * \@memberof Marker
         */
        Marker.MarkerCache = new Map();
        return Marker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var MapTypeId = {
        /** The aerial map type which uses top-down satellite & airplane imagery. */
        aerial: 0,
        /** A darker version of the road maps. */
        canvasDark: 1,
        /** A lighter version of the road maps which also has some of the details such as hill shading disabled. */
        canvasLight: 2,
        /** A grayscale version of the road maps. */
        grayscale: 3,
        /** The aerial map type including lables */
        hybrid: 4,
        /** Displays a blank canvas that uses the mercator map project. It basically removed the base maps layer. */
        mercator: 5,
        /** Ordnance survey map type (en-gb only). */
        ordnanceSurvey: 6,
        /** Road map type. */
        road: 7,
        /** Provides streetside panoramas from the street level. */
        streetside: 8,
    };
    MapTypeId[MapTypeId.aerial] = "aerial";
    MapTypeId[MapTypeId.canvasDark] = "canvasDark";
    MapTypeId[MapTypeId.canvasLight] = "canvasLight";
    MapTypeId[MapTypeId.grayscale] = "grayscale";
    MapTypeId[MapTypeId.hybrid] = "hybrid";
    MapTypeId[MapTypeId.mercator] = "mercator";
    MapTypeId[MapTypeId.ordnanceSurvey] = "ordnanceSurvey";
    MapTypeId[MapTypeId.road] = "road";
    MapTypeId[MapTypeId.streetside] = "streetside";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Defines the contract for a map layer implementation. Deriving providers should implements this abstract
     * to provide concrete layer functionality for the map.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Defines the contract for a map layer implementation. Deriving providers should implements this abstract
     * to provide concrete layer functionality for the map.
     *
     * @export
     * @abstract
     * @abstract
     */ Layer = (function () {
        function Layer() {
        }
        return Layer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract class defining the contract for a polygon in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract class defining the contract for a polygon in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */ Polygon = (function () {
        function Polygon() {
        }
        Object.defineProperty(Polygon.prototype, "Center", {
            get: /**
             * Gets the polygon's center.
             * \@readonly
             * \@memberof Polygon
             * @return {?}
             */ function () {
                if (this._center == null) {
                    this._center = this.GetBoundingCenter();
                }
                return this._center;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Polygon.prototype, "Centroid", {
            get: /**
             * Gets the polygon's centroid.
             * \@readonly
             * \@memberof Polygon
             * @return {?}
             */ function () {
                if (this._centroid == null) {
                    this._centroid = this.GetPolygonCentroid();
                }
                return this._centroid;
            },
            enumerable: true,
            configurable: true
        });
        ///
        /// Protected methods
        ///
        /**
         * Gets the center of the polygons' bounding box.
         *
         * @returns - ILatLong object containing the center of the bounding box.
         * @memberof Polygon
         * @method
         * @protected
         */
        /**
         * Gets the center of the polygons' bounding box.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - ILatLong object containing the center of the bounding box.
         */
        Polygon.prototype.GetBoundingCenter = /**
         * Gets the center of the polygons' bounding box.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - ILatLong object containing the center of the bounding box.
         */
            function () {
                var /** @type {?} */ c = { latitude: 0, longitude: 0 };
                var /** @type {?} */ x1 = 90, /** @type {?} */ x2 = -90, /** @type {?} */ y1 = 180, /** @type {?} */ y2 = -180;
                var /** @type {?} */ path = this.GetPaths();
                if (path) {
                    path.forEach(function (inner) {
                        return inner.forEach(function (p) {
                            if (p.latitude < x1) {
                                x1 = p.latitude;
                            }
                            if (p.latitude > x2) {
                                x2 = p.latitude;
                            }
                            if (p.longitude < y1) {
                                y1 = p.longitude;
                            }
                            if (p.longitude > y2) {
                                y2 = p.longitude;
                            }
                        });
                    });
                    c.latitude = x1 + (x2 - x1) / 2;
                    c.longitude = y1 + (y2 - y1) / 2;
                }
                else {
                    c = null;
                }
                return c;
            };
        /**
         * Get the centroid of the polygon based on the polygon path.
         *
         * @returns - The centroid coordinates of the polygon.
         * @memberof Polygon
         * @method
         * @protected
         */
        /**
         * Get the centroid of the polygon based on the polygon path.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polygon.
         */
        Polygon.prototype.GetPolygonCentroid = /**
         * Get the centroid of the polygon based on the polygon path.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polygon.
         */
            function () {
                var /** @type {?} */ c = { latitude: 0, longitude: 0 };
                var /** @type {?} */ path = this.GetPaths();
                var /** @type {?} */ off = path[0][0];
                if (off != null) {
                    var /** @type {?} */ twicearea = 0;
                    var /** @type {?} */ x = 0;
                    var /** @type {?} */ y = 0;
                    var /** @type {?} */ p1 = void 0, /** @type {?} */ p2 = void 0;
                    var /** @type {?} */ f = void 0;
                    for (var /** @type {?} */ k = 0; k < path.length; k++) {
                        for (var /** @type {?} */ i = 0, /** @type {?} */ j = path[k].length - 1; i < path[k].length; j = i++) {
                            p1 = path[k][i];
                            p2 = path[k][j];
                            f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -
                                (p2.latitude - off.latitude) * (p1.longitude - off.longitude);
                            twicearea += f;
                            x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;
                            y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;
                        }
                    }
                    if (twicearea !== 0) {
                        f = twicearea * 3;
                        c.latitude = x / f + off.latitude;
                        c.longitude = y / f + off.longitude;
                    }
                    else {
                        c.latitude = off.latitude;
                        c.longitude = off.longitude;
                    }
                }
                else {
                    c = null;
                }
                return c;
            };
        return Polygon;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract class defining the contract for a polyline in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract class defining the contract for a polyline in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */ Polyline = (function () {
        function Polyline() {
        }
        Object.defineProperty(Polyline.prototype, "Center", {
            get: /**
             * Gets the polyline's center.
             * \@readonly
             * \@memberof Polyline
             * @return {?}
             */ function () {
                if (this._center == null) {
                    this._center = this.GetBoundingCenter();
                }
                return this._center;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Polyline.prototype, "Centroid", {
            get: /**
             * Gets the polyline's centroid.
             * \@readonly
             * \@memberof Polyline
             * @return {?}
             */ function () {
                if (this._centroid == null) {
                    this._centroid = this.GetPolylineCentroid();
                }
                return this._centroid;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Get the centroid of the polyline based on the a path.
         *
         * \@memberof Polyline
         * \@method
         * @param {?} path - the path for which to generate the centroid
         * @return {?} - The centroid coordinates of the polyline.
         */
        Polyline.GetPolylineCentroid = /**
         * Get the centroid of the polyline based on the a path.
         *
         * \@memberof Polyline
         * \@method
         * @param {?} path - the path for which to generate the centroid
         * @return {?} - The centroid coordinates of the polyline.
         */
            function (path) {
                var /** @type {?} */ c = { latitude: 0, longitude: 0 };
                var /** @type {?} */ off = path[0];
                if (off != null) {
                    var /** @type {?} */ twicearea = 0;
                    var /** @type {?} */ x = 0;
                    var /** @type {?} */ y = 0;
                    var /** @type {?} */ p1 = void 0, /** @type {?} */ p2 = void 0;
                    var /** @type {?} */ f = void 0;
                    for (var /** @type {?} */ i = 0, /** @type {?} */ j = path.length - 1; i < path.length; j = i++) {
                        p1 = path[i];
                        p2 = path[j];
                        f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -
                            (p2.latitude - off.latitude) * (p1.longitude - off.longitude);
                        twicearea += f;
                        x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;
                        y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;
                    }
                    if (twicearea !== 0) {
                        f = twicearea * 3;
                        c.latitude = x / f + off.latitude;
                        c.longitude = y / f + off.longitude;
                    }
                    else {
                        c.latitude = off.latitude;
                        c.longitude = off.longitude;
                    }
                }
                else {
                    c = null;
                }
                return c;
            };
        ///
        /// Protected methods
        ///
        /**
         * Gets the center of the polyline' bounding box.
         *
         * @returns - {@link ILatLong} object containing the center of the bounding box.
         * @memberof Polyline
         * @method
         * @protected
         */
        /**
         * Gets the center of the polyline' bounding box.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - {\@link ILatLong} object containing the center of the bounding box.
         */
        Polyline.prototype.GetBoundingCenter = /**
         * Gets the center of the polyline' bounding box.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - {\@link ILatLong} object containing the center of the bounding box.
         */
            function () {
                var /** @type {?} */ c = { latitude: 0, longitude: 0 };
                var /** @type {?} */ x1 = 90, /** @type {?} */ x2 = -90, /** @type {?} */ y1 = 180, /** @type {?} */ y2 = -180;
                var /** @type {?} */ path = this.GetPath();
                if (path) {
                    path.forEach(function (p) {
                        if (p.latitude < x1) {
                            x1 = p.latitude;
                        }
                        if (p.latitude > x2) {
                            x2 = p.latitude;
                        }
                        if (p.longitude < y1) {
                            y1 = p.longitude;
                        }
                        if (p.longitude > y2) {
                            y2 = p.longitude;
                        }
                    });
                    c.latitude = x1 + (x2 - x1) / 2;
                    c.longitude = y1 + (y2 - y1) / 2;
                }
                else {
                    c = null;
                }
                return c;
            };
        /**
         * Get the centroid of the polyline based on the polyline path.
         *
         * @returns - The centroid coordinates of the polyline.
         * @memberof Polyline
         * @method
         * @protected
         */
        /**
         * Get the centroid of the polyline based on the polyline path.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polyline.
         */
        Polyline.prototype.GetPolylineCentroid = /**
         * Get the centroid of the polyline based on the polyline path.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polyline.
         */
            function () {
                var /** @type {?} */ path = this.GetPath();
                var /** @type {?} */ c = Polyline.GetPolylineCentroid(path);
                return c;
            };
        return Polyline;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ SpiderClusterMarker = (function (_super) {
        __extends(SpiderClusterMarker, _super);
        function SpiderClusterMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SpiderClusterMarker;
    }(Marker));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var ClusterPlacementMode = {
        None: 0,
        MeanValue: 1,
        FirstPin: 2,
    };
    ClusterPlacementMode[ClusterPlacementMode.None] = "None";
    ClusterPlacementMode[ClusterPlacementMode.MeanValue] = "MeanValue";
    ClusterPlacementMode[ClusterPlacementMode.FirstPin] = "FirstPin";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var ClusterClickAction = {
        None: 0,
        ZoomIntoCluster: 1,
        Spider: 2,
    };
    ClusterClickAction[ClusterClickAction.None] = "None";
    ClusterClickAction[ClusterClickAction.ZoomIntoCluster] = "ZoomIntoCluster";
    ClusterClickAction[ClusterClickAction.Spider] = "Spider";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ id = 0;
    /**
     * Abstract base implementing a canvas overlay to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract base implementing a canvas overlay to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */ CanvasOverlay = (function () {
        /**
         * Creates a new instance of the CanvasOverlay class.
         */
        function CanvasOverlay(drawCallback) {
            var _this = this;
            this._canvasReady = new Promise(function (resolve, reject) { _this._readyResolver = resolve; });
            this._drawCallback = drawCallback;
            id++;
        }
        Object.defineProperty(CanvasOverlay.prototype, "CanvasReady", {
            get: /**
             * Returns a promise that gets resolved when the canvas overlay is ready for interaction.
             * @return {?}
             */ function () { return this._canvasReady; },
            enumerable: true,
            configurable: true
        });
        /**
         * Deletes the canvas overlay.
         * @return {?}
         */
        CanvasOverlay.prototype.Delete = /**
         * Deletes the canvas overlay.
         * @return {?}
         */
            function () {
                this.SetMap(null);
            };
        /**
         * CanvasOverlay added to map, load canvas.
         * @return {?}
         */
        CanvasOverlay.prototype.OnAdd = /**
         * CanvasOverlay added to map, load canvas.
         * @return {?}
         */
            function () {
                this._canvas = document.createElement('canvas');
                this._canvas.style.position = 'absolute';
                this._canvas.style.left = '0px';
                this._canvas.style.top = '0px';
                this._canvas.id = "xMapOverlay" + id;
                // Add the canvas to the overlay.
                this.SetCanvasElement(this._canvas);
            };
        /**
         * When the CanvasLayer is removed from the map, release resources.
         * \@memberof CanvasOverlay
         * \@method
         * @return {?}
         */
        CanvasOverlay.prototype.OnRemove = /**
         * When the CanvasLayer is removed from the map, release resources.
         * \@memberof CanvasOverlay
         * \@method
         * @return {?}
         */
            function () {
                this.SetCanvasElement(null);
                this.RemoveEventHandlers();
                this._canvas = null;
            };
        /**
         * Redraws the canvas for the current map view.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} clear - True to clear the canvas before drawing.
         * @return {?}
         */
        CanvasOverlay.prototype.Redraw = /**
         * Redraws the canvas for the current map view.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} clear - True to clear the canvas before drawing.
         * @return {?}
         */
            function (clear) {
                if (this._canvas == null) {
                    return;
                }
                // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.
                if (clear) {
                    this.Resize();
                }
                // Call the drawing callback function if specified.
                if (this._drawCallback) {
                    this._drawCallback(this._canvas);
                }
            };
        /**
         * Simple function for updating the CSS position and dimensions of the canvas.
         * @param x The horizontal offset position of the canvas.
         * @param y The vertical offset position of the canvas.
         * @param w The width of the canvas.
         * @param h The height of the canvas.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Simple function for updating the CSS position and dimensions of the canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @param {?} x The horizontal offset position of the canvas.
         * @param {?} y The vertical offset position of the canvas.
         * @param {?} w The width of the canvas.
         * @param {?} h The height of the canvas.
         * @return {?}
         */
        CanvasOverlay.prototype.UpdatePosition = /**
         * Simple function for updating the CSS position and dimensions of the canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @param {?} x The horizontal offset position of the canvas.
         * @param {?} y The vertical offset position of the canvas.
         * @param {?} w The width of the canvas.
         * @param {?} h The height of the canvas.
         * @return {?}
         */
            function (x, y, w, h) {
                // Update CSS position.
                this._canvas.style.left = x + 'px';
                this._canvas.style.top = y + 'px';
                // Update CSS dimensions.
                this._canvas.style.width = w + 'px';
                this._canvas.style.height = h + 'px';
            };
        return CanvasOverlay;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of a map layer for the Bing Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a map layer for the Bing Map Provider.
     *
     * @export
     */ BingLayer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the BingClusterLayer class.
         *
         * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof BingLayer
         */
        function BingLayer(_layer, _maps) {
            this._layer = _layer;
            this._maps = _maps;
            this._pendingEntities = new Array();
        }
        Object.defineProperty(BingLayer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer.
             *
             * \@memberof BingLayer
             * @return {?} Microsoft.Maps.Layer.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        BingLayer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                Microsoft.Maps.Events.addHandler(this._layer, eventType, function (e) {
                    fn(e);
                });
            };
        /**
         * Adds an entity to the layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.AddEntity = /**
         * Adds an entity to the layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity && entity.NativePrimitve) {
                    if (this.GetVisible()) {
                        this._layer.add(entity.NativePrimitve);
                    }
                    else {
                        this._pendingEntities.push(entity);
                    }
                }
            };
        /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.AddEntities = /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                //
                // use eachSeries as opposed to _layer.add([]) to provide a non-blocking experience for larger data sets.
                //
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    async.eachSeries(__spread(entities), function (e, next) {
                        if (_this.GetVisible()) {
                            _this._layer.add(e.NativePrimitve);
                        }
                        else {
                            _this._pendingEntities.push(e);
                        }
                        async.nextTick(function () { return next(); });
                    });
                }
            };
        /**
         * Deletes the layer.
         *
         * \@memberof BingLayer
         * @return {?}
         */
        BingLayer.prototype.Delete = /**
         * Deletes the layer.
         *
         * \@memberof BingLayer
         * @return {?}
         */
            function () {
                this._maps.DeleteLayer(this);
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
        BingLayer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
            function () {
                var /** @type {?} */ o = {
                    id: Number(this._layer.getId())
                };
                return o;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        BingLayer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._layer.getVisible();
            };
        /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline to be removed from the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.RemoveEntity = /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve) {
                    this._layer.remove(entity.NativePrimitve);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.
         * This replaces any existing entities.
         *
         * @return {?}
         */
        BingLayer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.
         * This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                //
                // we are using removal and add as opposed to set as for large number of objects it yields a non-blocking, smoother performance...
                //
                this._layer.setPrimitives([]);
                this.AddEntities(entities);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        BingLayer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                this._layer.metadata.id = options.id.toString();
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                this._layer.setVisible(visible);
                if (visible && this._pendingEntities.length > 0) {
                    this.AddEntities(this._pendingEntities.splice(0));
                }
            };
        return BingLayer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This class contains helperfunctions to map various interfaces used to represent options and structures into the
     * corresponding Bing Maps V8 specific implementations.
     *
     * @export
     */
    var BingConversions = (function () {
        function BingConversions() {
        }
        /**
         * Maps an IInfoWindowAction to a Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} action - Object to be mapped.
         * @return {?} - Navtive mapped object.
         *
         */
        BingConversions.TranslateAction = /**
         * Maps an IInfoWindowAction to a Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} action - Object to be mapped.
         * @return {?} - Navtive mapped object.
         *
         */
            function (action) {
                var /** @type {?} */ a = {
                    eventHandler: action.eventHandler,
                    label: action.label
                };
                return a;
            };
        /**
         * Maps an Array of IInfoWindowAction to an Array of Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} actions - Array of objects to be mapped.
         * @return {?} - Array of mapped objects.
         *
         */
        BingConversions.TranslateActions = /**
         * Maps an Array of IInfoWindowAction to an Array of Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} actions - Array of objects to be mapped.
         * @return {?} - Array of mapped objects.
         *
         */
            function (actions) {
                var /** @type {?} */ a = new Array();
                actions.forEach(function (x) { return a.push(BingConversions.TranslateAction(x)); });
                return a;
            };
        /**
         * Maps an IBox object to a Microsoft.Maps.LocationRect object.
         *
         * \@memberof BingConversions
         * @param {?} box - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateBounds = /**
         * Maps an IBox object to a Microsoft.Maps.LocationRect object.
         *
         * \@memberof BingConversions
         * @param {?} box - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (box) {
                var /** @type {?} */ r = Microsoft.Maps.LocationRect.fromEdges(box.maxLatitude, box.minLongitude, box.minLatitude, box.maxLongitude);
                return r;
            };
        /**
         * Maps an IClusterOptions object to a Microsoft.Maps.IClusterLayerOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateClusterOptions = /**
         * Maps an IClusterOptions object to a Microsoft.Maps.IClusterLayerOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._clusterOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'layerOffset') {
                        o.layerOffset = BingConversions.TranslatePoint(options.layerOffset);
                    }
                    if (k === 'placementMode') {
                        if (options.placementMode === ClusterPlacementMode.FirstPin) {
                            o.placementMode = Microsoft.Maps.ClusterPlacementType.FirstLocation;
                        }
                        else {
                            o.placementMode = Microsoft.Maps.ClusterPlacementType.MeanAverage;
                        }
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IInfoWindowOptions object to a Microsoft.Maps.IInfoboxOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateInfoBoxOptions = /**
         * Maps an IInfoWindowOptions object to a Microsoft.Maps.IInfoboxOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._infoWindowOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'pixelOffset') {
                        o.offset = BingConversions.TranslatePoint(options.pixelOffset);
                    }
                    else if (k === 'position') {
                        o.location = BingConversions.TranslateLocation(options.position);
                    }
                    else if (k === 'actions') {
                        o.actions = BingConversions.TranslateActions(options.actions);
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapLoadOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateLoadOptions = /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapLoadOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) {
                    return BingConversions._mapOptionsAttributes.indexOf(k) !== -1 || BingConversions._viewOptionsAttributes.indexOf(k) !== -1;
                })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = BingConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'mapTypeId') {
                        if (options.mapTypeId === MapTypeId.hybrid) {
                            o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;
                            o.labelOverlay = Microsoft.Maps.LabelOverlay.visible;
                        }
                        else if (options.mapTypeId === MapTypeId.aerial) {
                            o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;
                            o.labelOverlay = Microsoft.Maps.LabelOverlay.hidden;
                        }
                        else {
                            o.mapTypeId = Microsoft.Maps.MapTypeId[((MapTypeId))[options.mapTypeId]];
                        }
                    }
                    else if (k === 'bounds') {
                        o.bounds = BingConversions.TranslateBounds(options.bounds);
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an ILatLong object to a Microsoft.Maps.Location object.
         *
         * \@memberof BingConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateLocation = /**
         * Maps an ILatLong object to a Microsoft.Maps.Location object.
         *
         * \@memberof BingConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlong) {
                var /** @type {?} */ l = new Microsoft.Maps.Location(latlong.latitude, latlong.longitude);
                return l;
            };
        /**
         * Maps an IMarkerOptions object to a Microsoft.Maps.IPushpinOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - The mapped object.
         *
         */
        BingConversions.TranslateMarkerOptions = /**
         * Maps an IMarkerOptions object to a Microsoft.Maps.IPushpinOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - The mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._markerOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'anchor') {
                        o.anchor = BingConversions.TranslatePoint(options.anchor);
                    }
                    else {
                        ((o))[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateOptions = /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._mapOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = BingConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'mapTypeId') {
                        o.mapTypeId = Microsoft.Maps.MapTypeId[((MapTypeId))[options.mapTypeId]];
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof BingConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
        BingConversions.TranslatePaths = /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof BingConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
            function (paths) {
                var /** @type {?} */ p = new Array();
                if (paths == null || !Array.isArray(paths) || paths.length === 0) {
                    p.push(new Array());
                }
                else if (Array.isArray(paths[0])) {
                    // parameter is an array or arrays
                    // us for loop for performance
                    var /** @type {?} */ p1 = (paths);
                    for (var /** @type {?} */ i = 0; i < p1.length; i++) {
                        var /** @type {?} */ _p = new Array();
                        for (var /** @type {?} */ j = 0; j < p1[i].length; j++) {
                            _p.push(new Microsoft.Maps.Location(p1[i][j].latitude, p1[i][j].longitude));
                        }
                        p.push(_p);
                    }
                }
                else {
                    // parameter is a simple array....
                    var /** @type {?} */ y = new Array();
                    var /** @type {?} */ p1 = (paths);
                    for (var /** @type {?} */ i = 0; i < p1.length; i++) {
                        y.push(new Microsoft.Maps.Location(p1[i].latitude, p1[i].longitude));
                    }
                    p.push(y);
                }
                return p;
            };
        /**
         *  Maps an IPoint object to a Microsoft.Maps.Point object.
         *
         * \@memberof BingConversions
         * @param {?} point - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslatePoint = /**
         *  Maps an IPoint object to a Microsoft.Maps.Point object.
         *
         * \@memberof BingConversions
         * @param {?} point - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (point) {
                var /** @type {?} */ p = new Microsoft.Maps.Point(point.x, point.y);
                return p;
            };
        /**
         *  Maps an IPolygonOptions object to a Microsoft.Maps.IPolygonOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslatePolygonOptions = /**
         *  Maps an IPolygonOptions object to a Microsoft.Maps.IPolygonOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                var /** @type {?} */ f = function (s, a) {
                    var /** @type {?} */ m = /rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*\d+[\.\d+]*)*\)/g.exec(s);
                    if (m && m.length > 3) {
                        a = a > 1 ? (a / 100) : a;
                        return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';
                    }
                    else if (s[0] === '#') {
                        var /** @type {?} */ z = s.substr(1);
                        var /** @type {?} */ r = parseInt(z.substr(0, 2), 16);
                        var /** @type {?} */ g = parseInt(z.substr(2, 2), 16);
                        var /** @type {?} */ b = parseInt(z.substr(4, 2), 16);
                        return 'rgba(' + [r, g, b, a].join(',') + ')';
                    }
                    else {
                        return s;
                    }
                };
                Object.keys(options)
                    .filter(function (k) { return BingConversions._polygonOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'strokeWeight') {
                        o.strokeThickness = options.strokeWeight;
                    }
                    else if (k === 'strokeColor') {
                        if (options.strokeOpacity) {
                            o.strokeColor = f(options.strokeColor, options.strokeOpacity);
                        }
                        else {
                            o.strokeColor = options.strokeColor;
                        }
                    }
                    else if (k === 'strokeOpacity') ;
                    else if (k === 'fillColor') {
                        if (options.fillOpacity) {
                            o.fillColor = f(options.fillColor, options.fillOpacity);
                        }
                        else {
                            o.fillColor = options.fillColor;
                        }
                    }
                    else if (k === 'fillOpacity') ;
                    else {
                        ((o))[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         *  Maps an IPolylineOptions object to a Microsoft.Maps.IPolylineOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslatePolylineOptions = /**
         *  Maps an IPolylineOptions object to a Microsoft.Maps.IPolylineOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                var /** @type {?} */ f = function (s, a) {
                    var /** @type {?} */ m = /rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*\d+[\.\d+]*)*\)/g.exec(s);
                    if (m && m.length > 3) {
                        a = a > 1 ? (a / 100) : a;
                        return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';
                    }
                    else if (s[0] === '#') {
                        var /** @type {?} */ z = s.substr(1);
                        var /** @type {?} */ r = parseInt(z.substr(0, 2), 16);
                        var /** @type {?} */ g = parseInt(z.substr(2, 2), 16);
                        var /** @type {?} */ b = parseInt(z.substr(4, 2), 16);
                        return 'rgba(' + [r, g, b, a].join(',') + ')';
                    }
                    else {
                        return s;
                    }
                };
                Object.keys(options)
                    .filter(function (k) { return BingConversions._polylineOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'strokeWeight') {
                        o.strokeThickness = options.strokeWeight;
                    }
                    else if (k === 'strokeColor') {
                        if (options.strokeOpacity) {
                            o.strokeColor = f(options.strokeColor, options.strokeOpacity);
                        }
                        else {
                            o.strokeColor = options.strokeColor;
                        }
                    }
                    else if (k === 'strokeOpacity') ;
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a Microsoft.Maps.IViewOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateViewOptions = /**
         * Maps an IMapOptions object to a Microsoft.Maps.IViewOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._viewOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = BingConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'bounds') {
                        o.bounds = BingConversions.TranslateBounds(options.bounds);
                    }
                    else if (k === 'centerOffset') {
                        o.centerOffset = BingConversions.TranslatePoint(options.centerOffset);
                    }
                    else if (k === 'mapTypeId') {
                        o.mapTypeId = Microsoft.Maps.MapTypeId[((MapTypeId))[options.mapTypeId]];
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Map option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._mapOptionsAttributes = [
            'backgroundColor',
            'credentials',
            'customizeOverlays',
            'customMapStyle',
            'disableBirdseye',
            'disableKeyboardInput',
            'disableMouseInput',
            'disablePanning',
            'disableTouchInput',
            'disableUserInput',
            'disableZooming',
            'disableStreetside',
            'enableClickableLogo',
            'enableSearchLogo',
            'fixedMapPosition',
            'height',
            'inertiaIntensity',
            'navigationBarMode',
            'showBreadcrumb',
            'showCopyright',
            'showDashboard',
            'showMapTypeSelector',
            'showScalebar',
            'theme',
            'tileBuffer',
            'useInertia',
            'width',
            'center',
            'zoom',
            'mapTypeId',
            'liteMode'
        ];
        /**
         * View option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._viewOptionsAttributes = [
            'animate',
            'bounds',
            'center',
            'centerOffset',
            'heading',
            'labelOverlay',
            'mapTypeId',
            'padding',
            'zoom'
        ];
        /**
         * InfoWindow option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._infoWindowOptionsAttributes = [
            'actions',
            'description',
            'htmlContent',
            'id',
            'position',
            'pixelOffset',
            'showCloseButton',
            'showPointer',
            'pushpin',
            'title',
            'titleClickHandler',
            'typeName',
            'visible',
            'width',
            'height'
        ];
        /**
         * Marker option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._markerOptionsAttributes = [
            'anchor',
            'draggable',
            'height',
            'htmlContent',
            'icon',
            'infobox',
            'state',
            'title',
            'textOffset',
            'typeName',
            'visible',
            'width',
            'zIndex'
        ];
        /**
         * Polygon option attributes that are supported for conversion to Bing Map Polygon properties
         *
         * \@memberof BingConversions
         */
        BingConversions._polygonOptionsAttributes = [
            'cursor',
            'fillColor',
            'fillOpacity',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible'
        ];
        /**
         * Polyline option attributes that are supported for conversion to Bing Map Polyline properties
         *
         * \@memberof BingConversions
         */
        BingConversions._polylineOptionsAttributes = [
            'cursor',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible'
        ];
        /**
         * Cluster option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._clusterOptionsAttributes = [
            'callback',
            'clusteredPinCallback',
            'clusteringEnabled',
            'gridSize',
            'layerOffset',
            'placementMode',
            'visible',
            'zIndex'
        ];
        return BingConversions;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link Marker} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */
    var /**
     * Concrete implementation of the {\@link Marker} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */ BingMarker = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMarker.
         * @param _pushpin - The {@link Microsoft.Maps.Pushpin} underlying the model.
         * @param _map - The context map.
         * @param _layer - The context layer.
         *
         * @memberof BingMarker
         */
        function BingMarker(_pushpin, _map, _layer) {
            this._pushpin = _pushpin;
            this._map = _map;
            this._layer = _layer;
            this._metadata = new Map();
            this._isFirst = false;
            this._isLast = true;
        }
        Object.defineProperty(BingMarker.prototype, "IsFirst", {
            get: /**
             * Indicates that the marker is the first marker in a set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isFirst; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isFirst = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "IsLast", {
            get: /**
             * Indicates that the marker is the last marker in the set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isLast; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isLast = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "Location", {
            get: /**
             * Gets the Location of the marker
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () {
                var /** @type {?} */ l = this._pushpin.getLocation();
                return {
                    latitude: l.latitude,
                    longitude: l.longitude
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "Metadata", {
            get: /**
             * Gets the marker metadata.
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the marker, in this case {\@link Microsoft.Maps.Pushpin}
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._pushpin; },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        BingMarker.prototype.AddListener = /**
         * Adds an event listener to the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                Microsoft.Maps.Events.addHandler(this._pushpin, eventType, function (e) {
                    fn(e);
                });
            };
        /**
         * Deletes the marker.
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
        BingMarker.prototype.DeleteMarker = /**
         * Deletes the marker.
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
            function () {
                if (!this._map && !this._layer) {
                    return;
                }
                if (this._layer) {
                    this._layer.remove(this.NativePrimitve);
                }
                else {
                    this._map.entities.remove(this.NativePrimitve);
                }
            };
        /**
         * Gets the marker label
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
        BingMarker.prototype.GetLabel = /**
         * Gets the marker label
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
            function () {
                return this._pushpin.getText();
            };
        /**
         * Gets whether the marker is visible.
         *
         * \@memberof BingMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
        BingMarker.prototype.GetVisible = /**
         * Gets whether the marker is visible.
         *
         * \@memberof BingMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
            function () {
                return this._pushpin.getVisible();
            };
        /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
        BingMarker.prototype.SetAnchor = /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
            function (anchor) {
                var /** @type {?} */ o = {};
                o.anchor = new Microsoft.Maps.Point(anchor.x, anchor.y);
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the draggability of a marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
        BingMarker.prototype.SetDraggable = /**
         * Sets the draggability of a marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                var /** @type {?} */ o = {};
                o.draggable = draggable;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the icon for the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
        BingMarker.prototype.SetIcon = /**
         * Sets the icon for the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
            function (icon) {
                var /** @type {?} */ o = {};
                o.icon = icon;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the marker label.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
        BingMarker.prototype.SetLabel = /**
         * Sets the marker label.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
            function (label) {
                var /** @type {?} */ o = {};
                o.text = label;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the marker position.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
        BingMarker.prototype.SetPosition = /**
         * Sets the marker position.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
            function (latLng) {
                var /** @type {?} */ p = BingConversions.TranslateLocation(latLng);
                this._pushpin.setLocation(p);
            };
        /**
         * Sets the marker title.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
        BingMarker.prototype.SetTitle = /**
         * Sets the marker title.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
            function (title) {
                var /** @type {?} */ o = {};
                o.title = title;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the marker options.
         *
         * @abstract
         * \@memberof Marker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         * @return {?}
         */
        BingMarker.prototype.SetOptions = /**
         * Sets the marker options.
         *
         * @abstract
         * \@memberof Marker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = BingConversions.TranslateMarkerOptions(options);
                this._pushpin.setOptions(o);
            };
        /**
         * Sets whether the marker is visible.
         *
         * \@memberof Marker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
        BingMarker.prototype.SetVisible = /**
         * Sets whether the marker is visible.
         *
         * \@memberof Marker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                var /** @type {?} */ o = {};
                o.visible = visible;
                this._pushpin.setOptions(o);
            };
        return BingMarker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BingSpiderClusterMarker = (function (_super) {
        __extends(BingSpiderClusterMarker, _super);
        function BingSpiderClusterMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return BingSpiderClusterMarker;
    }(BingMarker));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of a clustering layer for the Bing Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a clustering layer for the Bing Map Provider.
     *
     * @export
     */ BingClusterLayer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the BingClusterLayer class.
         *
         * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof BingClusterLayer
         */
        function BingClusterLayer(_layer, _maps) {
            this._layer = _layer;
            this._maps = _maps;
            this._isClustering = true;
            this._markers = new Array();
            this._markerLookup = new Map();
            this._pendingMarkers = new Array();
            this._spiderMarkers = new Array();
            this._spiderMarkerLookup = new Map();
            this._useSpiderCluster = false;
            this._mapclicks = 0;
            this._events = new Array();
            this._currentZoom = 0;
            this._spiderOptions = {
                circleSpiralSwitchover: 9,
                collapseClusterOnMapChange: false,
                collapseClusterOnNthClick: 1,
                invokeClickOnHover: true,
                minCircleLength: 60,
                minSpiralAngleSeperation: 25,
                spiralDistanceFactor: 5,
                stickStyle: {
                    strokeColor: 'black',
                    strokeThickness: 2
                },
                stickHoverStyle: { strokeColor: 'red' },
                markerSelected: null,
                markerUnSelected: null
            };
            this._currentCluster = null;
        }
        Object.defineProperty(BingClusterLayer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer.
             *
             * \@memberof BingClusterLayer
             * @return {?} Microsoft.Maps.ClusterLayer.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                Microsoft.Maps.Events.addHandler(this._layer, eventType, function (e) {
                    fn(e);
                });
            };
        /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.AddEntity = /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                var /** @type {?} */ isMarker = entity instanceof Marker;
                isMarker = entity instanceof BingMarker || isMarker;
                if (isMarker) {
                    if (entity.IsFirst) {
                        this.StopClustering();
                    }
                }
                if (entity.NativePrimitve && entity.Location) {
                    if (this._isClustering) {
                        var /** @type {?} */ p = this._layer.getPushpins();
                        p.push(entity.NativePrimitve);
                        this._layer.setPushpins(p);
                        this._markers.push(entity);
                    }
                    else {
                        this._pendingMarkers.push(entity);
                    }
                    this._markerLookup.set(entity.NativePrimitve, entity);
                }
                if (isMarker) {
                    if (entity.IsLast) {
                        this.StartClustering();
                    }
                }
            };
        /**
         * Adds a number of markers to the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.AddEntities = /**
         * Adds a number of markers to the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    var /** @type {?} */ e = entities.map(function (p) {
                        _this._markerLookup.set(p.NativePrimitve, p);
                        return p.NativePrimitve;
                    });
                    if (this._isClustering) {
                        var /** @type {?} */ p = this._layer.getPushpins();
                        p.push.apply(p, __spread(e));
                        this._layer.setPushpins(p);
                        (_a = this._markers).push.apply(_a, __spread(entities));
                    }
                    else {
                        (_b = this._pendingMarkers).push.apply(_b, __spread(entities));
                    }
                }
                var _a, _b;
            };
        /**
         * Initializes spider behavior for the clusering layer (when a cluster maker is clicked, it explodes into a spider of the
         * individual underlying pins.
         *
         * \@memberof BingClusterLayer
         * @param {?=} options ISpiderClusterOptions. Optional. Options governing the behavior of the spider.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.InitializeSpiderClusterSupport = /**
         * Initializes spider behavior for the clusering layer (when a cluster maker is clicked, it explodes into a spider of the
         * individual underlying pins.
         *
         * \@memberof BingClusterLayer
         * @param {?=} options ISpiderClusterOptions. Optional. Options governing the behavior of the spider.
         *
         * @return {?}
         */
            function (options) {
                var _this = this;
                if (this._useSpiderCluster) {
                    return;
                }
                var /** @type {?} */ m = ((this._maps)).MapInstance;
                this._useSpiderCluster = true;
                this._spiderLayer = new Microsoft.Maps.Layer();
                this._currentZoom = m.getZoom();
                this.SetSpiderOptions(options);
                m.layers.insert(this._spiderLayer);
                this._events.push(Microsoft.Maps.Events.addHandler(m, 'click', function (e) { return _this.OnMapClick(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangestart', function (e) { return _this.OnMapViewChangeStart(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangeend', function (e) { return _this.OnMapViewChangeEnd(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._layer, 'click', function (e) { return _this.OnLayerClick(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'click', function (e) { return _this.OnLayerClick(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseover', function (e) { return _this.OnSpiderMouseOver(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseout', function (e) { return _this.OnSpiderMouseOut(e); }));
            };
        /**
         * Deletes the clustering layer.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.Delete = /**
         * Deletes the clustering layer.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._useSpiderCluster) {
                    this._spiderLayer.clear();
                    ((this._maps)).MapPromise.then(function (m) {
                        m.layers.remove(_this._spiderLayer);
                        _this._spiderLayer = null;
                    });
                    this._events.forEach(function (e) { return Microsoft.Maps.Events.removeHandler(e); });
                    this._events.splice(0);
                    this._useSpiderCluster = false;
                }
                this._markers.splice(0);
                this._spiderMarkers.splice(0);
                this._pendingMarkers.splice(0);
                this._markerLookup.clear();
                this._maps.DeleteLayer(this);
            };
        /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
        BingClusterLayer.prototype.GetMarkerFromBingMarker = /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
            function (pin) {
                var /** @type {?} */ m = this._markerLookup.get(pin);
                return m;
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
        BingClusterLayer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
            function () {
                var /** @type {?} */ o = this._layer.getOptions();
                var /** @type {?} */ options = {
                    id: 0,
                    gridSize: o.gridSize,
                    layerOffset: o.layerOffset,
                    clusteringEnabled: o.clusteringEnabled,
                    callback: o.callback,
                    clusteredPinCallback: o.clusteredPinCallback,
                    visible: o.visible,
                    zIndex: o.zIndex
                };
                return options;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        BingClusterLayer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._layer.getOptions().visible;
            };
        /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} - The abstract marker object representing the pushpin.
         *
         */
        BingClusterLayer.prototype.GetSpiderMarkerFromBingMarker = /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} - The abstract marker object representing the pushpin.
         *
         */
            function (pin) {
                var /** @type {?} */ m = this._spiderMarkerLookup.get(pin);
                return m;
            };
        /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker - Entity to be removed from the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.RemoveEntity = /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker - Entity to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve && entity.Location) {
                    var /** @type {?} */ j = this._markers.indexOf(entity);
                    var /** @type {?} */ k = this._pendingMarkers.indexOf(entity);
                    if (j > -1) {
                        this._markers.splice(j, 1);
                    }
                    if (k > -1) {
                        this._pendingMarkers.splice(k, 1);
                    }
                    if (this._isClustering) {
                        var /** @type {?} */ p = this._layer.getPushpins();
                        var /** @type {?} */ i = p.indexOf(entity.NativePrimitve);
                        if (i > -1) {
                            p.splice(i, 1);
                            this._layer.setPushpins(p);
                        }
                    }
                    this._markerLookup.delete(entity.NativePrimitve);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                var /** @type {?} */ p = new Array();
                this._markers.splice(0);
                this._markerLookup.clear();
                entities.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        _this._markers.push(e);
                        _this._markerLookup.set(e.NativePrimitve, e);
                        p.push(/** @type {?} */ (e.NativePrimitve));
                    }
                });
                this._layer.setPushpins(p);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = BingConversions.TranslateClusterOptions(options);
                this._layer.setOptions(o);
                if (options.spiderClusterOptions) {
                    this.SetSpiderOptions(options.spiderClusterOptions);
                }
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingClusterLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingClusterLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                var /** @type {?} */ o = this._layer.getOptions();
                o.visible = visible;
                this._layer.setOptions(o);
            };
        /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.StartClustering = /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                if (this._isClustering) {
                    return;
                }
                var /** @type {?} */ p = new Array();
                this._markers.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        p.push(/** @type {?} */ (e.NativePrimitve));
                    }
                });
                this._pendingMarkers.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        p.push(/** @type {?} */ (e.NativePrimitve));
                    }
                });
                this._layer.setPushpins(p);
                this._markers = this._markers.concat(this._pendingMarkers.splice(0));
                this._isClustering = true;
            };
        /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.StopClustering = /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                if (!this._isClustering) {
                    return;
                }
                this._isClustering = false;
            };
        /**
         * Creates a copy of a pushpins basic options.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin Pushpin to copy options from.
         * @return {?} - A copy of a pushpins basic options.
         *
         */
        BingClusterLayer.prototype.GetBasicPushpinOptions = /**
         * Creates a copy of a pushpins basic options.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin Pushpin to copy options from.
         * @return {?} - A copy of a pushpins basic options.
         *
         */
            function (pin) {
                return /** @type {?} */ ({
                    anchor: pin.getAnchor(),
                    color: pin.getColor(),
                    cursor: pin.getCursor(),
                    icon: pin.getIcon(),
                    roundClickableArea: pin.getRoundClickableArea(),
                    subTitle: pin.getSubTitle(),
                    text: pin.getText(),
                    textOffset: pin.getTextOffset(),
                    title: pin.getTitle()
                });
            };
        /**
         * Hides the spider cluster and resotres the original pin.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.HideSpiderCluster = /**
         * Hides the spider cluster and resotres the original pin.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                this._mapclicks = 0;
                if (this._currentCluster) {
                    this._spiderLayer.clear();
                    this._spiderMarkers.splice(0);
                    this._spiderMarkerLookup.clear();
                    this._currentCluster = null;
                    this._mapclicks = -1;
                    if (this._spiderOptions.markerUnSelected) {
                        this._spiderOptions.markerUnSelected();
                    }
                }
            };
        /**
         * Click event handler for when a shape in the cluster layer is clicked.
         *
         * \@memberof BingClusterLayer
         * @param {?} e The mouse event argurment from the click event.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnLayerClick = /**
         * Click event handler for when a shape in the cluster layer is clicked.
         *
         * \@memberof BingClusterLayer
         * @param {?} e The mouse event argurment from the click event.
         *
         * @return {?}
         */
            function (e) {
                if (e.primitive instanceof Microsoft.Maps.ClusterPushpin) {
                    var /** @type {?} */ cp = (e.primitive);
                    var /** @type {?} */ showNewCluster = cp !== this._currentCluster;
                    this.HideSpiderCluster();
                    if (showNewCluster) {
                        this.ShowSpiderCluster(/** @type {?} */ (e.primitive));
                    }
                }
                else {
                    var /** @type {?} */ pin = (e.primitive);
                    if (pin.metadata && pin.metadata.isClusterMarker) {
                        var /** @type {?} */ m = this.GetSpiderMarkerFromBingMarker(pin);
                        var /** @type {?} */ p = m.ParentMarker;
                        var /** @type {?} */ ppin = p.NativePrimitve;
                        if (this._spiderOptions.markerSelected) {
                            this._spiderOptions.markerSelected(p, new BingMarker(this._currentCluster, null, null));
                        }
                        if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) {
                            Microsoft.Maps.Events.invoke(ppin, 'click', e);
                        }
                        this._mapclicks = 0;
                    }
                    else {
                        if (this._spiderOptions.markerSelected) {
                            this._spiderOptions.markerSelected(this.GetMarkerFromBingMarker(pin), null);
                        }
                        if (Microsoft.Maps.Events.hasHandler(pin, 'click')) {
                            Microsoft.Maps.Events.invoke(pin, 'click', e);
                        }
                    }
                }
            };
        /**
         * Delegate handling the click event on the map (outside a spider cluster). Depending on the
         * spider options, closes the cluster or increments the click counter.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnMapClick = /**
         * Delegate handling the click event on the map (outside a spider cluster). Depending on the
         * spider options, closes the cluster or increments the click counter.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event
         *
         * @return {?}
         */
            function (e) {
                if (this._mapclicks === -1) {
                    return;
                }
                else if (++this._mapclicks >= this._spiderOptions.collapseClusterOnNthClick) {
                    this.HideSpiderCluster();
                }
            };
        /**
         * Delegate handling the map view changed end event. Hides the spider cluster if the zoom level has changed.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnMapViewChangeEnd = /**
         * Delegate handling the map view changed end event. Hides the spider cluster if the zoom level has changed.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
            function (e) {
                var /** @type {?} */ z = ((e.target)).getZoom();
                var /** @type {?} */ hasZoomChanged = (z !== this._currentZoom);
                this._currentZoom = z;
                if (hasZoomChanged) {
                    this.HideSpiderCluster();
                }
            };
        /**
         * Delegate handling the map view change start event. Depending on the spider options, hides the
         * the exploded spider or does nothing.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnMapViewChangeStart = /**
         * Delegate handling the map view change start event. Depending on the spider options, hides the
         * the exploded spider or does nothing.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
            function (e) {
                if (this._spiderOptions.collapseClusterOnMapChange) {
                    this.HideSpiderCluster();
                }
            };
        /**
         * Delegate invoked on mouse out on an exploded spider marker. Resets the hover style on the stick.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
        BingClusterLayer.prototype.OnSpiderMouseOut = /**
         * Delegate invoked on mouse out on an exploded spider marker. Resets the hover style on the stick.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
            function (e) {
                var /** @type {?} */ pin = (e.primitive);
                if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {
                    var /** @type {?} */ m = this.GetSpiderMarkerFromBingMarker(pin);
                    m.Stick.setOptions(this._spiderOptions.stickStyle);
                }
            };
        /**
         * Invoked on mouse over on an exploded spider marker. Sets the hover style on the stick. Also invokes the click event
         * on the underlying original marker dependent on the spider options.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
        BingClusterLayer.prototype.OnSpiderMouseOver = /**
         * Invoked on mouse over on an exploded spider marker. Sets the hover style on the stick. Also invokes the click event
         * on the underlying original marker dependent on the spider options.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
            function (e) {
                var /** @type {?} */ pin = (e.primitive);
                if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {
                    var /** @type {?} */ m = this.GetSpiderMarkerFromBingMarker(pin);
                    m.Stick.setOptions(this._spiderOptions.stickHoverStyle);
                    if (this._spiderOptions.invokeClickOnHover) {
                        var /** @type {?} */ p = m.ParentMarker;
                        var /** @type {?} */ ppin = p.NativePrimitve;
                        if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) {
                            Microsoft.Maps.Events.invoke(ppin, 'click', e);
                        }
                    }
                }
            };
        /**
         * Sets the options for spider behavior.
         *
         * \@memberof BingClusterLayer
         * @param {?} options ISpiderClusterOptions containing the options enumeration controlling the spider cluster behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetSpiderOptions = /**
         * Sets the options for spider behavior.
         *
         * \@memberof BingClusterLayer
         * @param {?} options ISpiderClusterOptions containing the options enumeration controlling the spider cluster behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                if (options) {
                    if (typeof options.circleSpiralSwitchover === 'number') {
                        this._spiderOptions.circleSpiralSwitchover = options.circleSpiralSwitchover;
                    }
                    if (typeof options.collapseClusterOnMapChange === 'boolean') {
                        this._spiderOptions.collapseClusterOnMapChange = options.collapseClusterOnMapChange;
                    }
                    if (typeof options.collapseClusterOnNthClick === 'number') {
                        this._spiderOptions.collapseClusterOnNthClick = options.collapseClusterOnNthClick;
                    }
                    if (typeof options.invokeClickOnHover === 'boolean') {
                        this._spiderOptions.invokeClickOnHover = options.invokeClickOnHover;
                    }
                    if (typeof options.minSpiralAngleSeperation === 'number') {
                        this._spiderOptions.minSpiralAngleSeperation = options.minSpiralAngleSeperation;
                    }
                    if (typeof options.spiralDistanceFactor === 'number') {
                        this._spiderOptions.spiralDistanceFactor = options.spiralDistanceFactor;
                    }
                    if (typeof options.minCircleLength === 'number') {
                        this._spiderOptions.minCircleLength = options.minCircleLength;
                    }
                    if (options.stickHoverStyle) {
                        this._spiderOptions.stickHoverStyle = options.stickHoverStyle;
                    }
                    if (options.stickStyle) {
                        this._spiderOptions.stickStyle = options.stickStyle;
                    }
                    if (options.markerSelected) {
                        this._spiderOptions.markerSelected = options.markerSelected;
                    }
                    if (options.markerUnSelected) {
                        this._spiderOptions.markerUnSelected = options.markerUnSelected;
                    }
                    if (typeof options.visible === 'boolean') {
                        this._spiderOptions.visible = options.visible;
                    }
                    this.SetOptions(/** @type {?} */ (options));
                }
            };
        /**
         * Expands a cluster into it's open spider layout.
         *
         * \@memberof BingClusterLayer
         * @param {?} cluster The cluster to show in it's open spider layout..
         *
         * @return {?}
         */
        BingClusterLayer.prototype.ShowSpiderCluster = /**
         * Expands a cluster into it's open spider layout.
         *
         * \@memberof BingClusterLayer
         * @param {?} cluster The cluster to show in it's open spider layout..
         *
         * @return {?}
         */
            function (cluster) {
                this.HideSpiderCluster();
                this._currentCluster = cluster;
                if (cluster && cluster.containedPushpins) {
                    // Create spider data.
                    var /** @type {?} */ m = ((this._maps)).MapInstance;
                    var /** @type {?} */ pins = cluster.containedPushpins;
                    var /** @type {?} */ center = cluster.getLocation();
                    var /** @type {?} */ centerPoint = (m.tryLocationToPixel(center, Microsoft.Maps.PixelReference.control));
                    var /** @type {?} */ stick = void 0;
                    var /** @type {?} */ angle = 0;
                    var /** @type {?} */ makeSpiral = pins.length > this._spiderOptions.circleSpiralSwitchover;
                    var /** @type {?} */ legPixelLength = void 0;
                    var /** @type {?} */ stepAngle = void 0;
                    var /** @type {?} */ stepLength = void 0;
                    if (makeSpiral) {
                        legPixelLength = this._spiderOptions.minCircleLength / Math.PI;
                        stepLength = 2 * Math.PI * this._spiderOptions.spiralDistanceFactor;
                    }
                    else {
                        stepAngle = 2 * Math.PI / pins.length;
                        legPixelLength = (this._spiderOptions.spiralDistanceFactor / stepAngle / Math.PI / 2) * pins.length;
                        if (legPixelLength < this._spiderOptions.minCircleLength) {
                            legPixelLength = this._spiderOptions.minCircleLength;
                        }
                    }
                    for (var /** @type {?} */ i = 0, /** @type {?} */ len = pins.length; i < len; i++) {
                        // Calculate spider pin location.
                        if (!makeSpiral) {
                            angle = stepAngle * i;
                        }
                        else {
                            angle += this._spiderOptions.minSpiralAngleSeperation / legPixelLength + i * 0.0005;
                            legPixelLength += stepLength / angle;
                        }
                        var /** @type {?} */ point = new Microsoft.Maps.Point(centerPoint.x + legPixelLength * Math.cos(angle), centerPoint.y + legPixelLength * Math.sin(angle));
                        var /** @type {?} */ loc = (m.tryPixelToLocation(point, Microsoft.Maps.PixelReference.control));
                        // Create stick to pin.
                        stick = new Microsoft.Maps.Polyline([center, loc], this._spiderOptions.stickStyle);
                        this._spiderLayer.add(stick);
                        // Create pin in spiral that contains same metadata as parent pin.
                        var /** @type {?} */ pin = new Microsoft.Maps.Pushpin(loc);
                        pin.metadata = pins[i].metadata || {};
                        pin.metadata.isClusterMarker = true;
                        pin.setOptions(this.GetBasicPushpinOptions(pins[i]));
                        this._spiderLayer.add(pin);
                        var /** @type {?} */ spiderMarker = new BingSpiderClusterMarker(pin, null, this._spiderLayer);
                        spiderMarker.Stick = stick;
                        spiderMarker.ParentMarker = /** @type {?} */ (this.GetMarkerFromBingMarker(pins[i]));
                        this._spiderMarkers.push(spiderMarker);
                        this._spiderMarkerLookup.set(pin, spiderMarker);
                    }
                    this._mapclicks = 0;
                }
            };
        return BingClusterLayer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link InfoWindow} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */
    var /**
     * Concrete implementation of the {\@link InfoWindow} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */ BingInfoWindow = (function () {
        /**
         * Creates an instance of BingInfoWindow.
         * @param _infoBox - A {@link Microsoft.Maps.Infobox} instance underlying the model
         * @memberof BingInfoWindow
         */
        function BingInfoWindow(_infoBox) {
            this._infoBox = _infoBox;
            this._isOpen = false;
        }
        Object.defineProperty(BingInfoWindow.prototype, "IsOpen", {
            get: /**
             * Gets whether the info box is currently open.
             *
             * \@readonly
             * \@memberof BingInfoWindow
             * @return {?}
             */ function () {
                if (this._infoBox && this._infoBox.getOptions().visible === true) {
                    return true;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingInfoWindow.prototype, "NativePrimitve", {
            get: /**
             * Gets native primitve underlying the model.
             *
             * \@memberof BingInfoWindow
             * \@property
             * \@readonly
             * @return {?}
             */ function () {
                return this._infoBox;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        BingInfoWindow.prototype.AddListener = /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                Microsoft.Maps.Events.addHandler(this._infoBox, eventType, function (e) {
                    if (e.eventName === 'infoboxChanged') {
                        if (_this._infoBox.getOptions().visible === true) {
                            _this._isOpen = true;
                        }
                        else {
                            if (_this._infoBox.getOptions().visible === false && _this._isOpen === true) {
                                _this._isOpen = false;
                                fn(e);
                            }
                        }
                    }
                    else {
                        fn(e);
                    }
                });
            };
        /**
         * Closes the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
        BingInfoWindow.prototype.Close = /**
         * Closes the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
            function () {
                var /** @type {?} */ o = {};
                o.visible = false;
                this._infoBox.setOptions(o);
            };
        /**
         * Gets the position of the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?} - Returns the geo coordinates of the info window.
         */
        BingInfoWindow.prototype.GetPosition = /**
         * Gets the position of the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?} - Returns the geo coordinates of the info window.
         */
            function () {
                var /** @type {?} */ p = {
                    latitude: this._infoBox.getLocation().latitude,
                    longitude: this._infoBox.getLocation().longitude
                };
                return p;
            };
        /**
         * Opens the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
        BingInfoWindow.prototype.Open = /**
         * Opens the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
            function () {
                var /** @type {?} */ o = {};
                o.visible = true;
                this._infoBox.setOptions(o);
            };
        /**
         * Sets the info window options.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} options - Info window options to set. The options will be merged with any existing options.
         *
         * @return {?}
         */
        BingInfoWindow.prototype.SetOptions = /**
         * Sets the info window options.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} options - Info window options to set. The options will be merged with any existing options.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = BingConversions.TranslateInfoBoxOptions(options);
                this._infoBox.setOptions(o);
            };
        /**
         * Sets the info window position.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} position - Geo coordinates to move the anchor of the info window to.
         *
         * @return {?}
         */
        BingInfoWindow.prototype.SetPosition = /**
         * Sets the info window position.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} position - Geo coordinates to move the anchor of the info window to.
         *
         * @return {?}
         */
            function (position) {
                var /** @type {?} */ l = BingConversions.TranslateLocation(position);
                this._infoBox.setLocation(l);
            };
        return BingInfoWindow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract base implementing a label to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract base implementing a label to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */ MapLabel = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new MapLabel
         * @param options Optional properties to set.
         */
        function MapLabel(options) {
            this.Set('fontFamily', 'sans-serif');
            this.Set('fontSize', 12);
            this.Set('fontColor', '#ffffff');
            this.Set('strokeWeight', 4);
            this.Set('strokeColor', '#000000');
            this.Set('align', 'center');
            this.SetValues(options);
        }
        /**
         * Deletes the label from the map. This method does not atually delete the label itself, so
         * it can be readded to map later.
         * \@memberof MapLabel
         * \@method
         * @return {?}
         */
        MapLabel.prototype.Delete = /**
         * Deletes the label from the map. This method does not atually delete the label itself, so
         * it can be readded to map later.
         * \@memberof MapLabel
         * \@method
         * @return {?}
         */
            function () {
                this.SetMap(null);
            };
        /**
         * Delegate called when underlying properties change.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} prop - The property or properties that have changed.
         * @return {?}
         */
        MapLabel.prototype.Changed = /**
         * Delegate called when underlying properties change.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} prop - The property or properties that have changed.
         * @return {?}
         */
            function (prop) {
                var /** @type {?} */ shouldRunDrawCanvas = false;
                var /** @type {?} */ shouldRunDraw = false;
                if (!Array.isArray(prop)) {
                    prop = [prop];
                }
                prop.forEach(function (p) {
                    switch (p) {
                        case 'fontFamily':
                        case 'fontSize':
                        case 'fontColor':
                        case 'strokeWeight':
                        case 'strokeColor':
                        case 'align':
                        case 'text':
                            shouldRunDrawCanvas = true;
                            break;
                        case 'maxZoom':
                        case 'minZoom':
                        case 'offset':
                        case 'hidden':
                        case 'position':
                            shouldRunDraw = true;
                            break;
                    }
                });
                if (shouldRunDrawCanvas) {
                    this.DrawCanvas();
                }
                if (shouldRunDraw) {
                    this.Draw();
                }
            };
        ///
        /// Protected methods
        ///
        /**
         * Get the visibility of the label. Visibility depends on Zoom settings.
         * @returns - blank string if visible, 'hidden' if invisible.
         * @protected
         */
        /**
         * Get the visibility of the label. Visibility depends on Zoom settings.
         * @protected
         * @return {?} - blank string if visible, 'hidden' if invisible.
         */
        MapLabel.prototype.GetVisible = /**
         * Get the visibility of the label. Visibility depends on Zoom settings.
         * @protected
         * @return {?} - blank string if visible, 'hidden' if invisible.
         */
            function () {
                var /** @type {?} */ minZoom = this.Get('minZoom');
                var /** @type {?} */ maxZoom = this.Get('maxZoom');
                var /** @type {?} */ hidden = this.Get('hidden');
                if (hidden) {
                    return 'hidden';
                }
                if (minZoom === undefined && maxZoom === undefined) {
                    return '';
                }
                if (!this.GetMap()) {
                    return '';
                }
                var /** @type {?} */ mapZoom = this.GetMap().getZoom();
                if (mapZoom < minZoom || mapZoom > maxZoom) {
                    return 'hidden';
                }
                return '';
            };
        /**
         * Draws the label to the canvas 2d context.
         * @memberof MapLabel
         * @method
         * @protected
         */
        /**
         * Draws the label to the canvas 2d context.
         * \@memberof MapLabel
         * \@method
         * @protected
         * @return {?}
         */
        MapLabel.prototype.DrawCanvas = /**
         * Draws the label to the canvas 2d context.
         * \@memberof MapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                if (!this._canvas) {
                    return;
                }
                var /** @type {?} */ style = this._canvas.style;
                style.zIndex = this.Get('zIndex');
                var /** @type {?} */ ctx = this._canvas.getContext('2d');
                ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
                ctx.strokeStyle = this.Get('strokeColor');
                ctx.font = this.Get('fontSize') + 'px ' + this.Get('fontFamily');
                var /** @type {?} */ backgroundColor = this.Get('backgroundColor');
                var /** @type {?} */ strokeWeight = Number(this.Get('strokeWeight'));
                var /** @type {?} */ text = this.Get('text');
                var /** @type {?} */ textMeasure = ctx.measureText(text);
                var /** @type {?} */ textWidth = textMeasure.width;
                if (text && strokeWeight && strokeWeight > 0) {
                    ctx.lineWidth = strokeWeight;
                    ctx.strokeText(text, 4, 4);
                }
                if (backgroundColor && backgroundColor !== '') {
                    ctx.fillStyle = backgroundColor;
                    ctx.fillRect(0, 0, textWidth + 8, (parseInt(ctx.font, 10) * 2) - 2);
                }
                ctx.fillStyle = this.Get('fontColor');
                ctx.fillText(text, 4, 4);
                style.marginLeft = this.GetMarginLeft(textWidth) + 'px';
                style.marginTop = '-0.4em';
                style.pointerEvents = 'none';
                // Bring actual text top in line with desired latitude.
                // Cheaper than calculating height of text.
            };
        /**
         * Gets the appropriate margin-left for the canvas.
         * @param textWidth  - The width of the text, in pixels.
         * @returns - The margin-left, in pixels.
         * @protected
         * @method
         * @memberof MapLabel
         */
        /**
         * Gets the appropriate margin-left for the canvas.
         * @protected
         * \@method
         * \@memberof MapLabel
         * @param {?} textWidth  - The width of the text, in pixels.
         * @return {?} - The margin-left, in pixels.
         */
        MapLabel.prototype.GetMarginLeft = /**
         * Gets the appropriate margin-left for the canvas.
         * @protected
         * \@method
         * \@memberof MapLabel
         * @param {?} textWidth  - The width of the text, in pixels.
         * @return {?} - The margin-left, in pixels.
         */
            function (textWidth) {
                switch (this.Get('align')) {
                    case 'left': return 0;
                    case 'right': return -textWidth;
                }
                return textWidth / -2;
            };
        /**
         * Called when the label is removed from the map.
         * @method
         * @protected
         * @memberof MapLabel
         */
        /**
         * Called when the label is removed from the map.
         * \@method
         * @protected
         * \@memberof MapLabel
         * @return {?}
         */
        MapLabel.prototype.OnRemove = /**
         * Called when the label is removed from the map.
         * \@method
         * @protected
         * \@memberof MapLabel
         * @return {?}
         */
            function () {
                if (this._canvas && this._canvas.parentNode) {
                    this._canvas.parentNode.removeChild(this._canvas);
                }
            };
        return MapLabel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var Extender = (function () {
        function Extender(obj) {
            this._obj = obj;
            this._proto = obj.prototype;
        }
        /**
         * @param {?} newObj
         * @return {?}
         */
        Extender.prototype.Extend = /**
         * @param {?} newObj
         * @return {?}
         */
            function (newObj) {
                this.Set('prototype', newObj, this._obj);
                for (var /** @type {?} */ y in this._proto) {
                    if (((this._proto))[y] != null) {
                        this.Set(y, (this._proto)[y], ((this._obj.prototype))[y]);
                    }
                }
                return this;
            };
        /**
         * @param {?} property
         * @param {?} newObj
         * @param {?=} obj
         * @return {?}
         */
        Extender.prototype.Set = /**
         * @param {?} property
         * @param {?} newObj
         * @param {?=} obj
         * @return {?}
         */
            function (property, newObj, obj) {
                if (typeof newObj === 'undefined') {
                    return this;
                }
                if (typeof obj === 'undefined') {
                    obj = this._proto;
                }
                Object.defineProperty(obj, property, newObj);
            };
        /**
         * @param {?} property
         * @param {?} newProperty
         * @return {?}
         */
        Extender.prototype.Map = /**
         * @param {?} property
         * @param {?} newProperty
         * @return {?}
         */
            function (property, newProperty) {
                this.Set(property, this._proto[newProperty], this._obj.prototype);
                return this;
            };
        return Extender;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ id$1 = 0;
    /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */
    var /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */ BingMapLabel = (function (_super) {
        __extends(BingMapLabel, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates a new MapLabel
         * @param options Optional properties to set.
         */
        function BingMapLabel(options) {
            var _this = this;
            options["fontSize"] = options["fontSize"] || 12;
            options["fontColor"] = options["fontColor"] || '#ffffff';
            options["strokeWeight"] = options["strokeWeight"] || 2;
            options["strokeColor"] = options["strokeColor"] || '#000000';
            _this = _super.call(this, options) || this;
            ((_this))._options.beneathLabels = false;
            return _this;
        }
        Object.defineProperty(BingMapLabel.prototype, "DefaultLabelStyle", {
            get: /**
             * Returns the default label style for the platform
             *
             * \@readonly
             * @abstract
             * \@memberof BingMapLabel
             * @return {?}
             */ function () {
                return {
                    fontSize: 12,
                    fontFamily: 'sans-serif',
                    fontColor: '#ffffff',
                    strokeWeight: 2,
                    strokeColor: '#000000'
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the value of a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
        BingMapLabel.prototype.Get = /**
         * Gets the value of a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
            function (key) {
                return ((this))[key];
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
        BingMapLabel.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
            function () {
                return ((this)).getMap();
            };
        /**
         * Set the value for a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
        BingMapLabel.prototype.Set = /**
         * Set the value for a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
            function (key, val) {
                if (key === 'position' && !val.hasOwnProperty('altitude') && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {
                    val = new Microsoft.Maps.Location(val.latitude, val.longitude);
                }
                if (this.Get(key) !== val) {
                    ((this))[key] = val;
                    this.Changed(key);
                }
            };
        /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
        BingMapLabel.prototype.SetMap = /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
            function (map) {
                var /** @type {?} */ m = this.GetMap();
                if (map === m) {
                    return;
                }
                if (m) {
                    m.layers.remove(this);
                }
                if (map != null) {
                    map.layers.insert(this);
                }
            };
        /**
         * Applies settings to the object
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
        BingMapLabel.prototype.SetValues = /**
         * Applies settings to the object
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ p = new Array();
                for (var /** @type {?} */ key in options) {
                    if (key !== '') {
                        if (key === 'position' && !options[key].hasOwnProperty('altitude') &&
                            options[key].hasOwnProperty('latitude') && options[key].hasOwnProperty('longitude')) {
                            options[key] = new Microsoft.Maps.Location(options[key].latitude, options[key].longitude);
                        }
                        if (this.Get(key) !== options[key]) {
                            ((this))[key] = options[key];
                            p.push(key);
                        }
                    }
                }
                if (p.length > 0) {
                    this.Changed(p);
                }
            };
        ///
        /// Protected methods
        ///
        /**
         * Draws the label on the map.
         * @memberof BingMapLabel
         * @method
         * @protected
         */
        /**
         * Draws the label on the map.
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        BingMapLabel.prototype.Draw = /**
         * Draws the label on the map.
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ visibility = this.GetVisible();
                var /** @type {?} */ m = this.GetMap();
                if (!this._canvas) {
                    return;
                }
                if (!m) {
                    return;
                }
                var /** @type {?} */ style = this._canvas.style;
                if (visibility !== '') {
                    // label is not visible, don't calculate positions etc.
                    style['visibility'] = visibility;
                    return;
                }
                var /** @type {?} */ offset = this.Get('offset');
                var /** @type {?} */ latLng = this.Get('position');
                if (!latLng) {
                    return;
                }
                if (!offset) {
                    offset = new Microsoft.Maps.Point(0, 0);
                }
                var /** @type {?} */ pos = (m.tryLocationToPixel(latLng, Microsoft.Maps.PixelReference.control));
                style['top'] = (pos.y + offset.y) + 'px';
                style['left'] = (pos.x + offset.x) + 'px';
                style['visibility'] = visibility;
            };
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * @memberof BingMapLabel
         * @method
         * @protected
         */
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        BingMapLabel.prototype.OnAdd = /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                this._canvas = document.createElement('canvas');
                this._canvas.id = "xMapLabel" + id$1++;
                var /** @type {?} */ style = this._canvas.style;
                style.position = 'absolute';
                var /** @type {?} */ ctx = this._canvas.getContext('2d');
                ctx.lineJoin = 'round';
                ctx.textBaseline = 'top';
                ((this)).setHtmlElement(this._canvas);
            };
        /**
         * Delegate callled when the label is loaded
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
        BingMapLabel.prototype.OnLoad = /**
         * Delegate callled when the label is loaded
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                Microsoft.Maps.Events.addHandler(this.GetMap(), 'viewchange', function () {
                    _this.Changed('position');
                });
                this.DrawCanvas();
                this.Draw();
            };
        return BingMapLabel;
    }(MapLabel));
    /**
     * Helper function to extend the CustomOverlay into the MapLabel
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinMapLabelWithOverlayView() {
        new Extender(BingMapLabel)
            .Extend(new Microsoft.Maps.CustomOverlay())
            .Map('onAdd', 'OnAdd')
            .Map('onLoad', 'OnLoad')
            .Map('onRemove', 'OnRemove');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation for a polygon model for Bing Maps V8.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polygon model for Bing Maps V8.
     *
     * @export
     */ BingPolygon = (function (_super) {
        __extends(BingPolygon, _super);
        ///
        /// constructor
        ///
        /**
         * Creates an instance of BingPolygon.
         * @param _polygon - The {@link Microsoft.Maps.Polygon} underlying the model.
         * @param _mapService Instance of the Map Service.
         * @param _layer - The context layer.
         * @memberof BingPolygon
         */
        function BingPolygon(_polygon, _mapService, _layer) {
            var _this = _super.call(this) || this;
            _this._polygon = _polygon;
            _this._mapService = _mapService;
            _this._layer = _layer;
            _this._map = null;
            _this._isEditable = false;
            _this._title = '';
            _this._maxZoom = -1;
            _this._minZoom = -1;
            _this._showLabel = false;
            _this._showTooltip = false;
            _this._label = null;
            _this._tooltip = null;
            _this._hasToolTipReceiver = false;
            _this._tooltipVisible = false;
            _this._metadata = new Map();
            _this._map = _this._mapService.MapInstance;
            _this._originalPath = _this.GetPaths();
            return _this;
        }
        Object.defineProperty(BingPolygon.prototype, "LabelMaxZoom", {
            get: /**
             * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._maxZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._maxZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "LabelMinZoom", {
            get: /**
             * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._minZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._minZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "Metadata", {
            get: /**
             * Gets the polygon metadata.
             *
             * \@readonly
             * \@memberof BingPolygon
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the polygon, in this case {\@link Microsoft.Maps.Polygon}
             *
             * \@readonly
             * \@memberof BingPolygon
             * @return {?}
             */ function () { return this._polygon; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "ShowLabel", {
            get: /**
             * Gets or sets whether to show the label
             *
             * @abstract
             * \@memberof BingPolygon
             * \@property
             * @return {?}
             */ function () { return this._showLabel; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showLabel = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof BingPolygon
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polygon
             *
             * @abstract
             * \@memberof BingPolygon
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageLabel();
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        BingPolygon.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                var /** @type {?} */ supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    Microsoft.Maps.Events.addHandler(this._polygon, eventType, function (e) {
                        fn(e);
                    });
                }
                if (eventType === 'mousemove') {
                    var /** @type {?} */ handlerId_1;
                    Microsoft.Maps.Events.addHandler(this._polygon, 'mouseover', function (e) {
                        handlerId_1 = Microsoft.Maps.Events.addHandler(_this._map, 'mousemove', function (m) { return fn(m); });
                    });
                    Microsoft.Maps.Events.addHandler(this._polygon, 'mouseout', function (e) {
                        if (handlerId_1) {
                            Microsoft.Maps.Events.removeHandler(handlerId_1);
                        }
                    });
                }
                if (eventType === 'pathchanged') {
                    this._editingCompleteEmitter = /** @type {?} */ (fn);
                }
            };
        /**
         * Deleted the polygon.
         *
         * \@memberof BingPolygon
         * @return {?}
         */
        BingPolygon.prototype.Delete = /**
         * Deleted the polygon.
         *
         * \@memberof BingPolygon
         * @return {?}
         */
            function () {
                if (this._layer) {
                    this._layer.remove(this.NativePrimitve);
                }
                else {
                    this._map.entities.remove(this.NativePrimitve);
                }
                if (this._label) {
                    this._label.Delete();
                }
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
        BingPolygon.prototype.GetDraggable = /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
            function () {
                return false;
            };
        /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        BingPolygon.prototype.GetEditable = /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._isEditable;
            };
        /**
         * Gets the polygon path.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
        BingPolygon.prototype.GetPath = /**
         * Gets the polygon path.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
            function () {
                var /** @type {?} */ p = this._polygon.getLocations();
                var /** @type {?} */ path = new Array();
                p.forEach(function (l) { return path.push({ latitude: l.latitude, longitude: l.longitude }); });
                return path;
            };
        /**
         * Gets the polygon paths.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
        BingPolygon.prototype.GetPaths = /**
         * Gets the polygon paths.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
            function () {
                var /** @type {?} */ p = this._polygon.getRings();
                var /** @type {?} */ paths = new Array();
                p.forEach(function (x) {
                    var /** @type {?} */ path = new Array();
                    x.forEach(function (y) { return path.push({ latitude: y.latitude, longitude: y.longitude }); });
                    paths.push(path);
                });
                return paths;
            };
        /**
         * Gets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
        BingPolygon.prototype.GetVisible = /**
         * Gets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
            function () {
                return this._polygon.getVisible();
            };
        /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof BingPolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetDraggable = /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof BingPolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                //      ?forum=bingmaps
                throw (new Error('The bing maps implementation currently does not support draggable polygons.'));
            };
        /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof BingPolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetEditable = /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof BingPolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                var _this = this;
                var /** @type {?} */ isChanged = this._isEditable !== editable;
                this._isEditable = editable;
                if (!isChanged) {
                    return;
                }
                if (this._isEditable) {
                    this._originalPath = this.GetPaths();
                    this._mapService.GetDrawingTools().then(function (t) {
                        t.edit(_this._polygon);
                    });
                }
                else {
                    this._mapService.GetDrawingTools().then(function (t) {
                        t.finish(function (editedPolygon) {
                            if (editedPolygon !== _this._polygon || !_this._editingCompleteEmitter) {
                                return;
                            }
                            var /** @type {?} */ newPath = _this.GetPaths();
                            var /** @type {?} */ originalPath = _this._originalPath;
                            _this.SetPaths(newPath);
                            // this is necessary for the new path to persist it appears.
                            // this is necessary for the new path to persist it appears.
                            _this._editingCompleteEmitter({
                                Click: null,
                                Polygon: _this,
                                OriginalPath: originalPath,
                                NewPath: newPath
                            });
                        });
                    });
                }
            };
        /**
         * Sets the polygon options
         *
         * \@memberof Polygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetOptions = /**
         * Sets the polygon options
         *
         * \@memberof Polygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = BingConversions.TranslatePolygonOptions(options);
                this._polygon.setOptions(o);
                if (options.visible != null && this._showLabel && this._label) {
                    this._label.Set('hidden', !options.visible);
                }
                if (typeof options.editable !== 'undefined') {
                    this.SetEditable(options.editable);
                }
            };
        /**
         * Sets the polygon path.
         *
         * \@memberof BingPolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetPath = /**
         * Sets the polygon path.
         *
         * \@memberof BingPolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
            function (path) {
                var /** @type {?} */ p = new Array();
                path.forEach(function (x) { return p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)); });
                this._originalPath = [path];
                this._polygon.setLocations(p);
                if (this._label) {
                    this._centroid = null;
                    this.ManageLabel();
                }
            };
        /**
         * Set the polygon path or paths.
         *
         * \@memberof BingPolygon
         * @param {?} paths
         * An Array of {\@link ILatLong} (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
        BingPolygon.prototype.SetPaths = /**
         * Set the polygon path or paths.
         *
         * \@memberof BingPolygon
         * @param {?} paths
         * An Array of {\@link ILatLong} (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
            function (paths) {
                if (paths == null) {
                    return;
                }
                if (!Array.isArray(paths)) {
                    return;
                }
                if (paths.length === 0) {
                    this._polygon.setRings(new Array());
                    if (this._label) {
                        this._label.Delete();
                        this._label = null;
                    }
                    return;
                }
                if (Array.isArray(paths[0])) {
                    // parameter is an array or arrays
                    var /** @type {?} */ p_1 = new Array();
                    ((paths)).forEach(function (path) {
                        var /** @type {?} */ _p = new Array();
                        path.forEach(function (x) { return _p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)); });
                        p_1.push(_p);
                    });
                    this._originalPath = /** @type {?} */ (paths);
                    this._polygon.setRings(p_1);
                    if (this._label) {
                        this._centroid = null;
                        this.ManageLabel();
                    }
                }
                else {
                    // parameter is a simple array....
                    this.SetPath(/** @type {?} */ (paths));
                }
            };
        /**
         * Sets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetVisible = /**
         * Sets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polygon.setOptions(/** @type {?} */ ({ visible: visible }));
                if (this._showLabel && this._label) {
                    this._label.Set('hidden', !visible);
                }
            };
        /**
         * Configures the label for the polygon
         * \@memberof Polygon
         * @return {?}
         */
        BingPolygon.prototype.ManageLabel = /**
         * Configures the label for the polygon
         * \@memberof Polygon
         * @return {?}
         */
            function () {
                if (this.GetPath == null || this.GetPath().length === 0) {
                    return;
                }
                if (this._showLabel && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        position: BingConversions.TranslateLocation(this.Centroid)
                    };
                    if (o["position"] == null) {
                        return;
                    }
                    if (this._minZoom !== -1) {
                        o["minZoom"] = this._minZoom;
                    }
                    if (this._maxZoom !== -1) {
                        o["maxZoom"] = this._maxZoom;
                    }
                    if (this._label == null) {
                        this._label = new BingMapLabel(o);
                        this._label.SetMap(this._map);
                    }
                    else {
                        this._label.SetValues(o);
                    }
                    this._label.Set('hidden', !this.GetVisible());
                }
                else {
                    if (this._label) {
                        this._label.SetMap(null);
                        this._label = null;
                    }
                }
            };
        /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
        BingPolygon.prototype.ManageTooltip = /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        align: 'left',
                        offset: new Microsoft.Maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        this._tooltip = new BingMapLabel(o);
                        this._tooltip.SetMap(this._map);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = Microsoft.Maps.Events.addHandler(this._polygon, 'mouseover', function (e) {
                            _this._tooltip.Set('position', e.location);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                            _this._mouseMoveListener = Microsoft.Maps.Events.addHandler(_this._map, 'mousemove', function (m) {
                                if (_this._tooltipVisible && m.location && m.primitive === _this._polygon) {
                                    _this._tooltip.Set('position', m.location);
                                }
                            });
                        });
                        this._mouseOutListener = Microsoft.Maps.Events.addHandler(this._polygon, 'mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                            if (_this._mouseMoveListener) {
                                Microsoft.Maps.Events.removeHandler(_this._mouseMoveListener);
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return BingPolygon;
    }(Polygon));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation for a polyline model for Bing Maps V8.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polyline model for Bing Maps V8.
     *
     * @export
     */ BingPolyline = (function (_super) {
        __extends(BingPolyline, _super);
        ///
        /// constructor
        ///
        /**
         * Creates an instance of BingPolygon.
         * @param _polyline - The {@link Microsoft.Maps.Polyline} underlying the model.
         * @param _map - The context map.
         * @param _layer - The context layer.
         * @memberof BingPolyline
         */
        function BingPolyline(_polyline, _map, _layer) {
            var _this = _super.call(this) || this;
            _this._polyline = _polyline;
            _this._map = _map;
            _this._layer = _layer;
            _this._isEditable = true;
            _this._title = '';
            _this._showTooltip = false;
            _this._tooltip = null;
            _this._hasToolTipReceiver = false;
            _this._tooltipVisible = false;
            _this._metadata = new Map();
            return _this;
        }
        Object.defineProperty(BingPolyline.prototype, "Metadata", {
            get: /**
             * Gets the polyline metadata.
             *
             * \@readonly
             * \@memberof BingPolyline
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolyline.prototype, "NativePrimitve", {
            get: /**
             * Gets the Navitve Polyline underlying the model
             *
             * \@readonly
             * \@memberof BingPolyline
             * @return {?}
             */ function () { return this._polyline; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolyline.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof BingPolyline
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolyline.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polyline
             *
             * @abstract
             * \@memberof BingPolyline
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        BingPolyline.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                var /** @type {?} */ supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    Microsoft.Maps.Events.addHandler(this._polyline, eventType, function (e) {
                        fn(e);
                    });
                }
                if (eventType === 'mousemove') {
                    var /** @type {?} */ handlerId_1;
                    Microsoft.Maps.Events.addHandler(this._polyline, 'mouseover', function (e) {
                        handlerId_1 = Microsoft.Maps.Events.addHandler(_this._map, 'mousemove', function (m) { return fn(m); });
                    });
                    Microsoft.Maps.Events.addHandler(this._polyline, 'mouseout', function (e) {
                        if (handlerId_1) {
                            Microsoft.Maps.Events.removeHandler(handlerId_1);
                        }
                    });
                }
            };
        /**
         * Deleted the polyline.
         *
         * \@memberof BingPolyline
         * @return {?}
         */
        BingPolyline.prototype.Delete = /**
         * Deleted the polyline.
         *
         * \@memberof BingPolyline
         * @return {?}
         */
            function () {
                if (this._layer) {
                    this._layer.remove(this.NativePrimitve);
                }
                else {
                    this._map.entities.remove(this.NativePrimitve);
                }
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
        BingPolyline.prototype.GetDraggable = /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
            function () {
                return false;
            };
        /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        BingPolyline.prototype.GetEditable = /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._isEditable;
            };
        /**
         * Gets the polyline path.
         *
         * \@memberof BingPolyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
        BingPolyline.prototype.GetPath = /**
         * Gets the polyline path.
         *
         * \@memberof BingPolyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
            function () {
                var /** @type {?} */ p = this._polyline.getLocations();
                var /** @type {?} */ path = new Array();
                p.forEach(function (l) { return path.push({ latitude: l.latitude, longitude: l.longitude }); });
                return path;
            };
        /**
         * Gets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
        BingPolyline.prototype.GetVisible = /**
         * Gets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
            function () {
                return this._polyline.getVisible();
            };
        /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof BingPolyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetDraggable = /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof BingPolyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                throw (new Error('The bing maps implementation currently does not support draggable polylines.'));
            };
        /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof BingPolyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetEditable = /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof BingPolyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                this._isEditable = editable;
            };
        /**
         * Sets the polyline options
         *
         * \@memberof BingPolyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetOptions = /**
         * Sets the polyline options
         *
         * \@memberof BingPolyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = BingConversions.TranslatePolylineOptions(options);
                this._polyline.setOptions(o);
                if (options.path) {
                    this.SetPath(/** @type {?} */ (options.path));
                }
            };
        /**
         * Sets the polyline path.
         *
         * \@memberof BingPolyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetPath = /**
         * Sets the polyline path.
         *
         * \@memberof BingPolyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
            function (path) {
                var /** @type {?} */ p = new Array();
                path.forEach(function (x) { return p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)); });
                this._polyline.setLocations(p);
            };
        /**
         * Sets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetVisible = /**
         * Sets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polyline.setOptions(/** @type {?} */ ({ visible: visible }));
            };
        /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
        BingPolyline.prototype.ManageTooltip = /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        align: 'left',
                        offset: new Microsoft.Maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        this._tooltip = new BingMapLabel(o);
                        this._tooltip.SetMap(this._map);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = Microsoft.Maps.Events.addHandler(this._polyline, 'mouseover', function (e) {
                            _this._tooltip.Set('position', e.location);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        });
                        this._mouseMoveListener = Microsoft.Maps.Events.addHandler(this._map, 'mousemove', function (e) {
                            if (_this._tooltipVisible && e.location && e.primitive === _this._polyline) {
                                _this._tooltip.Set('position', e.location);
                            }
                        });
                        this._mouseOutListener = Microsoft.Maps.Events.addHandler(this._polyline, 'mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return BingPolyline;
    }(Polyline));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This contstant translates the abstract map events into their corresponding bing map
     * equivalents.
     */
    var /** @type {?} */ BingMapEventsLookup = {
        click: 'click',
        dblclick: 'dblclick',
        rightclick: 'rightclick',
        resize: 'resize',
        boundschanged: 'viewchangeend',
        centerchanged: 'viewchangeend',
        zoomchanged: 'viewchangeend',
        mouseover: 'mouseover',
        mouseout: 'mouseout',
        mousemove: 'mousemove',
        infowindowclose: 'infoboxChanged'
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementing a canvas overlay to be placed on the map for Bing Maps.
     *
     * @export
     */
    var /**
     * Concrete implementing a canvas overlay to be placed on the map for Bing Maps.
     *
     * @export
     */ BingCanvasOverlay = (function (_super) {
        __extends(BingCanvasOverlay, _super);
        /**
         * Creates a new instance of the BingCanvasOverlay class.
         * @param drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @memberof BingCanvasOverlay
         */
        function BingCanvasOverlay(drawCallback) {
            return _super.call(this, drawCallback) || this;
        }
        /**
         * Obtains geo coordinates for the click location
         *
         * @abstract
         * \@memberof BingCanvasOverlay
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
        BingCanvasOverlay.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the click location
         *
         * @abstract
         * \@memberof BingCanvasOverlay
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
            function (e) {
                return { latitude: e.location.latitude, longitude: e.location.longitude };
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?}
         */
        BingCanvasOverlay.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?}
         */
            function () {
                return ((this)).getMap();
            };
        /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller. Note that this method returns null until OnLoad has been called.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
        BingCanvasOverlay.prototype.GetToolTipOverlay = /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller. Note that this method returns null until OnLoad has been called.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
            function () {
                var /** @type {?} */ o = {
                    align: 'left',
                    offset: new Microsoft.Maps.Point(0, 25),
                    backgroundColor: 'bisque',
                    hidden: true,
                    fontSize: 12,
                    fontColor: '#000000',
                    strokeWeight: 0
                };
                var /** @type {?} */ label = new BingMapLabel(o);
                label.SetMap(this.GetMap());
                return label;
            };
        /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * @abstract
         * \@method
         * \@memberof BingCanvasOverlay
         * @return {?}
         */
        BingCanvasOverlay.prototype.OnLoad = /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * @abstract
         * \@method
         * \@memberof BingCanvasOverlay
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ map = ((this)).getMap();
                // Get the current map view information.
                this._zoomStart = map.getZoom();
                this._centerStart = /** @type {?} */ (map.getCenter());
                // Redraw the canvas.
                this.Redraw(true);
                // When the map moves, move the canvas accordingly.
                this._viewChangeEvent = Microsoft.Maps.Events.addHandler(map, 'viewchange', function (e) {
                    if (map.getMapTypeId() === Microsoft.Maps.MapTypeId.streetside) {
                        // Don't show the canvas if the map is in Streetside mode.
                        // Don't show the canvas if the map is in Streetside mode.
                        _this._canvas.style.display = 'none';
                    }
                    else {
                        // Re-drawing the canvas as it moves would be too slow. Instead, scale and translate canvas element.
                        var /** @type {?} */ zoomCurrent = map.getZoom();
                        var /** @type {?} */ centerCurrent = map.getCenter();
                        // Calculate map scale based on zoom level difference.
                        var /** @type {?} */ scale = Math.pow(2, zoomCurrent - _this._zoomStart);
                        // Calculate the scaled dimensions of the canvas.
                        var /** @type {?} */ newWidth = map.getWidth() * scale;
                        var /** @type {?} */ newHeight = map.getHeight() * scale;
                        // Calculate offset of canvas based on zoom and center offsets.
                        var /** @type {?} */ pixelPoints = (map.tryLocationToPixel([
                            BingConversions.TranslateLocation(_this._centerStart),
                            centerCurrent
                        ], Microsoft.Maps.PixelReference.control));
                        var /** @type {?} */ centerOffsetX = pixelPoints[1].x - pixelPoints[0].x;
                        var /** @type {?} */ centerOffsetY = pixelPoints[1].y - pixelPoints[0].y;
                        var /** @type {?} */ x = (-(newWidth - map.getWidth()) / 2) - centerOffsetX;
                        var /** @type {?} */ y = (-(newHeight - map.getHeight()) / 2) - centerOffsetY;
                        // Update the canvas CSS position and dimensions.
                        // Update the canvas CSS position and dimensions.
                        _this.UpdatePosition(x, y, newWidth, newHeight);
                    }
                });
                // When the map stops moving, render new data on the canvas.
                this._viewChangeEndEvent = Microsoft.Maps.Events.addHandler(map, 'viewchangeend', function (e) {
                    _this.UpdateCanvas();
                });
                // Update the position of the overlay when the map is resized.
                this._mapResizeEvent = Microsoft.Maps.Events.addHandler(map, 'mapresize', function (e) {
                    _this.UpdateCanvas();
                });
                // set the overlay to ready state
                this._readyResolver(true);
            };
        /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
        BingCanvasOverlay.prototype.SetMap = /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
            function (map) {
                var /** @type {?} */ m = this.GetMap();
                if (map === m) {
                    return;
                }
                if (m) {
                    m.layers.remove(this);
                }
                if (map != null) {
                    map.layers.insert(this);
                }
            };
        ///
        /// Protected methods
        ///
        /**
         * Attaches the canvas to the map.
         * @memberof CanvasOverlay
         * @method
         */
        /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
        BingCanvasOverlay.prototype.SetCanvasElement = /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
            function (el) {
                ((this)).setHtmlElement(el);
            };
        /**
         * Remove the map event handlers.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        BingCanvasOverlay.prototype.RemoveEventHandlers = /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                // Remove all event handlers from the map.
                Microsoft.Maps.Events.removeHandler(this._viewChangeEvent);
                Microsoft.Maps.Events.removeHandler(this._viewChangeEndEvent);
                Microsoft.Maps.Events.removeHandler(this._mapResizeEvent);
            };
        /**
         * Updates the Canvas size based on the map size.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        BingCanvasOverlay.prototype.Resize = /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ map = ((this)).getMap();
                // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.
                this._canvas.width = map.getWidth();
                this._canvas.height = map.getHeight();
            };
        /**
         * Updates the Canvas.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        BingCanvasOverlay.prototype.UpdateCanvas = /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ map = ((this)).getMap();
                // Only render the canvas if it isn't in streetside mode.
                if (map.getMapTypeId() !== Microsoft.Maps.MapTypeId.streetside) {
                    this._canvas.style.display = '';
                    // Reset CSS position and dimensions of canvas.
                    this.UpdatePosition(0, 0, map.getWidth(), map.getHeight());
                    // Redraw the canvas.
                    this.Redraw(true);
                    // Get the current map view information.
                    this._zoomStart = map.getZoom();
                    this._centerStart = /** @type {?} */ (map.getCenter());
                }
            };
        return BingCanvasOverlay;
    }(CanvasOverlay));
    /**
     * Helper function to extend the OverlayView into the CanvasOverlay
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinCanvasOverlay() {
        new Extender(BingCanvasOverlay)
            .Extend(new Microsoft.Maps.CustomOverlay())
            .Map('onAdd', 'OnAdd')
            .Map('onLoad', 'OnLoad')
            .Map('onRemove', 'OnRemove');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var MapTypeId$1 = {
        /** This map type displays a transparent layer of major streets on satellite images. */
        hybrid: 0,
        /** This map type displays a normal street map. */
        roadmap: 1,
        /** This map type displays satellite images. */
        satellite: 2,
        /** This map type displays maps with physical features such as terrain and vegetation. */
        terrain: 3,
    };
    MapTypeId$1[MapTypeId$1.hybrid] = "hybrid";
    MapTypeId$1[MapTypeId$1.roadmap] = "roadmap";
    MapTypeId$1[MapTypeId$1.satellite] = "satellite";
    MapTypeId$1[MapTypeId$1.terrain] = "terrain";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This class contains helperfunctions to map various interfaces used to represent options and structures into the
     * corresponding Google Maps specific implementations.
     *
     * @export
     */
    var GoogleConversions = (function () {
        function GoogleConversions() {
        }
        /**
         * Maps an IBox object to a GoogleMapTypes.LatLngBoundsLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} bounds - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateBounds = /**
         * Maps an IBox object to a GoogleMapTypes.LatLngBoundsLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} bounds - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (bounds) {
                var /** @type {?} */ b = {
                    east: bounds.maxLongitude,
                    north: bounds.maxLatitude,
                    south: bounds.minLatitude,
                    west: bounds.minLongitude,
                };
                return b;
            };
        /**
         * Maps an IInfoWindowOptions object to a GoogleMapTypes.InfoWindowOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateInfoWindowOptions = /**
         * Maps an IInfoWindowOptions object to a GoogleMapTypes.InfoWindowOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._infoWindowOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'htmlContent') {
                        o.content = ((options))[k];
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                if (o.content == null || o.content === '') {
                    if (options.title !== '' && options.description !== '') {
                        o.content = options.title + ": " + options.description;
                    }
                    else if (options.description !== '') {
                        o.content = options.description;
                    }
                    else {
                        o.content = options.title;
                    }
                }
                return o;
            };
        /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLngLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLocation = /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLngLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlong) {
                var /** @type {?} */ l = { lat: latlong.latitude, lng: latlong.longitude };
                return l;
            };
        /**
         * Maps an GoogleMapTypes.LatLngLiteral object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLatLng = /**
         * Maps an GoogleMapTypes.LatLngLiteral object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlng) {
                var /** @type {?} */ l = { latitude: latlng.lat, longitude: latlng.lng };
                return l;
            };
        /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLocationObject = /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlong) {
                var /** @type {?} */ l = new google.maps.LatLng(latlong.latitude, latlong.longitude);
                return l;
            };
        /**
         * Maps an GoogleMapTypes.LatLng object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLatLngObject = /**
         * Maps an GoogleMapTypes.LatLng object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlng) {
                var /** @type {?} */ l = { latitude: latlng.lat(), longitude: latlng.lng() };
                return l;
            };
        /**
         * Maps an ILatLong array to a array of GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlongArray - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLocationObjectArray = /**
         * Maps an ILatLong array to a array of GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlongArray - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlongArray) {
                // use for loop for performance in case we deal with large numbers of points and paths...
                var /** @type {?} */ p = new Array();
                for (var /** @type {?} */ i = 0; i < latlongArray.length; i++) {
                    p.push(GoogleConversions.TranslateLocationObject(latlongArray[i]));
                }
                return p;
            };
        /**
         * Maps a MapTypeId object to a Google maptype string.
         *
         * \@memberof GoogleConversions
         * @param {?} mapTypeId - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateMapTypeId = /**
         * Maps a MapTypeId object to a Google maptype string.
         *
         * \@memberof GoogleConversions
         * @param {?} mapTypeId - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (mapTypeId) {
                switch (mapTypeId) {
                    case MapTypeId.road: return MapTypeId$1[MapTypeId$1.roadmap];
                    case MapTypeId.grayscale: return MapTypeId$1[MapTypeId$1.terrain];
                    case MapTypeId.hybrid: return MapTypeId$1[MapTypeId$1.hybrid];
                    case MapTypeId.ordnanceSurvey: return MapTypeId$1[MapTypeId$1.terrain];
                    default: return MapTypeId$1[MapTypeId$1.satellite];
                }
            };
        /**
         * Maps an IMarkerOptions object to a GoogleMapTypes.MarkerOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Promise that when resolved contains the mapped object.
         *
         */
        GoogleConversions.TranslateMarkerOptions = /**
         * Maps an IMarkerOptions object to a GoogleMapTypes.MarkerOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Promise that when resolved contains the mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._markerOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'position') {
                        var /** @type {?} */ latlng = GoogleConversions.TranslateLocationObject(options[k]);
                        o.position = latlng;
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a GoogleMapTypes.MapOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateOptions = /**
         * Maps an IMapOptions object to a GoogleMapTypes.MapOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._mapOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = GoogleConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'mapTypeId') {
                        o.mapTypeId = GoogleConversions.TranslateMapTypeId(options.mapTypeId);
                    }
                    else if (k === 'disableZooming') {
                        o.gestureHandling = 'none';
                        o.zoomControl = false;
                    }
                    else if (k === 'showMapTypeSelector') {
                        o.mapTypeControl = false;
                    }
                    else if (k === 'customMapStyleGoogle') {
                        o.styles = /** @type {?} */ ((options.customMapStyleGoogle));
                    }
                    else {
                        ((o))[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof GoogleConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
        GoogleConversions.TranslatePaths = /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof GoogleConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
            function (paths) {
                var /** @type {?} */ p = new Array();
                if (paths == null || !Array.isArray(paths) || paths.length === 0) {
                    p.push(new Array());
                }
                else if (Array.isArray(paths[0])) {
                    // parameter is an array or arrays
                    // use for loop for performance in case we deal with large numbers of points and paths...
                    var /** @type {?} */ p1 = (paths);
                    for (var /** @type {?} */ i = 0; i < p1.length; i++) {
                        p.push(GoogleConversions.TranslateLocationObjectArray(p1[i]));
                    }
                }
                else {
                    // parameter is a simple array....
                    p.push(GoogleConversions.TranslateLocationObjectArray(/** @type {?} */ (paths)));
                }
                return p;
            };
        /**
         *  Maps an IPolygonOptions object to a GoogleMapTypes.PolygonOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslatePolygonOptions = /**
         *  Maps an IPolygonOptions object to a GoogleMapTypes.PolygonOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._polygonOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'paths') {
                        if (!Array.isArray(options.paths)) {
                            return;
                        }
                        if (options.paths.length === 0) {
                            o.paths = new Array();
                        }
                        else if (Array.isArray(options.paths[0])) {
                            o.paths = new Array();
                            // use for loop for performance in case we deal with large numbers of points and paths..
                            var /** @type {?} */ p1 = (options.paths);
                            for (var /** @type {?} */ i = 0; i < p1.length; i++) {
                                o.paths[i] = new Array();
                                for (var /** @type {?} */ j = 0; j < p1[i].length; j++) {
                                    o.paths[i][j] = { lat: p1[i][j].latitude, lng: p1[i][j].longitude };
                                }
                            }
                        }
                        else {
                            o.paths = new Array();
                            // use for loop for performance in case we deal with large numbers of points and paths..
                            var /** @type {?} */ p1 = (options.paths);
                            for (var /** @type {?} */ i = 0; i < p1.length; i++) {
                                o.paths[i] = { lat: p1[i].latitude, lng: p1[i].longitude };
                            }
                        }
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         *  Maps an IPolylineOptions object to a GoogleMapTypes.PolylineOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslatePolylineOptions = /**
         *  Maps an IPolylineOptions object to a GoogleMapTypes.PolylineOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._polylineOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    o[k] = ((options))[k];
                });
                return o;
            };
        /**
         * Map option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._mapOptionsAttributes = [
            'backgroundColor',
            'center',
            'clickableIcons',
            'customMapStyleGoogle',
            'disableDefaultUI',
            'disableDoubleClickZoom',
            'draggable',
            'draggableCursor',
            'draggingCursor',
            'disableZooming',
            'fullscreenControl',
            'fullscreenControlOptions',
            'gestureHandling',
            'heading',
            'keyboardShortcuts',
            'mapTypeControl',
            'mapTypeControlOptions',
            'mapTypeId',
            'maxZoom',
            'minZoom',
            'noClear',
            'panControl',
            'panControlOptions',
            'rotateControl',
            'rotateControlOptions',
            'scaleControl',
            'scaleControlOptions',
            'scrollwheel',
            'showMapTypeSelector',
            'streetView',
            'streetViewControl',
            'streetViewControlOptions',
            'styles',
            'tilt',
            'zoom',
            'zoomControl',
            'zoomControlOptions'
        ];
        /**
         * InfoWindow option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._infoWindowOptionsAttributes = [
            'actions',
            'description',
            'htmlContent',
            'id',
            'position',
            'pixelOffset',
            'showCloseButton',
            'showPointer',
            'pushpin',
            'title',
            'titleClickHandler',
            'typeName',
            'visible',
            'width',
            'height'
        ];
        /**
         * Marker option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._markerOptionsAttributes = [
            'anchor',
            'position',
            'title',
            'text',
            'label',
            'draggable',
            'icon',
            'width',
            'height',
            'iconInfo',
            'metadata',
            'visible'
        ];
        /**
         * Cluster option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._clusterOptionsAttributes = [
            'callback',
            'clusteredPinCallback',
            'clusteringEnabled',
            'gridSize',
            'layerOffset',
            'placementMode',
            'visible',
            'zIndex'
        ];
        /**
         * Polygon option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._polygonOptionsAttributes = [
            'clickable',
            'draggable',
            'editable',
            'fillColor',
            'fillOpacity',
            'geodesic',
            'paths',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible',
            'zIndex'
        ];
        /**
         * Polyline option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._polylineOptionsAttributes = [
            'clickable',
            'draggable',
            'editable',
            'geodesic',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible',
            'zIndex'
        ];
        return GoogleConversions;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation for a {\@link InfoWindow}} model for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementation for a {\@link InfoWindow}} model for Google Maps.
     *
     * @export
     */ GoogleInfoWindow = (function () {
        ///
        /// constructor
        ///
        /**
         * Creates an instance of GoogleInfoWindow.
         * @param _infoWindow - A {@link GoogleMapTypes.InfoWindow} instance underlying the model.
         * @param _mapService - An instance of the {@link GoogleMapService}.
         * @memberof GoogleInfoWindow
         */
        function GoogleInfoWindow(_infoWindow, _mapService) {
            this._infoWindow = _infoWindow;
            this._mapService = _mapService;
        }
        Object.defineProperty(GoogleInfoWindow.prototype, "IsOpen", {
            get: /**
             * Gets whether the info box is currently open.
             *
             * \@readonly
             * \@memberof InfoWGoogleInfoWindowindow
             * @return {?}
             */ function () {
                if (this._isOpen === true) {
                    return true;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleInfoWindow.prototype, "NativePrimitve", {
            get: /**
             * Gets the underlying native object.
             *
             * \@property
             * \@readonly
             * @return {?}
             */ function () {
                return this._infoWindow;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        GoogleInfoWindow.prototype.AddListener = /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                this._infoWindow.addListener(eventType, function (e) {
                    if (eventType === 'closeclick') {
                        _this._isOpen = false;
                    }
                    fn(e);
                });
            };
        /**
         *
         * Closes the info window.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?}
         */
        GoogleInfoWindow.prototype.Close = /**
         *
         * Closes the info window.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?}
         */
            function () {
                this._isOpen = false;
                this._infoWindow.close();
            };
        /**
         * Gets the position of the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?} - The geo coordinates of the info window.
         *
         */
        GoogleInfoWindow.prototype.GetPosition = /**
         * Gets the position of the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?} - The geo coordinates of the info window.
         *
         */
            function () {
                return GoogleConversions.TranslateLatLngObject(this._infoWindow.getPosition());
            };
        /**
         * Opens the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?=} anchor
         * @return {?}
         */
        GoogleInfoWindow.prototype.Open = /**
         * Opens the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?=} anchor
         * @return {?}
         */
            function (anchor) {
                var _this = this;
                this._mapService.MapPromise.then(function (m) {
                    _this._isOpen = true;
                    _this._infoWindow.open(m, anchor);
                });
            };
        /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} options - The options to set. This object will be merged with the existing options.
         *
         * @return {?}
         */
        GoogleInfoWindow.prototype.SetOptions = /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} options - The options to set. This object will be merged with the existing options.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = GoogleConversions.TranslateInfoWindowOptions(options);
                this._infoWindow.setOptions(o);
            };
        /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} position - Geo coordinates at which to anchor the info window.
         *
         * @return {?}
         */
        GoogleInfoWindow.prototype.SetPosition = /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} position - Geo coordinates at which to anchor the info window.
         *
         * @return {?}
         */
            function (position) {
                var /** @type {?} */ l = GoogleConversions.TranslateLocation(position);
                this._infoWindow.setPosition(l);
            };
        return GoogleInfoWindow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link Marker} contract for the Google Maps map architecture.
     *
     * @export
     */
    var /**
     * Concrete implementation of the {\@link Marker} contract for the Google Maps map architecture.
     *
     * @export
     */ GoogleMarker = (function () {
        ///
        /// Constructors
        ///
        /**
         * Creates an instance of GoogleMarker.
         * @param _marker
         *
         * @memberof GoogleMarker
         */
        function GoogleMarker(_marker) {
            this._marker = _marker;
            this._metadata = new Map();
            this._isFirst = false;
            this._isLast = true;
        }
        Object.defineProperty(GoogleMarker.prototype, "IsFirst", {
            get: /**
             * Indicates that the marker is the first marker in a set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isFirst; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isFirst = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "IsLast", {
            get: /**
             * Indicates that the marker is the last marker in the set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isLast; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isLast = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "Metadata", {
            get: /**
             * Gets the marker metadata.
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the marker, in this case {\@link Microsoft.Maps.Pushpin}
             *
             * \@readonly
             * @abstract
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._marker; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "Location", {
            get: /**
             * Gets the Location of the marker
             *
             * \@readonly
             * @abstract
             * \@memberof BingMarker
             * @return {?}
             */ function () {
                var /** @type {?} */ l = this._marker.getPosition();
                return {
                    latitude: l.lat(),
                    longitude: l.lng()
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        GoogleMarker.prototype.AddListener = /**
         * Adds an event listener to the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                this._marker.addListener(eventType, fn);
            };
        /**
         * Deletes the marker.
         *
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
        GoogleMarker.prototype.DeleteMarker = /**
         * Deletes the marker.
         *
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
            function () {
                this._marker.setMap(null);
            };
        /**
         * Gets the marker label
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
        GoogleMarker.prototype.GetLabel = /**
         * Gets the marker label
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
            function () {
                return this._marker.getLabel().text;
            };
        /**
         * Gets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
        GoogleMarker.prototype.GetVisible = /**
         * Gets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
            function () {
                return this._marker.getVisible();
            };
        /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * \@memberof GoogleMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetAnchor = /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * \@memberof GoogleMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
            function (anchor) {
                // not implemented
                // TODO: we need to switch the model to complex icons for google to
                // support anchors, sizes and origins.
                // https://developers.google.com/maps/documentation/javascript/markers
            };
        /**
         * Sets the draggability of a marker.
         *
         * \@memberof GoogleMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetDraggable = /**
         * Sets the draggability of a marker.
         *
         * \@memberof GoogleMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                this._marker.setDraggable(draggable);
            };
        /**
         * Sets the icon for the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetIcon = /**
         * Sets the icon for the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
            function (icon) {
                this._marker.setIcon(icon);
            };
        /**
         * Sets the marker label.
         *
         * \@memberof GoogleMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetLabel = /**
         * Sets the marker label.
         *
         * \@memberof GoogleMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
            function (label) {
                this._marker.setLabel(label);
            };
        /**
         * Sets the marker position.
         *
         * \@memberof GoogleMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetPosition = /**
         * Sets the marker position.
         *
         * \@memberof GoogleMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
            function (latLng) {
                var /** @type {?} */ p = GoogleConversions.TranslateLocationObject(latLng);
                this._marker.setPosition(p);
            };
        /**
         * Sets the marker title.
         *
         * \@memberof GoogleMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetTitle = /**
         * Sets the marker title.
         *
         * \@memberof GoogleMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
            function (title) {
                this._marker.setTitle(title);
            };
        /**
         * Sets the marker options.
         *
         * \@memberof GoogleMarker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetOptions = /**
         * Sets the marker options.
         *
         * \@memberof GoogleMarker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = GoogleConversions.TranslateMarkerOptions(options);
                this._marker.setOptions(o);
            };
        /**
         * Sets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetVisible = /**
         * Sets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._marker.setVisible(visible);
            };
        return GoogleMarker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */
    var /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */ GoogleMapLabel = (function (_super) {
        __extends(GoogleMapLabel, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates a new MapLabel
         * @param options Optional properties to set.
         */
        function GoogleMapLabel(options) {
            var _this = this;
            options["fontSize"] = options["fontSize"] || 12;
            options["fontColor"] = options["fontColor"] || '#ffffff';
            options["strokeWeight"] = options["strokeWeight"] || 3;
            options["strokeColor"] = options["strokeColor"] || '#000000';
            _this = _super.call(this, options) || this;
            return _this;
        }
        Object.defineProperty(GoogleMapLabel.prototype, "DefaultLabelStyle", {
            get: /**
             * Returns the default label style for the platform
             *
             * \@readonly
             * @abstract
             * \@memberof GoogleMapLabel
             * @return {?}
             */ function () {
                return {
                    fontSize: 12,
                    fontFamily: 'sans-serif',
                    fontColor: '#ffffff',
                    strokeWeight: 3,
                    strokeColor: '#000000'
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the value of a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
        GoogleMapLabel.prototype.Get = /**
         * Gets the value of a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
            function (key) {
                return ((this)).get(key);
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @return {?}
         */
        GoogleMapLabel.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @return {?}
         */
            function () {
                return ((this)).getMap();
            };
        /**
         * Set the value for a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
        GoogleMapLabel.prototype.Set = /**
         * Set the value for a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
            function (key, val) {
                if (key === 'position' && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {
                    val = new google.maps.LatLng(val.latitude, val.longitude);
                }
                if (this.Get(key) !== val) {
                    ((this)).set(key, val);
                }
            };
        /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
        GoogleMapLabel.prototype.SetMap = /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
            function (map) {
                ((this)).setMap(map);
            };
        /**
         * Applies settings to the object
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
        GoogleMapLabel.prototype.SetValues = /**
         * Applies settings to the object
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
            function (options) {
                for (var /** @type {?} */ key in options) {
                    if (key !== '') {
                        if (key === 'position' && options[key].hasOwnProperty('latitude') && options[key].hasOwnProperty('longitude')) {
                            options[key] = new google.maps.LatLng(options[key].latitude, options[key].longitude);
                        }
                        if (this.Get(key) === options[key]) {
                            delete options[key];
                        }
                    }
                }
                ((this)).setValues(options);
            };
        ///
        /// Protected methods
        ///
        /**
         * Draws the label on the map.
         * @memberof GoogleMapLabel
         * @method
         * @protected
         */
        /**
         * Draws the label on the map.
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        GoogleMapLabel.prototype.Draw = /**
         * Draws the label on the map.
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ projection = ((this)).getProjection();
                var /** @type {?} */ visibility = this.GetVisible();
                if (!projection) {
                    // The map projection is not ready yet so do nothing
                    return;
                }
                if (!this._canvas) {
                    // onAdd has not been called yet.
                    return;
                }
                var /** @type {?} */ style = this._canvas.style;
                if (visibility !== '') {
                    // label is not visible, don't calculate positions etc.
                    style['visibility'] = visibility;
                    return;
                }
                var /** @type {?} */ offset = this.Get('offset');
                var /** @type {?} */ latLng = this.Get('position');
                if (!latLng) {
                    return;
                }
                if (!(latLng instanceof google.maps.LatLng)) {
                    latLng = new google.maps.LatLng(latLng.lat, latLng.lng);
                }
                if (!offset) {
                    offset = new google.maps.Point(0, 0);
                }
                var /** @type {?} */ pos = projection.fromLatLngToDivPixel(latLng);
                style['top'] = (pos.y + offset.y) + 'px';
                style['left'] = (pos.x + offset.x) + 'px';
                style['visibility'] = visibility;
            };
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * @memberof GoogleMapLabel
         * @method
         * @protected
         */
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        GoogleMapLabel.prototype.OnAdd = /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                this._canvas = document.createElement('canvas');
                var /** @type {?} */ style = this._canvas.style;
                style.position = 'absolute';
                var /** @type {?} */ ctx = this._canvas.getContext('2d');
                ctx.lineJoin = 'round';
                ctx.textBaseline = 'top';
                this.DrawCanvas();
                var /** @type {?} */ panes = ((this)).getPanes();
                if (panes) {
                    panes.overlayLayer.appendChild(this._canvas);
                    // 4: floatPane (infowindow)
                    // 3: overlayMouseTarget (mouse events)
                    // 2: markerLayer (marker images)
                    // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)
                    // 0: mapPane (lowest pane above the map tiles)
                }
            };
        return GoogleMapLabel;
    }(MapLabel));
    /**
     * Helper function to extend the OverlayView into the MapLabel
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinMapLabelWithOverlayView$1() {
        new Extender(GoogleMapLabel)
            .Extend(new google.maps.OverlayView)
            .Map('changed', 'Changed')
            .Map('onAdd', 'OnAdd')
            .Map('draw', 'Draw')
            .Map('onRemove', 'OnRemove');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation for a polygon model for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polygon model for Google Maps.
     *
     * @export
     */ GooglePolygon = (function (_super) {
        __extends(GooglePolygon, _super);
        ///
        /// constructor
        ///
        /**
         * Creates an instance of GooglePolygon.
         * @param _polygon - The {@link GoogleMapTypes.Polygon} underlying the model.
         *
         * @memberof GooglePolygon
         */
        function GooglePolygon(_polygon) {
            var _this = _super.call(this) || this;
            _this._polygon = _polygon;
            _this._title = '';
            _this._showLabel = false;
            _this._showTooltip = false;
            _this._maxZoom = -1;
            _this._minZoom = -1;
            _this._label = null;
            _this._tooltip = null;
            _this._tooltipVisible = false;
            _this._hasToolTipReceiver = false;
            _this._mouseOverListener = null;
            _this._mouseOutListener = null;
            _this._mouseMoveListener = null;
            _this._metadata = new Map();
            _this._editingCompleteEmitter = null;
            _this._originalPath = _this.GetPaths();
            return _this;
        }
        Object.defineProperty(GooglePolygon.prototype, "LabelMaxZoom", {
            get: /**
             * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._maxZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._maxZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "LabelMinZoom", {
            get: /**
             * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._minZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._minZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "Metadata", {
            get: /**
             * Gets the polygon metadata.
             *
             * \@readonly
             * \@memberof GoolePolygon
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the polygon, in this case {\@link GoogleMapTypes.Polygon}
             *
             * \@readonly
             * \@memberof GooglePolygon
             * @return {?}
             */ function () { return this._polygon; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "ShowLabel", {
            get: /**
             * Gets or sets whether to show the label
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._showLabel; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showLabel = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polygon
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageLabel();
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof GooglePolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        GooglePolygon.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof GooglePolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                var /** @type {?} */ supportedEvents = [
                    'click',
                    'dblclick',
                    'drag', 'dragend',
                    'dragstart',
                    'mousedown',
                    'mousemove',
                    'mouseout',
                    'mouseover',
                    'mouseup',
                    'rightclick'
                ];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    this._polygon.addListener(eventType, fn);
                }
                if (eventType === 'pathchanged') {
                    this._editingCompleteEmitter = /** @type {?} */ (fn);
                }
            };
        /**
         * Deleted the polygon.
         *
         * \@memberof GooglePolygon
         * @return {?}
         */
        GooglePolygon.prototype.Delete = /**
         * Deleted the polygon.
         *
         * \@memberof GooglePolygon
         * @return {?}
         */
            function () {
                this._polygon.setMap(null);
                if (this._label) {
                    this._label.Delete();
                }
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
        GooglePolygon.prototype.GetDraggable = /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
            function () {
                return this._polygon.getDraggable();
            };
        /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        GooglePolygon.prototype.GetEditable = /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._polygon.getEditable();
            };
        /**
         * Gets the polygon path.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
        GooglePolygon.prototype.GetPath = /**
         * Gets the polygon path.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
            function () {
                var /** @type {?} */ p = this._polygon.getPath();
                var /** @type {?} */ path = new Array();
                p.forEach(function (x) { return path.push({ latitude: x.lat(), longitude: x.lng() }); });
                return path;
            };
        /**
         * Gets the polygon paths.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
        GooglePolygon.prototype.GetPaths = /**
         * Gets the polygon paths.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
            function () {
                var /** @type {?} */ p = this._polygon.getPaths();
                var /** @type {?} */ paths = new Array();
                p.forEach(function (x) {
                    var /** @type {?} */ path = new Array();
                    x.forEach(function (y) { return path.push({ latitude: y.lat(), longitude: y.lng() }); });
                    paths.push(path);
                });
                return paths;
            };
        /**
         * Gets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
        GooglePolygon.prototype.GetVisible = /**
         * Gets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
            function () {
                return this._polygon.getVisible();
            };
        /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof GooglePolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetDraggable = /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof GooglePolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                this._polygon.setDraggable(draggable);
            };
        /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof GooglePolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetEditable = /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof GooglePolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                var /** @type {?} */ previous = this._polygon.getEditable();
                this._polygon.setEditable(editable);
                if (previous && !editable && this._editingCompleteEmitter) {
                    this._editingCompleteEmitter({
                        Click: null,
                        Polygon: this,
                        OriginalPath: this._originalPath,
                        NewPath: this.GetPaths()
                    });
                    this._originalPath = this.GetPaths();
                }
            };
        /**
         * Sets the polygon options
         *
         * \@memberof GooglePolygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetOptions = /**
         * Sets the polygon options
         *
         * \@memberof GooglePolygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = GoogleConversions.TranslatePolygonOptions(options);
                if (typeof o.editable !== 'undefined') {
                    this.SetEditable(o.editable);
                    delete o.editable;
                }
                this._polygon.setOptions(o);
                if (options.visible != null && this._showLabel && this._label) {
                    this._label.Set('hidden', !options.visible);
                }
            };
        /**
         * Sets the polygon path.
         *
         * \@memberof GooglePolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetPath = /**
         * Sets the polygon path.
         *
         * \@memberof GooglePolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
            function (path) {
                var /** @type {?} */ p = new Array();
                path.forEach(function (x) { return p.push(new google.maps.LatLng(x.latitude, x.longitude)); });
                this._polygon.setPath(p);
                this._originalPath = [path];
                if (this._label) {
                    this._centroid = null;
                    this.ManageLabel();
                }
            };
        /**
         * Set the polygon path or paths.
         *
         * \@memberof GooglePolygon
         * @param {?} paths An Array of {\@link ILatLong}
         * (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetPaths = /**
         * Set the polygon path or paths.
         *
         * \@memberof GooglePolygon
         * @param {?} paths An Array of {\@link ILatLong}
         * (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
            function (paths) {
                if (paths == null) {
                    return;
                }
                if (!Array.isArray(paths)) {
                    return;
                }
                if (paths.length === 0) {
                    this._polygon.setPaths(new Array());
                    if (this._label) {
                        this._label.Delete();
                        this._label = null;
                    }
                    return;
                }
                if (Array.isArray(paths[0])) {
                    // parameter is an array or arrays
                    var /** @type {?} */ p_1 = new Array();
                    ((paths)).forEach(function (path) {
                        var /** @type {?} */ _p = new Array();
                        path.forEach(function (x) { return _p.push(new google.maps.LatLng(x.latitude, x.longitude)); });
                        p_1.push(_p);
                    });
                    this._polygon.setPaths(p_1);
                    this._originalPath = /** @type {?} */ (paths);
                    if (this._label) {
                        this._centroid = null;
                        this.ManageLabel();
                    }
                }
                else {
                    // parameter is a simple array....
                    this.SetPath(/** @type {?} */ (paths));
                }
            };
        /**
         * Sets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetVisible = /**
         * Sets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polygon.setVisible(visible);
                if (this._showLabel && this._label) {
                    this._label.Set('hidden', !visible);
                }
            };
        /**
         * Configures the label for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
        GooglePolygon.prototype.ManageLabel = /**
         * Configures the label for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
            function () {
                if (this.GetPath == null || this.GetPath().length === 0) {
                    return;
                }
                if (this._showLabel && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        position: GoogleConversions.TranslateLocationObject(this.Centroid)
                    };
                    if (o["position"] == null) {
                        return;
                    }
                    if (this._minZoom !== -1) {
                        o["minZoom"] = this._minZoom;
                    }
                    if (this._maxZoom !== -1) {
                        o["maxZoom"] = this._maxZoom;
                    }
                    if (this._label == null) {
                        o["map"] = this.NativePrimitve.getMap();
                        o["zIndex"] = this.NativePrimitve.zIndex ? this.NativePrimitve.zIndex + 1 : 100;
                        this._label = new GoogleMapLabel(o);
                    }
                    else {
                        this._label.SetValues(o);
                    }
                    this._label.Set('hidden', !this.GetVisible());
                }
                else {
                    if (this._label) {
                        this._label.SetMap(null);
                        this._label = null;
                    }
                }
            };
        /**
         * Configures the tooltip for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
        GooglePolygon.prototype.ManageTooltip = /**
         * Configures the tooltip for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        align: 'left',
                        offset: new google.maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        o["map"] = this.NativePrimitve.getMap();
                        o["zIndex"] = 100000;
                        this._tooltip = new GoogleMapLabel(o);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = this.NativePrimitve.addListener('mouseover', function (e) {
                            _this._tooltip.Set('position', e.latLng);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        });
                        this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('position', e.latLng);
                            }
                        });
                        this._mouseOutListener = this.NativePrimitve.addListener('mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            google.maps.event.removeListener(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            google.maps.event.removeListener(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            google.maps.event.removeListener(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return GooglePolygon;
    }(Polygon));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation for a polyline model for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polyline model for Google Maps.
     *
     * @export
     */ GooglePolyline = (function (_super) {
        __extends(GooglePolyline, _super);
        ///
        /// constructor
        ///
        /**
        * Creates an instance of GooglePolygon.
        * @param _polyline - The {@link GoogleMApTypes.Polyline} underlying the model.
        *
        * @memberof GooglePolyline
        */
        function GooglePolyline(_polyline) {
            var _this = _super.call(this) || this;
            _this._polyline = _polyline;
            _this._title = '';
            _this._showTooltip = false;
            _this._tooltip = null;
            _this._tooltipVisible = false;
            _this._hasToolTipReceiver = false;
            _this._mouseOverListener = null;
            _this._mouseOutListener = null;
            _this._mouseMoveListener = null;
            _this._metadata = new Map();
            return _this;
        }
        Object.defineProperty(GooglePolyline.prototype, "Metadata", {
            get: /**
             * Gets the polyline metadata.
             *
             * \@readonly
             * \@memberof GooglePolyline
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolyline.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the marker, in this case {\@link GoogleMApTypes.Polyline}
             *
             * \@readonly
             * \@memberof GooglePolygon
             * @return {?}
             */ function () { return this._polyline; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolyline.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolyline.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polygon
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof Polyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        GooglePolyline.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof Polyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                var /** @type {?} */ supportedEvents = [
                    'click',
                    'dblclick',
                    'drag', 'dragend',
                    'dragstart',
                    'mousedown',
                    'mousemove',
                    'mouseout',
                    'mouseover',
                    'mouseup',
                    'rightclick'
                ];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    this._polyline.addListener(eventType, fn);
                }
            };
        /**
         * Deleted the polyline.
         *
         *
         * \@memberof Polyline
         * @return {?}
         */
        GooglePolyline.prototype.Delete = /**
         * Deleted the polyline.
         *
         *
         * \@memberof Polyline
         * @return {?}
         */
            function () {
                this._polyline.setMap(null);
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
        GooglePolyline.prototype.GetDraggable = /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
            function () {
                return this._polyline.getDraggable();
            };
        /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof Polyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        GooglePolyline.prototype.GetEditable = /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof Polyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._polyline.getEditable();
            };
        /**
         * Gets the polyline path.
         *
         * \@memberof Polyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
        GooglePolyline.prototype.GetPath = /**
         * Gets the polyline path.
         *
         * \@memberof Polyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
            function () {
                var /** @type {?} */ p = this._polyline.getPath();
                var /** @type {?} */ path = new Array();
                p.forEach(function (x) { return path.push({ latitude: x.lat(), longitude: x.lng() }); });
                return path;
            };
        /**
         * Gets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
        GooglePolyline.prototype.GetVisible = /**
         * Gets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
            function () {
                return this._polyline.getVisible();
            };
        /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof Polyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetDraggable = /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof Polyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                this._polyline.setDraggable(draggable);
            };
        /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof Polyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetEditable = /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof Polyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                this._polyline.setEditable(editable);
            };
        /**
         * Sets the polyline options
         *
         * \@memberof Polyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetOptions = /**
         * Sets the polyline options
         *
         * \@memberof Polyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = GoogleConversions.TranslatePolylineOptions(options);
                this._polyline.setOptions(o);
                if (options.path) {
                    this.SetPath(/** @type {?} */ (options.path));
                }
            };
        /**
         * Sets the polyline path.
         *
         * \@memberof Polyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetPath = /**
         * Sets the polyline path.
         *
         * \@memberof Polyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
            function (path) {
                var /** @type {?} */ p = new Array();
                path.forEach(function (x) { return p.push(new google.maps.LatLng(x.latitude, x.longitude)); });
                this._polyline.setPath(p);
            };
        /**
         * Sets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetVisible = /**
         * Sets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polyline.setVisible(visible);
            };
        /**
         * Configures the tooltip for the polyline
         * \@memberof GooglePolyline
         * @return {?}
         */
        GooglePolyline.prototype.ManageTooltip = /**
         * Configures the tooltip for the polyline
         * \@memberof GooglePolyline
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        align: 'left',
                        offset: new google.maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        o["map"] = this.NativePrimitve.getMap();
                        o["zIndex"] = 100000;
                        this._tooltip = new GoogleMapLabel(o);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = this.NativePrimitve.addListener('mouseover', function (e) {
                            _this._tooltip.Set('position', e.latLng);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        });
                        this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('position', e.latLng);
                            }
                        });
                        this._mouseOutListener = this.NativePrimitve.addListener('mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            google.maps.event.removeListener(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            google.maps.event.removeListener(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            google.maps.event.removeListener(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return GooglePolyline;
    }(Polyline));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This contstant translates the abstract map events into their corresponding google map
     * equivalents.
     */
    var /** @type {?} */ GoogleMapEventsLookup = {
        click: 'click',
        dblclick: 'dblclick',
        rightclick: 'rightclick',
        resize: 'resize',
        boundschanged: 'bounds_changed',
        centerchanged: 'center_changed',
        zoomchanged: 'zoom_changed',
        mouseover: 'mouseover',
        mouseout: 'mouseout',
        mousemove: 'mousemove',
        infowindowclose: 'closeclick'
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementing a canvas overlay to be placed on the map for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementing a canvas overlay to be placed on the map for Google Maps.
     *
     * @export
     */ GoogleCanvasOverlay = (function (_super) {
        __extends(GoogleCanvasOverlay, _super);
        /**
         * Creates a new instance of the GoogleCanvasOverlay class.
         * @param drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @memberof GoogleCanvasOverlay
         */
        function GoogleCanvasOverlay(drawCallback) {
            return _super.call(this, drawCallback) || this;
        }
        /**
         * Obtains geo coordinates for the click location
         *
         * \@memberof GoogleCanvasOverlay
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
        GoogleCanvasOverlay.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the click location
         *
         * \@memberof GoogleCanvasOverlay
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.latLng) {
                    return null;
                }
                if (!e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?}
         */
            function () {
                return ((this)).getMap();
            };
        /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
        GoogleCanvasOverlay.prototype.GetToolTipOverlay = /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
            function () {
                var /** @type {?} */ o = {
                    align: 'left',
                    offset: new google.maps.Point(0, 25),
                    backgroundColor: 'bisque',
                    hidden: true,
                    fontSize: 12,
                    fontColor: '#000000',
                    strokeWeight: 0
                };
                o["zIndex"] = 100000;
                var /** @type {?} */ label = new GoogleMapLabel(o);
                label.SetMap(this.GetMap());
                return label;
            };
        /**
         * Called when the custom overlay is added to the map. Triggers Onload....
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.OnAdd = /**
         * Called when the custom overlay is added to the map. Triggers Onload....
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
            function () {
                _super.prototype.OnAdd.call(this);
                this.OnLoad();
                this._canvas.style.zIndex = '100';
                // move the canvas above primitives such as polygons.
                // set the overlay to ready state
                this._readyResolver(true);
            };
        /**
         * Called whenever the canvas needs to be redrawn. This method does not do the actual
         * update, it simply scales the canvas. The actual redraw happens once the map is idle.
         * \@memberof GoogleCanvasOverly
         * \@method
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.OnDraw = /**
         * Called whenever the canvas needs to be redrawn. This method does not do the actual
         * update, it simply scales the canvas. The actual redraw happens once the map is idle.
         * \@memberof GoogleCanvasOverly
         * \@method
         * @return {?}
         */
            function () {
                var /** @type {?} */ map = this.GetMap();
                {
                    // Re-drawing the canvas as it moves would be too slow. Instead, scale and translate canvas element.
                    // Upon idle or drag end, we can then redraw the canvas....
                    var /** @type {?} */ zoomCurrent = map.getZoom();
                    var /** @type {?} */ centerCurrent = map.getCenter();
                    // Calculate map scale based on zoom level difference.
                    var /** @type {?} */ scale = Math.pow(2, zoomCurrent - this._zoomStart);
                    // Calculate the scaled dimensions of the canvas.
                    var /** @type {?} */ el = map.getDiv();
                    var /** @type {?} */ w = el.offsetWidth;
                    var /** @type {?} */ h = el.offsetHeight;
                    var /** @type {?} */ newWidth = w * scale;
                    var /** @type {?} */ newHeight = h * scale;
                    // Calculate offset of canvas based on zoom and center offsets.
                    var /** @type {?} */ projection = ((this)).getProjection();
                    var /** @type {?} */ cc = projection.fromLatLngToDivPixel(centerCurrent);
                    // Update the canvas CSS position and dimensions.
                    this.UpdatePosition(cc.x - newWidth / 2, cc.y - newHeight / 2, newWidth, newHeight);
                }
            };
        /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.OnLoad = /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ map = ((this)).getMap();
                // Get the current map view information.
                this._zoomStart = map.getZoom();
                var /** @type {?} */ c = map.getCenter();
                this._centerStart = {
                    latitude: c.lat(),
                    longitude: c.lng()
                };
                // When the map stops moving, render new data on the canvas.
                this._viewChangeEndEvent = google.maps.event.addListener(map, 'idle', function (e) {
                    _this.UpdateCanvas();
                });
                // Update the position of the overlay when the map is resized.
                this._mapResizeEvent = google.maps.event.addListener(map, 'resize', function (e) {
                    _this.UpdateCanvas();
                });
            };
        /**
         * Associates the cnavas overlay with a map.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @param {?} map
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.SetMap = /**
         * Associates the cnavas overlay with a map.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @param {?} map
         * @return {?}
         */
            function (map) {
                ((this)).setMap(map);
            };
        ///
        /// Protected methods
        ///
        /**
         * Attaches the canvas to the map.
         * @memberof CanvasOverlay
         * @method
         */
        /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.SetCanvasElement = /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
            function (el) {
                var /** @type {?} */ panes = ((this)).getPanes();
                if (panes) {
                    if (el != null) {
                        panes.overlayLayer.appendChild(el);
                        // 4: floatPane (infowindow)
                        // 3: overlayMouseTarget (mouse events)
                        // 2: markerLayer (marker images)
                        // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)
                        // 0: mapPane (lowest pane above the map tiles)
                    }
                    else {
                        panes.overlayLayer.removeChild(this._canvas);
                    }
                }
            };
        /**
         * Remove the map event handlers.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.RemoveEventHandlers = /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                // Remove all event handlers from the map.
                if (this._viewChangeEndEvent) {
                    google.maps.event.removeListener(this._viewChangeEndEvent);
                }
                if (this._mapResizeEvent) {
                    google.maps.event.removeListener(this._mapResizeEvent);
                }
            };
        /**
         * Updates the Canvas size based on the map size.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.Resize = /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ map = ((this)).getMap();
                // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.
                var /** @type {?} */ el = map.getDiv();
                this._canvas.width = el.offsetWidth;
                this._canvas.height = el.offsetHeight;
            };
        /**
         * Updates the Canvas.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.UpdateCanvas = /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ map = ((this)).getMap();
                // Only render the canvas if it isn't in streetside mode.
                {
                    this._canvas.style.display = '';
                    // Reset CSS position and dimensions of canvas.
                    var /** @type {?} */ el = map.getDiv();
                    var /** @type {?} */ w = el.offsetWidth;
                    var /** @type {?} */ h = el.offsetHeight;
                    var /** @type {?} */ centerPoint = ((this)).getProjection().fromLatLngToDivPixel(map.getCenter());
                    this.UpdatePosition((centerPoint.x - w / 2), (centerPoint.y - h / 2), w, h);
                    // Redraw the canvas.
                    this.Redraw(true);
                    // Get the current map view information.
                    this._zoomStart = map.getZoom();
                    var /** @type {?} */ c = map.getCenter();
                    this._centerStart = {
                        latitude: c.lat(),
                        longitude: c.lng()
                    };
                }
            };
        return GoogleCanvasOverlay;
    }(CanvasOverlay));
    /**
     * Helper function to extend the OverlayView into the CanvasOverlay
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinCanvasOverlay$1() {
        new Extender(GoogleCanvasOverlay)
            .Extend(new google.maps.OverlayView)
            .Map('onAdd', 'OnAdd')
            .Map('draw', 'OnDraw')
            .Map('onRemove', 'OnRemove');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements a factory to create all the implementation specifc services for a map implementation
     *
     * @export
     * @abstract
     * @abstract
     */
    var MapServiceFactory = (function () {
        function MapServiceFactory() {
        }
        MapServiceFactory.decorators = [
            { type: core.Injectable },
        ];
        return MapServiceFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract class to implement map api. A concrete implementation should be created for each
     * Map provider supported (e.g. Bing, Goolge, ESRI)
     *
     * @export
     * @abstract
     * @abstract
     */
    var MapService = (function () {
        function MapService() {
        }
        /**
         * Gets a random geo locations filling the bounding box.
         *
         * \@memberof MapService
         * @param {?} count - number of locations to return
         * @param {?} bounds  - bounding box.
         * @return {?} - Array of geo locations.
         */
        MapService.GetRandonLocations = /**
         * Gets a random geo locations filling the bounding box.
         *
         * \@memberof MapService
         * @param {?} count - number of locations to return
         * @param {?} bounds  - bounding box.
         * @return {?} - Array of geo locations.
         */
            function (count, bounds) {
                var /** @type {?} */ a = [];
                var /** @type {?} */ _getRandomLocation = function (b) {
                    var /** @type {?} */ lat = Math.random() * (b.maxLatitude - b.minLatitude) + b.minLatitude;
                    var /** @type {?} */ lng = 0;
                    if (crossesDateLine) {
                        lng = Math.random() * (b.minLongitude + 360 - b.maxLongitude) + b.maxLongitude;
                        if (lng > 180) {
                            lng = lng - 360;
                        }
                    }
                    else {
                        lng = Math.random() * (b.maxLongitude - b.minLongitude) + b.minLongitude;
                    }
                    var /** @type {?} */ p = { latitude: lat, longitude: lng };
                    return p;
                };
                var /** @type {?} */ crossesDateLine = false;
                if (bounds == null) {
                    bounds = /** @type {?} */ ({
                        maxLatitude: 360,
                        minLatitude: 0,
                        maxLongitude: 170,
                        minLongitude: 0
                    });
                }
                if (bounds.center.longitude < bounds.minLongitude || bounds.center.longitude > bounds.maxLongitude) {
                    crossesDateLine = true;
                }
                if (!count || count <= 0) {
                    return [_getRandomLocation(bounds)];
                }
                for (var /** @type {?} */ r = 0; r < count; r++) {
                    a.push(_getRandomLocation(bounds));
                }
                return a;
            };
        MapService.decorators = [
            { type: core.Injectable },
        ];
        return MapService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The abstract class represents the contract defintions for a marker service to be implemented by an acutaly underlying
     * map architecture.
     *
     * @export
     * @abstract
     * @abstract
     */
    var MarkerService = (function () {
        function MarkerService() {
        }
        MarkerService.decorators = [
            { type: core.Injectable },
        ];
        return MarkerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This class defines the contract for an InfoBoxService. Each Map Architecture provider is expected the furnish a concrete implementation.
     *
     * @export
     * @abstract
     * @abstract
     */
    var InfoBoxService = (function () {
        function InfoBoxService() {
        }
        InfoBoxService.decorators = [
            { type: core.Injectable },
        ];
        return InfoBoxService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract class to to define the layer service contract. Must be realized by implementing provider.
     *
     * @export
     * @abstract
     * @abstract
     */
    var LayerService = (function () {
        function LayerService() {
        }
        LayerService.decorators = [
            { type: core.Injectable },
        ];
        return LayerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The abstract class represents the contract defintions for a polygon service to be implemented by an acutaly underlying
     * map architecture.
     *
     * @export
     * @abstract
     * @abstract
     */
    var PolygonService = (function () {
        function PolygonService() {
        }
        PolygonService.decorators = [
            { type: core.Injectable },
        ];
        return PolygonService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The abstract class represents the contract defintions for a polyline service to be implemented by an acutaly underlying
     * map architecture.
     *
     * @export
     * @abstract
     * @abstract
     */
    var PolylineService = (function () {
        function PolylineService() {
        }
        PolylineService.decorators = [
            { type: core.Injectable },
        ];
        return PolylineService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract class to to define teh cluster layer service contract. Must be realized by implementing provider.
     *
     * @export
     * @abstract
     * @abstract
     */
    var ClusterService = (function (_super) {
        __extends(ClusterService, _super);
        function ClusterService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ClusterService.decorators = [
            { type: core.Injectable },
        ];
        return ClusterService;
    }(LayerService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * InfoBoxAction renders an action in an info window {\@link InfoBox}
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *    .map-container { height: 300px; }
     *  `],
     *  template: `
     *    <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker [Latitude]="lat" [Longitude]="lng" [Label]="'M'">
     *        <x-info-box>
     *          <x-info-box-action [Label]="actionlabel" (ActionClicked)="actionClicked(this)"></x-info-box-action>
     *        </x-info-box>
     *      </x-map-marker>
     *    </x-map>
     *  `
     * })
     * ```
     *
     * @export
     */
    var InfoBoxActionDirective = (function () {
        function InfoBoxActionDirective() {
            /**
             * Emits an event when the action has been clicked
             *
             * \@memberof InfoBoxActionDirective
             */
            this.ActionClicked = new core.EventEmitter();
        }
        InfoBoxActionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-info-box-action'
                    },] },
        ];
        InfoBoxActionDirective.propDecorators = {
            Label: [{ type: core.Input }],
            ActionClicked: [{ type: core.Output }]
        };
        return InfoBoxActionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for multiple infoboxes.
     */
    var /** @type {?} */ infoBoxId = 0;
    /**
     * InfoBox renders a info window inside a {\@link MapMarkerDirective} or standalone.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *    .map-container { height: 300px; }
     * `],
     *  template: `
     *    <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker [Latitude]="lat" [Longitude]="lng" [Label]="'M'">
     *        <x-info-box [DisableAutoPan]="true">
     *          Hi, this is the content of the <strong>info window</strong>
     *         </x-info-box>
     *       </x-map-marker>
     *     </x-map>
     *  `
     * })
     * ```
     *
     * @export
     */
    var InfoBoxComponent = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of InfoBoxComponent.
         * @param _infoBoxService - Concrete {@link InfoBoxService} implementation for underlying Map architecture.
         *
         * @memberof InfoBoxComponent
         */
        function InfoBoxComponent(_infoBoxService) {
            this._infoBoxService = _infoBoxService;
            this._infoBoxAddedToManager = false;
            this._id = (infoBoxId++).toString();
            /**
             * Determine whether only one infobox can be open at a time. Note that ANY info box settings.
             *
             * \@memberof InfoBoxComponent
             */
            this.Modal = true;
            /**
             * Determines visibility of infobox
             *
             * \@memberof InfoBoxComponent
             */
            this.Visible = false;
            /**
             * Determines if other info boxes should be closed before opening this one
             *
             * \@memberof InfoBoxComponent
             */
            this.CloseInfoBoxesOnOpen = true;
            /**
             * Emits an event when the info window is closed.
             *
             * \@memberof InfoBoxComponent
             */
            this.InfoBoxClose = new core.EventEmitter();
        }
        Object.defineProperty(InfoBoxComponent.prototype, "HtmlContent", {
            get: /**
             * Gets the HTML content of the info box.
             *
             * \@readonly
             * \@memberof InfoBoxComponent
             * @return {?}
             */ function () {
                if (this._content.nativeElement && this._content.nativeElement.innerText && this._content.nativeElement.innerText.trim() !== '') {
                    return this._content.nativeElement.outerHTML;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfoBoxComponent.prototype, "Id", {
            get: /**
             * Gets the Id of the info box as a string.
             *
             * \@readonly
             * \@memberof InfoBoxComponent
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Closes the Infobox.
         *
         * \@memberof InfoBoxComponent
         * @return {?}
         */
        InfoBoxComponent.prototype.Close = /**
         * Closes the Infobox.
         *
         * \@memberof InfoBoxComponent
         * @return {?}
         */
            function () {
                var _this = this;
                return this._infoBoxService.Close(this).then(function () {
                    _this.InfoBoxClose.emit(_this._id);
                });
            };
        /**
         * Called on after component view as been initialized. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
        InfoBoxComponent.prototype.ngAfterViewInit = /**
         * Called on after component view as been initialized. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
            function () {
                this._infoBoxService.AddInfoWindow(this);
                this._infoBoxAddedToManager = true;
                this.HandleEvents();
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        InfoBoxComponent.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._infoBoxAddedToManager) {
                    return;
                }
                if ((changes['latitude'] || changes['longitude']) && typeof this.Latitude === 'number' &&
                    typeof this.Longitude === 'number') {
                    this._infoBoxService.SetPosition(this, {
                        latitude: changes['latitude'].currentValue,
                        longitude: changes['longitude'].currentValue
                    });
                }
                this.SetInfoWindowOptions(changes);
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
        InfoBoxComponent.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
            function () { this._infoBoxService.DeleteInfoWindow(this); };
        /**
         * Opens a closed info window.
         *
         * \@memberof InfoBoxComponent
         * @param {?=} loc
         * @return {?} - Promise that is fullfilled when the infobox has been opened.
         *
         */
        InfoBoxComponent.prototype.Open = /**
         * Opens a closed info window.
         *
         * \@memberof InfoBoxComponent
         * @param {?=} loc
         * @return {?} - Promise that is fullfilled when the infobox has been opened.
         *
         */
            function (loc) {
                return this._infoBoxService.Open(this, loc);
            };
        /**
         * Returns a string representation of the info box.
         *
         * \@memberof InfoBoxComponent
         * @return {?} - string representation of the info box.
         *
         */
        InfoBoxComponent.prototype.ToString = /**
         * Returns a string representation of the info box.
         *
         * \@memberof InfoBoxComponent
         * @return {?} - string representation of the info box.
         *
         */
            function () { return 'InfoBoxComponent-' + this._id; };
        /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        InfoBoxComponent.prototype.HandleEvents = /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._infoBoxService.CreateEventObservable('infowindowclose', this).subscribe(function (e) {
                    _this.InfoBoxClose.emit(_this._id);
                });
            };
        /**
         * Sets the info window options
         *
         * \@memberof InfoBoxComponent
         * @param {?} changes
         *
         * @return {?}
         */
        InfoBoxComponent.prototype.SetInfoWindowOptions = /**
         * Sets the info window options
         *
         * \@memberof InfoBoxComponent
         * @param {?} changes
         *
         * @return {?}
         */
            function (changes) {
                var /** @type {?} */ options = {};
                if (changes['title']) {
                    options.title = this.Title;
                }
                if (changes['description']) {
                    options.description = this.Description;
                }
                if (changes['disableAutoPan']) {
                    options.disableAutoPan = this.DisableAutoPan;
                }
                if (changes['visible']) {
                    options.visible = this.Visible;
                }
                if (changes['xOffset'] || changes['yOffset']) {
                    if (options.pixelOffset == null) {
                        options.pixelOffset = { x: 0, y: 0 };
                    }
                    options.pixelOffset.x = this.xOffset;
                    options.pixelOffset.y = this.yOffset;
                }
                this._infoBoxService.SetOptions(this, options);
            };
        InfoBoxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'x-info-box',
                        template: "\n        <div #infoBoxContent class='info-box-content'>\n            <ng-content></ng-content>\n        </div>",
                        styles: ["\n        x-map .MicrosoftMap .Infobox .infobox-title { padding: 10px 10px 5px 10px }\n        x-map .MicrosoftMap .Infobox .infobox-info { padding: 3px 10px 10px 10px }\n        x-map .MicrosoftMap .Infobox .infobox-actions { height: auto }\n    "],
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        InfoBoxComponent.ctorParameters = function () {
            return [
                { type: InfoBoxService }
            ];
        };
        InfoBoxComponent.propDecorators = {
            _content: [{ type: core.ViewChild, args: ['infoBoxContent',] }],
            InfoWindowActions: [{ type: core.ContentChildren, args: [InfoBoxActionDirective,] }],
            Latitude: [{ type: core.Input }],
            Longitude: [{ type: core.Input }],
            Title: [{ type: core.Input }],
            Description: [{ type: core.Input }],
            DisableAutoPan: [{ type: core.Input }],
            MaxWidth: [{ type: core.Input }],
            Modal: [{ type: core.Input }],
            HostMarker: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            xOffset: [{ type: core.Input }],
            yOffset: [{ type: core.Input }],
            CloseInfoBoxesOnOpen: [{ type: core.Input }],
            InfoBoxClose: [{ type: core.Output }]
        };
        return InfoBoxComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for marker.
     */
    var /** @type {?} */ markerId = 0;
    /**
     * MapMarkerDirective renders a map marker inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker [Latitude]="lat" [Longitude]="lng" [Label]="'M'"></x-map-marker>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapMarkerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapMarkerDirective.
         * @param _markerService - Concreate implementation of a {@link MarkerService}.
         * @param _containerRef - View container hosting the marker.
         * Used to determine parent layer through markup.
         *
         * @memberof MapMarkerDirective
         */
        function MapMarkerDirective(_markerService, _containerRef) {
            this._markerService = _markerService;
            this._containerRef = _containerRef;
            this._clickTimeout = null;
            this._events = [];
            this._inClusterLayer = false;
            this._inCustomLayer = false;
            this._markerAddedToManger = false;
            /**
             * This event is fired when the DOM dblclick event is fired on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.DblClick = new core.EventEmitter();
            /**
             * This event is repeatedly fired while the user drags the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.Drag = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.DragEnd = new core.EventEmitter();
            /**
             * If true, the marker can be dragged. Default value is false.
             *
             * \@memberof MapMarkerDirective
             */
            this.Draggable = false;
            /**
             * This event is fired when the user starts dragging the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.DragStart = new core.EventEmitter();
            /**
             * This event emitter gets emitted when a marker icon is being created.
             *
             * \@memberof MapMarkerDirective
             */
            this.DynamicMarkerCreated = new core.EventEmitter();
            /**
             * True to indiciate whether this is the first marker in a set.
             * Use this for bulk operations (particularily clustering) to ensure performance.
             *
             * \@memberof MapMarkerDirective
             */
            this.IsFirstInSet = false;
            /**
             * True to indiciate whether this is the last marker in a set.
             * Use this for bulk operations (particularily clustering) to ensure performance.
             *
             * \@memberof MapMarkerDirective
             */
            this.IsLastInSet = true;
            /**
             * This event emitter gets emitted when the user clicks on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.MarkerClick = new core.EventEmitter();
            /**
             * Arbitary metadata to assign to the Marker. This is useful for events
             *
             * \@memberof MapMarkerDirective
             */
            this.Metadata = new Map();
            /**
             * This event is fired when the DOM mousedown event is fired on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseDown = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseMove = new core.EventEmitter();
            /**
             * This event is fired on marker mouseout.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseOut = new core.EventEmitter();
            /**
             * This event is fired on marker mouseover.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseOver = new core.EventEmitter();
            /**
             * This event is fired whe the DOM mouseup event is fired on the marker
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseUp = new core.EventEmitter();
            /**
             * This even is fired when the marker is right-clicked on.
             *
             * \@memberof MapMarkerDirective
             */
            this.RightClick = new core.EventEmitter();
            this._id = (markerId++).toString();
        }
        Object.defineProperty(MapMarkerDirective.prototype, "AddedToManager", {
            get: /**
             * Getswhether the marker has already been added to the marker service and is ready for use.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._markerAddedToManger; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the marker as a string.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "InClusterLayer", {
            get: /**
             * Gets whether the marker is in a cluster layer. See {\@link ClusterLayer}.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._inClusterLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "InCustomLayer", {
            get: /**
             * Gets whether the marker is in a custom layer. See {\@link MapLayer}.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._inCustomLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "LayerId", {
            get: /**
             * gets the id of the Layer the marker belongs to.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._layerId; },
            enumerable: true,
            configurable: true
        });
        /**
         * Translates a marker geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerDirective
         * @param {?=} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
        MapMarkerDirective.prototype.LocationToPixel = /**
         * Translates a marker geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerDirective
         * @param {?=} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
            function (loc) {
                return this._markerService.LocationToPoint(loc ? loc : this);
            };
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
        MapMarkerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
            function () {
                if (this._infoBox != null) {
                    this._infoBox.HostMarker = this;
                }
                if (this._containerRef.element.nativeElement.parentElement) {
                    var /** @type {?} */ parentName = this._containerRef.element.nativeElement.parentElement.tagName;
                    if (parentName.toLowerCase() === 'x-cluster-layer') {
                        this._inClusterLayer = true;
                    }
                    else if (parentName.toLowerCase() === 'x-map-layer') {
                        this._inCustomLayer = true;
                    }
                    this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);
                }
                if (!this._markerAddedToManger) {
                    this._markerService.AddMarker(this);
                    this._markerAddedToManger = true;
                    this.AddEventListeners();
                }
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
        MapMarkerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
            function (changes) {
                if (typeof this.Latitude !== 'number' || typeof this.Longitude !== 'number') {
                    return;
                }
                if (!this._markerAddedToManger) {
                    return;
                }
                if (changes['Latitude'] || changes['Longitude']) {
                    this._markerService.UpdateMarkerPosition(this);
                }
                if (changes['Title']) {
                    this._markerService.UpdateTitle(this);
                }
                if (changes['Label']) {
                    this._markerService.UpdateLabel(this);
                }
                if (changes['Draggable']) {
                    this._markerService.UpdateDraggable(this);
                }
                if (changes['IconUrl'] || changes['IconInfo']) {
                    this._markerService.UpdateIcon(this);
                }
                if (changes['Anchor']) {
                    this._markerService.UpdateAnchor(this);
                }
                if (changes['Visible']) {
                    this._markerService.UpdateVisible(this);
                }
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
        MapMarkerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
            function () {
                this._markerService.DeleteMarker(this);
                this._events.forEach(function (s) { return s.unsubscribe(); });
            };
        /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerDirective
         * @return {?} - string representation of the marker id.
         */
        MapMarkerDirective.prototype.toString = /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerDirective
         * @return {?} - string representation of the marker id.
         */
            function () { return 'MapMarker-' + this._id.toString(); };
        /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
        MapMarkerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ _getEventArg = function (e) {
                    return {
                        Marker: _this,
                        Click: e,
                        Location: _this._markerService.GetCoordinatesFromClick(e),
                        Pixels: _this._markerService.GetPixelsFromClick(e)
                    };
                };
                this._events.push(this._markerService.CreateEventObservable('click', this).subscribe(function (e) {
                    ///
                    /// this is necessary since map will treat a doubleclick first as two clicks...'
                    ///
                    _this._clickTimeout = rxjs.timer(300).subscribe(function (n) {
                        if (_this._infoBox != null) {
                            _this._infoBox.Open(_this._markerService.GetCoordinatesFromClick(e));
                        }
                        _this.MarkerClick.emit(_getEventArg(e));
                    });
                }));
                this._events.push(this._markerService.CreateEventObservable('dblclick', this).subscribe(function (e) {
                    if (_this._clickTimeout) {
                        _this._clickTimeout.unsubscribe();
                        _this._clickTimeout = null;
                    }
                    _this.DblClick.emit(_getEventArg(e));
                }));
                var /** @type {?} */ handlers = [
                    { name: 'drag', handler: function (ev) { return _this.Drag.emit(_getEventArg(ev)); } },
                    { name: 'dragend', handler: function (ev) { return _this.DragEnd.emit(_getEventArg(ev)); } },
                    { name: 'dragstart', handler: function (ev) { return _this.DragStart.emit(_getEventArg(ev)); } },
                    { name: 'mousedown', handler: function (ev) { return _this.MouseDown.emit(_getEventArg(ev)); } },
                    { name: 'mousemove', handler: function (ev) { return _this.MouseMove.emit(_getEventArg(ev)); } },
                    { name: 'mouseout', handler: function (ev) { return _this.MouseOut.emit(_getEventArg(ev)); } },
                    { name: 'mouseover', handler: function (ev) { return _this.MouseOver.emit(_getEventArg(ev)); } },
                    { name: 'mouseup', handler: function (ev) { return _this.MouseUp.emit(_getEventArg(ev)); } },
                    { name: 'rightclick', handler: function (ev) { return _this.RightClick.emit(_getEventArg(ev)); } },
                ];
                handlers.forEach(function (obj) {
                    var /** @type {?} */ os = _this._markerService.CreateEventObservable(obj.name, _this).subscribe(obj.handler);
                    _this._events.push(os);
                });
            };
        MapMarkerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-marker'
                    },] },
        ];
        /** @nocollapse */
        MapMarkerDirective.ctorParameters = function () {
            return [
                { type: MarkerService },
                { type: core.ViewContainerRef }
            ];
        };
        MapMarkerDirective.propDecorators = {
            _infoBox: [{ type: core.ContentChild, args: [InfoBoxComponent,] }],
            Anchor: [{ type: core.Input }],
            DblClick: [{ type: core.Output }],
            Drag: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }],
            Draggable: [{ type: core.Input }],
            DragStart: [{ type: core.Output }],
            DynamicMarkerCreated: [{ type: core.Output }],
            Height: [{ type: core.Input }],
            IconInfo: [{ type: core.Input }],
            IconUrl: [{ type: core.Input }],
            IsFirstInSet: [{ type: core.Input }],
            IsLastInSet: [{ type: core.Input }],
            Label: [{ type: core.Input }],
            Latitude: [{ type: core.Input }],
            Longitude: [{ type: core.Input }],
            MarkerClick: [{ type: core.Output }],
            Metadata: [{ type: core.Input }],
            MouseDown: [{ type: core.Output }],
            MouseMove: [{ type: core.Output }],
            MouseOut: [{ type: core.Output }],
            MouseOver: [{ type: core.Output }],
            MouseUp: [{ type: core.Output }],
            RightClick: [{ type: core.Output }],
            Title: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            Width: [{ type: core.Input }]
        };
        return MapMarkerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Renders a map based on a given provider.
     * **Important note**: To be able see a map in the browser, you have to define a height for the CSS
     * class `map-container`.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent} from '...';
     *
     * \@Component({
     *  selector: 'my-map',
     *  styles: [`
     *    .map-container { height: 300px; }
     * `],
     *  template: `
     *    <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom"></x-map>
     *  `
     * })
     * ```
     *
     * @export
     */
    var MapComponent = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapComponent.
         *
         * @param _mapService - Concreted implementation of a map service for the underlying maps implementations.
         *                                   Generally provided via injections.
         * @memberof MapComponent
         */
        function MapComponent(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
            this._longitude = 0;
            this._latitude = 0;
            this._zoom = 0;
            this._options = {};
            this._box = null;
            this._containerClass = true;
            /**
             * This event emitter is fired when the map bounding box changes.
             *
             * \@memberof MapComponent
             */
            this.BoundsChange = new core.EventEmitter();
            /**
             * This event emitter is fired when the map center changes.
             *
             * \@memberof MapComponent
             */
            this.CenterChange = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user clicks on the map (but not when they click on a
             * marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapClick = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapDblClick = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user right-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapRightClick = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapMouseOver = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapMouseOut = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapMouseMove = new core.EventEmitter();
            /**
             * The event emitter is fired when the map service is available and the maps has been
             * Initialized (but not necessarily created). It contains a Promise that when fullfilled returns
             * the main map object of the underlying platform.
             *
             * \@memberof MapComponent
             */
            this.MapPromise = new core.EventEmitter();
            /**
             * This event emiiter is fired when the map zoom changes
             *
             * \@memberof MapComponent
             */
            this.ZoomChange = new core.EventEmitter();
            /**
             * This event emitter is fired when the map service is available and the maps has been
             * Initialized
             * \@memberOf MapComponent
             */
            this.MapService = new core.EventEmitter();
        }
        Object.defineProperty(MapComponent.prototype, "Box", {
            ///
            /// Property declarations
            ///
            /**
             * Get or sets the maximum and minimum bounding box for map.
             *
             * @memberof MapComponent
             */
            get: /**
             * Get or sets the maximum and minimum bounding box for map.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._box; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._box = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Latitude", {
            /**
             * Gets or sets the latitude that sets the center of the map.
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets the latitude that sets the center of the map.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._longitude; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._latitude = this.ConvertToDecimal(value);
                this.UpdateCenter();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Longitude", {
            /**
             * Gets or sets the longitude that sets the center of the map.
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets the longitude that sets the center of the map.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._longitude; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._longitude = this.ConvertToDecimal(value);
                this.UpdateCenter();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Options", {
            /**
             * Gets or sets general map Options
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets general map Options
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._options; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._options = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Zoom", {
            /**
             * Gets or sets the zoom level of the map. The default value is `8`.
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets the zoom level of the map. The default value is `8`.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._zoom; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._zoom = this.ConvertToDecimal(value, 8);
                if (typeof this._zoom === 'number') {
                    this._mapService.SetZoom(this._zoom);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.ngOnInit = /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                this.InitMapInstance(this._container.nativeElement);
                this.MapPromise.emit(this._mapService.MapPromise);
                this.MapService.emit(this._mapService);
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapComponent.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (this._mapPromise) {
                    if (changes['Box']) {
                        if (this._box != null) {
                            this._mapService.SetViewOptions(/** @type {?} */ ({
                                bounds: this._box
                            }));
                        }
                    }
                    if (changes['Options']) {
                        this._mapService.SetMapOptions(this._options);
                    }
                }
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                this._mapService.DisposeMap();
            };
        /**
         * Triggers a resize event on the map instance.
         *
         * \@memberof MapComponent
         * @return {?} - A promise that gets resolved after the event was triggered.
         *
         */
        MapComponent.prototype.TriggerResize = /**
         * Triggers a resize event on the map instance.
         *
         * \@memberof MapComponent
         * @return {?} - A promise that gets resolved after the event was triggered.
         *
         */
            function () {
                var _this = this;
                // Note: When we would trigger the resize event and show the map in the same turn (which is a
                // common case for triggering a resize event), then the resize event would not
                // work (to show the map), so we trigger the event in a timeout.
                return new Promise(function (resolve) {
                    setTimeout(function () { return _this._mapService.TriggerMapEvent('resize').then(function () { return resolve(); }); });
                });
            };
        /**
         * Converts a number-ish value to a number.
         *
         * \@memberof MapComponent
         * @param {?} value - The value to convert.
         * @param {?=} defaultValue
         * @return {?} - Converted number of the default.
         *
         */
        MapComponent.prototype.ConvertToDecimal = /**
         * Converts a number-ish value to a number.
         *
         * \@memberof MapComponent
         * @param {?} value - The value to convert.
         * @param {?=} defaultValue
         * @return {?} - Converted number of the default.
         *
         */
            function (value, defaultValue) {
                if (defaultValue === void 0) {
                    defaultValue = null;
                }
                if (typeof value === 'string') {
                    return parseFloat(value);
                }
                else if (typeof value === 'number') {
                    return /** @type {?} */ (value);
                }
                return defaultValue;
            };
        /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapClickEvents = /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('click').subscribe(function (e) {
                    //
                    // this is necessary since bing will treat a doubleclick first as two clicks...'
                    //
                    // this is necessary since bing will treat a doubleclick first as two clicks...'
                    ///
                    _this._clickTimeout = setTimeout(function () {
                        _this.MapClick.emit(/** @type {?} */ (e));
                    }, 300);
                });
                this._mapService.SubscribeToMapEvent('dblclick').subscribe(function (e) {
                    if (_this._clickTimeout) {
                        clearTimeout(/** @type {?} */ (_this._clickTimeout));
                    }
                    _this.MapDblClick.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('rightclick').subscribe(function (e) {
                    _this.MapRightClick.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('mouseover').subscribe(function (e) {
                    _this.MapMouseOver.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('mouseout').subscribe(function (e) {
                    _this.MapMouseOut.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('mousemove').subscribe(function (e) {
                    _this.MapMouseMove.emit(/** @type {?} */ (e));
                });
            };
        /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapBoundsChange = /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('boundschanged').subscribe(function () {
                    _this._mapService.GetBounds().then(function (bounds) {
                        _this.BoundsChange.emit(bounds);
                    });
                });
            };
        /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapCenterChange = /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('centerchanged').subscribe(function () {
                    _this._mapService.GetCenter().then(function (center) {
                        if (_this._latitude !== center.latitude || _this._longitude !== center.longitude) {
                            _this._latitude = center.latitude;
                            _this._longitude = center.longitude;
                            _this.CenterChange.emit(/** @type {?} */ ({ latitude: _this._latitude, longitude: _this._longitude }));
                        }
                    });
                });
            };
        /**
         * Delegate handling map zoom change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapZoomChange = /**
         * Delegate handling map zoom change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('zoomchanged').subscribe(function () {
                    _this._mapService.GetZoom().then(function (z) {
                        if (_this._zoom !== z) {
                            _this._zoom = z;
                            _this.ZoomChange.emit(z);
                        }
                    });
                });
            };
        /**
         * Initializes the map.
         *
         * \@memberof MapComponent
         * @param {?} el - Html elements which will host the map canvas.
         *
         * @return {?}
         */
        MapComponent.prototype.InitMapInstance = /**
         * Initializes the map.
         *
         * \@memberof MapComponent
         * @param {?} el - Html elements which will host the map canvas.
         *
         * @return {?}
         */
            function (el) {
                var _this = this;
                this._zone.runOutsideAngular(function () {
                    if (_this._options.center == null) {
                        _this._options.center = { latitude: _this._latitude, longitude: _this._longitude };
                    }
                    if (_this._options.zoom == null) {
                        _this._options.zoom = _this._zoom;
                    }
                    if (_this._options.mapTypeId == null) {
                        _this._options.mapTypeId = MapTypeId.hybrid;
                    }
                    if (_this._box != null) {
                        _this._options.bounds = _this._box;
                    }
                    _this._mapPromise = _this._mapService.CreateMap(el, _this._options);
                    _this.HandleMapCenterChange();
                    _this.HandleMapBoundsChange();
                    _this.HandleMapZoomChange();
                    _this.HandleMapClickEvents();
                });
            };
        /**
         * Updates the map center based on the geo properties of the component.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.UpdateCenter = /**
         * Updates the map center based on the geo properties of the component.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                if (typeof this._latitude !== 'number' || typeof this._longitude !== 'number') {
                    return;
                }
                this._mapService.SetCenter({
                    latitude: this._latitude,
                    longitude: this._longitude,
                });
            };
        MapComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'x-map',
                        providers: [
                            { provide: MapService, deps: [MapServiceFactory], useFactory: MapServiceCreator },
                            { provide: MarkerService, deps: [MapServiceFactory, MapService, LayerService, ClusterService], useFactory: MarkerServiceFactory },
                            {
                                provide: InfoBoxService, deps: [MapServiceFactory, MapService,
                                    MarkerService], useFactory: InfoBoxServiceFactory
                            },
                            { provide: LayerService, deps: [MapServiceFactory, MapService], useFactory: LayerServiceFactory },
                            { provide: ClusterService, deps: [MapServiceFactory, MapService], useFactory: ClusterServiceFactory },
                            { provide: PolygonService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolygonServiceFactory },
                            { provide: PolylineService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolylineServiceFactory }
                        ],
                        template: "\n        <div #container class='map-container-inner'></div>\n        <div class='map-content'>\n            <ng-content></ng-content>\n        </div>\n    ",
                        styles: ["\n        .map-container-inner { width: inherit; height: inherit; }\n        .map-container-inner div { background-repeat: no-repeat; }\n        .map-content { display:none; }\n    "],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MapComponent.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapComponent.propDecorators = {
            _containerClass: [{ type: core.HostBinding, args: ['class.map-container',] }],
            _container: [{ type: core.ViewChild, args: ['container',] }],
            _markers: [{ type: core.ContentChildren, args: [MapMarkerDirective,] }],
            Box: [{ type: core.Input }],
            Latitude: [{ type: core.Input }],
            Longitude: [{ type: core.Input }],
            Options: [{ type: core.Input }],
            Zoom: [{ type: core.Input }],
            BoundsChange: [{ type: core.Output }],
            CenterChange: [{ type: core.Output }],
            MapClick: [{ type: core.Output }],
            MapDblClick: [{ type: core.Output }],
            MapRightClick: [{ type: core.Output }],
            MapMouseOver: [{ type: core.Output }],
            MapMouseOut: [{ type: core.Output }],
            MapMouseMove: [{ type: core.Output }],
            MapPromise: [{ type: core.Output }],
            ZoomChange: [{ type: core.Output }],
            MapService: [{ type: core.Output }]
        };
        return MapComponent;
    }());
    /**
     * Factory function to generate a cluster service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @return {?} - A concrete instance of a Cluster Service based on the underlying map architecture
     */
    function ClusterServiceFactory(f, m) { return f.CreateClusterService(m); }
    /**
     * Factory function to generate a infobox service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} ma
     * @return {?} - A concrete instance of a InfoBox Service based on the underlying map architecture.
     */
    function InfoBoxServiceFactory(f, m, ma) { return f.CreateInfoBoxService(m, ma); }
    /**
     * Factory function to generate a layer service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @return {?} - A concrete instance of a Layer Service based on the underlying map architecture.
     */
    function LayerServiceFactory(f, m) { return f.CreateLayerService(m); }
    /**
     * Factory function to generate a map service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @return {?} - A concrete instance of a MapService based on the underlying map architecture.
     */
    function MapServiceCreator(f) { return f.Create(); }
    /**
     * Factory function to generate a marker service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} l - A {\@link LayerService} instance.
     * @param {?} c - A {\@link ClusterService} instance.
     * @return {?} - A concrete instance of a Marker Service based on the underlying map architecture.
     */
    function MarkerServiceFactory(f, m, l, c) {
        return f.CreateMarkerService(m, l, c);
    }
    /**
     * Factory function to generate a polygon service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} l - A {\@link LayerService} instance.
     * @return {?} - A concrete instance of a Polygon Service based on the underlying map architecture.
     */
    function PolygonServiceFactory(f, m, l) {
        return f.CreatePolygonService(m, l);
    }
    /**
     * Factory function to generate a polyline service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} l - A {\@link LayerService} instance.
     * @return {?} - A concrete instance of a Polyline Service based on the underlying map architecture.
     */
    function PolylineServiceFactory(f, m, l) {
        return f.CreatePolylineService(m, l);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for multiple layers.
     */
    var /** @type {?} */ layerId = 0;
    /**
     * MapLayerDirective creates a layer on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>
     *     <x-map-layer [Visible]='visible'>
     *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>
     *     </x-map-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapLayerDirective.
         * @param _layerService - Concreted implementation of a layer service for the underlying maps implementations.
         * Generally provided via injections.
         * @param _containerRef - Reference to the container hosting the map canvas. Generally provided via injection.
         *
         * @memberof MapLayerDirective
         */
        function MapLayerDirective(_layerService, _containerRef) {
            this._layerService = _layerService;
            this._containerRef = _containerRef;
            this._visible = true;
            this._addedToManager = false;
            this._id = layerId++;
        }
        Object.defineProperty(MapLayerDirective.prototype, "Visible", {
            ///
            /// Property declarations
            ///
            /**
             * Gets or sets the layer visibility.
             *
             * @memberof MapLayerDirective
             */
            get: /**
             * Gets or sets the layer visibility.
             *
             * \@memberof MapLayerDirective
             * @return {?}
             */ function () { return this._visible; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._visible = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapLayerDirective.prototype, "Id", {
            get: /**
             * Gets the layer id.
             *
             * \@readonly
             * \@memberof MapLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
        MapLayerDirective.prototype.ngOnInit = /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
            function () {
                this._containerRef.element.nativeElement.attributes['layerId'] = this._id.toString();
                this._layerService.AddLayer(this);
                this._addedToManager = true;
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapLayerDirective.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToManager) {
                    return;
                }
                if (changes['Visible']) {
                    this._layerService.GetNativeLayer(this).then(function (l) {
                        l.SetVisible(!l.GetVisible());
                    });
                }
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
        MapLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
            function () {
                this._layerService.DeleteLayer(this);
            };
        MapLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-layer'
                    },] },
        ];
        /** @nocollapse */
        MapLayerDirective.ctorParameters = function () {
            return [
                { type: LayerService },
                { type: core.ViewContainerRef }
            ];
        };
        MapLayerDirective.propDecorators = {
            _markers: [{ type: core.ContentChildren, args: [MapMarkerDirective,] }],
            Visible: [{ type: core.Input }]
        };
        return MapLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Creates a cluster layer on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>
     *     <x-cluster-layer [Visible]='visible'>
     *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>
     *     </x-cluster-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var ClusterLayerDirective = (function (_super) {
        __extends(ClusterLayerDirective, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of ClusterLayerDirective.
         *
         * @param _layerService - Concreted implementation of a cluster layer service for the underlying maps
         * implementations. Generally provided via injections.
         * @param _containerRef - A reference to the view container of the layer. Generally provided via injection.
         *
         * @memberof ClusterLayerDirective
         */
        function ClusterLayerDirective(_layerService, _containerRef) {
            var _this = _super.call(this, _layerService, _containerRef) || this;
            _this._clusteringEnabled = true;
            _this._clusterPlacementMode = ClusterPlacementMode.MeanValue;
            _this._clusterClickAction = ClusterClickAction.ZoomIntoCluster;
            _this._useDynamicSizeMarker = false;
            _this._dynamicMarkerBaseSize = 18;
            _this._dynamicMarkerRanges = new Map([
                [10, 'rgba(20, 180, 20, 0.5)'],
                [100, 'rgba(255, 210, 40, 0.5)'],
                [Number.MAX_SAFE_INTEGER, 'rgba(255, 40, 40, 0.5)']
            ]);
            _this._zoomOnClick = true;
            return _this;
        }
        Object.defineProperty(ClusterLayerDirective.prototype, "ClusterClickAction", {
            ///
            /// Property defintions
            ///
            /**
             * Gets or sets the the Cluster Click Action {@link ClusterClickAction}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the the Cluster Click Action {\@link ClusterClickAction}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._clusterClickAction; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._clusterClickAction = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ClusteringEnabled", {
            /**
             * Gets or sets whether the clustering layer enables clustering. When set to false, the layer
             * behaves like a generic layer. This is handy if you want to prevent clustering at certain zoom levels.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets whether the clustering layer enables clustering. When set to false, the layer
             * behaves like a generic layer. This is handy if you want to prevent clustering at certain zoom levels.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._clusteringEnabled; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._clusteringEnabled = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ClusterPlacementMode", {
            /**
             * Gets or sets the cluster placement mode. {@link ClusterPlacementMode}
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the cluster placement mode. {\@link ClusterPlacementMode}
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._clusterPlacementMode; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._clusterPlacementMode = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "CustomMarkerCallback", {
            /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {\@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._iconCreationCallback; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._useDynamicSizeMarker) {
                    throw (new Error("You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\n                    Set UseDynamicSizeMakers to false."));
                }
                this._iconCreationCallback = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "DynamicMarkerBaseSize", {
            /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerBaseSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerBaseSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "DynamicMarkerRanges", {
            /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerRanges; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerRanges = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "GridSize", {
            /**
             * Gets or sets the grid size to be used for clustering.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the grid size to be used for clustering.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._gridSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._gridSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "IconInfo", {
            /**
             * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.
             * See {@link IMarkerIconInfo}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.
             * See {\@link IMarkerIconInfo}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._iconInfo; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._iconInfo = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "LayerOffset", {
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._layerOffset; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._layerOffset = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "MinimumClusterSize", {
            /**
             * Gets or sets the minimum pins required to form a cluster
             *
             * @readonly
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the minimum pins required to form a cluster
             *
             * \@readonly
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._minimumClusterSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._minimumClusterSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "SpiderClusterOptions", {
            /**
             * Gets or sets the options for spider clustering behavior. See {@link ISpiderClusterOptions}
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the options for spider clustering behavior. See {\@link ISpiderClusterOptions}
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._spiderClusterOptions; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._spiderClusterOptions = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "Styles", {
            /**
             * Gets or sets the cluster styles
             *
             * @readonly
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the cluster styles
             *
             * \@readonly
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._styles; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._styles = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "UseDynamicSizeMarkers", {
            /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._useDynamicSizeMarker; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                var _this = this;
                this._useDynamicSizeMarker = val;
                if (val) {
                    this._iconCreationCallback = function (m, info) {
                        return ClusterLayerDirective.CreateDynamicSizeMarker(m.length, info, _this._dynamicMarkerBaseSize, _this._dynamicMarkerRanges);
                    };
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ZIndex", {
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._zIndex; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._zIndex = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ZoomOnClick", {
            /**
             * Gets or sets whether the cluster should zoom in on click
             *
             * @readonly
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets whether the cluster should zoom in on click
             *
             * \@readonly
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._zoomOnClick; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._zoomOnClick = val; },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates the dynamic size marker to be used for cluster markers if UseDynamicSizeMarkers is set to true.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} size - The number of markers in the cluster.
         * @param {?} info  - The icon info to be used. This will be hydrated with
         * the actualy dimensions of the created markers and is used by the underlying model/services
         * to correctly offset the marker for correct positioning.
         * @param {?} baseMarkerSize - The base size for dynmic markers.
         * @param {?} ranges - The ranges to use to calculate breakpoints and colors for dynamic markers.
         * The map contains key/value pairs, with the keys being
         * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range.
         * @return {?} - An string containing the SVG for the marker.
         *
         */
        ClusterLayerDirective.CreateDynamicSizeMarker = /**
         * Creates the dynamic size marker to be used for cluster markers if UseDynamicSizeMarkers is set to true.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} size - The number of markers in the cluster.
         * @param {?} info  - The icon info to be used. This will be hydrated with
         * the actualy dimensions of the created markers and is used by the underlying model/services
         * to correctly offset the marker for correct positioning.
         * @param {?} baseMarkerSize - The base size for dynmic markers.
         * @param {?} ranges - The ranges to use to calculate breakpoints and colors for dynamic markers.
         * The map contains key/value pairs, with the keys being
         * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range.
         * @return {?} - An string containing the SVG for the marker.
         *
         */
            function (size, info, baseMarkerSize, ranges) {
                var /** @type {?} */ mr = baseMarkerSize;
                var /** @type {?} */ outline = mr * 0.35;
                var /** @type {?} */ total = size;
                var /** @type {?} */ r = Math.log(total) / Math.log(10) * 5 + mr;
                var /** @type {?} */ d = r * 2;
                var /** @type {?} */ fillColor;
                ranges.forEach(function (v, k) {
                    if (total <= k && !fillColor) {
                        fillColor = v;
                    }
                });
                if (!fillColor) {
                    fillColor = 'rgba(20, 180, 20, 0.5)';
                }
                // Create an SVG string of two circles, one on top of the other, with the specified radius and color.
                var /** @type {?} */ svg = ["<svg xmlns='http://www.w3.org/2000/svg' width='" + d + "' height='" + d + "'>",
                    "<circle cx='" + r + "' cy='" + r + "' r='" + r + "' fill='" + fillColor + "'/>",
                    "<circle cx='" + r + "' cy='" + r + "' r='" + (r - outline) + "' fill='" + fillColor + "'/>",
                    "</svg>"];
                info.size = { width: d, height: d };
                info.markerOffsetRatio = { x: 0.5, y: 0.5 };
                info.textOffset = { x: 0, y: r - 8 };
                return svg.join('');
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
        ClusterLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToManager) {
                    return;
                }
                if (changes['ClusterClickAction']) {
                    throw (new Error('You cannot change the ClusterClickAction after the layer has been added to the layerservice.'));
                }
                var /** @type {?} */ options = { id: this._id };
                if (changes['ClusteringEnabled']) {
                    options.clusteringEnabled = this._clusteringEnabled;
                }
                if (changes['GridSize']) {
                    options.gridSize = this._gridSize;
                }
                if (changes['LayerOffset']) {
                    options.layerOffset = this._layerOffset;
                }
                if (changes['SpiderClusterOptions']) {
                    options.spiderClusterOptions = this._spiderClusterOptions;
                }
                if (changes['ZIndex']) {
                    options.zIndex = this._zIndex;
                }
                if (changes['Visible']) {
                    options.visible = this._visible;
                }
                this._layerService.GetNativeLayer(this).then(function (l) {
                    l.SetOptions(options);
                });
            };
        ClusterLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-cluster-layer'
                    },] },
        ];
        /** @nocollapse */
        ClusterLayerDirective.ctorParameters = function () {
            return [
                { type: ClusterService },
                { type: core.ViewContainerRef }
            ];
        };
        ClusterLayerDirective.propDecorators = {
            ClusterClickAction: [{ type: core.Input }],
            ClusteringEnabled: [{ type: core.Input }],
            ClusterPlacementMode: [{ type: core.Input }],
            CustomMarkerCallback: [{ type: core.Input }],
            DynamicMarkerBaseSize: [{ type: core.Input }],
            DynamicMarkerRanges: [{ type: core.Input }],
            GridSize: [{ type: core.Input }],
            IconInfo: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            MinimumClusterSize: [{ type: core.Input }],
            SpiderClusterOptions: [{ type: core.Input }],
            Styles: [{ type: core.Input }],
            UseDynamicSizeMarkers: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            ZoomOnClick: [{ type: core.Input }]
        };
        return ClusterLayerDirective;
    }(MapLayerDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ polygonId = 0;
    /**
     *
     * MapPolygonDirective renders a polygon inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapPolygonDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map,
     *  styles: [`
     *   .map-container { height: 300px; }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polygon [Paths]="path"></x-map-polygon>
     *   </x-map>
     * `
     * })
     * ```
     *
     *
     * @export
     */
    var MapPolygonDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolygonDirective.
         * @param _polygonManager
         *
         * @memberof MapPolygonDirective
         */
        function MapPolygonDirective(_polygonService, _containerRef) {
            this._polygonService = _polygonService;
            this._containerRef = _containerRef;
            this._inCustomLayer = false;
            this._addedToService = false;
            this._events = [];
            /**
             * Gets or sets whether this Polygon handles mouse events.
             *
             * \@memberof MapPolygonDirective
             */
            this.Clickable = true;
            /**
             * If set to true, the user can drag this shape over the map.
             *
             * \@memberof MapPolygonDirective
             */
            this.Draggable = false;
            /**
             * If set to true, the user can edit this shape by dragging the control
             * points shown at the vertices and on each segment.
             *
             * \@memberof MapPolygonDirective
             */
            this.Editable = false;
            /**
             * When true, edges of the polygon are interpreted as geodesic and will
             * follow the curvature of the Earth. When false, edges of the polygon are
             * rendered as straight lines in screen space. Note that the shape of a
             * geodesic polygon may appear to change when dragged, as the dimensions
             * are maintained relative to the surface of the earth. Defaults to false.
             *
             * \@memberof MapPolygonDirective
             */
            this.Geodesic = false;
            /**
             * Arbitary metadata to assign to the Polygon. This is useful for events
             *
             * \@memberof MapPolygonDirective
             */
            this.Metadata = new Map();
            /**
             * The ordered sequence of coordinates that designates a closed loop.
             * Unlike polylines, a polygon may consist of one or more paths.
             * As a result, the paths property may specify one or more arrays of
             * LatLng coordinates. Paths are closed automatically; do not repeat the
             * first vertex of the path as the last vertex. Simple polygons may be
             * defined using a single array of LatLngs. More complex polygons may
             * specify an array of arrays (for inner loops ). Any simple arrays are converted into Arrays.
             * Inserting or removing LatLngs from the Array will automatically update
             * the polygon on the map.
             *
             * \@memberof MapPolygonDirective
             */
            this.Paths = [];
            /**
             * Whether to show the title of the polygon as the tooltip on the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.ShowTooltip = true;
            /**
             * This event is fired when the DOM click event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.Click = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.DblClick = new core.EventEmitter();
            /**
             * This event is repeatedly fired while the user drags the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.Drag = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.DragEnd = new core.EventEmitter();
            /**
             * This event is fired when the user starts dragging the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.DragStart = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousedown event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseDown = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseMove = new core.EventEmitter();
            /**
             * This event is fired on Polygon mouseout.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseOut = new core.EventEmitter();
            /**
             * This event is fired on Polygon mouseover.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseOver = new core.EventEmitter();
            /**
             * This event is fired whe the DOM mouseup event is fired on the Polygon
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseUp = new core.EventEmitter();
            /**
             * This event is fired when the Polygon is right-clicked on.
             *
             * \@memberof MapPolygonDirective
             */
            this.RightClick = new core.EventEmitter();
            /**
             * This event is fired when editing has completed.
             *
             * \@memberof MapPolygonDirective
             */
            this.PathChanged = new core.EventEmitter();
            this._id = polygonId++;
        }
        Object.defineProperty(MapPolygonDirective.prototype, "AddedToService", {
            get: /**
             * Gets whether the polygon has been registered with the service.
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._addedToService; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "Id", {
            get: /**
             * Get the id of the polygon.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "IdAsString", {
            get: /**
             * Gets the id of the polygon as a string.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._id.toString(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "InCustomLayer", {
            get: /**
             * Gets whether the polygon is in a custom layer. See {\@link MapLayer}.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._inCustomLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "LayerId", {
            get: /**
             * gets the id of the Layer the polygon belongs to.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._layerId; },
            enumerable: true,
            configurable: true
        });
        ///
        /// Public methods
        ///
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * @memberof MapPolygonDirective
         */
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
        MapPolygonDirective.prototype.ngAfterContentInit = /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
            function () {
                if (this._containerRef.element.nativeElement.parentElement) {
                    var /** @type {?} */ parentName = this._containerRef.element.nativeElement.parentElement.tagName;
                    if (parentName.toLowerCase() === 'x-map-layer') {
                        this._inCustomLayer = true;
                        this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);
                    }
                }
                if (!this._addedToService) {
                    this._polygonService.AddPolygon(this);
                    this._addedToService = true;
                    this.AddEventListeners();
                }
                return;
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * @param changes - Changes that have occured.
         *
         * @memberof MapPolygonDirective
         */
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapPolygonDirective.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToService) {
                    return;
                }
                var /** @type {?} */ o = this.GeneratePolygonChangeSet(changes);
                if (o != null) {
                    this._polygonService.SetOptions(this, o);
                }
                if (changes['Paths'] && !changes['Paths'].isFirstChange()) {
                    this._polygonService.UpdatePolygon(this);
                }
            };
        /**
         * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * @memberof MapPolygonDirective
         */
        /**
         * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
        MapPolygonDirective.prototype.ngOnDestroy = /**
         * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
            function () {
                this._polygonService.DeletePolygon(this);
                this._events.forEach(function (s) { return s.unsubscribe(); });
            };
        /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
        MapPolygonDirective.prototype.AddEventListeners = /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ _getEventArg = function (e) {
                    return {
                        Polygon: _this,
                        Click: e
                    };
                };
                this._events.push(this._polygonService.CreateEventObservable('click', this).subscribe(function (ev) {
                    if (_this._infoBox != null) {
                        _this._infoBox.Open(_this._polygonService.GetCoordinatesFromClick(ev));
                    }
                    _this.Click.emit(_getEventArg(ev));
                }));
                var /** @type {?} */ handlers = [
                    { name: 'dblclick', handler: function (ev) { return _this.DblClick.emit(_getEventArg(ev)); } },
                    { name: 'drag', handler: function (ev) { return _this.Drag.emit(_getEventArg(ev)); } },
                    { name: 'dragend', handler: function (ev) { return _this.DragEnd.emit(_getEventArg(ev)); } },
                    { name: 'dragstart', handler: function (ev) { return _this.DragStart.emit(_getEventArg(ev)); } },
                    { name: 'mousedown', handler: function (ev) { return _this.MouseDown.emit(_getEventArg(ev)); } },
                    { name: 'mousemove', handler: function (ev) { return _this.MouseMove.emit(_getEventArg(ev)); } },
                    { name: 'mouseout', handler: function (ev) { return _this.MouseOut.emit(_getEventArg(ev)); } },
                    { name: 'mouseover', handler: function (ev) { return _this.MouseOver.emit(_getEventArg(ev)); } },
                    { name: 'mouseup', handler: function (ev) { return _this.MouseUp.emit(_getEventArg(ev)); } },
                    { name: 'rightclick', handler: function (ev) { return _this.RightClick.emit(_getEventArg(ev)); } },
                    { name: 'pathchanged', handler: function (ev) { return _this.PathChanged.emit(ev); } }
                ];
                handlers.forEach(function (obj) {
                    var /** @type {?} */ os = _this._polygonService.CreateEventObservable(obj.name, _this).subscribe(obj.handler);
                    _this._events.push(os);
                });
            };
        /**
         * Generates IPolygon option changeset from directive settings.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolygonOptions} containing the polygon options.
         *
         */
        MapPolygonDirective.prototype.GeneratePolygonChangeSet = /**
         * Generates IPolygon option changeset from directive settings.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolygonOptions} containing the polygon options.
         *
         */
            function (changes) {
                var /** @type {?} */ options = { id: this._id };
                var /** @type {?} */ hasOptions = false;
                if (changes['Clickable']) {
                    options.clickable = this.Clickable;
                    hasOptions = true;
                }
                if (changes['Draggable']) {
                    options.draggable = this.Draggable;
                    hasOptions = true;
                }
                if (changes['Editable']) {
                    options.editable = this.Editable;
                    hasOptions = true;
                }
                if (changes['FillColor'] || changes['FillOpacity']) {
                    options.fillColor = this.FillColor;
                    options.fillOpacity = this.FillOpacity;
                    hasOptions = true;
                }
                if (changes['Geodesic']) {
                    options.geodesic = this.Geodesic;
                    hasOptions = true;
                }
                if (changes['LabelMaxZoom']) {
                    options.labelMaxZoom = this.LabelMaxZoom;
                    hasOptions = true;
                }
                if (changes['LabelMinZoom']) {
                    options.labelMinZoom = this.LabelMinZoom;
                    hasOptions = true;
                }
                if (changes['ShowTooltip']) {
                    options.showTooltip = this.ShowTooltip;
                    hasOptions = true;
                }
                if (changes['ShowLabel']) {
                    options.showLabel = this.ShowLabel;
                    hasOptions = true;
                }
                if (changes['StrokeColor'] || changes['StrokeOpacity']) {
                    options.strokeColor = this.StrokeColor;
                    options.strokeOpacity = this.StrokeOpacity;
                    hasOptions = true;
                }
                if (changes['StrokeWeight']) {
                    options.strokeWeight = this.StrokeWeight;
                    hasOptions = true;
                }
                if (changes['Title']) {
                    options.title = this.Title;
                    hasOptions = true;
                }
                if (changes['Visible']) {
                    options.visible = this.Visible;
                    hasOptions = true;
                }
                if (changes['zIndex']) {
                    options.zIndex = this.zIndex;
                    hasOptions = true;
                }
                return hasOptions ? options : null;
            };
        MapPolygonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polygon'
                    },] },
        ];
        /** @nocollapse */
        MapPolygonDirective.ctorParameters = function () {
            return [
                { type: PolygonService },
                { type: core.ViewContainerRef }
            ];
        };
        MapPolygonDirective.propDecorators = {
            _infoBox: [{ type: core.ContentChild, args: [InfoBoxComponent,] }],
            Clickable: [{ type: core.Input }],
            Draggable: [{ type: core.Input }],
            Editable: [{ type: core.Input }],
            FillColor: [{ type: core.Input }],
            FillOpacity: [{ type: core.Input }],
            Geodesic: [{ type: core.Input }],
            LabelMaxZoom: [{ type: core.Input }],
            LabelMinZoom: [{ type: core.Input }],
            Metadata: [{ type: core.Input }],
            Paths: [{ type: core.Input }],
            ShowLabel: [{ type: core.Input }],
            ShowTooltip: [{ type: core.Input }],
            StrokeColor: [{ type: core.Input }],
            StrokeOpacity: [{ type: core.Input }],
            StrokeWeight: [{ type: core.Input }],
            Title: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            zIndex: [{ type: core.Input }],
            Click: [{ type: core.Output }],
            DblClick: [{ type: core.Output }],
            Drag: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }],
            DragStart: [{ type: core.Output }],
            MouseDown: [{ type: core.Output }],
            MouseMove: [{ type: core.Output }],
            MouseOut: [{ type: core.Output }],
            MouseOver: [{ type: core.Output }],
            MouseUp: [{ type: core.Output }],
            RightClick: [{ type: core.Output }],
            PathChanged: [{ type: core.Output }]
        };
        return MapPolygonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ polylineId = 0;
    /**
     *
     * MapPolylineDirective renders a polyline inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapPolylineDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map,
     *  styles: [`
     *   .map-container { height: 300px; }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polyline [Paths]="path"></x-map-polyline>
     *   </x-map>
     * `
     * })
     * ```
     *
     *
     * @export
     */
    var MapPolylineDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolylineDirective.
         * @param _polylineManager
         *
         * @memberof MapPolylineDirective
         */
        function MapPolylineDirective(_polylineService, _containerRef) {
            this._polylineService = _polylineService;
            this._containerRef = _containerRef;
            this._inCustomLayer = false;
            this._addedToService = false;
            this._events = [];
            /**
             * Gets or sets whether this Polyline handles mouse events.
             *
             * \@memberof MapPolylineDirective
             */
            this.Clickable = true;
            /**
             * If set to true, the user can drag this shape over the map.
             *
             * \@memberof MapPolylineDirective
             */
            this.Draggable = false;
            /**
             * If set to true, the user can edit this shape by dragging the control
             * points shown at the vertices and on each segment.
             *
             * \@memberof MapPolylineDirective
             */
            this.Editable = false;
            /**
             * When true, edges of the polyline are interpreted as geodesic and will
             * follow the curvature of the Earth. When false, edges of the polyline are
             * rendered as straight lines in screen space. Note that the shape of a
             * geodesic polyline may appear to change when dragged, as the dimensions
             * are maintained relative to the surface of the earth. Defaults to false.
             *
             * \@memberof MapPolylineDirective
             */
            this.Geodesic = false;
            /**
             * Arbitary metadata to assign to the Polyline. This is useful for events
             *
             * \@memberof MapPolylineDirective
             */
            this.Metadata = new Map();
            /**
             * The ordered sequence of coordinates that designates a polyline.
             * Simple polylines may be defined using a single array of LatLngs. More
             * complex polylines may specify an array of arrays.
             *
             * \@memberof MapPolylineDirective
             */
            this.Path = [];
            /**
             * Whether to show the title of the polyline as the tooltip on the polygon.
             *
             * \@memberof MapPolylineDirective
             */
            this.ShowTooltip = true;
            /**
             * This event is fired when the DOM click event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.Click = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.DblClick = new core.EventEmitter();
            /**
             * This event is repeatedly fired while the user drags the polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.Drag = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging the polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.DragEnd = new core.EventEmitter();
            /**
             * This event is fired when the user starts dragging the polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.DragStart = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousedown event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseDown = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseMove = new core.EventEmitter();
            /**
             * This event is fired on Polyline mouseout.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseOut = new core.EventEmitter();
            /**
             * This event is fired on Polyline mouseover.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseOver = new core.EventEmitter();
            /**
             * This event is fired whe the DOM mouseup event is fired on the Polyline
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseUp = new core.EventEmitter();
            /**
             * This even is fired when the Polyline is right-clicked on.
             *
             * \@memberof MapPolylineDirective
             */
            this.RightClick = new core.EventEmitter();
            this._id = polylineId++;
        }
        Object.defineProperty(MapPolylineDirective.prototype, "AddedToService", {
            get: /**
             * Gets whether the polyline has been registered with the service.
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._addedToService; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "Id", {
            get: /**
             * Get the id of the polyline.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "IdAsString", {
            get: /**
             * Gets the id of the polyline as a string.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._id.toString(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "InCustomLayer", {
            get: /**
             * Gets whether the polyline is in a custom layer. See {\@link MapLayer}.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._inCustomLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "LayerId", {
            get: /**
             * gets the id of the Layer the polyline belongs to.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._layerId; },
            enumerable: true,
            configurable: true
        });
        ///
        /// Public methods
        ///
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * @memberof MapPolylineDirective
         */
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
        MapPolylineDirective.prototype.ngAfterContentInit = /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
            function () {
                if (this._containerRef.element.nativeElement.parentElement) {
                    var /** @type {?} */ parentName = this._containerRef.element.nativeElement.parentElement.tagName;
                    if (parentName.toLowerCase() === 'x-map-layer') {
                        this._inCustomLayer = true;
                        this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);
                    }
                }
                if (!this._addedToService) {
                    this._polylineService.AddPolyline(this);
                    this._addedToService = true;
                    this.AddEventListeners();
                }
                return;
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * @param changes - Changes that have occured.
         *
         * @memberof MapPolylineDirective
         */
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapPolylineDirective.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToService) {
                    return;
                }
                var /** @type {?} */ o = this.GeneratePolylineChangeSet(changes);
                if (o != null) {
                    this._polylineService.SetOptions(this, o);
                }
                if (changes['Path'] && !changes['Path'].isFirstChange()) {
                    this._polylineService.UpdatePolyline(this);
                }
            };
        /**
         * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * @memberof MapPolylineDirective
         */
        /**
         * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
        MapPolylineDirective.prototype.ngOnDestroy = /**
         * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
            function () {
                this._polylineService.DeletePolyline(this);
                this._events.forEach(function (s) { return s.unsubscribe(); });
            };
        /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
        MapPolylineDirective.prototype.AddEventListeners = /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ _getEventArg = function (e) {
                    return {
                        Polyline: _this,
                        Click: e
                    };
                };
                this._polylineService.CreateEventObservable('click', this).subscribe(function (ev) {
                    if (_this._infoBox != null) {
                        _this._infoBox.Open(_this._polylineService.GetCoordinatesFromClick(ev));
                    }
                    _this.Click.emit(_getEventArg(ev));
                });
                var /** @type {?} */ handlers = [
                    { name: 'dblclick', handler: function (ev) { return _this.DblClick.emit(_getEventArg(ev)); } },
                    { name: 'drag', handler: function (ev) { return _this.Drag.emit(_getEventArg(ev)); } },
                    { name: 'dragend', handler: function (ev) { return _this.DragEnd.emit(_getEventArg(ev)); } },
                    { name: 'dragstart', handler: function (ev) { return _this.DragStart.emit(_getEventArg(ev)); } },
                    { name: 'mousedown', handler: function (ev) { return _this.MouseDown.emit(_getEventArg(ev)); } },
                    { name: 'mousemove', handler: function (ev) { return _this.MouseMove.emit(_getEventArg(ev)); } },
                    { name: 'mouseout', handler: function (ev) { return _this.MouseOut.emit(_getEventArg(ev)); } },
                    { name: 'mouseover', handler: function (ev) { return _this.MouseOver.emit(_getEventArg(ev)); } },
                    { name: 'mouseup', handler: function (ev) { return _this.MouseUp.emit(_getEventArg(ev)); } },
                    { name: 'rightclick', handler: function (ev) { return _this.RightClick.emit(_getEventArg(ev)); } },
                ];
                handlers.forEach(function (obj) {
                    var /** @type {?} */ os = _this._polylineService.CreateEventObservable(obj.name, _this).subscribe(obj.handler);
                    _this._events.push(os);
                });
            };
        /**
         * Generates IPolyline option changeset from directive settings.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolylineOptions} containing the polyline options.
         *
         */
        MapPolylineDirective.prototype.GeneratePolylineChangeSet = /**
         * Generates IPolyline option changeset from directive settings.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolylineOptions} containing the polyline options.
         *
         */
            function (changes) {
                var /** @type {?} */ options = { id: this._id };
                var /** @type {?} */ hasOptions = false;
                if (changes['Clickable']) {
                    options.clickable = this.Clickable;
                    hasOptions = true;
                }
                if (changes['Draggable']) {
                    options.draggable = this.Draggable;
                    hasOptions = true;
                }
                if (changes['Editable']) {
                    options.editable = this.Editable;
                    hasOptions = true;
                }
                if (changes['Geodesic']) {
                    options.geodesic = this.Geodesic;
                    hasOptions = true;
                }
                if (changes['ShowTooltip']) {
                    options.showTooltip = this.ShowTooltip;
                    hasOptions = true;
                }
                if (changes['StrokeColor']) {
                    options.strokeColor = this.StrokeColor;
                    hasOptions = true;
                }
                if (changes['StrokeOpacity']) {
                    options.strokeOpacity = this.StrokeOpacity;
                    hasOptions = true;
                }
                if (changes['StrokeWeight']) {
                    options.strokeWeight = this.StrokeWeight;
                    hasOptions = true;
                }
                if (changes['Title']) {
                    options.title = this.Title;
                    hasOptions = true;
                }
                if (changes['Visible']) {
                    options.visible = this.Visible;
                    hasOptions = true;
                }
                if (changes['zIndex']) {
                    options.zIndex = this.zIndex;
                    hasOptions = true;
                }
                return hasOptions ? options : null;
            };
        MapPolylineDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polyline'
                    },] },
        ];
        /** @nocollapse */
        MapPolylineDirective.ctorParameters = function () {
            return [
                { type: PolylineService },
                { type: core.ViewContainerRef }
            ];
        };
        MapPolylineDirective.propDecorators = {
            _infoBox: [{ type: core.ContentChild, args: [InfoBoxComponent,] }],
            Clickable: [{ type: core.Input }],
            Draggable: [{ type: core.Input }],
            Editable: [{ type: core.Input }],
            Geodesic: [{ type: core.Input }],
            Metadata: [{ type: core.Input }],
            Path: [{ type: core.Input }],
            ShowTooltip: [{ type: core.Input }],
            StrokeColor: [{ type: core.Input }],
            StrokeOpacity: [{ type: core.Input }],
            StrokeWeight: [{ type: core.Input }],
            Title: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            zIndex: [{ type: core.Input }],
            Click: [{ type: core.Output }],
            DblClick: [{ type: core.Output }],
            Drag: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }],
            DragStart: [{ type: core.Output }],
            MouseDown: [{ type: core.Output }],
            MouseMove: [{ type: core.Output }],
            MouseOut: [{ type: core.Output }],
            MouseOver: [{ type: core.Output }],
            MouseUp: [{ type: core.Output }],
            RightClick: [{ type: core.Output }]
        };
        return MapPolylineDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for marker.
     */
    var /** @type {?} */ layerId$1 = 1000000;
    /**
     * MapMarkerLayerDirective performantly renders a large set of map marker inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker-layer [MarkerOptions]="_markers"></x-map-marker-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapMarkerLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapMarkerLayerDirective.
         * @param _markerService - Concreate implementation of a {@link MarkerService}.
         * @param _layerService - Concreate implementation of a {@link LayerService}.
         * @param _clusterService - Concreate implementation of a {@link ClusterService}.
         * @param _mapService - Concreate implementation of a {@link MapService}.
         * @param _zone - Concreate implementation of a {@link NgZone} service.
         *
         * @memberof MapMarkerLayerDirective
         */
        function MapMarkerLayerDirective(_markerService, _layerService, _clusterService, _mapService, _zone) {
            this._markerService = _markerService;
            this._layerService = _layerService;
            this._clusterService = _clusterService;
            this._mapService = _mapService;
            this._zone = _zone;
            this._useDynamicSizeMarker = false;
            this._dynamicMarkerBaseSize = 18;
            this._dynamicMarkerRanges = new Map([
                [10, 'rgba(20, 180, 20, 0.5)'],
                [100, 'rgba(255, 210, 40, 0.5)'],
                [Number.MAX_SAFE_INTEGER, 'rgba(255, 40, 40, 0.5)']
            ]);
            this._streaming = false;
            this._markers = new Array();
            this._markersLast = new Array();
            /**
             * Gets or sets the the Cluster Click Action {\@link ClusterClickAction}.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.ClusterClickAction = ClusterClickAction.ZoomIntoCluster;
            /**
             * Gets or sets the cluster placement mode. {\@link ClusterPlacementMode}
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.ClusterPlacementMode = ClusterPlacementMode.MeanValue;
            /**
             * Determines whether the layer clusters. This property can only be set on creation of the layer.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.EnableClustering = false;
            /**
             * Gets or sets the grid size to be used for clustering.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.GridSize = 150;
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.LayerOffset = null;
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.ZIndex = 0;
            /**
             * Gets or sets whether the cluster should zoom in on click
             *
             * \@readonly
             * \@memberof MapMarkerLayerDirective
             */
            this.ZoomOnClick = true;
            /**
             * This event emitter gets emitted when the dynamic icon for a marker is being created.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.DynamicMarkerCreated = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user clicks a marker in the layer.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.MarkerClick = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging a marker.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.DragEnd = new core.EventEmitter();
            this._id = layerId$1++;
        }
        Object.defineProperty(MapMarkerLayerDirective.prototype, "CustomMarkerCallback", {
            /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {\@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._iconCreationCallback; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._useDynamicSizeMarker) {
                    throw (new Error("You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\n                    Set UseDynamicSizeMakers to false."));
                }
                this._iconCreationCallback = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "DynamicMarkerBaseSize", {
            /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerBaseSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerBaseSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "DynamicMarkerRanges", {
            /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerRanges; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerRanges = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "MarkerOptions", {
            /**
             *  IMarkerOptions array holding the marker info.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             *  IMarkerOptions array holding the marker info.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._markers; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._streaming) {
                    (_a = this._markersLast).push.apply(_a, __spread(val.slice(0)));
                    (_b = this._markers).push.apply(_b, __spread(val));
                }
                else {
                    this._markers = val.slice(0);
                }
                var _a, _b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "Styles", {
            /**
             * Gets or sets the cluster styles
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Gets or sets the cluster styles
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._styles; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._styles = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "TreatNewMarkerOptionsAsStream", {
            /**
             * Sets whether to treat changes in the MarkerOptions as streams of new markers. In thsi mode, changing the
             * Array supplied in MarkerOptions will be incrementally drawn on the map as opposed to replace the markers on the map.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Sets whether to treat changes in the MarkerOptions as streams of new markers. In thsi mode, changing the
             * Array supplied in MarkerOptions will be incrementally drawn on the map as opposed to replace the markers on the map.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._streaming; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._streaming = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "UseDynamicSizeMarkers", {
            /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._useDynamicSizeMarker; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                var _this = this;
                this._useDynamicSizeMarker = val;
                if (val) {
                    this._iconCreationCallback = function (m, info) {
                        return ClusterLayerDirective.CreateDynamicSizeMarker(m.length, info, _this._dynamicMarkerBaseSize, _this._dynamicMarkerRanges);
                    };
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the marker layer.
             *
             * \@readonly
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Translates a geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
        MapMarkerLayerDirective.prototype.LocationToPixel = /**
         * Translates a geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
            function (loc) {
                return this._markerService.LocationToPoint(loc);
            };
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ layerOptions = {
                    id: this._id
                };
                this._zone.runOutsideAngular(function () {
                    var /** @type {?} */ fakeLayerDirective = {
                        Id: _this._id,
                        Visible: _this.Visible
                    };
                    if (!_this.EnableClustering) {
                        _this._layerService.AddLayer(fakeLayerDirective);
                        _this._layerPromise = _this._layerService.GetNativeLayer(fakeLayerDirective);
                        _this._service = _this._layerService;
                    }
                    else {
                        fakeLayerDirective.LayerOffset = _this.LayerOffset;
                        fakeLayerDirective.ZIndex = _this.ZIndex;
                        fakeLayerDirective.ClusteringEnabled = _this.EnableClustering;
                        fakeLayerDirective.ClusterPlacementMode = _this.ClusterPlacementMode;
                        fakeLayerDirective.GridSize = _this.GridSize;
                        fakeLayerDirective.ClusterClickAction = _this.ClusterClickAction;
                        fakeLayerDirective.IconInfo = _this.ClusterIconInfo;
                        fakeLayerDirective.CustomMarkerCallback = _this.CustomMarkerCallback;
                        fakeLayerDirective.UseDynamicSizeMarkers = _this.UseDynamicSizeMarkers;
                        _this._clusterService.AddLayer(fakeLayerDirective);
                        _this._layerPromise = _this._clusterService.GetNativeLayer(fakeLayerDirective);
                        _this._service = _this._clusterService;
                    }
                    _this._layerPromise.then(function (l) {
                        l.SetVisible(_this.Visible);
                        if (_this.MarkerOptions) {
                            _this._zone.runOutsideAngular(function () { return _this.UpdateMarkers(); });
                        }
                    });
                });
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
            function () {
                this._layerPromise.then(function (l) {
                    l.Delete();
                });
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
            function (changes) {
                var _this = this;
                var /** @type {?} */ shouldSetOptions = false;
                var /** @type {?} */ o = {
                    id: this._id
                };
                if (changes['MarkerOptions']) {
                    this._zone.runOutsideAngular(function () {
                        _this.UpdateMarkers();
                    });
                }
                if (changes['Visible'] && !changes['Visible'].firstChange) {
                    this._zone.runOutsideAngular(function () {
                        _this._layerPromise.then(function (l) { return l.SetVisible(_this.Visible); });
                    });
                }
                if (changes['EnableClustering'] && !changes['EnableClustering'].firstChange) {
                    if ('StopClustering' in this._service) {
                        o.clusteringEnabled = this.EnableClustering;
                        shouldSetOptions = true;
                    }
                    else {
                        throw (new Error('You cannot change EnableClustering after the layer has been created.'));
                    }
                }
                if (changes['ClusterPlacementMode'] && !changes['ClusterPlacementMode'].firstChange && 'StopClustering' in this._service) {
                    o.placementMode = this.ClusterPlacementMode;
                    shouldSetOptions = true;
                }
                if (changes['GridSize'] && !changes['GridSize'].firstChange && 'StopClustering' in this._service) {
                    o.gridSize = this.GridSize;
                    shouldSetOptions = true;
                }
                if (changes['ClusterClickAction'] && !changes['ClusterClickAction'].firstChange && 'StopClustering' in this._service) {
                    o.zoomOnClick = this.ClusterClickAction === ClusterClickAction.ZoomIntoCluster;
                    shouldSetOptions = true;
                }
                if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||
                    (changes['LayerOffset'] && !changes['LayerOffset'].firstChange) ||
                    (changes['IconInfo'] && !changes['IconInfo'].firstChange)) {
                    throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));
                }
                if (shouldSetOptions) {
                    this._zone.runOutsideAngular(function () {
                        var /** @type {?} */ fakeLayerDirective = { Id: _this._id };
                        _this._layerPromise.then(function (l) { return l.SetOptions(o); });
                    });
                }
            };
        /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerLayerDirective
         * @return {?} - string representation of the marker id.
         */
        MapMarkerLayerDirective.prototype.toString = /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerLayerDirective
         * @return {?} - string representation of the marker id.
         */
            function () { return 'MapMarkerLayer-' + this._id.toString(); };
        /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} m - the marker for which to add the event.
         *
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} m - the marker for which to add the event.
         *
         * @return {?}
         */
            function (m) {
                var _this = this;
                m.AddListener('click', function (e) {
                    return _this.MarkerClick.emit({
                        Marker: m,
                        Click: e,
                        Location: _this._markerService.GetCoordinatesFromClick(e),
                        Pixels: _this._markerService.GetPixelsFromClick(e)
                    });
                });
                m.AddListener('dragend', function (e) {
                    return _this.DragEnd.emit({
                        Marker: m,
                        Click: e,
                        Location: _this._markerService.GetCoordinatesFromClick(e),
                        Pixels: _this._markerService.GetPixelsFromClick(e)
                    });
                });
            };
        /**
         * Sets or updates the markers based on the marker options. This will place the markers on the map
         * and register the associated events.
         *
         * \@memberof MapMarkerLayerDirective
         * \@method
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.UpdateMarkers = /**
         * Sets or updates the markers based on the marker options. This will place the markers on the map
         * and register the associated events.
         *
         * \@memberof MapMarkerLayerDirective
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._layerPromise == null) {
                    return;
                }
                this._layerPromise.then(function (l) {
                    var /** @type {?} */ markers = _this._streaming ? _this._markersLast.splice(0) : _this._markers;
                    // generate the promise for the markers
                    var /** @type {?} */ mp = _this._service.CreateMarkers(markers, _this.IconInfo);
                    // set markers once promises are fullfilled.
                    mp.then(function (m) {
                        m.forEach(function (marker) {
                            _this.AddEventListeners(marker);
                        });
                        _this._streaming ? l.AddEntities(m) : l.SetEntities(m);
                    });
                });
            };
        MapMarkerLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-marker-layer'
                    },] },
        ];
        /** @nocollapse */
        MapMarkerLayerDirective.ctorParameters = function () {
            return [
                { type: MarkerService },
                { type: LayerService },
                { type: ClusterService },
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapMarkerLayerDirective.propDecorators = {
            ClusterClickAction: [{ type: core.Input }],
            ClusterIconInfo: [{ type: core.Input }],
            ClusterPlacementMode: [{ type: core.Input }],
            CustomMarkerCallback: [{ type: core.Input }],
            DynamicMarkerBaseSize: [{ type: core.Input }],
            DynamicMarkerRanges: [{ type: core.Input }],
            EnableClustering: [{ type: core.Input }],
            GridSize: [{ type: core.Input }],
            IconInfo: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            MarkerOptions: [{ type: core.Input }],
            Styles: [{ type: core.Input }],
            TreatNewMarkerOptionsAsStream: [{ type: core.Input }],
            UseDynamicSizeMarkers: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            ZoomOnClick: [{ type: core.Input }],
            DynamicMarkerCreated: [{ type: core.Output }],
            MarkerClick: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }]
        };
        return MapMarkerLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for polygons.
     */
    var /** @type {?} */ layerId$2 = 1000000;
    /**
     * MapPolygonLayerDirective performantly renders a large set of polygons on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polygon-layer [PolygonOptions]="_polygons"></x-map-polygon-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapPolygonLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolygonLayerDirective.
         * @param _layerService - Concreate implementation of a {@link LayerService}.
         * @param _mapService - Concreate implementation of a {@link MapService}.
         * @param _zone - Concreate implementation of a {@link NgZone} service.
         * @memberof MapPolygonLayerDirective
         */
        function MapPolygonLayerDirective(_layerService, _mapService, _zone) {
            this._layerService = _layerService;
            this._mapService = _mapService;
            this._zone = _zone;
            this._labels = new Array();
            this._tooltipSubscriptions = new Array();
            this._tooltipVisible = false;
            this._defaultOptions = {
                fontSize: 11,
                fontFamily: 'sans-serif',
                strokeWeight: 2,
                strokeColor: '#000000',
                fontColor: '#ffffff'
            };
            this._streaming = false;
            this._polygons = new Array();
            this._polygonsLast = new Array();
            /**
             * Set the maximum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolygonLayerDirective
             */
            this.LabelMaxZoom = Number.MAX_SAFE_INTEGER;
            /**
             * Set the minimum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolygonLayerDirective
             */
            this.LabelMinZoom = -1;
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.LayerOffset = null;
            /**
             * Whether to show the polygon titles as the labels on the polygons.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.ShowLabels = false;
            /**
             * Whether to show the titles of the polygosn as the tooltips on the polygons.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.ShowTooltips = true;
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.ZIndex = 0;
            /**
             * This event emitter gets emitted when the user clicks a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonDblClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonMouseMove = new core.EventEmitter();
            /**
             * This event is fired on mouseout on a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonMouseOut = new core.EventEmitter();
            /**
             * This event is fired on mouseover on a polygon in a layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonMouseOver = new core.EventEmitter();
            this._id = layerId$2++;
        }
        Object.defineProperty(MapPolygonLayerDirective.prototype, "PolygonOptions", {
            /**
             * An array of polygon options representing the polygons in the layer.
             *
             * @memberof MapPolygonLayerDirective
             */
            get: /**
             * An array of polygon options representing the polygons in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             * @return {?}
             */ function () { return this._polygons; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._streaming) {
                    (_a = this._polygonsLast).push.apply(_a, __spread(val.slice(0)));
                    (_b = this._polygons).push.apply(_b, __spread(val));
                }
                else {
                    this._polygons = val.slice(0);
                }
                var _a, _b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonLayerDirective.prototype, "TreatNewPolygonOptionsAsStream", {
            /**
             * Sets whether to treat changes in the PolygonOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolygonOptions will be incrementally drawn on the map as opposed to replace the polygons on the map.
             *
             * @memberof MapPolygonLayerDirective
             */
            get: /**
             * Sets whether to treat changes in the PolygonOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolygonOptions will be incrementally drawn on the map as opposed to replace the polygons on the map.
             *
             * \@memberof MapPolygonLayerDirective
             * @return {?}
             */ function () { return this._streaming; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._streaming = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonLayerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the marker layer.
             *
             * \@readonly
             * \@memberof MapPolygonLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ layerOptions = {
                    id: this._id
                };
                this._zone.runOutsideAngular(function () {
                    var /** @type {?} */ fakeLayerDirective = {
                        Id: _this._id,
                        Visible: _this.Visible,
                        LayerOffset: _this.LayerOffset,
                        ZIndex: _this.ZIndex
                    };
                    _this._layerService.AddLayer(fakeLayerDirective);
                    _this._layerPromise = _this._layerService.GetNativeLayer(fakeLayerDirective);
                    Promise.all([
                        _this._layerPromise,
                        _this._mapService.CreateCanvasOverlay(function (el) { return _this.DrawLabels(el); })
                    ]).then(function (values) {
                        values[0].SetVisible(_this.Visible);
                        _this._canvas = values[1];
                        _this._canvas._canvasReady.then(function (b) {
                            _this._tooltip = _this._canvas.GetToolTipOverlay();
                            _this.ManageTooltip(_this.ShowTooltips);
                        });
                        if (_this.PolygonOptions) {
                            _this._zone.runOutsideAngular(function () { return _this.UpdatePolygons(); });
                        }
                    });
                    _this._service = _this._layerService;
                });
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
            function () {
                this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                this._layerPromise.then(function (l) {
                    l.Delete();
                });
                if (this._canvas) {
                    this._canvas.Delete();
                }
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
            function (changes) {
                var _this = this;
                if (changes['PolygonOptions']) {
                    this._zone.runOutsideAngular(function () {
                        _this.UpdatePolygons();
                    });
                }
                if (changes['Visible'] && !changes['Visible'].firstChange) {
                    this._layerPromise.then(function (l) { return l.SetVisible(_this.Visible); });
                }
                if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||
                    (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)) {
                    throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));
                }
                if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||
                    (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||
                    (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)) {
                    if (this._canvas) {
                        this._canvas.Redraw(true);
                    }
                }
                if (changes['ShowTooltips'] && this._tooltip) {
                    this.ManageTooltip(changes['ShowTooltips'].currentValue);
                }
            };
        /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapPolygonLayerDirective
         * @return {?} - string representation of the marker id.
         */
        MapPolygonLayerDirective.prototype.toString = /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapPolygonLayerDirective
         * @return {?} - string representation of the marker id.
         */
            function () { return 'MapPolygonLayer-' + this._id.toString(); };
        /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} p - the polygon for which to add the event.
         *
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} p - the polygon for which to add the event.
         *
         * @return {?}
         */
            function (p) {
                var _this = this;
                var /** @type {?} */ handlers = [
                    { name: 'click', handler: function (ev) { return _this.PolygonClick.emit({ Polygon: p, Click: ev }); } },
                    { name: 'dblclick', handler: function (ev) { return _this.PolygonDblClick.emit({ Polygon: p, Click: ev }); } },
                    { name: 'mousemove', handler: function (ev) { return _this.PolygonMouseMove.emit({ Polygon: p, Click: ev }); } },
                    { name: 'mouseout', handler: function (ev) { return _this.PolygonMouseOut.emit({ Polygon: p, Click: ev }); } },
                    { name: 'mouseover', handler: function (ev) { return _this.PolygonMouseOver.emit({ Polygon: p, Click: ev }); } }
                ];
                handlers.forEach(function (obj) { return p.AddListener(obj.name, obj.handler); });
            };
        /**
         * Draws the polygon labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.DrawLabels = /**
         * Draws the polygon labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
            function (el) {
                var _this = this;
                if (this.ShowLabels) {
                    this._mapService.GetZoom().then(function (z) {
                        if (_this.LabelMinZoom <= z && _this.LabelMaxZoom >= z) {
                            var /** @type {?} */ ctx_1 = el.getContext('2d');
                            var /** @type {?} */ labels_1 = _this._labels.map(function (x) { return x.title; });
                            _this._mapService.LocationsToPoints(_this._labels.map(function (x) { return x.loc; })).then(function (locs) {
                                var /** @type {?} */ size = _this._mapService.MapSize;
                                for (var /** @type {?} */ i = 0, /** @type {?} */ len = locs.length; i < len; i++) {
                                    // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.
                                    if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {
                                        _this.DrawText(ctx_1, locs[i], labels_1[i]);
                                    }
                                }
                            });
                        }
                    });
                }
            };
        /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.DrawText = /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
            function (ctx, loc, text) {
                var /** @type {?} */ lo = this.LabelOptions;
                if (lo == null && this._tooltip) {
                    lo = this._tooltip.DefaultLabelStyle;
                }
                if (lo == null) {
                    lo = this._defaultOptions;
                }
                ctx.strokeStyle = lo.strokeColor;
                ctx.font = lo.fontSize + "px " + lo.fontFamily;
                ctx.textAlign = 'center';
                var /** @type {?} */ strokeWeight = lo.strokeWeight;
                if (text && strokeWeight && strokeWeight > 0) {
                    ctx.lineWidth = strokeWeight;
                    ctx.strokeText(text, loc.x, loc.y);
                }
                ctx.fillStyle = lo.fontColor;
                ctx.fillText(text, loc.x, loc.y);
            };
        /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ManageTooltip = /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
            function (show) {
                var _this = this;
                if (show && this._canvas) {
                    // add tooltip subscriptions
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                    this._tooltipSubscriptions.push(this.PolygonMouseMove.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            var /** @type {?} */ loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('position', loc);
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolygonMouseOver.asObservable().subscribe(function (e) {
                        if (e.Polygon.Title && e.Polygon.Title.length > 0) {
                            var /** @type {?} */ loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('text', e.Polygon.Title);
                            _this._tooltip.Set('position', loc);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolygonMouseOut.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            _this._tooltip.Set('hidden', true);
                            _this._tooltipVisible = false;
                        }
                    }));
                }
                else {
                    // remove tooltip subscriptions
                    this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                    this._tooltipSubscriptions.splice(0);
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                }
            };
        /**
         * Sets or updates the polygons based on the polygon options. This will place the polygons on the map
         * and register the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * \@method
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.UpdatePolygons = /**
         * Sets or updates the polygons based on the polygon options. This will place the polygons on the map
         * and register the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._layerPromise == null) {
                    return;
                }
                this._layerPromise.then(function (l) {
                    var /** @type {?} */ polygons = _this._streaming ? _this._polygonsLast.splice(0) : _this._polygons;
                    if (!_this._streaming) {
                        _this._labels.splice(0);
                    }
                    // generate the promise for the markers
                    var /** @type {?} */ lp = _this._service.CreatePolygons(l.GetOptions().id, polygons);
                    // set markers once promises are fullfilled.
                    lp.then(function (p) {
                        p.forEach(function (poly) {
                            if (poly.Title != null && poly.Title.length > 0) {
                                _this._labels.push({ loc: poly.Centroid, title: poly.Title });
                            }
                            _this.AddEventListeners(poly);
                        });
                        _this._streaming ? l.AddEntities(p) : l.SetEntities(p);
                        if (_this._canvas) {
                            _this._canvas.Redraw(!_this._streaming);
                        }
                    });
                });
            };
        MapPolygonLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polygon-layer'
                    },] },
        ];
        /** @nocollapse */
        MapPolygonLayerDirective.ctorParameters = function () {
            return [
                { type: LayerService },
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapPolygonLayerDirective.propDecorators = {
            LabelMaxZoom: [{ type: core.Input }],
            LabelMinZoom: [{ type: core.Input }],
            LabelOptions: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            PolygonOptions: [{ type: core.Input }],
            ShowLabels: [{ type: core.Input }],
            ShowTooltips: [{ type: core.Input }],
            TreatNewPolygonOptionsAsStream: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            PolygonClick: [{ type: core.Output }],
            PolygonDblClick: [{ type: core.Output }],
            PolygonMouseMove: [{ type: core.Output }],
            PolygonMouseOut: [{ type: core.Output }],
            PolygonMouseOver: [{ type: core.Output }]
        };
        return MapPolygonLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for polylines.
     */
    var /** @type {?} */ layerId$3 = 1000000;
    /**
     * MapPolylineLayerDirective performantly renders a large set of polyline on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polyline-layer [PolygonOptions]="_polyline"></x-map-polyline-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapPolylineLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolylineLayerDirective.
         * @param _layerService - Concreate implementation of a {@link LayerService}.
         * @param _mapService - Concreate implementation of a {@link MapService}.
         * @param _zone - Concreate implementation of a {@link NgZone} service.
         * @memberof MapPolylineLayerDirective
         */
        function MapPolylineLayerDirective(_layerService, _mapService, _zone) {
            this._layerService = _layerService;
            this._mapService = _mapService;
            this._zone = _zone;
            this._labels = new Array();
            this._tooltipSubscriptions = new Array();
            this._tooltipVisible = false;
            this._defaultOptions = {
                fontSize: 11,
                fontFamily: 'sans-serif',
                strokeWeight: 2,
                strokeColor: '#000000',
                fontColor: '#ffffff'
            };
            this._streaming = false;
            this._polylines = new Array();
            this._polylinesLast = new Array();
            /**
             * Set the maximum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolylineLayerDirective
             */
            this.LabelMaxZoom = Number.MAX_SAFE_INTEGER;
            /**
             * Set the minimum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolylineLayerDirective
             */
            this.LabelMinZoom = -1;
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.LayerOffset = null;
            /**
             * Whether to show the polylines titles as the labels on the polylines.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.ShowLabels = false;
            /**
             * Whether to show the titles of the polylines as the tooltips on the polylines.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.ShowTooltips = true;
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.ZIndex = 0;
            /**
             * This event emitter gets emitted when the user clicks a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineDblClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineMouseMove = new core.EventEmitter();
            /**
             * This event is fired on mouseout on a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineMouseOut = new core.EventEmitter();
            /**
             * This event is fired on mouseover on a polyline in a layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineMouseOver = new core.EventEmitter();
            this._id = layerId$3++;
        }
        Object.defineProperty(MapPolylineLayerDirective.prototype, "PolylineOptions", {
            /**
             * An array of polyline options representing the polylines in the layer.
             *
             * @memberof MapPolylineLayerDirective
             */
            get: /**
             * An array of polyline options representing the polylines in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             * @return {?}
             */ function () { return this._polylines; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._streaming) {
                    (_a = this._polylinesLast).push.apply(_a, __spread(val.slice(0)));
                    (_b = this._polylines).push.apply(_b, __spread(val));
                }
                else {
                    this._polylines = val.slice(0);
                }
                var _a, _b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineLayerDirective.prototype, "TreatNewPolylineOptionsAsStream", {
            /**
             * Sets whether to treat changes in the PolylineOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolylineOptions will be incrementally drawn on the map as opposed to replace the polylines on the map.
             *
             * @memberof MapPolylineLayerDirective
             */
            get: /**
             * Sets whether to treat changes in the PolylineOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolylineOptions will be incrementally drawn on the map as opposed to replace the polylines on the map.
             *
             * \@memberof MapPolylineLayerDirective
             * @return {?}
             */ function () { return this._streaming; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._streaming = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineLayerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the polyline layer.
             *
             * \@readonly
             * \@memberof MapPolylineLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ layerOptions = {
                    id: this._id
                };
                this._zone.runOutsideAngular(function () {
                    var /** @type {?} */ fakeLayerDirective = {
                        Id: _this._id,
                        Visible: _this.Visible,
                        LayerOffset: _this.LayerOffset,
                        ZIndex: _this.ZIndex
                    };
                    _this._layerService.AddLayer(fakeLayerDirective);
                    _this._layerPromise = _this._layerService.GetNativeLayer(fakeLayerDirective);
                    Promise.all([
                        _this._layerPromise,
                        _this._mapService.CreateCanvasOverlay(function (el) { return _this.DrawLabels(el); })
                    ]).then(function (values) {
                        values[0].SetVisible(_this.Visible);
                        _this._canvas = values[1];
                        _this._canvas._canvasReady.then(function (b) {
                            _this._tooltip = _this._canvas.GetToolTipOverlay();
                            _this.ManageTooltip(_this.ShowTooltips);
                        });
                        if (_this.PolylineOptions) {
                            _this._zone.runOutsideAngular(function () { return _this.UpdatePolylines(); });
                        }
                    });
                    _this._service = _this._layerService;
                });
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
            function () {
                this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                this._layerPromise.then(function (l) {
                    l.Delete();
                });
                if (this._canvas) {
                    this._canvas.Delete();
                }
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
            function (changes) {
                var _this = this;
                if (changes['PolylineOptions']) {
                    this._zone.runOutsideAngular(function () {
                        _this.UpdatePolylines();
                    });
                }
                if (changes['Visible'] && !changes['Visible'].firstChange) {
                    this._layerPromise.then(function (l) { return l.SetVisible(_this.Visible); });
                }
                if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||
                    (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)) {
                    throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));
                }
                if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||
                    (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||
                    (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)) {
                    if (this._canvas) {
                        this._canvas.Redraw(true);
                    }
                }
                if (changes['ShowTooltips'] && this._tooltip) {
                    this.ManageTooltip(changes['ShowTooltips'].currentValue);
                }
            };
        /**
         * Obtains a string representation of the Layer Id.
         * \@memberof MapPolylineLayerDirective
         * @return {?} - string representation of the layer id.
         */
        MapPolylineLayerDirective.prototype.toString = /**
         * Obtains a string representation of the Layer Id.
         * \@memberof MapPolylineLayerDirective
         * @return {?} - string representation of the layer id.
         */
            function () { return 'MapPolylineLayer-' + this._id.toString(); };
        /**
         * Adds various event listeners for the polylines.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} p - the polyline for which to add the event.
         *
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the polylines.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} p - the polyline for which to add the event.
         *
         * @return {?}
         */
            function (p) {
                var _this = this;
                var /** @type {?} */ handlers = [
                    { name: 'click', handler: function (ev) { return _this.PolylineClick.emit({ Polyline: p, Click: ev }); } },
                    { name: 'dblclick', handler: function (ev) { return _this.PolylineDblClick.emit({ Polyline: p, Click: ev }); } },
                    { name: 'mousemove', handler: function (ev) { return _this.PolylineMouseMove.emit({ Polyline: p, Click: ev }); } },
                    { name: 'mouseout', handler: function (ev) { return _this.PolylineMouseOut.emit({ Polyline: p, Click: ev }); } },
                    { name: 'mouseover', handler: function (ev) { return _this.PolylineMouseOver.emit({ Polyline: p, Click: ev }); } }
                ];
                handlers.forEach(function (obj) { return p.AddListener(obj.name, obj.handler); });
            };
        /**
         * Draws the polyline labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.DrawLabels = /**
         * Draws the polyline labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
            function (el) {
                var _this = this;
                if (this.ShowLabels) {
                    this._mapService.GetZoom().then(function (z) {
                        if (_this.LabelMinZoom <= z && _this.LabelMaxZoom >= z) {
                            var /** @type {?} */ ctx_1 = el.getContext('2d');
                            var /** @type {?} */ labels_1 = _this._labels.map(function (x) { return x.title; });
                            _this._mapService.LocationsToPoints(_this._labels.map(function (x) { return x.loc; })).then(function (locs) {
                                var /** @type {?} */ size = _this._mapService.MapSize;
                                for (var /** @type {?} */ i = 0, /** @type {?} */ len = locs.length; i < len; i++) {
                                    // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.
                                    if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {
                                        _this.DrawText(ctx_1, locs[i], labels_1[i]);
                                    }
                                }
                            });
                        }
                    });
                }
            };
        /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.DrawText = /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
            function (ctx, loc, text) {
                var /** @type {?} */ lo = this.LabelOptions;
                if (lo == null && this._tooltip) {
                    lo = this._tooltip.DefaultLabelStyle;
                }
                if (lo == null) {
                    lo = this._defaultOptions;
                }
                ctx.strokeStyle = lo.strokeColor;
                ctx.font = lo.fontSize + "px " + lo.fontFamily;
                ctx.textAlign = 'center';
                var /** @type {?} */ strokeWeight = lo.strokeWeight;
                if (text && strokeWeight && strokeWeight > 0) {
                    ctx.lineWidth = strokeWeight;
                    ctx.strokeText(text, loc.x, loc.y);
                }
                ctx.fillStyle = lo.fontColor;
                ctx.fillText(text, loc.x, loc.y);
            };
        /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ManageTooltip = /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
            function (show) {
                var _this = this;
                if (show && this._canvas) {
                    // add tooltip subscriptions
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                    this._tooltipSubscriptions.push(this.PolylineMouseMove.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            var /** @type {?} */ loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('position', loc);
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolylineMouseOver.asObservable().subscribe(function (e) {
                        if (e.Polyline.Title && e.Polyline.Title.length > 0) {
                            var /** @type {?} */ loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('text', e.Polyline.Title);
                            _this._tooltip.Set('position', loc);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolylineMouseOut.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            _this._tooltip.Set('hidden', true);
                            _this._tooltipVisible = false;
                        }
                    }));
                }
                else {
                    // remove tooltip subscriptions
                    this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                    this._tooltipSubscriptions.splice(0);
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                }
            };
        /**
         * Sets or updates the polyliness based on the polyline options. This will place the polylines on the map
         * and register the associated events.
         *
         * \@memberof MapPolylineLayerDirective
         * \@method
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.UpdatePolylines = /**
         * Sets or updates the polyliness based on the polyline options. This will place the polylines on the map
         * and register the associated events.
         *
         * \@memberof MapPolylineLayerDirective
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._layerPromise == null) {
                    return;
                }
                this._layerPromise.then(function (l) {
                    var /** @type {?} */ polylines = _this._streaming ? _this._polylinesLast.splice(0) : _this._polylines;
                    if (!_this._streaming) {
                        _this._labels.splice(0);
                    }
                    // generate the promise for the polylines
                    var /** @type {?} */ lp = _this._service.CreatePolylines(l.GetOptions().id, polylines);
                    // set polylines once promises are fullfilled.
                    lp.then(function (p) {
                        var /** @type {?} */ y = new Array();
                        p.forEach(function (poly) {
                            if (Array.isArray(poly)) {
                                var /** @type {?} */ title_1 = '';
                                var /** @type {?} */ centroids_1 = new Array();
                                poly.forEach(function (x) {
                                    y.push(x);
                                    _this.AddEventListeners(x);
                                    centroids_1.push(x.Centroid);
                                    if (x.Title != null && x.Title.length > 0 && title_1.length === 0) {
                                        title_1 = x.Title;
                                    }
                                });
                                _this._labels.push({ loc: Polyline.GetPolylineCentroid(centroids_1), title: title_1 });
                            }
                            else {
                                y.push(poly);
                                if (poly.Title != null && poly.Title.length > 0) {
                                    _this._labels.push({ loc: poly.Centroid, title: poly.Title });
                                }
                                _this.AddEventListeners(poly);
                            }
                        });
                        _this._streaming ? l.AddEntities(y) : l.SetEntities(y);
                        if (_this._canvas) {
                            _this._canvas.Redraw(!_this._streaming);
                        }
                    });
                });
            };
        MapPolylineLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polyline-layer'
                    },] },
        ];
        /** @nocollapse */
        MapPolylineLayerDirective.ctorParameters = function () {
            return [
                { type: LayerService },
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapPolylineLayerDirective.propDecorators = {
            LabelMaxZoom: [{ type: core.Input }],
            LabelMinZoom: [{ type: core.Input }],
            LabelOptions: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            PolylineOptions: [{ type: core.Input }],
            ShowLabels: [{ type: core.Input }],
            ShowTooltips: [{ type: core.Input }],
            TreatNewPolylineOptionsAsStream: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            PolylineClick: [{ type: core.Output }],
            PolylineDblClick: [{ type: core.Output }],
            PolylineMouseMove: [{ type: core.Output }],
            PolylineMouseOut: [{ type: core.Output }],
            PolylineMouseOver: [{ type: core.Output }]
        };
        return MapPolylineLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract implementation. USed for defintion only and as a base to implement your
     * own provider.
     *
     * @export
     * @abstract
     * @abstract
     */
    var MapAPILoader = (function () {
        function MapAPILoader() {
        }
        MapAPILoader.decorators = [
            { type: core.Injectable },
        ];
        return MapAPILoader;
    }());
    /**
     * Document Reference service to assist with abstracting the availability of document. Needed for AOT and
     * Server Side rendering
     *
     * @export
     */
    var DocumentRef = (function () {
        function DocumentRef() {
        }
        Object.defineProperty(DocumentRef.prototype, "IsAvailable", {
            get: /**
             * Gets whether a document implementation is available. Generally will be true in the browser and false otherwise, unless there
             * there is a browser-less implementation in the current non-browser environment.
             *
             * \@readonly
             * \@memberof DocumentRef
             * @return {?}
             */ function () {
                return !(typeof (document) === 'undefined');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the document object of the current environment.
         *
         * \@memberof DocumentRef
         * @return {?} - The document object.
         *
         */
        DocumentRef.prototype.GetNativeDocument = /**
         * Returns the document object of the current environment.
         *
         * \@memberof DocumentRef
         * @return {?} - The document object.
         *
         */
            function () {
                if (typeof (document) === 'undefined') {
                    return null;
                }
                return document;
            };
        DocumentRef.decorators = [
            { type: core.Injectable },
        ];
        return DocumentRef;
    }());
    /**
     * Window Reference service to assist with abstracting the availability of window. Needed for AOT and
     * Server Side rendering
     *
     * @export
     */
    var WindowRef = (function () {
        function WindowRef() {
        }
        Object.defineProperty(WindowRef.prototype, "IsAvailable", {
            get: /**
             * Gets whether a window implementation is available. Generally will be true in the browser and false otherwise, unless there
             * there is a browser-less implementation in the current non-browser environment.
             *
             * \@readonly
             * \@memberof WindowRef
             * @return {?}
             */ function () {
                return !(typeof (window) === 'undefined');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the window object of the current environment.
         *
         * \@memberof WindowRef
         * @return {?} - The window object.
         *
         */
        WindowRef.prototype.GetNativeWindow = /**
         * Returns the window object of the current environment.
         *
         * \@memberof WindowRef
         * @return {?} - The window object.
         *
         */
            function () {
                if (typeof (window) === 'undefined') {
                    return null;
                }
                return window;
            };
        WindowRef.decorators = [
            { type: core.Injectable },
        ];
        return WindowRef;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var ScriptProtocol = {
        HTTP: 0,
        HTTPS: 1,
        AUTO: 2,
    };
    ScriptProtocol[ScriptProtocol.HTTP] = "HTTP";
    ScriptProtocol[ScriptProtocol.HTTPS] = "HTTPS";
    ScriptProtocol[ScriptProtocol.AUTO] = "AUTO";
    /**
     * Bing Maps V8 specific loader configuration to be used with the {\@link BingMapAPILoader}
     *
     * @export
     */
    var BingMapAPILoaderConfig = (function () {
        function BingMapAPILoaderConfig() {
            this.apiKey = '';
            this.hostAndPath = 'www.bing.com/api/maps/mapcontrol';
            this.protocol = ScriptProtocol.HTTPS;
            this.branch = '';
        }
        BingMapAPILoaderConfig.decorators = [
            { type: core.Injectable },
        ];
        return BingMapAPILoaderConfig;
    }());
    /**
     * Default loader configuration.
     */
    var /** @type {?} */ DEFAULT_CONFIGURATION = new BingMapAPILoaderConfig();
    /**
     * Bing Maps V8 implementation for the {\@link MapAPILoader} service.
     *
     * @export
     */
    var BingMapAPILoader = (function (_super) {
        __extends(BingMapAPILoader, _super);
        /**
         * Creates an instance of BingMapAPILoader.
         * @param _config  - The loader configuration.
         * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.
         * @param _documentRef - An instance of {@link DocumentRef}.
         * Necessary because Bing Map V8 interacts with the document object.
         *
         * @memberof BingMapAPILoader
         */
        function BingMapAPILoader(_config, _windowRef, _documentRef) {
            var _this = _super.call(this) || this;
            _this._config = _config;
            _this._windowRef = _windowRef;
            _this._documentRef = _documentRef;
            if (_this._config === null || _this._config === undefined) {
                _this._config = DEFAULT_CONFIGURATION;
            }
            return _this;
        }
        Object.defineProperty(BingMapAPILoader.prototype, "Config", {
            get: /**
             * Gets the loader configuration.
             *
             * \@readonly
             * \@memberof BingMapAPILoader
             * @return {?}
             */ function () { return this._config; },
            enumerable: true,
            configurable: true
        });
        /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof BingMapAPILoader
         * @return {?}
         */
        BingMapAPILoader.prototype.Load = /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof BingMapAPILoader
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._scriptLoadingPromise) {
                    return this._scriptLoadingPromise;
                }
                var /** @type {?} */ script = this._documentRef.GetNativeDocument().createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                script.defer = true;
                var /** @type {?} */ callbackName = "angular2bingmaps" + new Date().getMilliseconds();
                script.src = this.GetScriptSrc(callbackName);
                this._scriptLoadingPromise = new Promise(function (resolve, reject) {
                    ((_this._windowRef.GetNativeWindow()))[callbackName] = function () {
                        resolve();
                    };
                    script.onerror = function (error) { reject(error); };
                });
                this._documentRef.GetNativeDocument().head.appendChild(script);
                return this._scriptLoadingPromise;
            };
        /**
         * Gets the Bing Map V8 scripts url for injections into the header.
         *
         * \@memberof BingMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Bing Maps V8 scripts are loaded.
         * @return {?} - The url to be used to load the Bing Map scripts.
         *
         */
        BingMapAPILoader.prototype.GetScriptSrc = /**
         * Gets the Bing Map V8 scripts url for injections into the header.
         *
         * \@memberof BingMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Bing Maps V8 scripts are loaded.
         * @return {?} - The url to be used to load the Bing Map scripts.
         *
         */
            function (callbackName) {
                var /** @type {?} */ protocolType = (this._config && this._config.protocol) || DEFAULT_CONFIGURATION.protocol;
                var /** @type {?} */ protocol;
                switch (protocolType) {
                    case ScriptProtocol.AUTO:
                        protocol = '';
                        break;
                    case ScriptProtocol.HTTP:
                        protocol = 'http:';
                        break;
                    case ScriptProtocol.HTTPS:
                        protocol = 'https:';
                        break;
                }
                var /** @type {?} */ hostAndPath = this._config.hostAndPath || DEFAULT_CONFIGURATION.hostAndPath;
                var /** @type {?} */ queryParams = {
                    callback: callbackName
                };
                if (this._config.branch !== '') {
                    queryParams['branch'] = this._config.branch;
                }
                var /** @type {?} */ params = Object.keys(queryParams)
                    .map(function (k, i) {
                    var /** @type {?} */ param = (i === 0) ? '?' : '&';
                    return param += k + "=" + queryParams[k];
                })
                    .join('');
                return protocol + "//" + hostAndPath + params;
            };
        BingMapAPILoader.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMapAPILoader.ctorParameters = function () {
            return [
                { type: BingMapAPILoaderConfig, decorators: [{ type: core.Optional }] },
                { type: WindowRef },
                { type: DocumentRef }
            ];
        };
        return BingMapAPILoader;
    }(MapAPILoader));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link InfoBoxService} contract for the Bing Maps V8 architecture.
     *
     * @export
     */
    var BingInfoBoxService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingInfoBoxService.
         * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.
         * @param _zone - An instance of NgZone to provide zone aware promises.
         *
         * @memberof BingInfoBoxService
         */
        function BingInfoBoxService(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
            this._boxes = new Map();
        }
        /**
         * Adds an info window to the map or layer.
         *
         * \@memberof BingInfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         *
         * @return {?}
         */
        BingInfoBoxService.prototype.AddInfoWindow = /**
         * Adds an info window to the map or layer.
         *
         * \@memberof BingInfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         *
         * @return {?}
         */
            function (info) {
                var /** @type {?} */ options = {};
                if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {
                    options.position = {
                        latitude: info.Latitude,
                        longitude: info.Longitude
                    };
                }
                if (typeof info.InfoWindowActions !== 'undefined' && info.InfoWindowActions.length > 0) {
                    options.actions = [];
                    info.InfoWindowActions.forEach(function (action) {
                        options.actions.push({
                            label: action.Label,
                            eventHandler: function () { action.ActionClicked.emit(null); }
                        });
                    });
                }
                if (info.HtmlContent !== '') {
                    options.htmlContent = info.HtmlContent;
                }
                else {
                    options.title = info.Title;
                    options.description = info.Description;
                }
                if (info.xOffset || info.yOffset) {
                    if (options.pixelOffset == null) {
                        options.pixelOffset = { x: 0, y: 0 };
                    }
                    if (info.xOffset) {
                        options.pixelOffset.x = info.xOffset;
                    }
                    if (info.yOffset) {
                        options.pixelOffset.y = info.yOffset;
                    }
                }
                options.visible = info.Visible;
                var /** @type {?} */ infoPromise = this._mapService.CreateInfoWindow(options);
                this._boxes.set(info, infoPromise);
            };
        /**
         * Closes an InfoBoxComponent that is open.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been closed.
         *
         */
        BingInfoBoxService.prototype.Close = /**
         * Closes an InfoBoxComponent that is open.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been closed.
         *
         */
            function (info) {
                return this._boxes.get(info).then(function (w) { return w.Close(); });
            };
        /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingInfoBoxService.prototype.CreateEventObservable = /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, infoComponent) {
                var _this = this;
                var /** @type {?} */ eventNameTranslated = BingMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._boxes.get(infoComponent).then(function (b) {
                        b.AddListener(eventNameTranslated, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes an infobox.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been deleted.
         *
         */
        BingInfoBoxService.prototype.DeleteInfoWindow = /**
         * Deletes an infobox.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been deleted.
         *
         */
            function (info) {
                var _this = this;
                var /** @type {?} */ w = this._boxes.get(info);
                if (w == null) {
                    return Promise.resolve();
                }
                return w.then(function (i) {
                    return _this._zone.run(function () {
                        i.Close();
                        _this._boxes.delete(info);
                    });
                });
            };
        /**
         * Opens an infobox that is closed.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?=} loc
         * @return {?} - A promise that is fullfilled when the infobox has been opened.
         *
         */
        BingInfoBoxService.prototype.Open = /**
         * Opens an infobox that is closed.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?=} loc
         * @return {?} - A promise that is fullfilled when the infobox has been opened.
         *
         */
            function (info, loc) {
                if (info.CloseInfoBoxesOnOpen || info.Modal) {
                    // close all open info boxes.
                    this._boxes.forEach(function (v, i) {
                        if (info.Id !== i.Id) {
                            v.then(function (w) {
                                if (w.IsOpen) {
                                    w.Close();
                                    i.Close();
                                }
                            });
                        }
                    });
                }
                return this._boxes.get(info).then(function (w) {
                    var /** @type {?} */ options = {};
                    if (info.HtmlContent !== '') {
                        options.htmlContent = info.HtmlContent;
                    }
                    else {
                        options.title = info.Title;
                        options.description = info.Description;
                    }
                    w.SetOptions(options);
                    if (info.Latitude && info.Longitude) {
                        w.SetPosition({ latitude: info.Latitude, longitude: info.Longitude });
                    }
                    else if (loc) {
                        w.SetPosition(loc);
                    }
                    else if (info.HostMarker) {
                        w.SetPosition({ latitude: info.HostMarker.Latitude, longitude: info.HostMarker.Longitude });
                    }
                    w.Open();
                });
            };
        /**
         * Sets the infobox options.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?} options - {\@link IInfoWindowOptions} object containing the options to set. Options provided are
         * merged with the existing options of the underlying infobox.
         * @return {?} - A promise that is fullfilled when the infobox options have been updated.
         *
         */
        BingInfoBoxService.prototype.SetOptions = /**
         * Sets the infobox options.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?} options - {\@link IInfoWindowOptions} object containing the options to set. Options provided are
         * merged with the existing options of the underlying infobox.
         * @return {?} - A promise that is fullfilled when the infobox options have been updated.
         *
         */
            function (info, options) {
                return this._boxes.get(info).then(function (i) { return i.SetOptions(options); });
            };
        /**
         * Set the position of the infobox based on the properties set on the InfoBox component.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox position has been updated.
         *
         */
        BingInfoBoxService.prototype.SetPosition = /**
         * Set the position of the infobox based on the properties set on the InfoBox component.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox position has been updated.
         *
         */
            function (info) {
                return this._boxes.get(info).then(function (i) {
                    return i.SetPosition({
                        latitude: info.Latitude,
                        longitude: info.Longitude
                    });
                });
            };
        BingInfoBoxService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingInfoBoxService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return BingInfoBoxService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the MarkerService abstract class for Bing Maps V8.
     *
     * @export
     */
    var BingMarkerService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMarkerService.
         * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link BingLayerService} implementation is expected.
         * @param _clusterService - {@link ClusterService} instance.
         * The concrete {@link BingClusterService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof BingMarkerService
         */
        function BingMarkerService(_mapService, _layerService, _clusterService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._clusterService = _clusterService;
            this._zone = _zone;
            this._markers = new Map();
        }
        /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         *
         * @return {?}
         */
        BingMarkerService.prototype.AddMarker = /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         *
         * @return {?}
         */
            function (marker) {
                var /** @type {?} */ o = {
                    position: { latitude: marker.Latitude, longitude: marker.Longitude },
                    title: marker.Title,
                    label: marker.Label,
                    draggable: marker.Draggable,
                    icon: marker.IconUrl,
                    iconInfo: marker.IconInfo,
                    isFirst: marker.IsFirstInSet,
                    isLast: marker.IsLastInSet
                };
                if (marker.Width) {
                    o.width = marker.Width;
                }
                if (marker.Height) {
                    o.height = marker.Height;
                }
                if (marker.Anchor) {
                    o.anchor = marker.Anchor;
                }
                if (marker.Metadata) {
                    o.metadata = marker.Metadata;
                }
                // create marker via promise.
                var /** @type {?} */ markerPromise = null;
                if (marker.InClusterLayer) {
                    markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);
                }
                else if (marker.InCustomLayer) {
                    markerPromise = this._layerService.CreateMarker(marker.LayerId, o);
                }
                else {
                    markerPromise = this._mapService.CreateMarker(o);
                }
                this._markers.set(marker, markerPromise);
                if (marker.IconInfo) {
                    markerPromise.then(function (m) {
                        // update iconInfo to provide hook to do post icon creation activities and
                        // also re-anchor the marker
                        marker.DynamicMarkerCreated.emit(o.iconInfo);
                        var /** @type {?} */ p = {
                            x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,
                            y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,
                        };
                        m.SetAnchor(p);
                    });
                }
            };
        /**
         * Registers an event delegate for a marker.
         *
         * \@memberof BingMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarker} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingMarkerService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a marker.
         *
         * \@memberof BingMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarker} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, marker) {
                var _this = this;
                var /** @type {?} */ b = new rxjs.Subject();
                if (eventName === 'mousemove') {
                    return b.asObservable();
                }
                if (eventName === 'rightclick') {
                    return b.asObservable();
                }
                return rxjs.Observable.create(function (observer) {
                    _this._markers.get(marker).then(function (m) {
                        m.AddListener(eventName, function (e) {
                            return _this._zone.run(function () {
                                return observer.next(e);
                            });
                        });
                    });
                });
            };
        /**
         * Deletes a marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - {\@link MapMarker} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         *
         */
        BingMarkerService.prototype.DeleteMarker = /**
         * Deletes a marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - {\@link MapMarker} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         *
         */
            function (marker) {
                var _this = this;
                var /** @type {?} */ m = this._markers.get(marker);
                var /** @type {?} */ p = Promise.resolve();
                if (m != null) {
                    p = m.then(function (ma) {
                        if (marker.InClusterLayer) {
                            _this._clusterService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                        }
                        if (marker.InCustomLayer) {
                            _this._layerService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                        }
                        return _this._zone.run(function () {
                            ma.DeleteMarker();
                            _this._markers.delete(marker);
                        });
                    });
                }
                return p;
            };
        /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        BingMarkerService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.primitive) {
                    return null;
                }
                if (!(e.primitive instanceof Microsoft.Maps.Pushpin)) {
                    return null;
                }
                var /** @type {?} */ p = e.primitive;
                var /** @type {?} */ loc = p.getLocation();
                return { latitude: loc.latitude, longitude: loc.longitude };
            };
        /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarker} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         *
         */
        BingMarkerService.prototype.GetNativeMarker = /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarker} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         *
         */
            function (marker) {
                return this._markers.get(marker);
            };
        /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         *
         */
        BingMarkerService.prototype.GetPixelsFromClick = /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         *
         */
            function (e) {
                var /** @type {?} */ loc = this.GetCoordinatesFromClick(e);
                if (loc == null) {
                    return null;
                }
                var /** @type {?} */ l = BingConversions.TranslateLocation(loc);
                var /** @type {?} */ p = (((this._mapService)).MapInstance.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control));
                if (p == null) {
                    return null;
                }
                return { x: p.x, y: p.y };
            };
        /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof BingMarkerService
         * @param {?} target - Either a {\@link MapMarker} or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         *
         */
        BingMarkerService.prototype.LocationToPoint = /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof BingMarkerService
         * @param {?} target - Either a {\@link MapMarker} or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         *
         */
            function (target) {
                var _this = this;
                if (target == null) {
                    return Promise.resolve(null);
                }
                if (target instanceof MapMarkerDirective) {
                    return this._markers.get(target).then(function (m) {
                        var /** @type {?} */ l = m.Location;
                        var /** @type {?} */ p = _this._mapService.LocationToPoint(l);
                        return p;
                    });
                }
                return this._mapService.LocationToPoint(target);
            };
        /**
         * Updates the anchor position for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         *
         */
        BingMarkerService.prototype.UpdateAnchor = /**
         * Updates the anchor position for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    m.SetAnchor(marker.Anchor);
                });
            };
        /**
         * Updates whether the marker is draggable.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         *
         */
        BingMarkerService.prototype.UpdateDraggable = /**
         * Updates whether the marker is draggable.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetDraggable(marker.Draggable); });
            };
        /**
         * Updates the Icon on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         *
         */
        BingMarkerService.prototype.UpdateIcon = /**
         * Updates the Icon on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         *
         */
            function (marker) {
                var /** @type {?} */ payload = function (m, icon, iconInfo) {
                    if (icon && icon !== '') {
                        m.SetIcon(icon);
                        marker.DynamicMarkerCreated.emit(iconInfo);
                    }
                };
                return this._markers.get(marker).then(function (m) {
                    if (marker.IconInfo) {
                        var /** @type {?} */ s = Marker.CreateMarker(marker.IconInfo);
                        if (typeof (s) === 'string') {
                            return (payload(m, s, marker.IconInfo));
                        }
                        else {
                            return s.then(function (x) {
                                return (payload(m, x.icon, x.iconInfo));
                            });
                        }
                    }
                    else {
                        return (m.SetIcon(marker.IconUrl));
                    }
                });
            };
        /**
         * Updates the label on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         *
         */
        BingMarkerService.prototype.UpdateLabel = /**
         * Updates the label on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { m.SetLabel(marker.Label); });
            };
        /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         *
         */
        BingMarkerService.prototype.UpdateMarkerPosition = /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    return m.SetPosition({
                        latitude: marker.Latitude,
                        longitude: marker.Longitude
                    });
                });
            };
        /**
         * Updates the title on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         *
         */
        BingMarkerService.prototype.UpdateTitle = /**
         * Updates the title on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetTitle(marker.Title); });
            };
        /**
         * Updates the visibility on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the visibility has been updated.
         *
         */
        BingMarkerService.prototype.UpdateVisible = /**
         * Updates the visibility on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the visibility has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetVisible(marker.Visible); });
            };
        BingMarkerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMarkerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: ClusterService },
                { type: core.NgZone }
            ];
        };
        return BingMarkerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the MapService abstract implementing a Bin Map V8 provider
     *
     * @export
     */
    var BingMapService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMapService.
         * @param _loader MapAPILoader instance implemented for Bing Maps. This instance will generally be injected.
         * @param _zone NgZone object to enable zone aware promises. This will generally be injected.
         *
         * @memberof BingMapService
         */
        function BingMapService(_loader, _zone) {
            var _this = this;
            this._loader = _loader;
            this._zone = _zone;
            this._modules = new Map();
            this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
            this._config = ((this._loader)).Config;
        }
        Object.defineProperty(BingMapService.prototype, "LoadedModules", {
            get: /**
             * Gets an array of loaded Bong modules.
             *
             * \@readonly
             * \@memberof BingMapService
             * @return {?}
             */ function () { return this._modules; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMapService.prototype, "MapInstance", {
            get: /**
             * Gets the Bing Map control instance underlying the implementation
             *
             * \@readonly
             * \@memberof BingMapService
             * @return {?}
             */ function () { return this._mapInstance; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMapService.prototype, "MapPromise", {
            get: /**
             * Gets a Promise for a Bing Map control instance underlying the implementation. Use this instead of {\@link MapInstance} if you
             * are not sure if and when the instance will be created.
             * \@readonly
             * \@memberof BingMapService
             * @return {?}
             */ function () { return this._map; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMapService.prototype, "MapSize", {
            get: /**
             * Gets the maps physical size.
             *
             * \@readonly
             * @abstract
             * \@memberof BingMapService
             * @return {?}
             */ function () {
                if (this.MapInstance) {
                    var /** @type {?} */ s = { width: this.MapInstance.getWidth(), height: this.MapInstance.getHeight() };
                    return s;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof BingMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
        BingMapService.prototype.CreateCanvasOverlay = /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof BingMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
            function (drawCallback) {
                return this._map.then(function (map) {
                    var /** @type {?} */ overlay = new BingCanvasOverlay(drawCallback);
                    map.layers.insert(overlay);
                    return overlay;
                });
            };
        /**
         * Creates a Bing map cluster layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link IClusterOptions}.
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.
         *
         */
        BingMapService.prototype.CreateClusterLayer = /**
         * Creates a Bing map cluster layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link IClusterOptions}.
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    var /** @type {?} */ p = new Promise(function (resolve) {
                        _this.LoadModule('Microsoft.Maps.Clustering', function () {
                            var /** @type {?} */ o = BingConversions.TranslateClusterOptions(options);
                            var /** @type {?} */ layer = new Microsoft.Maps.ClusterLayer(new Array(), o);
                            var /** @type {?} */ bl;
                            map.layers.insert(layer);
                            bl = new BingClusterLayer(layer, _this);
                            bl.SetOptions(options);
                            resolve(bl);
                        });
                    });
                    return p;
                });
            };
        /**
         * Creates an information window for a map position
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
        BingMapService.prototype.CreateInfoWindow = /**
         * Creates an information window for a map position
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
            function (options) {
                return this._map.then(function (map) {
                    var /** @type {?} */ loc;
                    if (options.position == null) {
                        loc = map.getCenter();
                    }
                    else {
                        loc = new Microsoft.Maps.Location(options.position.latitude, options.position.longitude);
                    }
                    var /** @type {?} */ infoBox = new Microsoft.Maps.Infobox(loc, BingConversions.TranslateInfoBoxOptions(options));
                    infoBox.setMap(map);
                    return new BingInfoWindow(infoBox);
                });
            };
        /**
         * Creates a map layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
        BingMapService.prototype.CreateLayer = /**
         * Creates a map layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    var /** @type {?} */ layer = new Microsoft.Maps.Layer(options.id.toString());
                    map.layers.insert(layer);
                    return new BingLayer(layer, _this);
                });
            };
        /**
         * Creates a map instance
         *
         * \@memberof BingMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
        BingMapService.prototype.CreateMap = /**
         * Creates a map instance
         *
         * \@memberof BingMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
            function (el, mapOptions) {
                var _this = this;
                return this._loader.Load().then(function () {
                    // apply mixins
                    MixinMapLabelWithOverlayView();
                    MixinCanvasOverlay();
                    // map startup...
                    if (_this._mapInstance != null) {
                        _this.DisposeMap();
                    }
                    var /** @type {?} */ o = BingConversions.TranslateLoadOptions(mapOptions);
                    if (!o.credentials) {
                        o.credentials = _this._config.apiKey;
                    }
                    var /** @type {?} */ map = new Microsoft.Maps.Map(el, o);
                    _this._mapInstance = map;
                    _this._mapResolver(map);
                });
            };
        /**
         * Creates a Bing map marker within the map context
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
        BingMapService.prototype.CreateMarker = /**
         * Creates a Bing map marker within the map context
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
            function (options) {
                if (options === void 0) {
                    options = /** @type {?} */ ({});
                }
                var /** @type {?} */ payload = function (icon, map) {
                    var /** @type {?} */ loc = BingConversions.TranslateLocation(options.position);
                    var /** @type {?} */ o = BingConversions.TranslateMarkerOptions(options);
                    if (icon && icon !== '') {
                        o.icon = icon;
                    }
                    var /** @type {?} */ pushpin = new Microsoft.Maps.Pushpin(loc, o);
                    var /** @type {?} */ marker = new BingMarker(pushpin, map, null);
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return marker.Metadata.set(k, v); });
                    }
                    map.entities.push(pushpin);
                    return marker;
                };
                return this._map.then(function (map) {
                    if (options.iconInfo && options.iconInfo.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            return (payload(s, map));
                        }
                        else {
                            return s.then(function (x) {
                                return (payload(x.icon, map));
                            });
                        }
                    }
                    else {
                        return (payload(null, map));
                    }
                });
            };
        /**
         * Creates a polygon within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
        BingMapService.prototype.CreatePolygon = /**
         * Creates a polygon within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    var /** @type {?} */ locs = BingConversions.TranslatePaths(options.paths);
                    var /** @type {?} */ o = BingConversions.TranslatePolygonOptions(options);
                    var /** @type {?} */ poly = new Microsoft.Maps.Polygon(locs, o);
                    map.entities.push(poly);
                    var /** @type {?} */ p = new BingPolygon(poly, _this, null);
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return p.Metadata.set(k, v); });
                    }
                    if (options.title && options.title !== '') {
                        p.Title = options.title;
                    }
                    if (options.showLabel != null) {
                        p.ShowLabel = options.showLabel;
                    }
                    if (options.showTooltip != null) {
                        p.ShowTooltip = options.showTooltip;
                    }
                    if (options.labelMaxZoom != null) {
                        p.LabelMaxZoom = options.labelMaxZoom;
                    }
                    if (options.labelMinZoom != null) {
                        p.LabelMinZoom = options.labelMinZoom;
                    }
                    if (options.editable) {
                        p.SetEditable(options.editable);
                    }
                    return p;
                });
            };
        /**
         * Creates a polyline within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array thereof for complex paths),
         * which models the underlying native polygon.
         *
         */
        BingMapService.prototype.CreatePolyline = /**
         * Creates a polyline within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array thereof for complex paths),
         * which models the underlying native polygon.
         *
         */
            function (options) {
                var /** @type {?} */ polyline;
                return this._map.then(function (map) {
                    var /** @type {?} */ o = BingConversions.TranslatePolylineOptions(options);
                    var /** @type {?} */ locs = BingConversions.TranslatePaths(options.path);
                    if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {
                        polyline = new Microsoft.Maps.Polyline(locs[0], o);
                        map.entities.push(polyline);
                        var /** @type {?} */ pl_1 = new BingPolyline(polyline, map, null);
                        if (options.metadata) {
                            options.metadata.forEach(function (v, k) { return pl_1.Metadata.set(k, v); });
                        }
                        if (options.title && options.title !== '') {
                            pl_1.Title = options.title;
                        }
                        if (options.showTooltip != null) {
                            pl_1.ShowTooltip = options.showTooltip;
                        }
                        return pl_1;
                    }
                    else {
                        var /** @type {?} */ lines_1 = new Array();
                        locs.forEach(function (p) {
                            polyline = new Microsoft.Maps.Polyline(p, o);
                            map.entities.push(polyline);
                            var /** @type {?} */ pl = new BingPolyline(polyline, map, null);
                            if (options.metadata) {
                                options.metadata.forEach(function (v, k) { return pl.Metadata.set(k, v); });
                            }
                            if (options.title && options.title !== '') {
                                pl.Title = options.title;
                            }
                            if (options.showTooltip != null) {
                                pl.ShowTooltip = options.showTooltip;
                            }
                            lines_1.push(pl);
                        });
                        return lines_1;
                    }
                });
            };
        /**
         * Deletes a layer from the map.
         *
         * \@memberof BingMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Bing specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
        BingMapService.prototype.DeleteLayer = /**
         * Deletes a layer from the map.
         *
         * \@memberof BingMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Bing specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                return this._map.then(function (map) {
                    map.layers.remove(layer.NativePrimitve);
                });
            };
        /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof BingMapService
         * @return {?}
         */
        BingMapService.prototype.DisposeMap = /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof BingMapService
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._map == null && this._mapInstance == null) {
                    return;
                }
                if (this._mapInstance != null) {
                    this._mapInstance.dispose();
                    this._mapInstance = null;
                    this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
                }
            };
        /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
        BingMapService.prototype.GetCenter = /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    var /** @type {?} */ center = map.getCenter();
                    return /** @type {?} */ ({
                        latitude: center.latitude,
                        longitude: center.longitude
                    });
                });
            };
        /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the bounding box. See {\@link IBox}.
         *
         */
        BingMapService.prototype.GetBounds = /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the bounding box. See {\@link IBox}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    var /** @type {?} */ box = map.getBounds();
                    return /** @type {?} */ ({
                        maxLatitude: box.getNorth(),
                        maxLongitude: box.crossesInternationalDateLine() ? box.getWest() : box.getEast(),
                        minLatitude: box.getSouth(),
                        minLongitude: box.crossesInternationalDateLine() ? box.getEast() : box.getWest(),
                        center: { latitude: box.center.latitude, longitude: box.center.longitude },
                        padding: 0
                    });
                });
            };
        /**
         * Gets a shared or private instance of the map drawing tools.
         *
         * \@memberof BingMapService
         * @param {?=} useSharedInstance
         * @return {?} - Promise that when resolved containst an instance of the drawing tools.
         */
        BingMapService.prototype.GetDrawingTools = /**
         * Gets a shared or private instance of the map drawing tools.
         *
         * \@memberof BingMapService
         * @param {?=} useSharedInstance
         * @return {?} - Promise that when resolved containst an instance of the drawing tools.
         */
            function (useSharedInstance) {
                var _this = this;
                if (useSharedInstance === void 0) {
                    useSharedInstance = true;
                }
                return new Promise(function (resolve, reject) {
                    _this.LoadModuleInstance('Microsoft.Maps.DrawingTools', useSharedInstance).then(function (o) {
                        resolve(o);
                    });
                });
            };
        /**
         * Gets the current zoom level of the map.
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
        BingMapService.prototype.GetZoom = /**
         * Gets the current zoom level of the map.
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
            function () {
                return this._map.then(function (map) { return map.getZoom(); });
            };
        /**
         * Loads a module into the Map.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?} callback - Callback to call once loading is complete.
         * @return {?}
         */
        BingMapService.prototype.LoadModule = /**
         * Loads a module into the Map.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?} callback - Callback to call once loading is complete.
         * @return {?}
         */
            function (moduleName, callback) {
                var _this = this;
                if (this._modules.has(moduleName)) {
                    callback();
                }
                else {
                    Microsoft.Maps.loadModule(moduleName, function () {
                        _this._modules.set(moduleName, null);
                        callback();
                    });
                }
            };
        /**
         * Loads a module into the Map and delivers and instance of the module payload.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?=} useSharedInstance
         * @return {?}
         */
        BingMapService.prototype.LoadModuleInstance = /**
         * Loads a module into the Map and delivers and instance of the module payload.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?=} useSharedInstance
         * @return {?}
         */
            function (moduleName, useSharedInstance) {
                var _this = this;
                if (useSharedInstance === void 0) {
                    useSharedInstance = true;
                }
                var /** @type {?} */ s = moduleName.substr(moduleName.lastIndexOf('.') + 1);
                if (this._modules.has(moduleName)) {
                    var /** @type {?} */ o = null;
                    if (!useSharedInstance) {
                        o = new ((Microsoft.Maps))[s](this._mapInstance);
                    }
                    else if (this._modules.get(moduleName) != null) {
                        o = this._modules.get(moduleName);
                    }
                    else {
                        o = new ((Microsoft.Maps))[s](this._mapInstance);
                        this._modules.set(moduleName, o);
                    }
                    return Promise.resolve(o);
                }
                else {
                    return new Promise(function (resolve, reject) {
                        try {
                            Microsoft.Maps.loadModule(moduleName, function () {
                                var /** @type {?} */ o = new ((Microsoft.Maps))[s](_this._mapInstance);
                                if (useSharedInstance) {
                                    _this._modules.set(moduleName, o);
                                }
                                else {
                                    _this._modules.set(moduleName, null);
                                }
                                resolve(o);
                            });
                        }
                        catch (e) {
                            reject('Could not load module or create instance.');
                        }
                    });
                }
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
        BingMapService.prototype.LocationToPoint = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
            function (loc) {
                return this._map.then(function (m) {
                    var /** @type {?} */ l = BingConversions.TranslateLocation(loc);
                    var /** @type {?} */ p = (m.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control));
                    if (p != null) {
                        return { x: p.x, y: p.y };
                    }
                    return null;
                });
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
        BingMapService.prototype.LocationsToPoints = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
            function (locs) {
                return this._map.then(function (m) {
                    var /** @type {?} */ l = locs.map(function (loc) { return BingConversions.TranslateLocation(loc); });
                    var /** @type {?} */ p = (m.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control));
                    return p ? p : new Array();
                });
            };
        /**
         * Centers the map on a geo location.
         *
         * \@memberof BingMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
        BingMapService.prototype.SetCenter = /**
         * Centers the map on a geo location.
         *
         * \@memberof BingMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
            function (latLng) {
                return this._map.then(function (map) {
                    return map.setView({
                        center: BingConversions.TranslateLocation(latLng)
                    });
                });
            };
        /**
         * Sets the generic map options.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        BingMapService.prototype.SetMapOptions = /**
         * Sets the generic map options.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    var /** @type {?} */ o = BingConversions.TranslateOptions(options);
                    m.setOptions(o);
                });
            };
        /**
         * Sets the view options of the map.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        BingMapService.prototype.SetViewOptions = /**
         * Sets the view options of the map.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    var /** @type {?} */ o = BingConversions.TranslateViewOptions(options);
                    m.setView(o);
                });
            };
        /**
         * Sets the zoom level of the map.
         *
         * \@memberof BingMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
        BingMapService.prototype.SetZoom = /**
         * Sets the zoom level of the map.
         *
         * \@memberof BingMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
            function (zoom) {
                return this._map.then(function (map) {
                    return map.setView({
                        zoom: zoom
                    });
                });
            };
        /**
         * Creates an event subscription
         *
         * \@memberof BingMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of tpye E that fires when the event occurs.
         *
         */
        BingMapService.prototype.SubscribeToMapEvent = /**
         * Creates an event subscription
         *
         * \@memberof BingMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of tpye E that fires when the event occurs.
         *
         */
            function (eventName) {
                var _this = this;
                var /** @type {?} */ eventNameTranslated = BingMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._map.then(function (m) {
                        Microsoft.Maps.Events.addHandler(m, eventNameTranslated, function (e) {
                            _this._zone.run(function () { return observer.next(e); });
                        });
                    });
                });
            };
        /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof BingMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
        BingMapService.prototype.TriggerMapEvent = /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof BingMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
            function (eventName) {
                return this._map.then(function (m) { return Microsoft.Maps.Events.invoke(m, eventName, null); });
            };
        BingMapService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMapService.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return BingMapService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Bing Maps V8 archtiecture. It serves
     * as the base class for basic layer ({\@link BingLayerService}) and cluster layer ({\@link BingClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Bing Maps V8 archtiecture. It serves
     * as the base class for basic layer ({\@link BingLayerService}) and cluster layer ({\@link BingClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */ BingLayerBase = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingLayerBase.
         * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.
         *
         * @memberof BingLayerBase
         */
        function BingLayerBase(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
            this._layers = new Map();
        }
        /**
         * Creates a marker in the layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
        BingLayerBase.prototype.CreateMarker = /**
         * Creates a marker in the layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
            function (layer, options) {
                var /** @type {?} */ payload = function (icon, l) {
                    var /** @type {?} */ loc = BingConversions.TranslateLocation(options.position);
                    var /** @type {?} */ o = BingConversions.TranslateMarkerOptions(options);
                    if (icon && icon !== '') {
                        o.icon = icon;
                    }
                    var /** @type {?} */ pushpin = new Microsoft.Maps.Pushpin(loc, o);
                    var /** @type {?} */ marker = new BingMarker(pushpin, null, l.NativePrimitve);
                    marker.IsFirst = options.isFirst;
                    marker.IsLast = options.isLast;
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return marker.Metadata.set(k, v); });
                    }
                    l.AddEntity(marker);
                    return marker;
                };
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    if (options.iconInfo && options.iconInfo.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            return (payload(s, l));
                        }
                        else {
                            return s.then(function (x) {
                                return (payload(x.icon, l));
                            });
                        }
                    }
                    else {
                        return (payload(null, l));
                    }
                });
            };
        /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof BingLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
        BingLayerBase.prototype.CreateMarkers = /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof BingLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
            function (options, markerIcon) {
                var /** @type {?} */ payload = function (icon, op) {
                    var /** @type {?} */ markers = op.map(function (mo) {
                        var /** @type {?} */ s;
                        var /** @type {?} */ o = BingConversions.TranslateMarkerOptions(mo);
                        if (icon && icon !== '') {
                            s = icon;
                        }
                        else if (o.icon) {
                            s = o.icon;
                        }
                        if (o.icon) {
                            delete o.icon;
                        }
                        var /** @type {?} */ loc = BingConversions.TranslateLocation(mo.position);
                        var /** @type {?} */ pushpin = new Microsoft.Maps.Pushpin(loc, o);
                        var /** @type {?} */ img = Marker.GetImageForMarker(s);
                        if (img != null) {
                            ((pushpin)).image = img;
                        }
                        var /** @type {?} */ marker = new BingMarker(pushpin, null, null);
                        marker.IsFirst = mo.isFirst;
                        marker.IsLast = mo.isLast;
                        if (mo.metadata) {
                            mo.metadata.forEach(function (v, k) { return marker.Metadata.set(k, v); });
                        }
                        return marker;
                    });
                    return markers;
                };
                var /** @type {?} */ p = new Promise(function (resolve, reject) {
                    if (markerIcon && markerIcon.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(markerIcon);
                        if (typeof (s) === 'string') {
                            resolve(payload(s, options));
                        }
                        else {
                            return s.then(function (x) {
                                resolve(payload(x.icon, options));
                            });
                        }
                    }
                    else {
                        resolve(payload(null, options));
                    }
                });
                return p;
            };
        /**
         * Deletes the layer
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
        BingLayerBase.prototype.DeleteLayer = /**
         * Deletes the layer
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.Delete();
                        _this._layers.delete(layer.Id);
                    });
                });
            };
        /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object or Layer Id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
        BingLayerBase.prototype.GetNativeLayer = /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object or Layer Id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
            function (layer) {
                var /** @type {?} */ p = null;
                if (typeof (layer) === 'number') {
                    p = this._layers.get(layer);
                }
                else {
                    p = this._layers.get(((layer)).Id);
                }
                return p;
            };
        ///
        /// Protected methods
        ///
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * @param id - Layer Id.
         * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.
         *
         * @memberof BingLayerBase
         */
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof BingLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
        BingLayerBase.prototype.GetLayerById = /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof BingLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
            function (id) {
                var /** @type {?} */ p;
                this._layers.forEach(function (l, k) {
                    if (k === id) {
                        p = l;
                    }
                });
                return p;
            };
        return BingLayerBase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements the {\@link LayerService} contract for a  Bing Maps V8 specific implementation.
     *
     * @export
     */
    var BingLayerService = (function (_super) {
        __extends(BingLayerService, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingLayerService.
         * @param _mapService - Instance of the Bing Maps Service. Will generally be injected.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof BingLayerService
         */
        function BingLayerService(_mapService, _zone) {
            return _super.call(this, _mapService, _zone) || this;
        }
        /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
        BingLayerService.prototype.AddLayer = /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
            function (layer) {
                var /** @type {?} */ layerPromise = this._mapService.CreateLayer({ id: layer.Id });
                this._layers.set(layer.Id, layerPromise);
                layerPromise.then(function (l) { return l.SetVisible(layer.Visible); });
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        BingLayerService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                var _this = this;
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ locs = BingConversions.TranslatePaths(options.paths);
                    var /** @type {?} */ o = BingConversions.TranslatePolygonOptions(options);
                    var /** @type {?} */ poly = new Microsoft.Maps.Polygon(locs, o);
                    var /** @type {?} */ polygon = new BingPolygon(poly, /** @type {?} */ (_this._mapService), l.NativePrimitve);
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return polygon.Metadata.set(k, v); });
                    }
                    if (options.title && options.title !== '') {
                        polygon.Title = options.title;
                    }
                    if (options.showLabel != null) {
                        polygon.ShowLabel = options.showLabel;
                    }
                    if (options.showTooltip != null) {
                        polygon.ShowTooltip = options.showTooltip;
                    }
                    if (options.labelMaxZoom != null) {
                        polygon.LabelMaxZoom = options.labelMaxZoom;
                    }
                    if (options.labelMinZoom != null) {
                        polygon.LabelMinZoom = options.labelMinZoom;
                    }
                    l.AddEntity(polygon);
                    return polygon;
                });
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        BingLayerService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                var _this = this;
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ polygons = new Promise(function (resolve, reject) {
                        var /** @type {?} */ polys = options.map(function (o) {
                            var /** @type {?} */ locs = BingConversions.TranslatePaths(o.paths);
                            var /** @type {?} */ op = BingConversions.TranslatePolygonOptions(o);
                            var /** @type {?} */ poly = new Microsoft.Maps.Polygon(locs, op);
                            var /** @type {?} */ polygon = new BingPolygon(poly, /** @type {?} */ (_this._mapService), l.NativePrimitve);
                            if (o.title && o.title !== '') {
                                polygon.Title = o.title;
                            }
                            if (o.metadata) {
                                o.metadata.forEach(function (v, k) { return polygon.Metadata.set(k, v); });
                            }
                            return polygon;
                        });
                        resolve(polys);
                    });
                    return polygons;
                });
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
        BingLayerService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                var _this = this;
                var /** @type {?} */ p = this.GetLayerById(layer);
                var /** @type {?} */ polyline;
                var /** @type {?} */ line;
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ locs = BingConversions.TranslatePaths(options.path);
                    var /** @type {?} */ o = BingConversions.TranslatePolylineOptions(options);
                    if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {
                        polyline = new Microsoft.Maps.Polyline(locs[0], o);
                        line = new BingPolyline(polyline, _this._mapService.MapInstance, l.NativePrimitve);
                        l.AddEntity(line);
                        if (options.metadata) {
                            options.metadata.forEach(function (v, k) { return line.Metadata.set(k, v); });
                        }
                        if (options.title && options.title !== '') {
                            line.Title = options.title;
                        }
                        if (options.showTooltip != null) {
                            line.ShowTooltip = options.showTooltip;
                        }
                        return line;
                    }
                    else {
                        var /** @type {?} */ lines_1 = new Array();
                        locs.forEach(function (x) {
                            polyline = new Microsoft.Maps.Polyline(x, o);
                            line = new BingPolyline(polyline, _this._mapService.MapInstance, l.NativePrimitve);
                            l.AddEntity(line);
                            if (options.metadata) {
                                options.metadata.forEach(function (v, k) { return line.Metadata.set(k, v); });
                            }
                            if (options.title && options.title !== '') {
                                line.Title = options.title;
                            }
                            if (options.showTooltip != null) {
                                line.ShowTooltip = options.showTooltip;
                            }
                            lines_1.push(line);
                        });
                        return lines_1;
                    }
                });
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        BingLayerService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                var _this = this;
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ polylines = new Promise(function (resolve, reject) {
                        var /** @type {?} */ polys = options.map(function (o) {
                            var /** @type {?} */ locs = BingConversions.TranslatePaths(o.path);
                            var /** @type {?} */ op = BingConversions.TranslatePolylineOptions(o);
                            if (locs && locs.length > 0 && !Array.isArray(locs[0])) {
                                var /** @type {?} */ poly = new Microsoft.Maps.Polyline(locs[0], op);
                                var /** @type {?} */ polyline_1 = new BingPolyline(poly, _this._mapService.MapInstance, l.NativePrimitve);
                                if (o.title && o.title !== '') {
                                    polyline_1.Title = o.title;
                                }
                                if (o.metadata) {
                                    o.metadata.forEach(function (v, k) { return polyline_1.Metadata.set(k, v); });
                                }
                                return polyline_1;
                            }
                            else {
                                var /** @type {?} */ lines_2 = new Array();
                                locs.forEach(function (x) {
                                    var /** @type {?} */ poly = new Microsoft.Maps.Polyline(x, op);
                                    var /** @type {?} */ polyline = new BingPolyline(poly, _this._mapService.MapInstance, l.NativePrimitve);
                                    if (o.metadata) {
                                        o.metadata.forEach(function (v, k) { return polyline.Metadata.set(k, v); });
                                    }
                                    if (o.title && o.title !== '') {
                                        polyline.Title = o.title;
                                    }
                                    lines_2.push(polyline);
                                });
                                return lines_2;
                            }
                        });
                        resolve(polys);
                    });
                    return polylines;
                });
            };
        BingLayerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingLayerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return BingLayerService;
    }(BingLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements the {\@link ClusterService} contract for a  Bing Maps V8 specific implementation.
     *
     * @export
     */
    var BingClusterService = (function (_super) {
        __extends(BingClusterService, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingClusterService.
         * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof BingClusterService
         */
        function BingClusterService(_mapService, _zone) {
            return _super.call(this, _mapService, _zone) || this;
        }
        /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object.
         * Generally, MapLayer will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
        BingClusterService.prototype.AddLayer = /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object.
         * Generally, MapLayer will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ options = {
                    id: layer.Id,
                    visible: layer.Visible,
                    clusteringEnabled: layer.ClusteringEnabled,
                    placementMode: layer.ClusterPlacementMode
                };
                if (layer.GridSize) {
                    options.gridSize = layer.GridSize;
                }
                if (layer.LayerOffset) {
                    options.layerOffset = layer.LayerOffset;
                }
                if (layer.ZIndex) {
                    options.zIndex = layer.ZIndex;
                }
                if (layer.IconInfo) {
                    options.clusteredPinCallback = function (pin) { _this.CreateClusterPushPin(pin, layer); };
                }
                if (layer.CustomMarkerCallback) {
                    options.clusteredPinCallback = function (pin) { _this.CreateCustomClusterPushPin(pin, layer); };
                }
                if (layer.SpiderClusterOptions) {
                    options.spiderClusterOptions = layer.SpiderClusterOptions;
                }
                var /** @type {?} */ layerPromise = this._mapService.CreateClusterLayer(options);
                ((this._mapService)).MapPromise.then(function (m) {
                    Microsoft.Maps.Events.addHandler(m, 'viewchangeend', function (e) {
                        if (layer.ClusteringEnabled && m.getZoom() === 19) {
                            layerPromise.then(function (l) {
                                l.SetOptions({ id: layer.Id, clusteringEnabled: false });
                            });
                        }
                        if (layer.ClusteringEnabled && m.getZoom() < 19) {
                            layerPromise.then(function (l) {
                                if (!l.GetOptions().clusteringEnabled) {
                                    l.SetOptions({ id: layer.Id, clusteringEnabled: true });
                                }
                            });
                        }
                    });
                });
                this._layers.set(layer.Id, layerPromise);
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        BingClusterService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        BingClusterService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
        BingClusterService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        BingClusterService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
        BingClusterService.prototype.StartClustering = /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.StartClustering();
                    });
                });
            };
        /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
        BingClusterService.prototype.StopClustering = /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.StopClustering();
                    });
                });
            };
        /**
         * Creates the default cluster pushpin as a callback from BingMaps when clustering occurs. The {\@link ClusterLayerDirective} model
         * can provide an IconInfo property that would govern the apparenace of the pin. This method will assign the same pin to all
         * clusters in the layer.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component representing the layer.
         *
         * @return {?}
         */
        BingClusterService.prototype.CreateClusterPushPin = /**
         * Creates the default cluster pushpin as a callback from BingMaps when clustering occurs. The {\@link ClusterLayerDirective} model
         * can provide an IconInfo property that would govern the apparenace of the pin. This method will assign the same pin to all
         * clusters in the layer.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component representing the layer.
         *
         * @return {?}
         */
            function (cluster, layer) {
                var _this = this;
                this._layers.get(layer.Id).then(function (l) {
                    if (layer.IconInfo) {
                        var /** @type {?} */ o_1 = {};
                        var /** @type {?} */ payload_1 = function (ico, info) {
                            o_1.icon = ico;
                            o_1.anchor = new Microsoft.Maps.Point((info.size && info.markerOffsetRatio) ? (info.size.width * info.markerOffsetRatio.x) : 0, (info.size && info.markerOffsetRatio) ? (info.size.height * info.markerOffsetRatio.y) : 0);
                            cluster.setOptions(o_1);
                        };
                        var /** @type {?} */ icon = Marker.CreateMarker(layer.IconInfo);
                        if (typeof (icon) === 'string') {
                            payload_1(icon, layer.IconInfo);
                        }
                        else {
                            icon.then(function (x) {
                                payload_1(x.icon, x.iconInfo);
                            });
                        }
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {
                        Microsoft.Maps.Events.addHandler(cluster, 'click', function (e) { return _this.ZoomIntoCluster(e); });
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.Spider) {
                        Microsoft.Maps.Events.addHandler(cluster, 'dblclick', function (e) { return _this.ZoomIntoCluster(e); });
                        l.InitializeSpiderClusterSupport();
                    }
                });
            };
        /**
         * Provides a hook for consumers to provide a custom function to create cluster bins for a cluster. This is particuarily useful
         * in situation where the pin should differ to represent information about the pins in the cluster.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component
         * representing the layer. Set the {\@link ClusterLayerDirective.CustomMarkerCallback}
         * property to define the callback generating the pin.
         *
         * @return {?}
         */
        BingClusterService.prototype.CreateCustomClusterPushPin = /**
         * Provides a hook for consumers to provide a custom function to create cluster bins for a cluster. This is particuarily useful
         * in situation where the pin should differ to represent information about the pins in the cluster.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component
         * representing the layer. Set the {\@link ClusterLayerDirective.CustomMarkerCallback}
         * property to define the callback generating the pin.
         *
         * @return {?}
         */
            function (cluster, layer) {
                var _this = this;
                this._layers.get(layer.Id).then(function (l) {
                    // assemble markers for callback
                    var /** @type {?} */ m = new Array();
                    cluster.containedPushpins.forEach(function (p) {
                        var /** @type {?} */ marker = l.GetMarkerFromBingMarker(p);
                        if (marker) {
                            m.push(marker);
                        }
                    });
                    var /** @type {?} */ iconInfo = { markerType: MarkerTypeId.None };
                    var /** @type {?} */ o = {};
                    o.icon = layer.CustomMarkerCallback(m, iconInfo);
                    if (o.icon !== '') {
                        o.anchor = new Microsoft.Maps.Point((iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.width * iconInfo.markerOffsetRatio.x) : 0, (iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.height * iconInfo.markerOffsetRatio.y) : 0);
                        if (iconInfo.textOffset) {
                            o.textOffset = new Microsoft.Maps.Point(iconInfo.textOffset.x, iconInfo.textOffset.y);
                        }
                        cluster.setOptions(o);
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {
                        Microsoft.Maps.Events.addHandler(cluster, 'click', function (e) { return _this.ZoomIntoCluster(e); });
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.Spider) {
                        Microsoft.Maps.Events.addHandler(cluster, 'dblclick', function (e) { return _this.ZoomIntoCluster(e); });
                        l.InitializeSpiderClusterSupport();
                    }
                });
            };
        /**
         * Zooms into the cluster on click so that the members of the cluster comfortable fit into the zommed area.
         *
         * \@memberof BingClusterService
         * @param {?} e - Mouse Event.
         *
         * @return {?}
         */
        BingClusterService.prototype.ZoomIntoCluster = /**
         * Zooms into the cluster on click so that the members of the cluster comfortable fit into the zommed area.
         *
         * \@memberof BingClusterService
         * @param {?} e - Mouse Event.
         *
         * @return {?}
         */
            function (e) {
                var /** @type {?} */ pin = (e.target);
                if (pin && pin.containedPushpins) {
                    var /** @type {?} */ bounds_1;
                    var /** @type {?} */ locs_1 = new Array();
                    pin.containedPushpins.forEach(function (p) { return locs_1.push(p.getLocation()); });
                    bounds_1 = Microsoft.Maps.LocationRect.fromLocations(locs_1);
                    // Zoom into the bounding box of the cluster.
                    // Add a padding to compensate for the pixel area of the pushpins.
                    ((this._mapService)).MapPromise.then(function (m) {
                        m.setView({ bounds: bounds_1, padding: 75 });
                    });
                }
            };
        BingClusterService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingClusterService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return BingClusterService;
    }(BingLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the Polygon Service abstract class for Bing Maps V8.
     *
     * @export
     */
    var BingPolygonService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingPolygonService.
         * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.
         * @param _layerService - {@link BingLayerService} instance.
         * The concrete {@link BingLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof BingPolygonService
         */
        function BingPolygonService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polygons = new Map();
        }
        /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
        BingPolygonService.prototype.AddPolygon = /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
            function (polygon) {
                var /** @type {?} */ o = {
                    id: polygon.Id,
                    clickable: polygon.Clickable,
                    draggable: polygon.Draggable,
                    editable: polygon.Editable,
                    fillColor: polygon.FillColor,
                    fillOpacity: polygon.FillOpacity,
                    geodesic: polygon.Geodesic,
                    labelMaxZoom: polygon.LabelMaxZoom,
                    labelMinZoom: polygon.LabelMinZoom,
                    paths: polygon.Paths,
                    showLabel: polygon.ShowLabel,
                    showTooltip: polygon.ShowTooltip,
                    strokeColor: polygon.StrokeColor,
                    strokeOpacity: polygon.StrokeOpacity,
                    strokeWeight: polygon.StrokeWeight,
                    title: polygon.Title,
                    visible: polygon.Visible,
                    zIndex: polygon.zIndex,
                };
                var /** @type {?} */ polygonPromise;
                if (polygon.InCustomLayer) {
                    polygonPromise = this._layerService.CreatePolygon(polygon.LayerId, o);
                }
                else {
                    polygonPromise = this._mapService.CreatePolygon(o);
                }
                this._polygons.set(polygon, polygonPromise);
            };
        /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof BingPolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingPolygonService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof BingPolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polygon) {
                var _this = this;
                var /** @type {?} */ b = new rxjs.Subject();
                if (eventName === 'mousemove') {
                    return b.asObservable();
                }
                if (eventName === 'rightclick') {
                    return b.asObservable();
                }
                return rxjs.Observable.create(function (observer) {
                    _this._polygons.get(polygon).then(function (p) {
                        p.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes a polygon.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
        BingPolygonService.prototype.DeletePolygon = /**
         * Deletes a polygon.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
            function (polygon) {
                var _this = this;
                var /** @type {?} */ m = this._polygons.get(polygon);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        l.Delete();
                        _this._polygons.delete(polygon);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof BingPolygonService
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        BingPolygonService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof BingPolygonService
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                var /** @type {?} */ x = (e);
                return { latitude: x.location.latitude, longitude: x.location.longitude };
            };
        /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
        BingPolygonService.prototype.GetNativePolygon = /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
            function (polygon) {
                return this._polygons.get(polygon);
            };
        /**
         * Set the polygon options.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
        BingPolygonService.prototype.SetOptions = /**
         * Set the polygon options.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
            function (polygon, options) {
                return this._polygons.get(polygon).then(function (l) { l.SetOptions(options); });
            };
        /**
         * Updates the Polygon path
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
        BingPolygonService.prototype.UpdatePolygon = /**
         * Updates the Polygon path
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
            function (polygon) {
                var /** @type {?} */ m = this._polygons.get(polygon);
                if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    if (Array.isArray(polygon.Paths[0])) {
                        l.SetPaths(polygon.Paths);
                    }
                    else {
                        l.SetPath(/** @type {?} */ (polygon.Paths));
                    }
                });
            };
        BingPolygonService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingPolygonService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return BingPolygonService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the Polyline Service abstract class for Bing Maps V8.
     *
     * @export
     */
    var BingPolylineService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingPolylineService.
         * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link BingLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof BingPolylineService
         */
        function BingPolylineService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polylines = new Map();
        }
        /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * corresponding layer.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
        BingPolylineService.prototype.AddPolyline = /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * corresponding layer.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
            function (polyline) {
                var /** @type {?} */ o = {
                    id: polyline.Id,
                    clickable: polyline.Clickable,
                    draggable: polyline.Draggable,
                    editable: polyline.Editable,
                    geodesic: polyline.Geodesic,
                    path: polyline.Path,
                    showTooltip: polyline.ShowTooltip,
                    strokeColor: polyline.StrokeColor,
                    strokeOpacity: polyline.StrokeOpacity,
                    strokeWeight: polyline.StrokeWeight,
                    title: polyline.Title,
                    visible: polyline.Visible,
                    zIndex: polyline.zIndex,
                };
                var /** @type {?} */ polylinePromise;
                if (polyline.InCustomLayer) {
                    polylinePromise = this._layerService.CreatePolyline(polyline.LayerId, o);
                }
                else {
                    polylinePromise = this._mapService.CreatePolyline(o);
                }
                this._polylines.set(polyline, polylinePromise);
            };
        /**
         * Registers an event delegate for a line.
         *
         * \@memberof BingPolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingPolylineService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a line.
         *
         * \@memberof BingPolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polyline) {
                var _this = this;
                var /** @type {?} */ b = new rxjs.Subject();
                if (eventName === 'mousemove') {
                    return b.asObservable();
                }
                if (eventName === 'rightclick') {
                    return b.asObservable();
                }
                return rxjs.Observable.create(function (observer) {
                    _this._polylines.get(polyline).then(function (p) {
                        var /** @type {?} */ x = Array.isArray(p) ? p : [p];
                        x.forEach(function (line) { return line.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); }); });
                    });
                });
            };
        /**
         * Deletes a polyline.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
        BingPolylineService.prototype.DeletePolyline = /**
         * Deletes a polyline.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
            function (polyline) {
                var _this = this;
                var /** @type {?} */ m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                        x.forEach(function (line) { return line.Delete(); });
                        _this._polylines.delete(polyline);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the marker on the click location
         *
         * @abstract
         * \@memberof BingPolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        BingPolylineService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the marker on the click location
         *
         * @abstract
         * \@memberof BingPolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.location) {
                    return null;
                }
                return { latitude: e.location.latitude, longitude: e.location.longitude };
            };
        /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
        BingPolylineService.prototype.GetNativePolyline = /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
            function (polyline) {
                return this._polylines.get(polyline);
            };
        /**
         * Set the polyline options.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
        BingPolylineService.prototype.SetOptions = /**
         * Set the polyline options.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
            function (polyline, options) {
                return this._polylines.get(polyline).then(function (l) {
                    var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                    x.forEach(function (line) { return line.SetOptions(options); });
                });
            };
        /**
         * Updates the Polyline path
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
        BingPolylineService.prototype.UpdatePolyline = /**
         * Updates the Polyline path
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
            function (polyline) {
                var _this = this;
                var /** @type {?} */ m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                        var /** @type {?} */ p = polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? /** @type {?} */ (polyline.Path) : /** @type {?} */ ([polyline.Path]);
                        x.forEach(function (line, index) {
                            if (p.length > index) {
                                line.SetPath(p[index]);
                            }
                        });
                        if (Array.isArray(l) && l.length > p.length) {
                            l.splice(p.length - 1).forEach(function (line) { return line.Delete(); });
                        }
                    });
                });
            };
        BingPolylineService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingPolylineService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return BingPolylineService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements a factory to create thre necessary Bing Maps V8 specific service instances.
     *
     * @export
     */
    var BingMapServiceFactory = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMapServiceFactory.
         * @param _loader - {@link MapAPILoader} implementation for the Bing Map V8 provider.
         * @param _zone - NgZone object to implement zone aware promises.
         *
         * @memberof BingMapServiceFactory
         */
        function BingMapServiceFactory(_loader, _zone) {
            this._loader = _loader;
            this._zone = _zone;
        }
        /**
         * Creates the map service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link BingMapService}.
         *
         */
        BingMapServiceFactory.prototype.Create = /**
         * Creates the map service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link BingMapService}.
         *
         */
            function () {
                return new BingMapService(this._loader, this._zone);
            };
        /**
         * Creates the cluster service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link BingClusterService}.
         *
         */
        BingMapServiceFactory.prototype.CreateClusterService = /**
         * Creates the cluster service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link BingClusterService}.
         *
         */
            function (_mapService) {
                return new BingClusterService(_mapService, this._zone);
            };
        /**
         * Creates thh info box service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link BingInfoBoxService}.
         *
         */
        BingMapServiceFactory.prototype.CreateInfoBoxService = /**
         * Creates thh info box service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link BingInfoBoxService}.
         *
         */
            function (_mapService) {
                return new BingInfoBoxService(_mapService, this._zone);
            };
        /**
         * Creates the layer service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link BingLayerService}.
         *
         */
        BingMapServiceFactory.prototype.CreateLayerService = /**
         * Creates the layer service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link BingLayerService}.
         *
         */
            function (_mapService) {
                return new BingLayerService(_mapService, this._zone);
            };
        /**
         * Creates the marker service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link BingMarkerService}.
         *
         */
        BingMapServiceFactory.prototype.CreateMarkerService = /**
         * Creates the marker service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link BingMarkerService}.
         *
         */
            function (_mapService, _layerService, _clusterService) {
                return new BingMarkerService(_mapService, _layerService, _clusterService, this._zone);
            };
        /**
         * Creates the polygon service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
        BingMapServiceFactory.prototype.CreatePolygonService = /**
         * Creates the polygon service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new BingPolygonService(map, layers, this._zone);
            };
        /**
         * Creates the polyline service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
        BingMapServiceFactory.prototype.CreatePolylineService = /**
         * Creates the polyline service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new BingPolylineService(map, layers, this._zone);
            };
        BingMapServiceFactory.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMapServiceFactory.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return BingMapServiceFactory;
    }());
    /**
     * Creates a new instance of a plaform specific MapServiceFactory.
     *
     * @export
     * @param {?} apiLoader - An {\@link MapAPILoader} instance. This is expected to the a {\@link BingMapAPILoader}.
     * @param {?} zone - An NgZone instance to provide zone aware promises.
     *
     * @return {?} -  A {\@link MapServiceFactory} instance.
     */
    function BingMapServiceFactoryFactory(apiLoader, zone) {
        return new BingMapServiceFactory(apiLoader, zone);
    }
    /**
     * Creates a new instance of a plaform specific MapLoaderFactory.
     *
     * @export
     * @return {?} - A {\@link MapAPILoader} instance.
     */
    function BingMapLoaderFactory() {
        return new BingMapAPILoader(new BingMapAPILoaderConfig(), new WindowRef(), new DocumentRef());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Google Maps archtiecture. It serves
     * as the base class for basic layer ({\@link GoogleLayerService}) and cluster layer ({\@link GoogleClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Google Maps archtiecture. It serves
     * as the base class for basic layer ({\@link GoogleLayerService}) and cluster layer ({\@link GoogleClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */ GoogleLayerBase = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleLayerBase.
         * @param _mapService - Concrete {@link MapService} implementation for Google Maps.
         * An instance of {@link GoogleMapService}.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof GoogleLayerBase
         */
        function GoogleLayerBase(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
        }
        /**
         * Deletes the layer
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
        GoogleLayerBase.prototype.DeleteLayer = /**
         * Deletes the layer
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.Delete();
                        _this._layers.delete(layer.Id);
                    });
                });
            };
        /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object or layer id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
        GoogleLayerBase.prototype.GetNativeLayer = /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object or layer id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
            function (layer) {
                var /** @type {?} */ p = null;
                if (typeof (layer) === 'number') {
                    p = this._layers.get(layer);
                }
                else {
                    p = this._layers.get(((layer)).Id);
                }
                return p;
            };
        /**
         * Creates a marker in the layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
        GoogleLayerBase.prototype.CreateMarker = /**
         * Creates a marker in the layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
            function (layer, options) {
                var /** @type {?} */ mp = this._mapService.MapPromise;
                var /** @type {?} */ lp = this._layers.get(layer);
                return Promise.all([mp, lp]).then(function (_a) {
                    var _b = __read(_a, 2), map = _b[0], l = _b[1];
                    var /** @type {?} */ payload = function (x) {
                        var /** @type {?} */ marker = new google.maps.Marker(x);
                        if (options.metadata) {
                            options.metadata.forEach(function (val, key) { return marker.Metadata.set(key, val); });
                        }
                        marker.setMap(map);
                        var /** @type {?} */ m = new GoogleMarker(marker);
                        m.IsFirst = options.isFirst;
                        m.IsLast = options.isLast;
                        if (options.metadata) {
                            options.metadata.forEach(function (val, key) { return m.Metadata.set(key, val); });
                        }
                        l.AddEntity(m);
                        return m;
                    };
                    var /** @type {?} */ o = GoogleConversions.TranslateMarkerOptions(options);
                    if (options.iconInfo && options.iconInfo.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            o.icon = s;
                            return payload(o);
                        }
                        else {
                            return s.then(function (x) {
                                o.icon = x.icon;
                                return payload(o);
                            });
                        }
                    }
                    else {
                        return payload(o);
                    }
                });
            };
        /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
        GoogleLayerBase.prototype.CreateMarkers = /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
            function (options, markerIcon) {
                var /** @type {?} */ payload = function (icon) {
                    var /** @type {?} */ markers = options.map(function (mo) {
                        var /** @type {?} */ o = GoogleConversions.TranslateMarkerOptions(mo);
                        if (icon && icon !== '') {
                            o.icon = icon;
                        }
                        var /** @type {?} */ pushpin = new google.maps.Marker(o);
                        var /** @type {?} */ marker = new GoogleMarker(pushpin);
                        marker.IsFirst = mo.isFirst;
                        marker.IsLast = mo.isLast;
                        if (mo.metadata) {
                            mo.metadata.forEach(function (val, key) { return marker.Metadata.set(key, val); });
                        }
                        return marker;
                    });
                    return markers;
                };
                var /** @type {?} */ p = new Promise(function (resolve, reject) {
                    if (markerIcon && markerIcon.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(markerIcon);
                        if (typeof (s) === 'string') {
                            resolve(payload(s));
                        }
                        else {
                            return s.then(function (x) {
                                resolve(payload(x.icon));
                            });
                        }
                    }
                    else {
                        resolve(payload(null));
                    }
                });
                return p;
            };
        ///
        /// Protected methods
        ///
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * @param id - Layer Id.
         * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.
         *
         * @memberof GoogleLayerBase
         */
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof GoogleLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
        GoogleLayerBase.prototype.GetLayerById = /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof GoogleLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
            function (id) {
                var /** @type {?} */ p;
                this._layers.forEach(function (l, k) {
                    if (k === id) {
                        p = l;
                    }
                });
                return p;
            };
        return GoogleLayerBase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var GoogleClusterService = (function (_super) {
        __extends(GoogleClusterService, _super);
        ///
        /// Constructors
        ///
        /**
         * Creates an instance of GoogleClusterService.
         * @param _mapService
         * @param _zone
         * @memberof GoogleClusterService
         */
        function GoogleClusterService(_mapService, _zone) {
            var _this = _super.call(this, _mapService, _zone) || this;
            _this._layers = new Map();
            _this._layerStyles = new Map();
            return _this;
        }
        /**
         * Creates the cluster icon from the styles
         *
         * \@memberof GoogleClusterService
         * @param {?} styles
         * @return {?} - Promise that when resolved contains an Array of IClusterIconInfo objects
         * containing the hydrated cluster icons.
         */
        GoogleClusterService.CreateClusterIcons = /**
         * Creates the cluster icon from the styles
         *
         * \@memberof GoogleClusterService
         * @param {?} styles
         * @return {?} - Promise that when resolved contains an Array of IClusterIconInfo objects
         * containing the hydrated cluster icons.
         */
            function (styles) {
                var /** @type {?} */ i = new Promise(function (resolve, reject) {
                    var /** @type {?} */ pa = new Array();
                    styles.forEach(function (style, index) {
                        if (style.iconInfo) {
                            var /** @type {?} */ s = Marker.CreateMarker(style.iconInfo);
                            if (typeof (s) === 'string') {
                                style.url = s;
                                if (style.width == null) {
                                    style.width = style.iconInfo.size.width;
                                    style.height = style.iconInfo.size.height;
                                }
                                if (style.iconInfo.markerOffsetRatio && style.iconInfo.size && style.anchor == null) {
                                    var /** @type {?} */ o = style.iconInfo;
                                    style.anchor = [
                                        o.size.width * o.markerOffsetRatio.x,
                                        o.size.height * o.markerOffsetRatio.y
                                    ];
                                }
                                delete style.iconInfo;
                            }
                            else {
                                s.then(function (x) {
                                    style.url = x.icon;
                                    if (style.width == null) {
                                        style.width = x.iconInfo.size.width;
                                        style.height = x.iconInfo.size.height;
                                    }
                                    if (x.iconInfo.markerOffsetRatio && x.iconInfo.size && style.anchor == null) {
                                        var /** @type {?} */ o = x.iconInfo;
                                        style.anchor = [
                                            o.size.width * o.markerOffsetRatio.x,
                                            o.size.height * o.markerOffsetRatio.y
                                        ];
                                    }
                                    delete style.iconInfo;
                                });
                                pa.push(s);
                            }
                        }
                    });
                    if (pa.length === 0) {
                        resolve(styles);
                    }
                    else {
                        Promise.all(pa).then(function () {
                            resolve(styles);
                        });
                    }
                });
                return i;
            };
        /**
         * Adds the cluster layer to the map
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
        GoogleClusterService.prototype.AddLayer = /**
         * Adds the cluster layer to the map
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ options = {
                    id: layer.Id,
                    visible: layer.Visible,
                    clusteringEnabled: layer.ClusteringEnabled,
                    zoomOnClick: layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster
                };
                if (layer.GridSize) {
                    options.gridSize = layer.GridSize;
                }
                if (layer.MinimumClusterSize) {
                    options.minimumClusterSize = layer.MinimumClusterSize;
                }
                if (layer.Styles) {
                    options.styles = layer.Styles;
                }
                if (layer.UseDynamicSizeMarkers) {
                    options.styles = null;
                    // do not to attempt to setup styles here as the dynamic call back will generate them.
                }
                else {
                    options.styles = [{
                            height: 30,
                            width: 35,
                            textColor: 'white',
                            textSize: 11,
                            backgroundPosition: 'center',
                            iconInfo: {
                                markerType: MarkerTypeId.FontMarker,
                                fontName: 'FontAwesome',
                                fontSize: 30,
                                color: 'green',
                                text: '\uF111'
                            }
                        }];
                }
                var /** @type {?} */ dynamicClusterCallback = function (markers, numStyles, clusterer) {
                    // dynamically ensure that the necessary style for this cluster icon exists and
                    // the clusterer is already hooked up to the styles array via pointer, so we only
                    // need to update the style. Since the clusterer re-renders a cluster icon is the
                    // the marker count changes, we will only need to retain the current icon as opposed
                    // to all cluster icon.
                    var /** @type {?} */ styles = _this._layerStyles.get(layer.Id);
                    var /** @type {?} */ iconInfo = {
                        markerType: MarkerTypeId.None
                    };
                    var /** @type {?} */ icon = layer.CustomMarkerCallback(/** @type {?} */ (markers), iconInfo);
                    styles[0] = {
                        url: "\"data:image/svg+xml;utf8," + icon + "\"",
                        height: iconInfo.size.height,
                        width: iconInfo.size.width,
                        textColor: 'white',
                        textSize: 11,
                        backgroundPosition: 'center',
                    };
                    return {
                        text: markers.length.toString(),
                        index: 1
                    };
                };
                var /** @type {?} */ resetStyles = function (clusterer) {
                    if (_this._layerStyles.has(layer.Id)) {
                        _this._layerStyles.get(layer.Id).splice(0);
                    }
                    else {
                        var /** @type {?} */ styles = new Array();
                        styles.push({});
                        _this._layerStyles.set(layer.Id, styles);
                        clusterer.setStyles(styles);
                        // this is important for dynamic styles as the pointer to this array gets passed
                        // around key objects in the clusterer. Therefore, it must be initialized here in order for
                        // updates to the styles to be visible.
                        // also, we need to add at least one style to prevent the default styles from being picked up.
                    }
                };
                var /** @type {?} */ layerPromise = this._mapService.CreateClusterLayer(options);
                this._layers.set(layer.Id, layerPromise);
                layerPromise.then(function (l) {
                    var /** @type {?} */ clusterer = (l.NativePrimitve);
                    if (options.styles) {
                        var /** @type {?} */ s = GoogleClusterService.CreateClusterIcons(options.styles);
                        s.then(function (x) {
                            clusterer.setStyles(/** @type {?} */ (x));
                        });
                    }
                    else {
                        resetStyles(clusterer);
                        _this._mapService.MapPromise.then(function (m) {
                            m.addListener('zoom_changed', function () {
                                resetStyles(clusterer);
                            });
                        });
                        clusterer.setCalculator(function (m, n) {
                            return dynamicClusterCallback(m, n, clusterer);
                        });
                    }
                });
            };
        /**
         * Create a marker in the cluster
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @param {?} options
         * @return {?}
         */
        GoogleClusterService.prototype.CreateMarker = /**
         * Create a marker in the cluster
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @param {?} options
         * @return {?}
         */
            function (layer, options) {
                var _this = this;
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    return _this._mapService.CreateMarker(options)
                        .then(function (marker) {
                        marker.IsFirst = options.isFirst;
                        marker.IsLast = options.isLast;
                        l.AddEntity(marker);
                        return marker;
                    });
                });
            };
        /**
         * Starts the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
        GoogleClusterService.prototype.StartClustering = /**
         * Starts the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                return Promise.resolve();
            };
        /**
         * Stops the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
        GoogleClusterService.prototype.StopClustering = /**
         * Stops the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                return Promise.resolve();
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        GoogleClusterService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        GoogleClusterService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an
         * array of polygons for complex paths) model.
         *
         */
        GoogleClusterService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an
         * array of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        GoogleClusterService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        GoogleClusterService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleClusterService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return GoogleClusterService;
    }(GoogleLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var GoogleInfoBoxService = (function (_super) {
        __extends(GoogleInfoBoxService, _super);
        ///
        /// Constructors
        ///
        /**
         * Creates an instance of GoogleInfoBoxService.
         * @param _mapService
         * @param _markerService
         * @param _zone
         *
         * @memberof GoogleInfoBoxService
         */
        function GoogleInfoBoxService(_mapService, _markerService, _zone) {
            var _this = _super.call(this) || this;
            _this._mapService = _mapService;
            _this._markerService = _markerService;
            _this._zone = _zone;
            _this._boxes = new Map();
            return _this;
        }
        /**
         * Creates a new instance of an info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.AddInfoWindow = /**
         * Creates a new instance of an info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
            function (info) {
                var /** @type {?} */ options = {};
                if (info.HtmlContent !== '') {
                    options.htmlContent = info.HtmlContent;
                }
                else {
                    options.title = info.Title;
                    options.description = info.Description;
                }
                if (info.xOffset || info.yOffset) {
                    if (options.pixelOffset == null) {
                        options.pixelOffset = { x: 0, y: 0 };
                    }
                    if (info.xOffset) {
                        options.pixelOffset.x = info.xOffset;
                    }
                    if (info.yOffset) {
                        options.pixelOffset.y = info.yOffset;
                    }
                }
                options.disableAutoPan = info.DisableAutoPan;
                options.visible = info.Visible;
                if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {
                    options.position = { latitude: info.Latitude, longitude: info.Longitude };
                }
                var /** @type {?} */ infoWindowPromise = this._mapService.CreateInfoWindow(options);
                this._boxes.set(info, infoWindowPromise);
            };
        /**
         * Closes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @return {?} -  A promise that is resolved when the info box is closed.
         *
         */
        GoogleInfoBoxService.prototype.Close = /**
         * Closes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @return {?} -  A promise that is resolved when the info box is closed.
         *
         */
            function (info) {
                return this._boxes.get(info).then(function (w) {
                    w.Close();
                });
            };
        /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        GoogleInfoBoxService.prototype.CreateEventObservable = /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, infoComponent) {
                var _this = this;
                var /** @type {?} */ googleEventName = GoogleMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._boxes.get(infoComponent).then(function (b) {
                        b.AddListener(googleEventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.DeleteInfoWindow = /**
         * Deletes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
            function (info) {
                return Promise.resolve();
            };
        /**
         * Opens the info window. Window opens on a marker, if supplied, or a specific location if given
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?=} loc
         * @return {?}
         */
        GoogleInfoBoxService.prototype.Open = /**
         * Opens the info window. Window opens on a marker, if supplied, or a specific location if given
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?=} loc
         * @return {?}
         */
            function (info, loc) {
                var _this = this;
                if (info.CloseInfoBoxesOnOpen || info.Modal) {
                    // close all open info boxes
                    this._boxes.forEach(function (box, i) {
                        if (info.Id !== i.Id) {
                            box.then(function (w) {
                                if (w.IsOpen) {
                                    w.Close();
                                    i.Close();
                                }
                            });
                        }
                    });
                }
                return this._boxes.get(info).then(function (w) {
                    var /** @type {?} */ options = {};
                    if (info.HtmlContent !== '') {
                        options.htmlContent = info.HtmlContent;
                    }
                    else {
                        options.title = info.Title;
                        options.description = info.Description;
                    }
                    w.SetOptions(options);
                    if (info.HostMarker != null) {
                        return _this._markerService.GetNativeMarker(info.HostMarker).then(function (marker) {
                            return _this._mapService.MapPromise.then(function (map) { return ((w)).Open(((marker)).NativePrimitve); });
                        });
                    }
                    return _this._mapService.MapPromise.then(function (map) {
                        if (loc) {
                            w.SetPosition(loc);
                        }
                        w.Open();
                    });
                });
            };
        /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} options
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.SetOptions = /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} options
         *
         * @return {?}
         */
            function (info, options) {
                return this._boxes.get(info).then(function (w) {
                    w.SetOptions(options);
                });
            };
        /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} latlng
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.SetPosition = /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} latlng
         *
         * @return {?}
         */
            function (info, latlng) {
                this._boxes.get(info).then(function (w) {
                    w.SetPosition(latlng);
                });
                return Promise.resolve();
            };
        GoogleInfoBoxService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleInfoBoxService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: MarkerService },
                { type: core.NgZone }
            ];
        };
        return GoogleInfoBoxService;
    }(InfoBoxService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of a layer for the Google Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a layer for the Google Map Provider.
     *
     * @export
     */ GoogleLayer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the GoogleMarkerClusterer class.
         *
         * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof GoogleLayer
         */
        function GoogleLayer(_layer, _maps, _id) {
            this._layer = _layer;
            this._maps = _maps;
            this._id = _id;
            this._entities = new Array();
            this._visible = true;
        }
        Object.defineProperty(GoogleLayer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer. Google does not have the concept of a custom layer,
             * so we are returning the Map as the native object because it hosts all the markers.
             *
             * \@memberof GoogleLayer
             * @return {?} GoogleMapTypes.GoogleMap.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        GoogleLayer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                throw (new Error('Events are not supported on Google Layers. You can still add events to individual markers.'));
            };
        /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleLAyer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.AddEntity = /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleLAyer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve) {
                    this._entities.push(entity);
                    entity.NativePrimitve.setVisible(this._visible);
                    entity.NativePrimitve.setMap(this.NativePrimitve);
                }
            };
        /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof GoogleLAyer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.AddEntities = /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof GoogleLAyer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    (_a = this._entities).push.apply(_a, __spread(entities));
                    async.eachSeries(__spread(entities), function (e, next) {
                        e.NativePrimitve.setVisible(_this._visible);
                        e.NativePrimitve.setMap(_this.NativePrimitve);
                        async.nextTick(function () { return next(); });
                    });
                }
                var _a;
            };
        /**
         * Deletes the layer anbd the markers in it.
         *
         * \@memberof GoogleLayer
         * @return {?}
         */
        GoogleLayer.prototype.Delete = /**
         * Deletes the layer anbd the markers in it.
         *
         * \@memberof GoogleLayer
         * @return {?}
         */
            function () {
                async.eachSeries(this._entities.splice(0), function (e, next) {
                    e.NativePrimitve.setMap(null);
                    async.nextTick(function () { return next(); });
                });
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} ILayerOptions. The layer options.
         *
         */
        GoogleLayer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} ILayerOptions. The layer options.
         *
         */
            function () {
                var /** @type {?} */ options = {
                    id: this._id
                };
                return options;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        GoogleLayer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._visible;
            };
        /**
         * Removes an entity from the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.RemoveEntity = /**
         * Removes an entity from the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve) {
                    var /** @type {?} */ j = this._entities.indexOf(entity);
                    if (j > -1) {
                        this._entities.splice(j, 1);
                    }
                    entity.NativePrimitve.setMap(null);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
        GoogleLayer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                this.Delete();
                this.AddEntities(entities);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} options ILayerOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        GoogleLayer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} options ILayerOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                this._id = options.id;
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                async.eachSeries(__spread(this._entities), function (e, next) {
                    e.NativePrimitve.setVisible(visible);
                    async.nextTick(function () { return next(); });
                });
                this._visible = visible;
            };
        return GoogleLayer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements the {\@link LayerService} contract for a Google Maps specific implementation.
     *
     * @export
     */
    var GoogleLayerService = (function (_super) {
        __extends(GoogleLayerService, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleLayerService.
         * @param _mapService - Instance of the Google Maps Service. Will generally be injected.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof GoogleLayerService
         */
        function GoogleLayerService(_mapService, _zone) {
            var _this = _super.call(this, _mapService, _zone) || this;
            _this._layers = new Map();
            return _this;
        }
        /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
        GoogleLayerService.prototype.AddLayer = /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ p = new Promise(function (resolve, reject) {
                    _this._mapService.MapPromise.then(function (m) {
                        var /** @type {?} */ l = new GoogleLayer(m, _this._mapService, layer.Id);
                        l.SetVisible(layer.Visible);
                        resolve(l);
                    });
                });
                this._layers.set(layer.Id, p);
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        GoogleLayerService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                var /** @type {?} */ p = this._mapService.CreatePolygon(options);
                var /** @type {?} */ l = this._layers.get(layer);
                Promise.all([p, l]).then(function (x) { return x[1].AddEntity(x[0]); });
                return p;
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        GoogleLayerService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                //
                // Note: we attempted using data.Polygons in an attempt to improve performance, but either data.Polygon
                // or data.MultiPolygon actually operate significantly slower than generating the polygons this way.
                // the slowness in google as opposed to bing probably comes from the point reduction algorithm uses.
                // Signigicant performance improvements might be possible in google when using a pixel based reduction algorithm
                // prior to setting the polygon path. This will lower to processing overhead of the google algorithm (with is Douglas-Peucker
                // and rather compute intensive)
                //
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ polygons = new Promise(function (resolve, reject) {
                        var /** @type {?} */ polys = options.map(function (o) {
                            var /** @type {?} */ op = GoogleConversions.TranslatePolygonOptions(o);
                            var /** @type {?} */ poly = new google.maps.Polygon(op);
                            var /** @type {?} */ polygon = new GooglePolygon(poly);
                            if (o.title && o.title !== '') {
                                polygon.Title = o.title;
                            }
                            if (o.metadata) {
                                o.metadata.forEach(function (val, key) { return polygon.Metadata.set(key, val); });
                            }
                            return polygon;
                        });
                        resolve(polys);
                    });
                    return polygons;
                });
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polyline.
         * @param {?} options - Polyline options defining the polyline.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
        GoogleLayerService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polyline.
         * @param {?} options - Polyline options defining the polyline.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                var /** @type {?} */ p = this._mapService.CreatePolyline(options);
                var /** @type {?} */ l = this._layers.get(layer);
                Promise.all([p, l]).then(function (x) {
                    var /** @type {?} */ p1 = Array.isArray(x[0]) ? /** @type {?} */ (x[0]) : [/** @type {?} */ (x[0])];
                    try {
                        for (var p1_1 = __values(p1), p1_1_1 = p1_1.next(); !p1_1_1.done; p1_1_1 = p1_1.next()) {
                            var p2 = p1_1_1.value;
                            x[1].AddEntity(p2);
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (p1_1_1 && !p1_1_1.done && (_a = p1_1.return))
                                _a.call(p1_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    var e_1, _a;
                });
                return p;
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        GoogleLayerService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ polylines = new Promise(function (resolve, reject) {
                        var /** @type {?} */ polys = options.map(function (o) {
                            var /** @type {?} */ op = GoogleConversions.TranslatePolylineOptions(o);
                            if (o.path && o.path.length > 0 && !Array.isArray(o.path[0])) {
                                op.path = GoogleConversions.TranslatePaths(o.path)[0];
                                var /** @type {?} */ poly = new google.maps.Polyline(op);
                                var /** @type {?} */ polyline_1 = new GooglePolyline(poly);
                                if (o.title && o.title !== '') {
                                    polyline_1.Title = o.title;
                                }
                                if (o.metadata) {
                                    o.metadata.forEach(function (v, k) { return polyline_1.Metadata.set(k, v); });
                                }
                                return polyline_1;
                            }
                            else {
                                var /** @type {?} */ paths = GoogleConversions.TranslatePaths(o.path);
                                var /** @type {?} */ lines_1 = new Array();
                                paths.forEach(function (x) {
                                    op.path = x;
                                    var /** @type {?} */ poly = new google.maps.Polyline(op);
                                    var /** @type {?} */ polyline = new GooglePolyline(poly);
                                    if (o.metadata) {
                                        o.metadata.forEach(function (v, k) { return polyline.Metadata.set(k, v); });
                                    }
                                    if (o.title && o.title !== '') {
                                        polyline.Title = o.title;
                                    }
                                    lines_1.push(polyline);
                                });
                                return lines_1;
                            }
                        });
                        resolve(polys);
                    });
                    return polylines;
                });
            };
        GoogleLayerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleLayerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return GoogleLayerService;
    }(GoogleLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var ScriptProtocol$1 = {
        HTTP: 0,
        HTTPS: 1,
        AUTO: 2,
    };
    ScriptProtocol$1[ScriptProtocol$1.HTTP] = "HTTP";
    ScriptProtocol$1[ScriptProtocol$1.HTTPS] = "HTTPS";
    ScriptProtocol$1[ScriptProtocol$1.AUTO] = "AUTO";
    /**
     * Bing Maps V8 specific loader configuration to be used with the {\@link GoogleMapAPILoader}
     *
     * @export
     */
    var GoogleMapAPILoaderConfig = (function () {
        function GoogleMapAPILoaderConfig() {
        }
        GoogleMapAPILoaderConfig.decorators = [
            { type: core.Injectable },
        ];
        return GoogleMapAPILoaderConfig;
    }());
    /**
     * Default loader configuration.
     */
    var /** @type {?} */ DEFAULT_CONFIGURATION$1 = new GoogleMapAPILoaderConfig();
    /**
     * Bing Maps V8 implementation for the {\@link MapAPILoader} service.
     *
     * @export
     */
    var GoogleMapAPILoader = (function (_super) {
        __extends(GoogleMapAPILoader, _super);
        /**
         * Creates an instance of GoogleMapAPILoader.
         * @param _config - The loader configuration.
         * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.
         * @param _documentRef - An instance of {@link DocumentRef}.
         *                                     Necessary because Bing Map V8 interacts with the document object.
         * @memberof GoogleMapAPILoader
         */
        function GoogleMapAPILoader(_config, _windowRef, _documentRef) {
            var _this = _super.call(this) || this;
            _this._config = _config;
            _this._windowRef = _windowRef;
            _this._documentRef = _documentRef;
            if (_this._config === null || _this._config === undefined) {
                _this._config = DEFAULT_CONFIGURATION$1;
            }
            return _this;
        }
        Object.defineProperty(GoogleMapAPILoader.prototype, "Config", {
            get: /**
             * Gets the loader configuration.
             *
             * \@readonly
             * \@memberof GoogleMapAPILoader
             * @return {?}
             */ function () { return this._config; },
            enumerable: true,
            configurable: true
        });
        /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?}
         */
        GoogleMapAPILoader.prototype.Load = /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._scriptLoadingPromise) {
                    return this._scriptLoadingPromise;
                }
                var /** @type {?} */ script = this._documentRef.GetNativeDocument().createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                script.defer = true;
                var /** @type {?} */ callbackName = "Create";
                script.src = this.GetMapsScriptSrc(callbackName);
                this._scriptLoadingPromise = new Promise(function (resolve, reject) {
                    ((_this._windowRef.GetNativeWindow()))[callbackName] = function () {
                        if (_this._config.enableClustering) {
                            // if clustering is enabled then delay the loading until after the cluster library is loaded
                            var /** @type {?} */ clusterScript = _this._documentRef.GetNativeDocument().createElement('script');
                            clusterScript.type = 'text/javascript';
                            clusterScript.src = _this.GetClusterScriptSrc();
                            clusterScript.onload = clusterScript.onreadystatechange = function () {
                                resolve();
                            };
                            _this._documentRef.GetNativeDocument().head.appendChild(clusterScript);
                        }
                        else {
                            resolve();
                        }
                    };
                    script.onerror = function (error) { reject(error); };
                });
                this._documentRef.GetNativeDocument().head.appendChild(script);
                return this._scriptLoadingPromise;
            };
        /**
         * Gets the Google Maps scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Google Maps scripts are loaded.
         * @return {?} - The url to be used to load the Google Map scripts.
         *
         */
        GoogleMapAPILoader.prototype.GetMapsScriptSrc = /**
         * Gets the Google Maps scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Google Maps scripts are loaded.
         * @return {?} - The url to be used to load the Google Map scripts.
         *
         */
            function (callbackName) {
                var /** @type {?} */ hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
                var /** @type {?} */ queryParams = {
                    v: this._config.apiVersion,
                    callback: callbackName,
                    key: this._config.apiKey,
                    client: this._config.clientId,
                    channel: this._config.channel,
                    libraries: this._config.libraries,
                    region: this._config.region,
                    language: this._config.language
                };
                return this.GetScriptSrc(hostAndPath, queryParams);
            };
        /**
         * Gets the Google Maps Cluster library url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?} - The url to be used to load the Google Map Cluster library.
         *
         */
        GoogleMapAPILoader.prototype.GetClusterScriptSrc = /**
         * Gets the Google Maps Cluster library url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?} - The url to be used to load the Google Map Cluster library.
         *
         */
            function () {
                var /** @type {?} */ hostAndPath = this._config.clusterHostAndPath ||
                    'developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js';
                return this.GetScriptSrc(hostAndPath, {});
            };
        /**
         * Gets a scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} hostAndPath - Host and path name of the script to load.
         * @param {?} queryParams - Url query parameters.
         * @return {?} - The url with correct protocol, path, and query parameters.
         *
         */
        GoogleMapAPILoader.prototype.GetScriptSrc = /**
         * Gets a scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} hostAndPath - Host and path name of the script to load.
         * @param {?} queryParams - Url query parameters.
         * @return {?} - The url with correct protocol, path, and query parameters.
         *
         */
            function (hostAndPath, queryParams) {
                var /** @type {?} */ protocolType = (((this._config && this._config.protocol) || ScriptProtocol$1.HTTPS));
                var /** @type {?} */ protocol;
                switch (protocolType) {
                    case ScriptProtocol$1.AUTO:
                        protocol = '';
                        break;
                    case ScriptProtocol$1.HTTP:
                        protocol = 'http:';
                        break;
                    case ScriptProtocol$1.HTTPS:
                        protocol = 'https:';
                        break;
                }
                var /** @type {?} */ params = Object.keys(queryParams)
                    .filter(function (k) { return queryParams[k] != null; })
                    .filter(function (k) {
                    // remove empty arrays
                    return !Array.isArray(queryParams[k]) ||
                        (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
                })
                    .map(function (k) {
                    // join arrays as comma seperated strings
                    var /** @type {?} */ i = queryParams[k];
                    if (Array.isArray(i)) {
                        return { key: k, value: i.join(',') };
                    }
                    return { key: k, value: queryParams[k] };
                })
                    .map(function (entry) { return entry.key + "=" + entry.value; })
                    .join('&');
                return protocol + "//" + hostAndPath + "?" + params;
            };
        GoogleMapAPILoader.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMapAPILoader.ctorParameters = function () {
            return [
                { type: GoogleMapAPILoaderConfig, decorators: [{ type: core.Optional }] },
                { type: WindowRef },
                { type: DocumentRef }
            ];
        };
        return GoogleMapAPILoader;
    }(MapAPILoader));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the MarkerService abstract class for Google.
     *
     * @export
     */
    var GoogleMarkerService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleMarkerService.
         * @param _mapService - {@link MapService} instance.
         * The concrete {@link GoogleMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link GoogleLayerService} implementation is expected.
         * @param _clusterService - {@link ClusterService} instance.
         * The concrete {@link GoogleClusterService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof GoogleMarkerService
         */
        function GoogleMarkerService(_mapService, _layerService, _clusterService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._clusterService = _clusterService;
            this._zone = _zone;
            this._markers = new Map();
        }
        /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         * @return {?}
         */
        GoogleMarkerService.prototype.AddMarker = /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         * @return {?}
         */
            function (marker) {
                var /** @type {?} */ o = {
                    anchor: marker.Anchor,
                    position: { latitude: marker.Latitude, longitude: marker.Longitude },
                    title: marker.Title,
                    label: marker.Label,
                    draggable: marker.Draggable,
                    icon: marker.IconUrl,
                    iconInfo: marker.IconInfo,
                    width: marker.Width,
                    height: marker.Height,
                    isFirst: marker.IsFirstInSet,
                    isLast: marker.IsLastInSet
                };
                // create marker via promise.
                var /** @type {?} */ markerPromise = null;
                if (marker.InClusterLayer) {
                    markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);
                }
                else if (marker.InCustomLayer) {
                    markerPromise = this._layerService.CreateMarker(marker.LayerId, o);
                }
                else {
                    markerPromise = this._mapService.CreateMarker(o);
                }
                this._markers.set(marker, markerPromise);
                if (marker.IconInfo) {
                    markerPromise.then(function (m) {
                        // update iconInfo to provide hook to do post icon creation activities and
                        // also re-anchor the marker
                        marker.DynamicMarkerCreated.emit(o.iconInfo);
                        var /** @type {?} */ p = {
                            x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,
                            y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,
                        };
                        m.SetAnchor(p);
                    });
                }
            };
        /**
         * Registers an event delegate for a marker.
         *
         * \@memberof GoogleMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarkerDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         */
        GoogleMarkerService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a marker.
         *
         * \@memberof GoogleMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarkerDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         */
            function (eventName, marker) {
                var _this = this;
                return rxjs.Observable.create(function (observer) {
                    _this._markers.get(marker).then(function (m) {
                        m.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes a marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - {\@link MapMarkerDirective} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         */
        GoogleMarkerService.prototype.DeleteMarker = /**
         * Deletes a marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - {\@link MapMarkerDirective} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         */
            function (marker) {
                var _this = this;
                var /** @type {?} */ m = this._markers.get(marker);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (ma) {
                    if (marker.InClusterLayer) {
                        _this._clusterService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                    }
                    if (marker.InCustomLayer) {
                        _this._layerService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                    }
                    return _this._zone.run(function () {
                        ma.DeleteMarker();
                        _this._markers.delete(marker);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
        GoogleMarkerService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.latLng) {
                    return null;
                }
                if (!e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         */
        GoogleMarkerService.prototype.GetNativeMarker = /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         */
            function (marker) {
                return this._markers.get(marker);
            };
        /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         */
        GoogleMarkerService.prototype.GetPixelsFromClick = /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         */
            function (e) {
                if (!e || !e.latLng || !e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                if (this._mapService.MapInstance == null) {
                    return null;
                }
                var /** @type {?} */ crossesDateLine = false;
                var /** @type {?} */ m = this._mapService.MapInstance;
                var /** @type {?} */ p = m.getProjection();
                var /** @type {?} */ s = Math.pow(2, m.getZoom());
                var /** @type {?} */ b = m.getBounds();
                if (b.getCenter().lng() < b.getSouthWest().lng() ||
                    b.getCenter().lng() > b.getNorthEast().lng()) {
                    crossesDateLine = true;
                }
                var /** @type {?} */ offsetY = p.fromLatLngToPoint(b.getNorthEast()).y;
                var /** @type {?} */ offsetX = p.fromLatLngToPoint(b.getSouthWest()).x;
                var /** @type {?} */ point = p.fromLatLngToPoint(e.latLng);
                return {
                    x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),
                    y: Math.floor((point.y - offsetY) * s)
                };
            };
        /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof GoogleMarkerService
         * @param {?} target - Either a {\@link MapMarkerDirective}
         * or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         */
        GoogleMarkerService.prototype.LocationToPoint = /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof GoogleMarkerService
         * @param {?} target - Either a {\@link MapMarkerDirective}
         * or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         */
            function (target) {
                var _this = this;
                if (target == null) {
                    return Promise.resolve(null);
                }
                if (target instanceof MapMarkerDirective) {
                    return this._markers.get(target).then(function (m) {
                        var /** @type {?} */ l = m.Location;
                        var /** @type {?} */ p = _this._mapService.LocationToPoint(l);
                        return p;
                    });
                }
                return this._mapService.LocationToPoint(target);
            };
        /**
         * Updates the anchor position for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         */
        GoogleMarkerService.prototype.UpdateAnchor = /**
         * Updates the anchor position for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    m.SetAnchor(marker.Anchor);
                });
            };
        /**
         * Updates whether the marker is draggable.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         */
        GoogleMarkerService.prototype.UpdateDraggable = /**
         * Updates whether the marker is draggable.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetDraggable(marker.Draggable); });
            };
        /**
         * Updates the Icon on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         */
        GoogleMarkerService.prototype.UpdateIcon = /**
         * Updates the Icon on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    if (marker.IconInfo) {
                        var /** @type {?} */ x = {
                            position: { latitude: marker.Latitude, longitude: marker.Longitude },
                            iconInfo: marker.IconInfo
                        };
                        var /** @type {?} */ o = GoogleConversions.TranslateMarkerOptions(x);
                        m.SetIcon(o.icon);
                        marker.DynamicMarkerCreated.emit(x.iconInfo);
                    }
                    else {
                        m.SetIcon(marker.IconUrl);
                    }
                });
            };
        /**
         * Updates the label on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         */
        GoogleMarkerService.prototype.UpdateLabel = /**
         * Updates the label on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { m.SetLabel(marker.Label); });
            };
        /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         */
        GoogleMarkerService.prototype.UpdateMarkerPosition = /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    return m.SetPosition({
                        latitude: marker.Latitude,
                        longitude: marker.Longitude
                    });
                });
            };
        /**
         * Updates the title on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
        GoogleMarkerService.prototype.UpdateTitle = /**
         * Updates the title on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetTitle(marker.Title); });
            };
        /**
         * Updates the visibility on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
        GoogleMarkerService.prototype.UpdateVisible = /**
         * Updates the visibility on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetVisible(marker.Visible); });
            };
        GoogleMarkerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMarkerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: ClusterService },
                { type: core.NgZone }
            ];
        };
        return GoogleMarkerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of a clustering layer for the Google Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a clustering layer for the Google Map Provider.
     *
     * @export
     */ GoogleMarkerClusterer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the GoogleMarkerClusterer class.
         *
         * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof GoogleMarkerClusterer
         */
        function GoogleMarkerClusterer(_layer) {
            this._layer = _layer;
            this._isClustering = true;
            this._markerLookup = new Map();
            this._markers = new Array();
            this._pendingMarkers = new Array();
            this._mapclicks = 0;
            this._currentZoom = 0;
            this._visible = true;
        }
        Object.defineProperty(GoogleMarkerClusterer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer.
             *
             * \@memberof GoogleMarkerClusterer
             * @return {?} GoogleMapTypes.MarkerClusterer.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                throw (new Error('Events are not supported on Google Cluster Layers. You can still add events to individual markers.'));
            };
        /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.AddEntity = /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                var /** @type {?} */ isMarker = entity instanceof Marker;
                isMarker = entity instanceof GoogleMarker || isMarker;
                if (isMarker) {
                    entity.NativePrimitve.setMap(null);
                    // remove the marker from the map as the clusterer will control marker visibility.
                    if (entity.IsFirst) {
                        this.StopClustering();
                    }
                }
                if (entity.NativePrimitve && entity.Location) {
                    if (this._isClustering && this._visible) {
                        this._layer.addMarker(entity.NativePrimitve);
                        this._markers.push(entity);
                    }
                    else {
                        this._pendingMarkers.push(entity);
                    }
                    this._markerLookup.set(entity.NativePrimitve, entity);
                }
                if (isMarker) {
                    if (entity.IsLast) {
                        this.StartClustering();
                    }
                }
            };
        /**
         * Adds a number of markers to the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.AddEntities = /**
         * Adds a number of markers to the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    var /** @type {?} */ e = entities.map(function (p) {
                        _this._markerLookup.set(p.NativePrimitve, p);
                        p.NativePrimitve.setMap(null);
                        // remove the marker from the map as the clusterer will control marker visibility.
                        return p.NativePrimitve;
                    });
                    if (this._isClustering && this._visible) {
                        this._layer.addMarkers(e);
                        (_a = this._markers).push.apply(_a, __spread(entities));
                    }
                    else {
                        // if layer is not visible, always add to pendingMarkers. Setting the layer to visible later
                        // will render the markers appropriately
                        // if layer is not visible, always add to pendingMarkers. Setting the layer to visible later
                        // will render the markers appropriately
                        (_b = this._pendingMarkers).push.apply(_b, __spread(entities));
                    }
                }
                var _a, _b;
            };
        /**
         * Deletes the clustering layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.Delete = /**
         * Deletes the clustering layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
            function () {
                this._layer.getMarkers().forEach(function (m) {
                    m.setMap(null);
                    // remove the marker from the map as the clusterer will control marker visibility.
                });
                this._layer.clearMarkers();
                this._markers.splice(0);
                this._pendingMarkers.splice(0);
            };
        /**
         * Returns the abstract marker used to wrap the Google Marker.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
        GoogleMarkerClusterer.prototype.GetMarkerFromGoogleMarker = /**
         * Returns the abstract marker used to wrap the Google Marker.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
            function (pin) {
                var /** @type {?} */ m = this._markerLookup.get(pin);
                return m;
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} IClusterOptions. The layer options.
         *
         */
        GoogleMarkerClusterer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} IClusterOptions. The layer options.
         *
         */
            function () {
                var /** @type {?} */ options = {
                    id: 0,
                    gridSize: this._layer.getGridSize(),
                    clusteringEnabled: this._layer.getGridSize() === 0,
                    maxZoom: this._layer.getMaxZoom(),
                    minimumClusterSize: this._layer.getMinClusterSize(),
                    placementMode: this._layer.isAverageCenter() ? ClusterPlacementMode.MeanValue : ClusterPlacementMode.FirstPin,
                    visible: this._visible,
                    zoomOnClick: this._layer.isZoomOnClick(),
                    styles: this._layer.getStyles()
                };
                return options;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        GoogleMarkerClusterer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._visible;
            };
        /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker Entity to be removed from the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.RemoveEntity = /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker Entity to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve && entity.Location) {
                    var /** @type {?} */ j = this._markers.indexOf(entity);
                    var /** @type {?} */ k = this._pendingMarkers.indexOf(entity);
                    if (j > -1) {
                        this._markers.splice(j, 1);
                    }
                    if (k > -1) {
                        this._pendingMarkers.splice(k, 1);
                    }
                    if (this._isClustering) {
                        this._layer.removeMarker(entity.NativePrimitve);
                    }
                    this._markerLookup.delete(entity.NativePrimitve);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                this._layer.getMarkers().forEach(function (m) {
                    m.setMap(null);
                });
                this._layer.clearMarkers();
                this._markers.splice(0);
                this._pendingMarkers.splice(0);
                this._markerLookup.clear();
                var /** @type {?} */ p = new Array();
                entities.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        e.NativePrimitve.setMap(null);
                        _this._markerLookup.set(e.NativePrimitve, e);
                        if (_this._visible) {
                            _this._markers.push(e);
                            p.push(e.NativePrimitve);
                        }
                        else {
                            _this._pendingMarkers.push(e);
                        }
                    }
                });
                this._layer.addMarkers(p);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                if (options.placementMode != null) {
                    throw (new Error('GoogleMarkerClusterer: PlacementMode option cannot be set after initial creation.'));
                }
                if (options.zoomOnClick != null) {
                    throw (new Error('GoogleMarkerClusterer: ZoomOnClick option cannot be set after initial creation.'));
                }
                if (options.callback != null) ;
                if (options.clusteringEnabled != null) {
                    this._layer.setMinClusterSize(options.clusteringEnabled ? 1 : 10000000);
                    this._layer.resetViewport();
                    this._layer.redraw();
                }
                if (options.gridSize != null && (options.clusteringEnabled == null || options.clusteringEnabled)) {
                    this._layer.setGridSize(options.gridSize);
                    this._layer.resetViewport();
                    this._layer.redraw();
                }
                if (options.maxZoom != null) {
                    this._layer.setMaxZoom(options.maxZoom);
                }
                if (options.minimumClusterSize != null) {
                    this._layer.setMinClusterSize(options.minimumClusterSize);
                }
                if (options.styles != null) {
                    this._layer.setStyles(options.styles);
                }
                if (options.visible != null) {
                    this.SetVisible(options.visible);
                }
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                var /** @type {?} */ map = visible ? this._layer.getMap() : null;
                if (!visible) {
                    this._layer.resetViewport(true);
                }
                else {
                    var /** @type {?} */ p_1 = new Array();
                    if (this._pendingMarkers.length > 0) {
                        this._pendingMarkers.forEach(function (e) {
                            if (e.NativePrimitve && e.Location) {
                                p_1.push(/** @type {?} */ (e.NativePrimitve));
                            }
                        });
                        this._layer.addMarkers(p_1);
                        this._markers = this._markers.concat(this._pendingMarkers.splice(0));
                    }
                    else {
                        this._layer.redraw();
                    }
                }
                this._visible = visible;
            };
        /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.StartClustering = /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._isClustering) {
                    return;
                }
                if (this._visible) {
                    var /** @type {?} */ p_2 = new Array();
                    this._markers.forEach(function (e) {
                        if (e.NativePrimitve && e.Location) {
                            p_2.push(/** @type {?} */ (e.NativePrimitve));
                        }
                    });
                    this._pendingMarkers.forEach(function (e) {
                        if (e.NativePrimitve && e.Location) {
                            p_2.push(/** @type {?} */ (e.NativePrimitve));
                        }
                    });
                    this._layer.addMarkers(p_2);
                    this._markers = this._markers.concat(this._pendingMarkers.splice(0));
                }
                if (!this._visible) {
                    // only add the markers if the layer is visible. Otherwise, keep them pending. They would be added once the
                    // layer is set to visible.
                    rxjs.timer(0).subscribe(function () {
                        _this._layer.resetViewport(true);
                    });
                }
                this._isClustering = true;
            };
        /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         *
         */
        GoogleMarkerClusterer.prototype.StopClustering = /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         *
         */
            function () {
                if (!this._isClustering) {
                    return;
                }
                this._isClustering = false;
            };
        return GoogleMarkerClusterer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the MapService abstract implementing a Google Maps provider
     *
     * @export
     */
    var GoogleMapService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleMapService.
         * @param _loader MapAPILoader instance implemented for Google Maps. This instance will generally be injected.
         * @param _zone NgZone object to enable zone aware promises. This will generally be injected.
         *
         * @memberof GoogleMapService
         */
        function GoogleMapService(_loader, _zone) {
            var _this = this;
            this._loader = _loader;
            this._zone = _zone;
            this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
            this._config = ((this._loader)).Config;
        }
        Object.defineProperty(GoogleMapService.prototype, "MapInstance", {
            get: /**
             * Gets the Google Map control instance underlying the implementation
             *
             * \@readonly
             * \@memberof GoogleMapService
             * @return {?}
             */ function () { return this._mapInstance; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMapService.prototype, "MapPromise", {
            get: /**
             * Gets a Promise for a Google Map control instance underlying the implementation. Use this instead of {\@link MapInstance} if you
             * are not sure if and when the instance will be created.
             * \@readonly
             * \@memberof GoogleMapService
             * @return {?}
             */ function () { return this._map; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMapService.prototype, "MapSize", {
            get: /**
             * Gets the maps physical size.
             *
             * \@readonly
             * @abstract
             * \@memberof BingMapService
             * @return {?}
             */ function () {
                if (this.MapInstance) {
                    var /** @type {?} */ el = this.MapInstance.getDiv();
                    var /** @type {?} */ s = { width: el.offsetWidth, height: el.offsetHeight };
                    return s;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof GoogleMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
        GoogleMapService.prototype.CreateCanvasOverlay = /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof GoogleMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
            function (drawCallback) {
                return this._map.then(function (map) {
                    var /** @type {?} */ overlay = new GoogleCanvasOverlay(drawCallback);
                    overlay.SetMap(map);
                    return overlay;
                });
            };
        /**
         * @param {?} options
         * @return {?}
         */
        GoogleMapService.prototype.CreateClusterLayer = /**
         * @param {?} options
         * @return {?}
         */
            function (options) {
                return this._map.then(function (map) {
                    var /** @type {?} */ updateOptions = false;
                    var /** @type {?} */ markerClusterer = new MarkerClusterer(map, [], options);
                    var /** @type {?} */ clusterLayer = new GoogleMarkerClusterer(markerClusterer);
                    var /** @type {?} */ o = {
                        id: options.id
                    };
                    if (!options.visible) {
                        o.visible = false;
                        updateOptions = true;
                    }
                    if (!options.clusteringEnabled) {
                        o.clusteringEnabled = false;
                        updateOptions = true;
                    }
                    if (updateOptions) {
                        clusterLayer.SetOptions(o);
                    }
                    return clusterLayer;
                });
            };
        /**
         * Creates an information window for a map position
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
        GoogleMapService.prototype.CreateInfoWindow = /**
         * Creates an information window for a map position
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    var /** @type {?} */ o = GoogleConversions.TranslateInfoWindowOptions(options);
                    var /** @type {?} */ infoWindow = new google.maps.InfoWindow(o);
                    return new GoogleInfoWindow(infoWindow, _this);
                });
            };
        /**
         * Creates a map layer within the map context
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
        GoogleMapService.prototype.CreateLayer = /**
         * Creates a map layer within the map context
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    return new GoogleLayer(map, _this, options.id);
                });
            };
        /**
         * Creates a map instance
         *
         * \@memberof GoogleMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
        GoogleMapService.prototype.CreateMap = /**
         * Creates a map instance
         *
         * \@memberof GoogleMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
            function (el, mapOptions) {
                var _this = this;
                return this._loader.Load().then(function () {
                    // apply mixins
                    MixinMapLabelWithOverlayView$1();
                    MixinCanvasOverlay$1();
                    // execute map startup
                    if (!mapOptions.mapTypeId == null) {
                        mapOptions.mapTypeId = MapTypeId.hybrid;
                    }
                    if (_this._mapInstance != null) {
                        _this.DisposeMap();
                    }
                    var /** @type {?} */ o = GoogleConversions.TranslateOptions(mapOptions);
                    var /** @type {?} */ map = new google.maps.Map(el, o);
                    if (mapOptions.bounds) {
                        map.fitBounds(GoogleConversions.TranslateBounds(mapOptions.bounds));
                    }
                    _this._mapInstance = map;
                    _this._mapResolver(map);
                    return;
                });
            };
        /**
         * Creates a Google map marker within the map context
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
        GoogleMapService.prototype.CreateMarker = /**
         * Creates a Google map marker within the map context
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
            function (options) {
                if (options === void 0) {
                    options = /** @type {?} */ ({});
                }
                var /** @type {?} */ payload = function (x, map) {
                    var /** @type {?} */ marker = new google.maps.Marker(x);
                    var /** @type {?} */ m = new GoogleMarker(marker);
                    m.IsFirst = options.isFirst;
                    m.IsLast = options.isLast;
                    if (options.metadata) {
                        options.metadata.forEach(function (val, key) { return m.Metadata.set(key, val); });
                    }
                    marker.setMap(map);
                    return m;
                };
                return this._map.then(function (map) {
                    var /** @type {?} */ o = GoogleConversions.TranslateMarkerOptions(options);
                    if (options.iconInfo && options.iconInfo.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            o.icon = s;
                            return payload(o, map);
                        }
                        else {
                            return s.then(function (x) {
                                o.icon = x.icon;
                                return payload(o, map);
                            });
                        }
                    }
                    else {
                        return payload(o, map);
                    }
                });
            };
        /**
         * Creates a polygon within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
        GoogleMapService.prototype.CreatePolygon = /**
         * Creates a polygon within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
            function (options) {
                return this._map.then(function (map) {
                    var /** @type {?} */ o = GoogleConversions.TranslatePolygonOptions(options);
                    var /** @type {?} */ polygon = new google.maps.Polygon(o);
                    polygon.setMap(map);
                    var /** @type {?} */ p = new GooglePolygon(polygon);
                    if (options.metadata) {
                        options.metadata.forEach(function (val, key) { return p.Metadata.set(key, val); });
                    }
                    if (options.title && options.title !== '') {
                        p.Title = options.title;
                    }
                    if (options.showLabel != null) {
                        p.ShowLabel = options.showLabel;
                    }
                    if (options.showTooltip != null) {
                        p.ShowTooltip = options.showTooltip;
                    }
                    if (options.labelMaxZoom != null) {
                        p.LabelMaxZoom = options.labelMaxZoom;
                    }
                    if (options.labelMinZoom != null) {
                        p.LabelMinZoom = options.labelMinZoom;
                    }
                    return p;
                });
            };
        /**
         * Creates a polyline within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array therefore for complex paths)
         * which models the underlying native polyline.
         *
         */
        GoogleMapService.prototype.CreatePolyline = /**
         * Creates a polyline within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array therefore for complex paths)
         * which models the underlying native polyline.
         *
         */
            function (options) {
                var /** @type {?} */ polyline;
                return this._map.then(function (map) {
                    var /** @type {?} */ o = GoogleConversions.TranslatePolylineOptions(options);
                    if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {
                        o.path = GoogleConversions.TranslatePaths(options.path)[0];
                        polyline = new google.maps.Polyline(o);
                        polyline.setMap(map);
                        var /** @type {?} */ pl_1 = new GooglePolyline(polyline);
                        if (options.metadata) {
                            options.metadata.forEach(function (val, key) { return pl_1.Metadata.set(key, val); });
                        }
                        if (options.title && options.title !== '') {
                            pl_1.Title = options.title;
                        }
                        if (options.showTooltip != null) {
                            pl_1.ShowTooltip = options.showTooltip;
                        }
                        return pl_1;
                    }
                    else {
                        var /** @type {?} */ paths = GoogleConversions.TranslatePaths(options.path);
                        var /** @type {?} */ lines_1 = new Array();
                        paths.forEach(function (p) {
                            o.path = p;
                            polyline = new google.maps.Polyline(o);
                            polyline.setMap(map);
                            var /** @type {?} */ pl = new GooglePolyline(polyline);
                            if (options.metadata) {
                                options.metadata.forEach(function (val, key) { return pl.Metadata.set(key, val); });
                            }
                            if (options.title && options.title !== '') {
                                pl.Title = options.title;
                            }
                            if (options.showTooltip != null) {
                                pl.ShowTooltip = options.showTooltip;
                            }
                            lines_1.push(pl);
                        });
                        return lines_1;
                    }
                });
            };
        /**
         * Deletes a layer from the map.
         *
         * \@memberof GoogleMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Google specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
        GoogleMapService.prototype.DeleteLayer = /**
         * Deletes a layer from the map.
         *
         * \@memberof GoogleMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Google specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                // return resolved promise as there is no conept of a custom layer in Google.
                return Promise.resolve();
            };
        /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof GoogleMapService
         * @return {?}
         */
        GoogleMapService.prototype.DisposeMap = /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof GoogleMapService
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._map == null && this._mapInstance == null) {
                    return;
                }
                if (this._mapInstance != null) {
                    this._mapInstance = null;
                    this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
                }
            };
        /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
        GoogleMapService.prototype.GetCenter = /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    var /** @type {?} */ center = map.getCenter();
                    return /** @type {?} */ ({
                        latitude: center.lat(),
                        longitude: center.lng()
                    });
                });
            };
        /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the geo location of the bounding box. See {\@link IBox}.
         *
         */
        GoogleMapService.prototype.GetBounds = /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the geo location of the bounding box. See {\@link IBox}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    var /** @type {?} */ box = map.getBounds();
                    return /** @type {?} */ ({
                        maxLatitude: box.getNorthEast().lat(),
                        maxLongitude: Math.max(box.getNorthEast().lng(), box.getSouthWest().lng()),
                        minLatitude: box.getSouthWest().lat(),
                        minLongitude: Math.min(box.getNorthEast().lng(), box.getSouthWest().lng()),
                        center: { latitude: box.getCenter().lat(), longitude: box.getCenter().lng() },
                        padding: 0
                    });
                });
            };
        /**
         * Gets the current zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
        GoogleMapService.prototype.GetZoom = /**
         * Gets the current zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
            function () {
                return this._map.then(function (map) { return map.getZoom(); });
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof GoogleMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
        GoogleMapService.prototype.LocationToPoint = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof GoogleMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
            function (loc) {
                return this._map.then(function (m) {
                    var /** @type {?} */ crossesDateLine = false;
                    var /** @type {?} */ l = GoogleConversions.TranslateLocationObject(loc);
                    var /** @type {?} */ p = m.getProjection();
                    var /** @type {?} */ s = Math.pow(2, m.getZoom());
                    var /** @type {?} */ b = m.getBounds();
                    if (b.getCenter().lng() < b.getSouthWest().lng() ||
                        b.getCenter().lng() > b.getNorthEast().lng()) {
                        crossesDateLine = true;
                    }
                    var /** @type {?} */ offsetY = p.fromLatLngToPoint(b.getNorthEast()).y;
                    var /** @type {?} */ offsetX = p.fromLatLngToPoint(b.getSouthWest()).x;
                    var /** @type {?} */ point = p.fromLatLngToPoint(l);
                    return {
                        x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),
                        y: Math.floor((point.y - offsetY) * s)
                    };
                });
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
        GoogleMapService.prototype.LocationsToPoints = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
            function (locs) {
                return this._map.then(function (m) {
                    var /** @type {?} */ crossesDateLine = false;
                    var /** @type {?} */ p = m.getProjection();
                    var /** @type {?} */ s = Math.pow(2, m.getZoom());
                    var /** @type {?} */ b = m.getBounds();
                    if (b.getCenter().lng() < b.getSouthWest().lng() ||
                        b.getCenter().lng() > b.getNorthEast().lng()) {
                        crossesDateLine = true;
                    }
                    var /** @type {?} */ offsetX = p.fromLatLngToPoint(b.getSouthWest()).x;
                    var /** @type {?} */ offsetY = p.fromLatLngToPoint(b.getNorthEast()).y;
                    var /** @type {?} */ l = locs.map(function (ll) {
                        var /** @type {?} */ l1 = GoogleConversions.TranslateLocationObject(ll);
                        var /** @type {?} */ point = p.fromLatLngToPoint(l1);
                        return {
                            x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),
                            y: Math.floor((point.y - offsetY) * s)
                        };
                    });
                    return l;
                });
            };
        /**
         * Centers the map on a geo location.
         *
         * \@memberof GoogleMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
        GoogleMapService.prototype.SetCenter = /**
         * Centers the map on a geo location.
         *
         * \@memberof GoogleMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
            function (latLng) {
                return this._map.then(function (map) {
                    var /** @type {?} */ center = GoogleConversions.TranslateLocationObject(latLng);
                    map.setCenter(center);
                });
            };
        /**
         * Sets the generic map options.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        GoogleMapService.prototype.SetMapOptions = /**
         * Sets the generic map options.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    var /** @type {?} */ o = GoogleConversions.TranslateOptions(options);
                    m.setOptions(o);
                });
            };
        /**
         * Sets the view options of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        GoogleMapService.prototype.SetViewOptions = /**
         * Sets the view options of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    if (options.bounds) {
                        m.fitBounds(GoogleConversions.TranslateBounds(options.bounds));
                    }
                    var /** @type {?} */ o = GoogleConversions.TranslateOptions(options);
                    m.setOptions(o);
                });
            };
        /**
         * Sets the zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
        GoogleMapService.prototype.SetZoom = /**
         * Sets the zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
            function (zoom) {
                return this._map.then(function (map) { return map.setZoom(zoom); });
            };
        /**
         * Creates an event subscription
         *
         * \@memberof GoogleMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of type E that fires when the event occurs.
         *
         */
        GoogleMapService.prototype.SubscribeToMapEvent = /**
         * Creates an event subscription
         *
         * \@memberof GoogleMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of type E that fires when the event occurs.
         *
         */
            function (eventName) {
                var _this = this;
                var /** @type {?} */ googleEventName = GoogleMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._map.then(function (m) {
                        m.addListener(googleEventName, function (e) {
                            _this._zone.run(function () { return observer.next(e); });
                        });
                    });
                });
            };
        /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof GoogleMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
        GoogleMapService.prototype.TriggerMapEvent = /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof GoogleMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
            function (eventName) {
                return this._map.then(function (m) { return google.maps.event.trigger(m, eventName, null); });
            };
        GoogleMapService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMapService.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return GoogleMapService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the Polygon Service abstract class for Google Maps.
     *
     * @export
     */
    var GooglePolygonService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GooglePolygonService.
         * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.
         * @param _layerService - {@link GoogleLayerService} instance.
         * The concrete {@link GoogleLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof GooglePolygonService
         */
        function GooglePolygonService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polygons = new Map();
        }
        /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
        GooglePolygonService.prototype.AddPolygon = /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
            function (polygon) {
                var /** @type {?} */ o = {
                    id: polygon.Id,
                    clickable: polygon.Clickable,
                    draggable: polygon.Draggable,
                    editable: polygon.Editable,
                    fillColor: polygon.FillColor,
                    fillOpacity: polygon.FillOpacity,
                    geodesic: polygon.Geodesic,
                    labelMaxZoom: polygon.LabelMaxZoom,
                    labelMinZoom: polygon.LabelMinZoom,
                    paths: polygon.Paths,
                    showLabel: polygon.ShowLabel,
                    showTooltip: polygon.ShowTooltip,
                    strokeColor: polygon.StrokeColor,
                    strokeOpacity: polygon.StrokeOpacity,
                    strokeWeight: polygon.StrokeWeight,
                    title: polygon.Title,
                    visible: polygon.Visible,
                    zIndex: polygon.zIndex,
                };
                var /** @type {?} */ polygonPromise = this._mapService.CreatePolygon(o);
                this._polygons.set(polygon, polygonPromise);
            };
        /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof GooglePolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        GooglePolygonService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof GooglePolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polygon) {
                var _this = this;
                return rxjs.Observable.create(function (observer) {
                    _this._polygons.get(polygon).then(function (p) {
                        p.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes a polygon.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
        GooglePolygonService.prototype.DeletePolygon = /**
         * Deletes a polygon.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
            function (polygon) {
                var _this = this;
                var /** @type {?} */ m = this._polygons.get(polygon);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        l.Delete();
                        _this._polygons.delete(polygon);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof GooglePolygonService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        GooglePolygonService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof GooglePolygonService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
        GooglePolygonService.prototype.GetNativePolygon = /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
            function (polygon) {
                return this._polygons.get(polygon);
            };
        /**
         * Set the polygon options.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
        GooglePolygonService.prototype.SetOptions = /**
         * Set the polygon options.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
            function (polygon, options) {
                return this._polygons.get(polygon).then(function (l) { l.SetOptions(options); });
            };
        /**
         * Updates the Polygon path
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
        GooglePolygonService.prototype.UpdatePolygon = /**
         * Updates the Polygon path
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
            function (polygon) {
                var /** @type {?} */ m = this._polygons.get(polygon);
                if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    if (Array.isArray(polygon.Paths[0])) {
                        l.SetPaths(polygon.Paths);
                    }
                    else {
                        l.SetPath(/** @type {?} */ (polygon.Paths));
                    }
                });
            };
        GooglePolygonService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GooglePolygonService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return GooglePolygonService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the Polyline Service abstract class for Google Maps.
     *
     * @export
     */
    var GooglePolylineService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GooglePolylineService.
         * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link GoogleLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof GooglePolylineService
         */
        function GooglePolylineService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polylines = new Map();
        }
        /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
        GooglePolylineService.prototype.AddPolyline = /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
            function (polyline) {
                var /** @type {?} */ o = {
                    id: polyline.Id,
                    clickable: polyline.Clickable,
                    draggable: polyline.Draggable,
                    editable: polyline.Editable,
                    geodesic: polyline.Geodesic,
                    path: polyline.Path,
                    showTooltip: polyline.ShowTooltip,
                    strokeColor: polyline.StrokeColor,
                    strokeOpacity: polyline.StrokeOpacity,
                    strokeWeight: polyline.StrokeWeight,
                    title: polyline.Title,
                    visible: polyline.Visible,
                    zIndex: polyline.zIndex,
                };
                var /** @type {?} */ polylinePromise = this._mapService.CreatePolyline(o);
                this._polylines.set(polyline, polylinePromise);
            };
        /**
         * Registers an event delegate for a line.
         *
         * \@memberof GooglePolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        GooglePolylineService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a line.
         *
         * \@memberof GooglePolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polyline) {
                var _this = this;
                return rxjs.Observable.create(function (observer) {
                    _this._polylines.get(polyline).then(function (p) {
                        var /** @type {?} */ x = Array.isArray(p) ? p : [p];
                        x.forEach(function (line) { return line.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); }); });
                    });
                });
            };
        /**
         * Deletes a polyline.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
        GooglePolylineService.prototype.DeletePolyline = /**
         * Deletes a polyline.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
            function (polyline) {
                var _this = this;
                var /** @type {?} */ m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                        x.forEach(function (line) { return line.Delete(); });
                        _this._polylines.delete(polyline);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the line on the click location
         *
         * @abstract
         * \@memberof GooglePolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked line.
         *
         */
        GooglePolylineService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the line on the click location
         *
         * @abstract
         * \@memberof GooglePolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked line.
         *
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.latLng) {
                    return null;
                }
                if (!e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Obtains the polyline model for the line allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
        GooglePolylineService.prototype.GetNativePolyline = /**
         * Obtains the polyline model for the line allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
            function (polyline) {
                return this._polylines.get(polyline);
            };
        /**
         * Set the polyline options.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
        GooglePolylineService.prototype.SetOptions = /**
         * Set the polyline options.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
            function (polyline, options) {
                return this._polylines.get(polyline).then(function (l) {
                    var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                    x.forEach(function (line) { return line.SetOptions(options); });
                });
            };
        /**
         * Updates the Polyline path
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
        GooglePolylineService.prototype.UpdatePolyline = /**
         * Updates the Polyline path
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
            function (polyline) {
                var _this = this;
                var /** @type {?} */ m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                        var /** @type {?} */ p = polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? /** @type {?} */ (polyline.Path) : /** @type {?} */ ([polyline.Path]);
                        x.forEach(function (line, index) {
                            if (p.length > index) {
                                line.SetPath(p[index]);
                            }
                        });
                        if (Array.isArray(l) && l.length > p.length) {
                            l.splice(p.length - 1).forEach(function (line) { return line.Delete(); });
                        }
                    });
                });
            };
        GooglePolylineService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GooglePolylineService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return GooglePolylineService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements a factory to create three necessary Google Maps specific service instances.
     *
     * @export
     */
    var GoogleMapServiceFactory = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleMapServiceFactory.
         * @param _loader - {@link MapAPILoader} implementation for the Google Map provider.
         * @param _zone - NgZone object to implement zone aware promises.
         *
         * @memberof GoogleMapServiceFactory
         */
        function GoogleMapServiceFactory(_loader, _zone) {
            var _this = this;
            this._loader = _loader;
            this._zone = _zone;
            this._map =
                new Promise(function (resolve) { _this._mapResolver = resolve; });
        }
        /**
         * Creates the map service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link GoogleMapService}.
         *
         */
        GoogleMapServiceFactory.prototype.Create = /**
         * Creates the map service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link GoogleMapService}.
         *
         */
            function () {
                return new GoogleMapService(this._loader, this._zone);
            };
        /**
         * Creates the cluster service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link GoogleClusterService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateClusterService = /**
         * Creates the cluster service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link GoogleClusterService}.
         *
         */
            function (_mapService) {
                return new GoogleClusterService(_mapService, this._zone);
            };
        /**
         * Creates thh info box service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _markerService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link GoogleInfoBoxService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateInfoBoxService = /**
         * Creates thh info box service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _markerService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link GoogleInfoBoxService}.
         *
         */
            function (_mapService, _markerService) {
                return new GoogleInfoBoxService(_mapService, _markerService, this._zone);
            };
        /**
         * Creates the layer service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link GoogleLayerService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateLayerService = /**
         * Creates the layer service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link GoogleLayerService}.
         *
         */
            function (_mapService) {
                return new GoogleLayerService(_mapService, this._zone);
            };
        /**
         * Creates the marker service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link GoogleMarkerService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateMarkerService = /**
         * Creates the marker service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link GoogleMarkerService}.
         *
         */
            function (_mapService, _layerService, _clusterService) {
                return new GoogleMarkerService(_mapService, _layerService, _clusterService, this._zone);
            };
        /**
         * Creates the polygon service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
        GoogleMapServiceFactory.prototype.CreatePolygonService = /**
         * Creates the polygon service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new GooglePolygonService(map, layers, this._zone);
            };
        /**
         * Creates the polyline service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
        GoogleMapServiceFactory.prototype.CreatePolylineService = /**
         * Creates the polyline service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new GooglePolylineService(map, layers, this._zone);
            };
        GoogleMapServiceFactory.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMapServiceFactory.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return GoogleMapServiceFactory;
    }());
    /**
     *  Creates a new instance of a plaform specific MapServiceFactory.
     *
     * @param {?} apiLoader - An {\@link MapAPILoader} instance. This is expected to the a {\@link GoogleMapAPILoader}.
     * @param {?} zone - An NgZone instance to provide zone aware promises.
     *
     * @return {?} - A {\@link MapServiceFactory} instance.
     */
    function GoogleMapServiceFactoryFactory(apiLoader, zone) {
        return new GoogleMapServiceFactory(apiLoader, zone);
    }
    /**
     * Creates a new instance of a plaform specific MapLoaderFactory.
     *
     * @export
     * @return {?} - A {\@link MapAPILoader} instance.
     */
    function GoogleMapLoaderFactory() {
        return new GoogleMapAPILoader(new GoogleMapAPILoaderConfig(), new WindowRef(), new DocumentRef());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MapModule = (function () {
        function MapModule() {
        }
        /**
         * @param {?=} mapServiceFactory
         * @param {?=} loader
         * @return {?}
         */
        MapModule.forRoot = /**
         * @param {?=} mapServiceFactory
         * @param {?=} loader
         * @return {?}
         */
            function (mapServiceFactory, loader) {
                return {
                    ngModule: MapModule,
                    providers: [
                        mapServiceFactory ? { provide: MapServiceFactory, useValue: mapServiceFactory } :
                            { provide: MapServiceFactory, deps: [MapAPILoader, core.NgZone], useFactory: BingMapServiceFactoryFactory },
                        loader ? { provide: MapAPILoader, useValue: loader } : { provide: MapAPILoader, useFactory: BingMapLoaderFactory },
                        DocumentRef,
                        WindowRef
                    ]
                };
            };
        /**
         * @return {?}
         */
        MapModule.forRootBing = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: MapModule,
                    providers: [
                        { provide: MapServiceFactory, deps: [MapAPILoader, core.NgZone], useFactory: BingMapServiceFactoryFactory },
                        { provide: MapAPILoader, useFactory: BingMapLoaderFactory },
                        DocumentRef,
                        WindowRef
                    ]
                };
            };
        /**
         * @return {?}
         */
        MapModule.forRootGoogle = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: MapModule,
                    providers: [
                        { provide: MapServiceFactory, deps: [MapAPILoader, core.NgZone], useFactory: GoogleMapServiceFactoryFactory },
                        { provide: MapAPILoader, useFactory: GoogleMapLoaderFactory },
                        DocumentRef,
                        WindowRef
                    ]
                };
            };
        MapModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            MapLayerDirective,
                            MapComponent,
                            MapMarkerDirective,
                            InfoBoxComponent,
                            InfoBoxActionDirective,
                            MapPolygonDirective,
                            MapPolylineDirective,
                            ClusterLayerDirective,
                            MapMarkerLayerDirective,
                            MapPolygonLayerDirective,
                            MapPolylineLayerDirective
                        ],
                        imports: [common.CommonModule],
                        exports: [
                            common.CommonModule,
                            MapComponent,
                            MapMarkerDirective,
                            MapPolygonDirective,
                            MapPolylineDirective,
                            InfoBoxComponent,
                            InfoBoxActionDirective,
                            MapLayerDirective,
                            ClusterLayerDirective,
                            MapMarkerLayerDirective,
                            MapPolygonLayerDirective,
                            MapPolylineLayerDirective
                        ]
                    },] },
        ];
        return MapModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.MapComponent = MapComponent;
    exports.InfoBoxComponent = InfoBoxComponent;
    exports.MapMarkerDirective = MapMarkerDirective;
    exports.MapPolygonDirective = MapPolygonDirective;
    exports.MapPolylineDirective = MapPolylineDirective;
    exports.InfoBoxActionDirective = InfoBoxActionDirective;
    exports.MapMarkerLayerDirective = MapMarkerLayerDirective;
    exports.MapPolygonLayerDirective = MapPolygonLayerDirective;
    exports.MapLayerDirective = MapLayerDirective;
    exports.ClusterLayerDirective = ClusterLayerDirective;
    exports.MapPolylineLayerDirective = MapPolylineLayerDirective;
    exports.MapTypeId = MapTypeId;
    exports.Marker = Marker;
    exports.MarkerTypeId = MarkerTypeId;
    exports.InfoWindow = InfoWindow;
    exports.Layer = Layer;
    exports.ClusterPlacementMode = ClusterPlacementMode;
    exports.ClusterClickAction = ClusterClickAction;
    exports.SpiderClusterMarker = SpiderClusterMarker;
    exports.Polygon = Polygon;
    exports.Polyline = Polyline;
    exports.CanvasOverlay = CanvasOverlay;
    exports.MapService = MapService;
    exports.MapServiceFactory = MapServiceFactory;
    exports.MarkerService = MarkerService;
    exports.InfoBoxService = InfoBoxService;
    exports.MapAPILoader = MapAPILoader;
    exports.WindowRef = WindowRef;
    exports.DocumentRef = DocumentRef;
    exports.LayerService = LayerService;
    exports.PolygonService = PolygonService;
    exports.PolylineService = PolylineService;
    exports.ClusterService = ClusterService;
    exports.BingMapServiceFactory = BingMapServiceFactory;
    exports.BingMapAPILoaderConfig = BingMapAPILoaderConfig;
    exports.BingMapService = BingMapService;
    exports.BingInfoBoxService = BingInfoBoxService;
    exports.BingMarkerService = BingMarkerService;
    exports.BingPolygonService = BingPolygonService;
    exports.BingPolylineService = BingPolylineService;
    exports.BingMapAPILoader = BingMapAPILoader;
    exports.BingLayerService = BingLayerService;
    exports.BingClusterService = BingClusterService;
    exports.BingLayer = BingLayer;
    exports.BingMarker = BingMarker;
    exports.BingPolyline = BingPolyline;
    exports.BingMapEventsLookup = BingMapEventsLookup;
    exports.BingPolygon = BingPolygon;
    exports.BingInfoWindow = BingInfoWindow;
    exports.BingClusterLayer = BingClusterLayer;
    exports.BingSpiderClusterMarker = BingSpiderClusterMarker;
    exports.BingCanvasOverlay = BingCanvasOverlay;
    exports.GoogleClusterService = GoogleClusterService;
    exports.GoogleInfoBoxService = GoogleInfoBoxService;
    exports.GoogleLayerService = GoogleLayerService;
    exports.GoogleMapAPILoader = GoogleMapAPILoader;
    exports.GoogleMapAPILoaderConfig = GoogleMapAPILoaderConfig;
    exports.GoogleMapServiceFactory = GoogleMapServiceFactory;
    exports.GoogleMapService = GoogleMapService;
    exports.GoogleMarkerService = GoogleMarkerService;
    exports.GooglePolygonService = GooglePolygonService;
    exports.GooglePolylineService = GooglePolylineService;
    exports.GoogleMarker = GoogleMarker;
    exports.GoogleInfoWindow = GoogleInfoWindow;
    exports.GooglePolygon = GooglePolygon;
    exports.GooglePolyline = GooglePolyline;
    exports.GoogleMapEventsLookup = GoogleMapEventsLookup;
    exports.GoogleCanvasOverlay = GoogleCanvasOverlay;
    exports.MapModule = MapModule;
    exports.a = ClusterServiceFactory;
    exports.b = InfoBoxServiceFactory;
    exports.c = LayerServiceFactory;
    exports.d = MapServiceCreator;
    exports.e = MarkerServiceFactory;
    exports.f = PolygonServiceFactory;
    exports.g = PolylineServiceFactory;
    exports.l = BingLayerBase;
    exports.i = BingMapLoaderFactory;
    exports.h = BingMapServiceFactoryFactory;
    exports.m = GoogleLayerBase;
    exports.k = GoogleMapLoaderFactory;
    exports.j = GoogleMapServiceFactoryFactory;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1tYXBzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvaW5mby13aW5kb3cudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL21hcmtlci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvbGF5ZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL3BvbHlnb24udHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL3BvbHlsaW5lLnRzIixudWxsLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL3NwaWRlci1jbHVzdGVyLW1hcmtlci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvY2FudmFzLW92ZXJsYXkudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctY29udmVyc2lvbnMudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1tYXJrZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1zcGlkZXItY2x1c3Rlci1tYXJrZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1jbHVzdGVyLWxheWVyLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9iaW5nL2JpbmctaW5mby13aW5kb3cudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL21hcC1sYWJlbC50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvZXh0ZW5kZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1sYWJlbC50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvYmluZy9iaW5nLXBvbHlnb24udHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1wb2x5bGluZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvYmluZy9iaW5nLWV2ZW50cy1sb29rdXAudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1jYW52YXMtb3ZlcmxheS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC10eXBlcy50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWNvbnZlcnNpb25zLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLWluZm8td2luZG93LnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLW1hcmtlci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1sYWJlbC50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1wb2x5Z29uLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLXBvbHlsaW5lLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLWV2ZW50cy1sb29rdXAudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtY2FudmFzLW92ZXJsYXkudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvbWFwc2VydmljZWZhY3RvcnkudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvbWFwLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvbWFya2VyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvaW5mb2JveC5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2xheWVyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvcG9seWdvbi5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL3BvbHlsaW5lLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvY2x1c3Rlci5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL2NvbXBvbmVudHMvaW5mb2JveC1hY3Rpb24udHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvY29tcG9uZW50cy9pbmZvYm94LnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL2NvbXBvbmVudHMvbWFwLW1hcmtlci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL2NsdXN0ZXItbGF5ZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvY29tcG9uZW50cy9tYXAtcG9seWdvbi50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC1wb2x5bGluZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC1tYXJrZXItbGF5ZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvY29tcG9uZW50cy9tYXAtcG9seWdvbi1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC1wb2x5bGluZS1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9tYXBhcGlsb2FkZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvYmluZy9iaW5nLW1hcC5hcGktbG9hZGVyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvYmluZy9iaW5nLWluZm9ib3guc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctbWFya2VyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvYmluZy9iaW5nLW1hcC5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1sYXllci1iYXNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1sYXllci5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1jbHVzdGVyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvYmluZy9iaW5nLXBvbHlnb24uc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctcG9seWxpbmUuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UuZmFjdG9yeS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWxheWVyLWJhc2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1jbHVzdGVyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1pbmZvYm94LnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtbGF5ZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1sYXllci5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLWFwaS1sb2FkZXIuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcmtlci5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLW1hcmtlci1jbHVzdGVyZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLXBvbHlnb24uc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLXBvbHlsaW5lLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAuc2VydmljZS5mYWN0b3J5LnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSUluZm9XaW5kb3dPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctb3B0aW9ucyc7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5mb1dpbmRvdyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGluZm8gYm94IGlzIGN1cnJlbnRseSBvcGVuLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb1dpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IElzT3BlbigpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBwcmltaXRpdmUgb2YgdGhlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb1dpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGluZm8gd2luZG93LlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGxpc3RlbmVyIChlLmcuIFwiY2xpY2tcIilcclxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGludm9rZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvV2luZG93XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyB0aGUgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9XaW5kb3dcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IENsb3NlKCk6IHZvaWQgO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGluZm8gd2luZG93LlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybnMgLSBSZXR1cm5zIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIGluZm8gd2luZG93LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvV2luZG93XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRQb3NpdGlvbigpOiBJTGF0TG9uZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW5zIHRoZSBpbmZvIHdpbmRvdy5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb1dpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgT3BlbigpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaW5mbyB3aW5kb3cgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gSW5mbyB3aW5kb3cgb3B0aW9ucyB0byBzZXQuIFRoZSBvcHRpb25zIHdpbGwgYmUgbWVyZ2VkIHdpdGggYW55IGV4aXN0aW5nIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9XaW5kb3dcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldE9wdGlvbnMob3B0aW9uczogSUluZm9XaW5kb3dPcHRpb25zKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIC0gR2VvIGNvb3JkaW5hdGVzIHRvIG1vdmUgdGhlIGFuY2hvciBvZiB0aGUgaW5mbyB3aW5kb3cgdG8uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9XaW5kb3dcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldFBvc2l0aW9uKHBvc2l0aW9uOiBJTGF0TG9uZyk6IHZvaWQ7XHJcbn1cclxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pc2l6ZSc7XHJcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4uL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XHJcblxyXG4vKipcclxuICogVGhpcyBpbnRlcmZhY2UgZGVmaW5lcyB0aGUgY29udHJhY3QgZm9yIGFuIGljb24gY2FjaGUgZW50cnkuXHJcbiAqL1xyXG5pbnRlcmZhY2UgSU1hcmtlckljb25DYWNoZUVudHJ5IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGljb24gc3RyaW5nIG9mIHRoZSBjYWNoZSBlbnRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSU1hcmtlckljb25DYWNoZUVudHJ5XHJcbiAgICAgKi9cclxuICAgIG1hcmtlckljb25TdHJpbmc6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBTaXplIG9mIHRoZSBpY29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJTWFya2VySWNvbkNhY2hlRW50cnlcclxuICAgICogKi9cclxuICAgIG1hcmtlclNpemU6IElTaXplO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBkZWZpbmVzIHRoZSBjb250cmFjdCBmb3IgYSBtYXJrZXIuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTWFya2VyIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWZpbml0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZXMgY29uY3JldGUgaW1nIGVsZW1lbnRzIGZvciBtYXJrZXIgaWNvbnMgdG8gYWNjZWxlcmF0ZSBwYXRpbmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIEltYWdlRWxlbWVudENhY2hlOiBNYXA8c3RyaW5nLCBIVE1MSW1hZ2VFbGVtZW50PiA9IG5ldyBNYXA8c3RyaW5nLCBIVE1MSW1hZ2VFbGVtZW50PigpO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gY2FjaGUgZ2VuZXJhdGVkIG1hcmtlcnMgZm9yIHBlcmZvcm1hbmNlIGFuZCByZXVzYWJpbGl0eS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIE1hcmtlckNhY2hlOiBNYXA8c3RyaW5nLCBJTWFya2VySWNvbkNhY2hlRW50cnk+ID0gbmV3IE1hcDxzdHJpbmcsIElNYXJrZXJJY29uQ2FjaGVFbnRyeT4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXJrZXIgYmFzZWQgb24gdGhlIG1hcmtlciBpbmZvLiBJbiB0dXJuIGNhbGxzIGEgbnVtYmVyIG9mIGludGVybmFsIG1lbWJlcnMgdG9cclxuICAgICAqIGNyZWF0ZSB0aGUgYWN0dWFsIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWNvbkluZm8gLSBpY29uIGluZm9ybWF0aW9uLiBEZXBlbmRpbmcgb24gdGhlIG1hcmtlciB0eXBlLCB2YXJpb3VzIHByb3BlcnRpZXNcclxuICAgICAqIG5lZWQgdG8gYmUgcHJlc2VudC4gRm9yIHBlcmZvcm1hbmNlLCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYW4gaWQgZm9yIG1hcmtlcnMgdGhhdCBhcmUgY29tbW9uIHRvIGZhY2lsaXRhdGVcclxuICAgICAqIHJldXNlLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBjYWxsYmFjayB0aGF0IGlzIGludm9rZWQgb24gbWFya2VycyB0aGF0IHJlcXVpcmUgYXN5bmNyb25vdXNcclxuICAgICAqIHByb2Nlc3NpbmcgZHVyaW5nIGNyZWF0aW9uLiBGb3IgbWFya2VycyB0aGF0IGRvIG5vdCByZXF1aXJlIGFzeW5jIHByb2Nlc3NpbmcsIHRoaXMgcGFyYW1ldGVyIGlzIGlnbm9yZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIGEgc3RyaW5nIG9yIGEgcHJvbWlzZSBmb3IgYSBzdHJpbmcgY29udGFpbmluZ1xyXG4gICAgICogYSBkYXRhIHVybCB3aXRoIHRoZSBtYXJrZXIgaW1hZ2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ3JlYXRlTWFya2VyKGljb25JbmZvOiBJTWFya2VySWNvbkluZm8pOiBzdHJpbmd8UHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4ge1xyXG4gICAgICAgIHN3aXRjaCAoaWNvbkluZm8ubWFya2VyVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIE1hcmtlclR5cGVJZC5DYW52YXNNYXJrZXI6IHJldHVybiBNYXJrZXIuQ3JlYXRlQ2FudmFzTWFya2VyKGljb25JbmZvKTtcclxuICAgICAgICAgICAgY2FzZSBNYXJrZXJUeXBlSWQuRHluYW1pY0NpcmNsZU1hcmtlcjogcmV0dXJuIE1hcmtlci5DcmVhdGVEeW5hbWljQ2lyY2xlTWFya2VyKGljb25JbmZvKTtcclxuICAgICAgICAgICAgY2FzZSBNYXJrZXJUeXBlSWQuRm9udE1hcmtlcjogcmV0dXJuIE1hcmtlci5DcmVhdGVGb250QmFzZWRNYXJrZXIoaWNvbkluZm8pO1xyXG4gICAgICAgICAgICBjYXNlIE1hcmtlclR5cGVJZC5Sb3RhdGVkSW1hZ2VNYXJrZXI6IHJldHVybiBNYXJrZXIuQ3JlYXRlUm90YXRlZEltYWdlTWFya2VyKGljb25JbmZvKTtcclxuICAgICAgICAgICAgY2FzZSBNYXJrZXJUeXBlSWQuUm91bmRlZEltYWdlTWFya2VyOiByZXR1cm4gTWFya2VyLkNyZWF0ZVJvdW5kZWRJbWFnZU1hcmtlcihpY29uSW5mbyk7XHJcbiAgICAgICAgICAgIGNhc2UgTWFya2VyVHlwZUlkLlNjYWxlZEltYWdlTWFya2VyOiByZXR1cm4gTWFya2VyLkNyZWF0ZVNjYWxlZEltYWdlTWFya2VyKGljb25JbmZvKTtcclxuICAgICAgICAgICAgY2FzZSBNYXJrZXJUeXBlSWQuQ3VzdG9tOiB0aHJvdyBFcnJvcignQ3VzdG9tIE1hcmtlciBDcmVhdG9ycyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBtYXJrZXIgdHlwZTogJyArIGljb25JbmZvLm1hcmtlclR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyBhIHNoYXJlZCBpbWcgZWxlbWVudCBmb3IgYSBtYXJrZXIgaWNvbiB0byBwcmV2ZW50IHVuZWNlc3NhcnkgY3JlYXRpb24gb2ZcclxuICAgICAqIERPTSBpdGVtcy4gVGhpcyBoYXMgc3BlZCB1cCBsYXJnZSBzY2FsZSBtYWtlcnMgb24gQmluZyBNYXBzIGJ5IGFib3V0IDcwJVxyXG4gICAgICogQHBhcmFtIGljb24gLSBUaGUgaWNvbiBzdHJpbmcgKHVybCwgZGF0YSB1cmwsIHN2ZykgZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgaW1hZ2UuXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBvYnRhaW5lZCBpbWFnZSBlbGVtZW50LlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEdldEltYWdlRm9yTWFya2VyKGljb246IHN0cmluZyk6IEhUTUxJbWFnZUVsZW1lbnQge1xyXG4gICAgICAgIGlmIChpY29uID09IG51bGwgfHwgaWNvbiA9PT0gJycgKSB7IHJldHVybiAgbnVsbDsgfVxyXG5cclxuICAgICAgICBsZXQgaW1nOiBIVE1MSW1hZ2VFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICBpbWcgPSBNYXJrZXIuSW1hZ2VFbGVtZW50Q2FjaGUuZ2V0KGljb24pO1xyXG4gICAgICAgIGlmIChpbWcgIT0gbnVsbCkgeyByZXR1cm4gaW1nOyB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG4gICAgICAgICAgICBpbWcuc3JjID0gaWNvbjtcclxuICAgICAgICAgICAgTWFya2VyLkltYWdlRWxlbWVudENhY2hlLnNldChpY29uLCBpbWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW1nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNhbnZhc2VkIGJhc2VkIG1hcmtlciB1c2luZyB0aGUgcG9pbnQgY29sbGVjdGlvbiBjb250YWluZWQgaW4gdGhlIGljb25JbmZvIHBhcmFtZXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0gaWNvbkluZm8gLSB7QGxpbmsgSU1hcmtlckljb25JbmZvfSBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoZSBpY29uLlxyXG4gICAgICogQHJldHVybnMgLSBTdHJpbmcgd2l0aCB0aGUgZGF0YSB1cmwgZm9yIHRoZSBtYXJrZXIgaW1hZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIENyZWF0ZUNhbnZhc01hcmtlcihpY29uSW5mbzogSU1hcmtlckljb25JbmZvKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQgPT0gbnVsbCkgeyB0aHJvdyBFcnJvcignRG9jdW1lbnQgY29udGV4dCAod2luZG93LmRvY3VtZW50KSBpcyByZXF1aXJlZCBmb3IgY2FudmFzIG1hcmtlcnMuJyk7IH1cclxuICAgICAgICBpZiAoaWNvbkluZm8gPT0gbnVsbCB8fCBpY29uSW5mby5zaXplID09IG51bGwgfHwgaWNvbkluZm8ucG9pbnRzID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0lNYXJrZXJJY29uSW5mby5zaXplLCBhbmQgSU1hcmtlcklDb25JbmZvLnBvaW50cyBhcmUgcmVxdWlyZWQgZm9yIGNhbnZhcyBtYXJrZXJzLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaWNvbkluZm8uaWQgIT0gbnVsbCAmJiBNYXJrZXIuTWFya2VyQ2FjaGUuaGFzKGljb25JbmZvLmlkKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtaTogSU1hcmtlckljb25DYWNoZUVudHJ5ID0gTWFya2VyLk1hcmtlckNhY2hlLmdldChpY29uSW5mby5pZCk7XHJcbiAgICAgICAgICAgIGljb25JbmZvLnNpemUgPSBtaS5tYXJrZXJTaXplO1xyXG4gICAgICAgICAgICByZXR1cm4gbWkubWFya2VySWNvblN0cmluZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgYy53aWR0aCA9IGljb25JbmZvLnNpemUud2lkdGg7XHJcbiAgICAgICAgYy5oZWlnaHQgPSBpY29uSW5mby5zaXplLmhlaWdodDtcclxuICAgICAgICBpZiAoaWNvbkluZm8ucm90YXRpb24pIHtcclxuICAgICAgICAgICAgLy8gT2Zmc2V0IHRoZSBjYW52YXMgc3VjaCB0aGF0IHdlIHdpbGwgcm90YXRlIGFyb3VuZCB0aGUgY2VudGVyIG9mIG91ciBhcnJvd1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGMud2lkdGggKiAwLjUsIGMuaGVpZ2h0ICogMC41KTtcclxuICAgICAgICAgICAgLy8gUm90YXRlIHRoZSBjYW52YXMgYnkgdGhlIGRlc2lyZWQgaGVhZGluZ1xyXG4gICAgICAgICAgICBjdHgucm90YXRlKGljb25JbmZvLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY2FudmFzIG9mZnNldCBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgcG9zaXRpb25cclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtYy53aWR0aCAqIDAuNSwgLWMuaGVpZ2h0ICogMC41KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBpY29uSW5mby5jb2xvciB8fCAncmVkJztcclxuXHJcbiAgICAgICAgLy8gRHJhdyBhIHBhdGggaW4gdGhlIHNoYXBlIG9mIGFuIGFycm93LlxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBpZiAoaWNvbkluZm8uZHJhd2luZ09mZnNldCkgeyBjdHgubW92ZVRvKGljb25JbmZvLmRyYXdpbmdPZmZzZXQueCwgaWNvbkluZm8uZHJhd2luZ09mZnNldC55KTsgfVxyXG4gICAgICAgIGljb25JbmZvLnBvaW50cy5mb3JFYWNoKChwOiBJUG9pbnQpID0+IHsgY3R4LmxpbmVUbyhwLngsIHAueSk7IH0pO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgczogc3RyaW5nID0gYy50b0RhdGFVUkwoKTtcclxuICAgICAgICBpZiAoaWNvbkluZm8uaWQgIT0gbnVsbCkgeyBNYXJrZXIuTWFya2VyQ2FjaGUuc2V0KGljb25JbmZvLmlkLCB7IG1hcmtlckljb25TdHJpbmc6IHMsIG1hcmtlclNpemU6IGljb25JbmZvLnNpemUgfSk7IH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjaXJjbGUgbWFya2VyIGltYWdlIHVzaW5nIGluZm9ybWF0aW9uIGNvbnRhaW5lZCBpbiB0aGUgaWNvbkluZm8gcGFyYW1ldGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBpY29uSW5mbyAtIHtAbGluayBJTWFya2VySWNvbkluZm99IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBjcmVhdGUgdGhlIGljb24uXHJcbiAgICAgKiBAcmV0dXJucyAtIFN0cmluZyB3aXRoIHRoZSBkYXRhIHVybCBmb3IgdGhlIG1hcmtlciBpbWFnZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgQ3JlYXRlRHluYW1pY0NpcmNsZU1hcmtlcihpY29uSW5mbzogSU1hcmtlckljb25JbmZvKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQgPT0gbnVsbCkgeyB0aHJvdyBFcnJvcignRG9jdW1lbnQgY29udGV4dCAod2luZG93LmRvY3VtZW50KSBpcyByZXF1aXJlZCBmb3IgZHluYW1pYyBjaXJjbGUgbWFya2Vycy4nKTsgfVxyXG4gICAgICAgIGlmIChpY29uSW5mbyA9PSBudWxsIHx8IGljb25JbmZvLnNpemUgPT0gbnVsbCkgeyB0aHJvdyBFcnJvcignSU1hcmtlckljb25JbmZvLnNpemUgaXMgcmVxdWlyZWQgZm9yIGR5bmFtaWMgY2lyY2xlIG1hcmtlcnMuJyk7IH1cclxuICAgICAgICBpZiAoaWNvbkluZm8uaWQgIT0gbnVsbCAmJiBNYXJrZXIuTWFya2VyQ2FjaGUuaGFzKGljb25JbmZvLmlkKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtaTogSU1hcmtlckljb25DYWNoZUVudHJ5ID0gTWFya2VyLk1hcmtlckNhY2hlLmdldChpY29uSW5mby5pZCk7XHJcbiAgICAgICAgICAgIGljb25JbmZvLnNpemUgPSBtaS5tYXJrZXJTaXplO1xyXG4gICAgICAgICAgICByZXR1cm4gbWkubWFya2VySWNvblN0cmluZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoOiBudW1iZXIgPSBpY29uSW5mby5zdHJva2VXaWR0aCB8fCAwO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhbiBTVkcgc3RyaW5nIG9mIGEgY2lyY2xlIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMgYW5kIGNvbG9yLlxyXG4gICAgICAgIGNvbnN0IHN2ZzogQXJyYXk8c3RyaW5nPiA9IFtcclxuICAgICAgICAgICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiJyxcclxuICAgICAgICAgICAgaWNvbkluZm8uc2l6ZS53aWR0aC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcclxuICAgICAgICAgICAgaWNvbkluZm8uc2l6ZS53aWR0aC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAnXCI+PGNpcmNsZSBjeD1cIicsXHJcbiAgICAgICAgICAgIChpY29uSW5mby5zaXplLndpZHRoIC8gMikudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgJ1wiIGN5PVwiJyxcclxuICAgICAgICAgICAgKGljb25JbmZvLnNpemUud2lkdGggLyAyKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAnXCIgcj1cIicsXHJcbiAgICAgICAgICAgICgoaWNvbkluZm8uc2l6ZS53aWR0aCAvIDIpIC0gc3Ryb2tlV2lkdGgpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICdcIiBzdHJva2U9XCInLFxyXG4gICAgICAgICAgICBpY29uSW5mby5jb2xvciB8fCAncmVkJyxcclxuICAgICAgICAgICAgJ1wiIHN0cm9rZS13aWR0aD1cIicsXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICdcIiBmaWxsPVwiJyxcclxuICAgICAgICAgICAgaWNvbkluZm8uY29sb3IgfHwgJ3JlZCcsXHJcbiAgICAgICAgICAgICdcIi8+PC9zdmc+J1xyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGNvbnN0IHM6IHN0cmluZyA9IHN2Zy5qb2luKCcnKTtcclxuICAgICAgICBpZiAoaWNvbkluZm8uaWQgIT0gbnVsbCkgeyBNYXJrZXIuTWFya2VyQ2FjaGUuc2V0KGljb25JbmZvLmlkLCB7IG1hcmtlckljb25TdHJpbmc6IHMsIG1hcmtlclNpemU6IGljb25JbmZvLnNpemUgfSk7IH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmb250IGJhc2VkIG1hcmtlciBpbWFnZSAoc3VjaCBhcyBGb250LUF3ZXNvbWUpLCBieSB1c2luZyBpbmZvcm1hdGlvbiBzdXBwbGllZCBpbiB0aGUgcGFyYW1ldGVycyAoc3VjaCBhcyBGb250LUF3ZXNvbWUpLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBpY29uSW5mbyAtIHtAbGluayBJTWFya2VySWNvbkluZm99IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBjcmVhdGUgdGhlIGljb24uXHJcbiAgICAgKiBAcmV0dXJucyAtIFN0cmluZyB3aXRoIHRoZSBkYXRhIHVybCBmb3IgdGhlIG1hcmtlciBpbWFnZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgQ3JlYXRlRm9udEJhc2VkTWFya2VyKGljb25JbmZvOiBJTWFya2VySWNvbkluZm8pOiBzdHJpbmcge1xyXG4gICAgICAgIGlmIChkb2N1bWVudCA9PSBudWxsKSB7IHRocm93IEVycm9yKCdEb2N1bWVudCBjb250ZXh0ICh3aW5kb3cuZG9jdW1lbnQpIGlzIHJlcXVpcmVkIGZvciBmb250IGJhc2VkIG1hcmtlcnMnKTsgfVxyXG4gICAgICAgIGlmIChpY29uSW5mbyA9PSBudWxsIHx8IGljb25JbmZvLmZvbnROYW1lID09IG51bGwgfHwgaWNvbkluZm8uZm9udFNpemUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSU1hcmtlckljb25JbmZvLmZvbnROYW1lLCBJTWFya2VySWNvbkluZm8uZm9udFNpemUgYW5kIElNYXJrZXJJQ29uSW5mby50ZXh0IGFyZSByZXF1aXJlZCBmb3IgZm9udCBiYXNlZCBtYXJrZXJzLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaWNvbkluZm8uaWQgIT0gbnVsbCAmJiBNYXJrZXIuTWFya2VyQ2FjaGUuaGFzKGljb25JbmZvLmlkKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtaTogSU1hcmtlckljb25DYWNoZUVudHJ5ID0gTWFya2VyLk1hcmtlckNhY2hlLmdldChpY29uSW5mby5pZCk7XHJcbiAgICAgICAgICAgIGljb25JbmZvLnNpemUgPSBtaS5tYXJrZXJTaXplO1xyXG4gICAgICAgICAgICByZXR1cm4gbWkubWFya2VySWNvblN0cmluZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgY29uc3QgZm9udDogc3RyaW5nID0gaWNvbkluZm8uZm9udFNpemUgKyAncHggJyArIGljb25JbmZvLmZvbnROYW1lO1xyXG4gICAgICAgIGN0eC5mb250ID0gZm9udDtcclxuXHJcbiAgICAgICAgLy8gUmVzaXplIGNhbnZhcyBiYXNlZCBvbiBzaWUgb2YgdGV4dC5cclxuICAgICAgICBjb25zdCBzaXplOiBUZXh0TWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChpY29uSW5mby50ZXh0KTtcclxuICAgICAgICBjLndpZHRoID0gc2l6ZS53aWR0aDtcclxuICAgICAgICBjLmhlaWdodCA9IGljb25JbmZvLmZvbnRTaXplO1xyXG5cclxuICAgICAgICBpZiAoaWNvbkluZm8ucm90YXRpb24pIHtcclxuICAgICAgICAgICAgLy8gT2Zmc2V0IHRoZSBjYW52YXMgc3VjaCB0aGF0IHdlIHdpbGwgcm90YXRlIGFyb3VuZCB0aGUgY2VudGVyIG9mIG91ciBhcnJvd1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGMud2lkdGggKiAwLjUsIGMuaGVpZ2h0ICogMC41KTtcclxuICAgICAgICAgICAgLy8gUm90YXRlIHRoZSBjYW52YXMgYnkgdGhlIGRlc2lyZWQgaGVhZGluZ1xyXG4gICAgICAgICAgICBjdHgucm90YXRlKGljb25JbmZvLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY2FudmFzIG9mZnNldCBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgcG9zaXRpb25cclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtYy53aWR0aCAqIDAuNSwgLWMuaGVpZ2h0ICogMC41KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IGZvbnQgYXMgaXQgd2lsbCBiZSBjbGVhcmVkIGJ5IHRoZSByZXNpemUuXHJcbiAgICAgICAgY3R4LmZvbnQgPSBmb250O1xyXG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gaWNvbkluZm8uY29sb3IgfHwgJ3JlZCc7XHJcblxyXG4gICAgICAgIGN0eC5maWxsVGV4dChpY29uSW5mby50ZXh0LCAwLCAwKTtcclxuICAgICAgICBpY29uSW5mby5zaXplID0geyB3aWR0aDogYy53aWR0aCwgaGVpZ2h0OiBjLmhlaWdodCB9O1xyXG4gICAgICAgIGNvbnN0IHM6IHN0cmluZyA9IGMudG9EYXRhVVJMKCk7XHJcbiAgICAgICAgaWYgKGljb25JbmZvLmlkICE9IG51bGwpIHsgTWFya2VyLk1hcmtlckNhY2hlLnNldChpY29uSW5mby5pZCwgeyBtYXJrZXJJY29uU3RyaW5nOiBzLCBtYXJrZXJTaXplOiBpY29uSW5mby5zaXplIH0pOyB9XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGltYWdlIG1hcmtlciBieSBhcHBseWluZyBhIHJvYXRpb24gdG8gYSBzdXBwbGllZCBpbWFnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0gaWNvbkluZm8gLSB7QGxpbmsgSU1hcmtlckljb25JbmZvfSBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoZSBpY29uLlxyXG4gICAgICogQHJldHVybnMgLSBhIHN0cmluZyBvciBhIHByb21pc2UgZm9yIGEgc3RyaW5nIGNvbnRhaW5pbmdcclxuICAgICAqIGEgZGF0YSB1cmwgd2l0aCB0aGUgbWFya2VyIGltYWdlLiBJbiBjYXNlIG9mIGEgY2FjaGVkIGltYWdlLCB0aGUgaW1hZ2Ugd2lsbCBiZSByZXR1cm5lZCwgb3RoZXJ3aXNlIHRoZSBwcm9taXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBDcmVhdGVSb3RhdGVkSW1hZ2VNYXJrZXIoaWNvbkluZm86IElNYXJrZXJJY29uSW5mbyk6IHN0cmluZ3xQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PiB7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50ID09IG51bGwpIHsgdGhyb3cgRXJyb3IoJ0RvY3VtZW50IGNvbnRleHQgKHdpbmRvdy5kb2N1bWVudCkgaXMgcmVxdWlyZWQgZm9yIHJvdGF0ZWQgaW1hZ2UgbWFya2VycycpOyB9XHJcbiAgICAgICAgaWYgKGljb25JbmZvID09IG51bGwgfHwgaWNvbkluZm8ucm90YXRpb24gPT0gbnVsbCB8fCBpY29uSW5mby51cmwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSU1hcmtlckljb25JbmZvLnJvdGF0aW9uLCBJTWFya2VySWNvbkluZm8udXJsIGFyZSByZXF1aXJlZCBmb3Igcm90YXRlZCBpbWFnZSBtYXJrZXJzLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaWNvbkluZm8uaWQgIT0gbnVsbCAmJiBNYXJrZXIuTWFya2VyQ2FjaGUuaGFzKGljb25JbmZvLmlkKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtaTogSU1hcmtlckljb25DYWNoZUVudHJ5ID0gTWFya2VyLk1hcmtlckNhY2hlLmdldChpY29uSW5mby5pZCk7XHJcbiAgICAgICAgICAgIGljb25JbmZvLnNpemUgPSBtaS5tYXJrZXJTaXplO1xyXG4gICAgICAgICAgICByZXR1cm4gbWkubWFya2VySWNvblN0cmluZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZTogUHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4gPVxyXG4gICAgICAgICAgICBuZXcgUHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBBbGxvdyBjcm9zcyBkb21haW4gaW1hZ2UgZWRpdHRpbmcuXHJcbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgICAgICAgICAgIGltYWdlLnNyYyA9IGljb25JbmZvLnVybDtcclxuICAgICAgICAgICAgaWYgKGljb25JbmZvLnNpemUpIHtcclxuICAgICAgICAgICAgICAgIGltYWdlLndpZHRoID0gaWNvbkluZm8uc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGltYWdlLmhlaWdodCA9IGljb25JbmZvLnNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZHM6IG51bWJlciA9IGljb25JbmZvLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcm90YXRlZCBpbWFnZSBzaXplLlxyXG4gICAgICAgICAgICAgICAgYy53aWR0aCA9IE1hdGguY2VpbChNYXRoLmFicyhpbWFnZS53aWR0aCAqIE1hdGguY29zKHJhZHMpKSArIE1hdGguYWJzKGltYWdlLmhlaWdodCAqIE1hdGguc2luKHJhZHMpKSk7XHJcbiAgICAgICAgICAgICAgICBjLmhlaWdodCA9IE1hdGguY2VpbChNYXRoLmFicyhpbWFnZS53aWR0aCAqIE1hdGguc2luKHJhZHMpKSArIE1hdGguYWJzKGltYWdlLmhlaWdodCAqIE1hdGguY29zKHJhZHMpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgY2VudGVyIG9mIHRoZSBjYW52YXMuXHJcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGMud2lkdGggLyAyLCBjLmhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgLy8gUm90YXRlIHRoZSBjYW52YXMgdG8gdGhlIHNwZWNpZmllZCBhbmdsZSBpbiBkZWdyZWVzLlxyXG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShyYWRzKTtcclxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhlIGltYWdlLCBzaW5jZSB0aGUgY29udGV4dCBpcyByb3RhdGVkLCB0aGUgaW1hZ2Ugd2lsbCBiZSByb3RhdGVkIGFsc28uXHJcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAtaW1hZ2Uud2lkdGggLyAyLCAtaW1hZ2UuaGVpZ2h0IC8gMiwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBpY29uSW5mby5zaXplID0geyB3aWR0aDogYy53aWR0aCwgaGVpZ2h0OiBjLmhlaWdodCB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHM6IHN0cmluZyA9IGMudG9EYXRhVVJMKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWNvbkluZm8uaWQgIT0gbnVsbCkgeyBNYXJrZXIuTWFya2VyQ2FjaGUuc2V0KGljb25JbmZvLmlkLCB7IG1hcmtlckljb25TdHJpbmc6IHMsIG1hcmtlclNpemU6IGljb25JbmZvLnNpemUgfSk7IH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoe2ljb246IHMsIGljb25JbmZvOiBpY29uSW5mb30pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJvdW5kZWQgaW1hZ2UgbWFya2VyIGJ5IGFwcGx5aW5nIGEgY2lyY2xlIG1hc2sgdG8gYSBzdXBwbGllZCBpbWFnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0gaWNvbkluZm8gLSB7QGxpbmsgSU1hcmtlckljb25JbmZvfSBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoZSBpY29uLlxyXG4gICAgICogQHBhcmFtIGljb25JbmZvIC0gQ2FsbGJhY2sgaW52b2tlZCBvbmNlIG1hcmtlciBnZW5lcmF0aW9uIGlzIGNvbXBsZXRlLiBUaGUgY2FsbGJhY2tcclxuICAgICAqIHBhcmFtZXRlcnMgYXJlIHRoZSBkYXRhIHVyaSBhbmQgdGhlIElNYXJrZXJJY29uSW5mby5cclxuICAgICAqIEByZXR1cm5zIC0gYSBzdHJpbmcgb3IgYSBwcm9taXNlIGZvciBhIHN0cmluZyBjb250YWluaW5nXHJcbiAgICAgKiBhIGRhdGEgdXJsIHdpdGggdGhlIG1hcmtlciBpbWFnZS4gSW4gY2FzZSBvZiBhIGNhY2hlZCBpbWFnZSwgdGhlIGltYWdlIHdpbGwgYmUgcmV0dXJuZWQsIG90aGVyd2lzZSB0aGUgcHJvbWlzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgQ3JlYXRlUm91bmRlZEltYWdlTWFya2VyKGljb25JbmZvOiBJTWFya2VySWNvbkluZm8pOiBzdHJpbmd8UHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4ge1xyXG4gICAgICAgIGlmIChkb2N1bWVudCA9PSBudWxsKSB7IHRocm93IEVycm9yKCdEb2N1bWVudCBjb250ZXh0ICh3aW5kb3cuZG9jdW1lbnQpIGlzIHJlcXVpcmVkIGZvciByb3VuZGVkIGltYWdlIG1hcmtlcnMnKTsgfVxyXG4gICAgICAgIGlmIChpY29uSW5mbyA9PSBudWxsIHx8IGljb25JbmZvLnNpemUgPT0gbnVsbCB8fCBpY29uSW5mby51cmwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSU1hcmtlckljb25JbmZvLnNpemUsIElNYXJrZXJJY29uSW5mby51cmwgYXJlIHJlcXVpcmVkIGZvciByb3VuZGVkIGltYWdlIG1hcmtlcnMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsICYmIE1hcmtlci5NYXJrZXJDYWNoZS5oYXMoaWNvbkluZm8uaWQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pOiBJTWFya2VySWNvbkNhY2hlRW50cnkgPSBNYXJrZXIuTWFya2VyQ2FjaGUuZ2V0KGljb25JbmZvLmlkKTtcclxuICAgICAgICAgICAgaWNvbkluZm8uc2l6ZSA9IG1pLm1hcmtlclNpemU7XHJcbiAgICAgICAgICAgIHJldHVybiBtaS5tYXJrZXJJY29uU3RyaW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcHJvbWlzZTogUHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4gPVxyXG4gICAgICAgICAgICBuZXcgUHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByYWRpdXM6IG51bWJlciA9IGljb25JbmZvLnNpemUud2lkdGggLyAyO1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZTogSFRNTEltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQ6IElQb2ludCA9IGljb25JbmZvLmRyYXdpbmdPZmZzZXQgfHwgeyB4OiAwLCB5OiAwIH07XHJcblxyXG4gICAgICAgICAgICAvLyBBbGxvdyBjcm9zcyBkb21haW4gaW1hZ2UgZWRpdHRpbmcuXHJcbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgICAgICAgICAgIGltYWdlLnNyYyA9IGljb25JbmZvLnVybDtcclxuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYzogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gYy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgYy53aWR0aCA9IGljb25JbmZvLnNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjLmhlaWdodCA9IGljb25JbmZvLnNpemUud2lkdGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBhIGNpcmNsZSB3aGljaCBjYW4gYmUgdXNlZCB0byBjbGlwIHRoZSBpbWFnZSwgdGhlbiBkcmF3IHRoZSBpbWFnZS5cclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5hcmMocmFkaXVzLCByYWRpdXMsIHJhZGl1cywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguY2xpcCgpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgb2Zmc2V0LngsIG9mZnNldC55LCBpY29uSW5mby5zaXplLndpZHRoLCBpY29uSW5mby5zaXplLndpZHRoKTtcclxuICAgICAgICAgICAgICAgIGljb25JbmZvLnNpemUgPSB7IHdpZHRoOiBjLndpZHRoLCBoZWlnaHQ6IGMuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgczogc3RyaW5nID0gYy50b0RhdGFVUkwoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsKSB7IE1hcmtlci5NYXJrZXJDYWNoZS5zZXQoaWNvbkluZm8uaWQsIHsgbWFya2VySWNvblN0cmluZzogcywgbWFya2VyU2l6ZTogaWNvbkluZm8uc2l6ZSB9KTsgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7aWNvbjogcywgaWNvbkluZm86IGljb25JbmZvfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc2NhbGVkIGltYWdlIG1hcmtlciBieSBzY2FsaW5nIGEgc3VwcGxpZWQgaW1hZ2UgYnkgYSBmYWN0b3IgdXNpbmcgYSBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIGljb25JbmZvIC0ge0BsaW5rIElNYXJrZXJJY29uSW5mb30gY29udGFpbmluZyB0aGUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGNyZWF0ZSB0aGUgaWNvbi5cclxuICAgICAqIEBwYXJhbSBpY29uSW5mbyAtIENhbGxiYWNrIGludm9rZWQgb25jZSBtYXJrZXIgZ2VuZXJhdGlvbiBpcyBjb21wbGV0ZS4gVGhlIGNhbGxiYWNrXHJcbiAgICAgKiBwYXJhbWV0ZXJzIGFyZSB0aGUgZGF0YSB1cmkgYW5kIHRoZSBJTWFya2VySWNvbkluZm8uXHJcbiAgICAgKiBAcmV0dXJucyAtIGEgc3RyaW5nIG9yIGEgcHJvbWlzZSBmb3IgYSBzdHJpbmcgY29udGFpbmluZ1xyXG4gICAgICogYSBkYXRhIHVybCB3aXRoIHRoZSBtYXJrZXIgaW1hZ2UuIEluIGNhc2Ugb2YgYSBjYWNoZWQgaW1hZ2UsIHRoZSBpbWFnZSB3aWxsIGJlIHJldHVybmVkLCBvdGhlcndpc2UgdGhlIHByb21pc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIENyZWF0ZVNjYWxlZEltYWdlTWFya2VyKGljb25JbmZvOiBJTWFya2VySWNvbkluZm8pOiBzdHJpbmd8UHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4ge1xyXG4gICAgICAgIGlmIChkb2N1bWVudCA9PSBudWxsKSB7IHRocm93IEVycm9yKCdEb2N1bWVudCBjb250ZXh0ICh3aW5kb3cuZG9jdW1lbnQpIGlzIHJlcXVpcmVkIGZvciBzY2FsZWQgaW1hZ2UgbWFya2VycycpOyB9XHJcbiAgICAgICAgaWYgKGljb25JbmZvID09IG51bGwgfHwgaWNvbkluZm8uc2NhbGUgPT0gbnVsbCB8fCBpY29uSW5mby51cmwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSU1hcmtlckljb25JbmZvLnNjYWxlLCBJTWFya2VySWNvbkluZm8udXJsIGFyZSByZXF1aXJlZCBmb3Igc2NhbGVkIGltYWdlIG1hcmtlcnMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsICYmIE1hcmtlci5NYXJrZXJDYWNoZS5oYXMoaWNvbkluZm8uaWQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pOiBJTWFya2VySWNvbkNhY2hlRW50cnkgPSBNYXJrZXIuTWFya2VyQ2FjaGUuZ2V0KGljb25JbmZvLmlkKTtcclxuICAgICAgICAgICAgaWNvbkluZm8uc2l6ZSA9IG1pLm1hcmtlclNpemU7XHJcbiAgICAgICAgICAgIHJldHVybiBtaS5tYXJrZXJJY29uU3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm9taXNlOiBQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PiA9XHJcbiAgICAgICAgICAgIG5ldyBQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGxvdyBjcm9zcyBkb21haW4gaW1hZ2UgZWRpdHRpbmcuXHJcbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgICAgICAgICAgIGltYWdlLnNyYyA9IGljb25JbmZvLnVybDtcclxuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYzogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gYy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgYy53aWR0aCA9IGltYWdlLndpZHRoICogaWNvbkluZm8uc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBjLmhlaWdodCA9IGltYWdlLmhlaWdodCAqIGljb25JbmZvLnNjYWxlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERyYXcgYSBjaXJjbGUgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2xpcCB0aGUgaW1hZ2UsIHRoZW4gZHJhdyB0aGUgaW1hZ2UuXHJcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBjLndpZHRoLCBjLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBpY29uSW5mby5zaXplID0geyB3aWR0aDogYy53aWR0aCwgaGVpZ2h0OiBjLmhlaWdodCB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHM6IHN0cmluZyA9IGMudG9EYXRhVVJMKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWNvbkluZm8uaWQgIT0gbnVsbCkgeyBNYXJrZXIuTWFya2VyQ2FjaGUuc2V0KGljb25JbmZvLmlkLCB7IG1hcmtlckljb25TdHJpbmc6IHMsIG1hcmtlclNpemU6IGljb25JbmZvLnNpemUgfSk7IH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoe2ljb246IHMsIGljb25JbmZvOiBpY29uSW5mb30pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBtYXJrZXIgaXMgdGhlIGZpcnN0IG1hcmtlciBpbiBhIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBJc0ZpcnN0KCk6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgYWJzdHJhY3Qgc2V0IElzRmlyc3QodmFsOiBib29sZWFuKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBtYXJrZXIgaXMgdGhlIGxhc3QgbWFya2VyIGluIHRoZSBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgSXNMYXN0KCk6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgYWJzdHJhY3Qgc2V0IElzTGFzdCh2YWw6IGJvb2xlYW4pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgTG9jYXRpb24gb2YgdGhlIG1hcmtlclxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgTG9jYXRpb24oKTogSUxhdExvbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXJrZXIgbWV0YWRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBNZXRhZGF0YSgpOiBNYXA8c3RyaW5nLCBhbnk+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIHByaW1pdHZlIGltcGxlbWVudGluZyB0aGUgbWFya2VyIChlLmcuIE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4pXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBOYXRpdmVQcmltaXR2ZSgpOiBhbnk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGxpc3RlbmVyIChlLmcuIFwiY2xpY2tcIilcclxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGludm9rZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IERlbGV0ZU1hcmtlcigpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbWFya2VyIGxhYmVsXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0TGFiZWwoKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbWFya2VyIHZpc2liaWxpdHlcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRWaXNpYmxlKCk6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBhbmNob3IgZm9yIHRoZSBtYXJrZXIuIFVzZSB0aGlzIHRvIGFkanVzdCB0aGUgcm9vdCBsb2NhdGlvbiBmb3IgdGhlIG1hcmtlciB0byBhY2NvbW9kYXRlIHZhcmlvdXMgbWFya2VyIGltYWdlIHNpemVzLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGFuY2hvciAtIFBvaW50IGNvb3JkaW5hdGVzIGZvciB0aGUgbWFya2VyIGFuY2hvci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRBbmNob3IoYW5jaG9yOiBJUG9pbnQpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZHJhZ2dhYmlsaXR5IG9mIGEgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFyayB0aGUgbWFya2VyIGFzIGRyYWdnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaWNvbiBmb3IgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBpY29uIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGljb24gaW4gdmFyaW91cyBmb3JtcyAodXJsLCBkYXRhIHVybCwgZXRjLilcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRJY29uKGljb246IHN0cmluZyk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgbGFiZWwuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGFiZWwgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgbGFiZWwgdG8gc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldExhYmVsKGxhYmVsOiBzdHJpbmcpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFya2VyIHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxhdExuZyAtIEdlbyBjb29yZGluYXRlcyB0byBzZXQgdGhlIG1hcmtlciBwb3NpdGlvbiB0by5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRQb3NpdGlvbihsYXRMbmc6IElMYXRMb25nKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1hcmtlciB0aXRsZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSB0aXRsZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSB0aXRsZSB0byBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0VGl0bGUodGl0bGU6IHN0cmluZyk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElNYXJrZXJPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgbWFya2VyIG9wdGlvbnMgdG8gc2V0LiBUaGUgc3VwcGxpZWQgb3B0aW9ucyBhcmVcclxuICAgICAqIG1lcmdlZCB3aXRoIHRoZSB1bmRlcmx5aW5nIG1hcmtlciBvcHRpb25zLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0T3B0aW9ucyhvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmxpbHR5IG9mIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSAtIEJvb2xlYW4gd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgbWFya2VyIGlzIHZpc2libGUgb3Igbm90LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG59XHJcbiIsImltcG9ydCB7IElMYXllck9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXllci1vcHRpb25zJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi9tYXJrZXInO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuL3BvbHlsaW5lJztcclxuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4vaW5mby13aW5kb3cnO1xyXG5cclxuLyoqXHJcbiAqIERlZmluZXMgdGhlIGNvbnRyYWN0IGZvciBhIG1hcCBsYXllciBpbXBsZW1lbnRhdGlvbi4gRGVyaXZpbmcgcHJvdmlkZXJzIHNob3VsZCBpbXBsZW1lbnRzIHRoaXMgYWJzdHJhY3RcclxuICogdG8gcHJvdmlkZSBjb25jcmV0ZSBsYXllciBmdW5jdGlvbmFsaXR5IGZvciB0aGUgbWFwLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExheWVyIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWZpbml0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG5hdGl2ZSBwcmltaXRpdmUgdW5kZXJuZWF0aCB0aGUgYWJzdHJhY3Rpb24gbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGxheWVyIGluIHRoZSB1bmRlcmx5aW5nIHByb3ZpZGVyIChzdWNoIGFzXHJcbiAgICAgKiBNaWNyb3NvZnQuTWFwcy5MYXllcikuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBOYXRpdmVQcmltaXR2ZSgpOiBhbnk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHMsIExheWVyIGludGVyZmFjZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSBzdHJpbmcuIFR5cGUgb2YgZXZlbnQgdG8gYWRkIChjbGljaywgbW91c2VvdmVyLCBldGMpLiBZb3UgY2FuIHVzZSBhbnkgZXZlbnQgdGhhdCB0aGUgdW5kZXJseWluZyBuYXRpdmVcclxuICAgICAqIGxheWVyIHN1cHBvcnRzLlxyXG4gICAgICogQHBhcmFtIGZuIGZ1bmN0aW9uLiBIYW5kbGVyIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBMYXllclxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZW50aXR5IHRvIHRoZSBsYXllci4gRW50aXRpZXMgaW4gdGhpcyBjb250ZXh0IHNob3VsZCBiZSBtb2RlbCBhYnN0cmFjdGlvbnMgb2YgY29uY2VyZWQgbWFwIGZ1bmN0aW9uYWxpdHkgKHN1Y2hcclxuICAgICAqIGFzIG1hcmtlciwgaW5mb3dpbmRvdywgcG9seWxpbmUsIHBvbHlnb24sIGV0Yy4uKSBJbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBleHBlY3QgbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mXHJcbiAgICAgKiB0aGVzZSBjb25jZXB0cywgaW5zdGVhZCwgdGhlIGFwcHJvcHJpYXRlIGFic3RyYWN0IG1vZGVsIGNsYXNzZXMgc2hvdWxkIGJlIGltcGxlbWVudGVkIGZvciBlYWNoIHByb3ZpZGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudGl0eSBNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lLiBFbnRpdHkgdG8gYWRkIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkRW50aXR5KGVudGl0eTogTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZSk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbnVtYmVyIG9mIGVudGl0aWVzIHRvIHRoZSBsYXllci4gRW50aXRpZXMgaW4gdGhpcyBjb250ZXh0IHNob3VsZCBiZSBtb2RlbCBhYnN0cmFjdGlvbnMgb2YgY29uY2VyZWQgbWFwIGZ1bmN0aW9uYWxpdHkgKHN1Y2hcclxuICAgICAqIGFzIG1hcmtlciwgaW5mb3dpbmRvdywgcG9seWxpbmUsIHBvbHlnb24sIGV0Yy4uKSBJbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBleHBlY3QgbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mXHJcbiAgICAgKiB0aGlzZSBjb25jZXB0cywgaW5zdGVhZCwgdGhlIGFwcHJvcHJpYXRlIGFic3RyYWN0IG1vZGVsIGNsYXNzZXMgc2hvdWxkIGJlIGltcGxlbWVudGVkIGZvciBlYWNoIHByb3ZpZGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudGl0aWVzIEFycmF5PE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmU+LiBFbnRpdGllcyB0byBhZGQgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBMYXllclxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBBZGRFbnRpdGllcyhlbnRpdHk6IEFycmF5PE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmU+KTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBMYXllclxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBEZWxldGUoKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG9wdGlvbnMgZ292ZXJuaW5nIHRoZSBiZWhhdmlvciBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgbGF5ZXIgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0T3B0aW9ucygpOiBJTGF5ZXJPcHRpb25zO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlzIHRoZSBsYXllciBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldFZpc2libGUoKTogYm9vbGVhbjtcclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGVudGl0eSBmcm9tIHRoZSBjbHVzdGVyIGxheWVyLiBFbnRpdGllcyBpbiB0aGlzIGNvbnRleHQgc2hvdWxkIGJlIG1vZGVsIGFic3RyYWN0aW9ucyBvZiBjb25jZXJlZCBtYXAgZnVuY3Rpb25hbGl0eSAoc3VjaFxyXG4gICAgICogYXMgbWFya2VyLCBpbmZvd2luZG93LCBwb2x5bGluZSwgcG9seWdvbiwgZXRjLi4pIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGV4cGVjdCBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2ZcclxuICAgICAqIHRoaXNlIGNvbmNlcHRzLCBpbnN0ZWFkLCB0aGUgYXBwcm9wcmlhdGUgYWJzdHJhY3QgbW9kZWwgY2xhc3NlcyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgZm9yIGVhY2ggcHJvdmlkZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmUgRW50aXR5IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFJlbW92ZUVudGl0eShlbnRpdHk6IE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmUpOiB2b2lkO1xyXG5cclxuICAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVudGl0aWVzIGZvciB0aGUgY2x1c3RlciBsYXllci4gRW50aXRpZXMgaW4gdGhpcyBjb250ZXh0IHNob3VsZCBiZSBtb2RlbCBhYnN0cmFjdGlvbnMgb2YgY29uY2VyZWQgbWFwIGZ1bmN0aW9uYWxpdHkgKHN1Y2hcclxuICAgICAqIGFzIG1hcmtlciwgaW5mb3dpbmRvdywgcG9seWxpbmUsIHBvbHlnb24sIGV0Yy4uKSBJbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBleHBlY3QgbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mXHJcbiAgICAgKiB0aGlzZSBjb25jZXB0cywgaW5zdGVhZCwgdGhlIGFwcHJvcHJpYXRlIGFic3RyYWN0IG1vZGVsIGNsYXNzZXMgc2hvdWxkIGJlIGltcGxlbWVudGVkIGZvciBlYWNoIHByb3ZpZGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudGl0aWVzIEFycmF5PE1hcmtlcj58QXJyYXk8SW5mb1dpbmRvdz58QXJyYXk8UG9seWdvbj58QXJyYXk8UG9seWxpbmU+IGNvbnRhaW5pbmcgdGhlIGVudGl0aWVzIHRvIGFkZCB0byB0aGUgY2x1c3Rlci5cclxuICAgICAqIFRoaXMgcmVwbGFjZXMgYW55IGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBMYXllclxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRFbnRpdGllcyhlbnRpdGllczogQXJyYXk8TWFya2VyPnxBcnJheTxJbmZvV2luZG93PnxBcnJheTxQb2x5Z29uPnxBcnJheTxQb2x5bGluZT4pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgb3B0aW9ucyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgSUNsdXN0ZXJPcHRpb25zIGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMgZW51bWVyYXRpb24gY29udHJvbGxpbmcgdGhlIGxheWVyIGJlaGF2aW9yLiBUaGUgc3VwcGxpZWQgb3B0aW9uc1xyXG4gICAgICogYXJlIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0L2V4aXN0aW5nIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldE9wdGlvbnMob3B0aW9uczogSUxheWVyT3B0aW9ucyk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUb2dnbGVzIHRoZSBjbHVzdGVyIGxheWVyIHZpc2liaWxpdHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZpc2libGUgQm9vbGVhbiB0cnVlIHRvIG1ha2UgdGhlIGxheWVyIHZpc2libGUsIGZhbHNlIHRvIGhpZGUgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG59XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgY2xhc3MgZGVmaW5pbmcgdGhlIGNvbnRyYWN0IGZvciBhIHBvbHlnb24gaW4gdGhlIGFyY2hpdGVjdHVyZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbi5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQb2x5Z29uIHtcclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcm90ZWN0ZWQgX2NlbnRyb2lkOiBJTGF0TG9uZztcclxuICAgIHByb3RlY3RlZCBfY2VudGVyOiBJTGF0TG9uZztcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWZpbml0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uJ3MgY2VudGVyLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IENlbnRlcigpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NlbnRlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NlbnRlciA9IHRoaXMuR2V0Qm91bmRpbmdDZW50ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlnb24ncyBjZW50cm9pZC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBDZW50cm9pZCgpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NlbnRyb2lkID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2VudHJvaWQgPSB0aGlzLkdldFBvbHlnb25DZW50cm9pZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY2VudHJvaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gem9vbSBhdCB3aGljaCB0aGUgbGFiZWwgaXMgZGlzcGxheWVkLiBJZ25vcmVkIG9yIFNob3dMYWJlbCBpcyBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBMYWJlbE1heFpvb20oKTogbnVtYmVyO1xyXG4gICAgcHVibGljIGFic3RyYWN0IHNldCBMYWJlbE1heFpvb20odmFsOiBudW1iZXIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHpvb20gYXQgd2hpY2ggdGhlIGxhYmVsIGlzIGRpc3BsYXllZC4gSWdub3JlZCBvciBTaG93TGFiZWwgaXMgZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgTGFiZWxNaW5ab29tKCk6IG51bWJlcjtcclxuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgTGFiZWxNaW5ab29tKHZhbDogbnVtYmVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlnb24gbWV0YWRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgTWV0YWRhdGEoKTogTWFwPHN0cmluZywgYW55PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBwcmltaXR2ZSBpbXBsZW1lbnRpbmcgdGhlIHBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRvIHNob3cgdGhlIGxhYmVsXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgU2hvd0xhYmVsKCk6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgYWJzdHJhY3Qgc2V0IFNob3dMYWJlbCh2YWw6IGJvb2xlYW4pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gc2hvdyB0aGUgdG9vbHRpcFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IFNob3dUb29sdGlwKCk6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgYWJzdHJhY3Qgc2V0IFNob3dUb29sdGlwKHZhbDogYm9vbGVhbik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHRpdGxlIG9mZiB0aGUgcG9seWdvblxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IFRpdGxlKCk6IHN0cmluZztcclxuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgVGl0bGUodmFsOiBzdHJpbmcpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBkZWxlZ2F0ZSBmb3IgYW4gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gZm4gLSBEZWxlZ2F0ZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZWQgdGhlIHBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IERlbGV0ZSgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIGRyYWdnYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcG9seWdvbiBpcyBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXREcmFnZ2FibGUoKTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWdvbiBwYXRoIGNhbiBiZSBlZGl0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBhdGggY2FuIGJlIGVkaXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRFZGl0YWJsZSgpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9seWdvbiBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiBJTGF0TG9uZyBvYmplY3RzIGRlc2NyaWJpbmcgdGhlIHBvbHlnb24gcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0UGF0aCgpOiBBcnJheTxJTGF0TG9uZz47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uIHBhdGhzLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiBBcnJheSBvZiBJTGF0TG9uZyBvYmplY3RzIGRlc2NyaWJpbmcgbXVsdGlwbGUgcG9seWdvbiBwYXRocy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0UGF0aHMoKTogQXJyYXk8QXJyYXk8SUxhdExvbmc+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWdvbiBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5Z29uIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0VmlzaWJsZSgpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIGRyYWdhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFrZSB0aGUgcG9seWdvbiBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2V0aGVyIHRoZSBwb2x5Z29uIHBhdGggaXMgZWRpdGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZWRpdGFibGUgLSBUcnVlIHRvIG1ha2UgcG9seWdvbiBwYXRoIGVkaXRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldEVkaXRhYmxlKGVkaXRhYmxlOiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvbHlnb24gb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSUxhdExvbmd9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zLiBUaGUgb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggaHRlIG9uZXNcclxuICAgICAqIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldE9wdGlvbnMob3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvbHlnb24gcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gQW4gQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfSAob3IgYXJyYXkgb2YgYXJyYXlzKSBkZXNjcmliaW5nIHRoZSBwb2x5Z29ucyBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRQYXRoKHBhdGg6IEFycmF5PElMYXRMb25nPiB8IEFycmF5PElMYXRMb25nPik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBvbHlnb24gcGF0aCBvciBwYXRocy5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBwYXRocyBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9XHJcbiAgICAgKiAob3IgYXJyYXkgb2YgYXJyYXlzKSBkZXNjcmliaW5nIHRoZSBwb2x5Z29ucyBwYXRoKHMpLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRQYXRocyhwYXRoczogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiB8IEFycmF5PElMYXRMb25nPik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgdmlzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSB2aXNpYmxlIC0gVHJ1ZSB0byBzZXQgdGhlIHBvbHlnb24gdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbnMnIGJvdW5kaW5nIGJveC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIElMYXRMb25nIG9iamVjdCBjb250YWluaW5nIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIGJveC5cclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBHZXRCb3VuZGluZ0NlbnRlcigpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgbGV0IGM6IElMYXRMb25nID0ge2xhdGl0dWRlOiAwLCBsb25naXR1ZGU6IDB9O1xyXG4gICAgICAgIGxldCB4MTogbnVtYmVyID0gOTAsIHgyOiBudW1iZXIgPSAtOTAsIHkxOiBudW1iZXIgPSAxODAsIHkyOiBudW1iZXIgPSAtMTgwO1xyXG4gICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PEFycmF5PElMYXRMb25nPj4gPSB0aGlzLkdldFBhdGhzKCk7XHJcbiAgICAgICAgaWYgKHBhdGgpIHtcclxuICAgICAgICAgICAgcGF0aC5mb3JFYWNoKGlubmVyID0+IGlubmVyLmZvckVhY2gocCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5sYXRpdHVkZSA8IHgxKSB7IHgxID0gcC5sYXRpdHVkZTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHAubGF0aXR1ZGUgPiB4MikgeyB4MiA9IHAubGF0aXR1ZGU7IH1cclxuICAgICAgICAgICAgICAgIGlmIChwLmxvbmdpdHVkZSA8IHkxKSB7IHkxID0gcC5sb25naXR1ZGU7IH1cclxuICAgICAgICAgICAgICAgIGlmIChwLmxvbmdpdHVkZSA+IHkyKSB7IHkyID0gcC5sb25naXR1ZGU7IH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBjLmxhdGl0dWRlID0geDEgKyAoeDIgLSB4MSkgLyAyO1xyXG4gICAgICAgICAgICBjLmxvbmdpdHVkZSA9IHkxICsgKHkyIC0geTEpIC8gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2VudHJvaWQgb2YgdGhlIHBvbHlnb24gYmFzZWQgb24gdGhlIHBvbHlnb24gcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBjZW50cm9pZCBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbi5cclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBHZXRQb2x5Z29uQ2VudHJvaWQoKTogSUxhdExvbmcge1xyXG4gICAgICAgIGxldCBjOiBJTGF0TG9uZyA9IHtsYXRpdHVkZTogMCwgbG9uZ2l0dWRlOiAwfTtcclxuICAgICAgICBjb25zdCBwYXRoOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID0gdGhpcy5HZXRQYXRocygpO1xyXG4gICAgICAgIGNvbnN0IG9mZiA9IHBhdGhbMF1bMF07XHJcbiAgICAgICAgaWYgKG9mZiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCB0d2ljZWFyZWE6IG51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIGxldCB4OiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBsZXQgeTogbnVtYmVyID0gMDtcclxuICAgICAgICAgICAgbGV0IHAxOiBJTGF0TG9uZywgcDI6IElMYXRMb25nO1xyXG4gICAgICAgICAgICBsZXQgZjogbnVtYmVyO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHBhdGgubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gcGF0aFtrXS5sZW5ndGggLSAxOyBpIDwgcGF0aFtrXS5sZW5ndGg7IGogPSBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwMSA9IHBhdGhba11baV07XHJcbiAgICAgICAgICAgICAgICAgICAgcDIgPSBwYXRoW2tdW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSAocDEubGF0aXR1ZGUgLSBvZmYubGF0aXR1ZGUpICogKHAyLmxvbmdpdHVkZSAtIG9mZi5sb25naXR1ZGUpIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKHAyLmxhdGl0dWRlIC0gb2ZmLmxhdGl0dWRlKSAqIChwMS5sb25naXR1ZGUgLSBvZmYubG9uZ2l0dWRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0d2ljZWFyZWEgKz0gZjtcclxuICAgICAgICAgICAgICAgICAgICB4ICs9IChwMS5sYXRpdHVkZSArIHAyLmxhdGl0dWRlIC0gMiAqIG9mZi5sYXRpdHVkZSkgKiBmO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgKz0gKHAxLmxvbmdpdHVkZSArIHAyLmxvbmdpdHVkZSAtIDIgKiBvZmYubG9uZ2l0dWRlKSAqIGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR3aWNlYXJlYSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZiA9IHR3aWNlYXJlYSAqIDM7XHJcbiAgICAgICAgICAgICAgICBjLmxhdGl0dWRlID0geCAvIGYgKyBvZmYubGF0aXR1ZGU7XHJcbiAgICAgICAgICAgICAgICBjLmxvbmdpdHVkZSA9IHkgLyBmICsgb2ZmLmxvbmdpdHVkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGMubGF0aXR1ZGUgPSBvZmYubGF0aXR1ZGU7XHJcbiAgICAgICAgICAgICAgICBjLmxvbmdpdHVkZSA9IG9mZi5sb25naXR1ZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgY2xhc3MgZGVmaW5pbmcgdGhlIGNvbnRyYWN0IGZvciBhIHBvbHlsaW5lIGluIHRoZSBhcmNoaXRlY3R1cmUgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUG9seWxpbmUge1xyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByb3RlY3RlZCBfY2VudHJvaWQ6IElMYXRMb25nO1xyXG4gICAgcHJvdGVjdGVkIF9jZW50ZXI6IElMYXRMb25nO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlsaW5lJ3MgY2VudGVyLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBDZW50ZXIoKTogSUxhdExvbmcge1xyXG4gICAgICAgIGlmICh0aGlzLl9jZW50ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jZW50ZXIgPSB0aGlzLkdldEJvdW5kaW5nQ2VudGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jZW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5bGluZSdzIGNlbnRyb2lkLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBDZW50cm9pZCgpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NlbnRyb2lkID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2VudHJvaWQgPSB0aGlzLkdldFBvbHlsaW5lQ2VudHJvaWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnRyb2lkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIHByaW1pdHZlIGltcGxlbWVudGluZyB0aGUgcG9seWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBOYXRpdmVQcmltaXR2ZSgpOiBhbnk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5bGluZSBtZXRhZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBNZXRhZGF0YSgpOiBNYXA8c3RyaW5nLCBhbnk+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gc2hvdyB0aGUgdG9vbHRpcFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBTaG93VG9vbHRpcCgpOiBib29sZWFuO1xyXG4gICAgcHVibGljIGFic3RyYWN0IHNldCBTaG93VG9vbHRpcCh2YWw6IGJvb2xlYW4pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB0aXRsZSBvZmYgdGhlIHBvbHlsaW5lXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IFRpdGxlKCk6IHN0cmluZztcclxuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgVGl0bGUodmFsOiBzdHJpbmcpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2VudHJvaWQgb2YgdGhlIHBvbHlsaW5lIGJhc2VkIG9uIHRoZSBhIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSB0aGUgcGF0aCBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgdGhlIGNlbnRyb2lkXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBjZW50cm9pZCBjb29yZGluYXRlcyBvZiB0aGUgcG9seWxpbmUuXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHZXRQb2x5bGluZUNlbnRyb2lkKHBhdGg6IEFycmF5PElMYXRMb25nPik6IElMYXRMb25nIHtcclxuICAgICAgICBsZXQgYzogSUxhdExvbmcgPSB7bGF0aXR1ZGU6IDAsIGxvbmdpdHVkZTogMH07XHJcbiAgICAgICAgY29uc3Qgb2ZmID0gcGF0aFswXTtcclxuICAgICAgICBpZiAob2ZmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IHR3aWNlYXJlYTogbnVtYmVyID0gMDtcclxuICAgICAgICAgICAgbGV0IHg6IG51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIGxldCB5OiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBsZXQgcDE6IElMYXRMb25nLCBwMjogSUxhdExvbmc7XHJcbiAgICAgICAgICAgIGxldCBmOiBudW1iZXI7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHBhdGgubGVuZ3RoIC0gMTsgaSA8IHBhdGgubGVuZ3RoOyBqID0gaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwMSA9IHBhdGhbaV07XHJcbiAgICAgICAgICAgICAgICBwMiA9IHBhdGhbal07XHJcbiAgICAgICAgICAgICAgICBmID0gKHAxLmxhdGl0dWRlIC0gb2ZmLmxhdGl0dWRlKSAqIChwMi5sb25naXR1ZGUgLSBvZmYubG9uZ2l0dWRlKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKHAyLmxhdGl0dWRlIC0gb2ZmLmxhdGl0dWRlKSAqIChwMS5sb25naXR1ZGUgLSBvZmYubG9uZ2l0dWRlKTtcclxuICAgICAgICAgICAgICAgIHR3aWNlYXJlYSArPSBmO1xyXG4gICAgICAgICAgICAgICAgeCArPSAocDEubGF0aXR1ZGUgKyBwMi5sYXRpdHVkZSAtIDIgKiBvZmYubGF0aXR1ZGUpICogZjtcclxuICAgICAgICAgICAgICAgIHkgKz0gKHAxLmxvbmdpdHVkZSArIHAyLmxvbmdpdHVkZSAtIDIgKiBvZmYubG9uZ2l0dWRlKSAqIGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR3aWNlYXJlYSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZiA9IHR3aWNlYXJlYSAqIDM7XHJcbiAgICAgICAgICAgICAgICBjLmxhdGl0dWRlID0geCAvIGYgKyBvZmYubGF0aXR1ZGU7XHJcbiAgICAgICAgICAgICAgICBjLmxvbmdpdHVkZSA9IHkgLyBmICsgb2ZmLmxvbmdpdHVkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGMubGF0aXR1ZGUgPSBvZmYubGF0aXR1ZGU7XHJcbiAgICAgICAgICAgICAgICBjLmxvbmdpdHVkZSA9IG9mZi5sb25naXR1ZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBkZWxlZ2F0ZSBmb3IgYW4gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gZm4gLSBEZWxlZ2F0ZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlZCB0aGUgcG9seWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBEZWxldGUoKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWxpbmUgaXMgZHJhZ2dhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5bGluZSBpcyBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0RHJhZ2dhYmxlKCk6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIHBhdGggY2FuIGJlIGVkaXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcGF0aCBjYW4gYmUgZWRpdGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRFZGl0YWJsZSgpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9seWxpbmUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEByZXR1cm5zIC0gQXJyYXkgb2YgSUxhdExvbmcgb2JqZWN0cyBkZXNjcmliaW5nIHRoZSBwb2x5bGluZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0UGF0aCgpOiBBcnJheTxJTGF0TG9uZz47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBvbHlsaW5lIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldFZpc2libGUoKTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0aGUgcG9seWxpbmUgaXMgZHJhZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZHJhZ2dhYmxlIC0gVHJ1ZSB0byBtYWtlIHRoZSBwb2x5bGluZSBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdldGhlciB0aGUgcG9seWxpbmUgcGF0aCBpcyBlZGl0YWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBlZGl0YWJsZSAtIFRydWUgdG8gbWFrZSBwb2x5bGluZSBwYXRoIGVkaXRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb2x5bGluZSBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIFRoZSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBodGUgb25lc1xyXG4gICAgICogYWxyZWFkeSBvbiB0aGUgdW5kZXJseWluZyBtb2RlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldE9wdGlvbnMob3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb2x5bGluZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHBhdGggLSBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlsaW5lcyBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0UGF0aChwYXRoOiBBcnJheTxJTGF0TG9uZz4gfCBBcnJheTxJTGF0TG9uZz4pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHZpc2libGUgLSBUcnVlIHRvIHNldCB0aGUgcG9seWxpbmUgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm90ZWN0ZWQgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlsaW5lJyBib3VuZGluZyBib3guXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IG9iamVjdCBjb250YWluaW5nIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIGJveC5cclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgR2V0Qm91bmRpbmdDZW50ZXIoKTogSUxhdExvbmcge1xyXG4gICAgICAgIGxldCBjOiBJTGF0TG9uZyA9IHtsYXRpdHVkZTogMCwgbG9uZ2l0dWRlOiAwfTtcclxuICAgICAgICBsZXQgeDE6IG51bWJlciA9IDkwLCB4MjogbnVtYmVyID0gLTkwLCB5MTogbnVtYmVyID0gMTgwLCB5MjogbnVtYmVyID0gLTE4MDtcclxuICAgICAgICBjb25zdCBwYXRoOiBBcnJheTxJTGF0TG9uZz4gPSB0aGlzLkdldFBhdGgoKTtcclxuICAgICAgICBpZiAocGF0aCkge1xyXG4gICAgICAgICAgICBwYXRoLmZvckVhY2gocCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5sYXRpdHVkZSA8IHgxKSB7IHgxID0gcC5sYXRpdHVkZTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHAubGF0aXR1ZGUgPiB4MikgeyB4MiA9IHAubGF0aXR1ZGU7IH1cclxuICAgICAgICAgICAgICAgIGlmIChwLmxvbmdpdHVkZSA8IHkxKSB7IHkxID0gcC5sb25naXR1ZGU7IH1cclxuICAgICAgICAgICAgICAgIGlmIChwLmxvbmdpdHVkZSA+IHkyKSB7IHkyID0gcC5sb25naXR1ZGU7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGMubGF0aXR1ZGUgPSB4MSArICh4MiAtIHgxKSAvIDI7XHJcbiAgICAgICAgICAgIGMubG9uZ2l0dWRlID0geTEgKyAoeTIgLSB5MSkgLyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjZW50cm9pZCBvZiB0aGUgcG9seWxpbmUgYmFzZWQgb24gdGhlIHBvbHlsaW5lIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgY2VudHJvaWQgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlsaW5lLlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBHZXRQb2x5bGluZUNlbnRyb2lkKCk6IElMYXRMb25nIHtcclxuICAgICAgICBjb25zdCBwYXRoOiBBcnJheTxJTGF0TG9uZz4gPSB0aGlzLkdldFBhdGgoKTtcclxuICAgICAgICBjb25zdCBjOiBJTGF0TG9uZyAgPSBQb2x5bGluZS5HZXRQb2x5bGluZUNlbnRyb2lkKHBhdGgpO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi9tYXJrZXInO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNwaWRlckNsdXN0ZXJNYXJrZXIgZXh0ZW5kcyBNYXJrZXIge1xyXG5cclxuICAgIC8qKiBUaGUgcGFyZW50IHB1c2hwaW4gaW4gd2hpY2ggdGhlIHNwaWRlciBwdXNocGluIGlzIGRlcml2ZWQgZnJvbS4gKi9cclxuICAgIHB1YmxpYyBQYXJlbnRNYXJrZXI6IE1hcmtlcjtcclxuXHJcbiAgICAvKiogVGhlIHN0aWNrIHRoYXQgY29ubmVjdHMgdGhlIHNwaWRlciBwdXNocGluIHRvIHRoZSBjbHVzdGVyLiAqL1xyXG4gICAgcHVibGljIFN0aWNrOiBhbnk7XHJcblxyXG59XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IE1hcExhYmVsIH0gZnJvbSAnLi9tYXAtbGFiZWwnO1xyXG5cclxubGV0IGlkOiBudW1iZXIgPSAwO1xyXG5cclxuLyoqXHJcbiAqIEFic3RyYWN0IGJhc2UgaW1wbGVtZW50aW5nIGEgY2FudmFzIG92ZXJsYXkgdG8gYmUgcGxhY2VkIG9uIHRoZSBtYXAuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2FudmFzT3ZlcmxheSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gZmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByb3RlY3RlZCBfcmVhZHlSZXNvbHZlcjogKHZhbDogYm9vbGVhbikgPT4gdm9pZDtcclxuICAgIHByb3RlY3RlZCBfY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudDtcclxuICAgIHByb3RlY3RlZCBfem9vbVN0YXJ0OiBudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgX2NlbnRlclN0YXJ0OiBJTGF0TG9uZztcclxuICAgIHB1YmxpYyBfY2FudmFzUmVhZHk6IFByb21pc2U8Ym9vbGVhbj4gPSBuZXcgUHJvbWlzZTxib29sZWFuPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7IHRoaXMuX3JlYWR5UmVzb2x2ZXIgPSByZXNvbHZlOyB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgZ2V0cyByZXNvbHZlZCB3aGVuIHRoZSBjYW52YXMgb3ZlcmxheSBpcyByZWFkeSBmb3IgaW50ZXJhY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgQ2FudmFzUmVhZHkoKTogUHJvbWlzZTxib29sZWFuPiB7IHJldHVybiB0aGlzLl9jYW52YXNSZWFkeTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbnZhcyBpcyByZWFkeSB0byBiZSByZW5kZXJlZCBmb3IgdGhlIGN1cnJlbnQgbWFwIHZpZXcuXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZDtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBDYW52YXNPdmVybGF5IGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihkcmF3Q2FsbGJhY2s6IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB2b2lkKSB7XHJcbiAgICAgICAgdGhpcy5fZHJhd0NhbGxiYWNrID0gZHJhd0NhbGxiYWNrO1xyXG4gICAgICAgIGlkKys7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgY2FudmFzIG92ZXJsYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5TZXRNYXAobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRDb29yZGluYXRlc0Zyb21DbGljayhlOiBhbnkpOiBJTGF0TG9uZztcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXAgYXNzb2NpdGVkIHdpdGggdGhlIGxhYmVsLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0TWFwKCk6IGFueTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBNYXBMYWJlbCBpbnN0YW5jZSBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0gdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHRvb2x0aXAuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBvbmx5IGdlbmVyYXRlcyB0aGUgbWFwIGxhYmVsLiBDb250ZW50IGFuZCBwbGFjZW1lbnQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5XHJcbiAgICAgKiBvZiB0aGUgY2FsbGVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0VG9vbFRpcE92ZXJsYXkoKTogTWFwTGFiZWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW52YXNPdmVybGF5IGFkZGVkIHRvIG1hcCwgbG9hZCBjYW52YXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBPbkFkZCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5sZWZ0ID0gJzBweCc7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnRvcCA9ICcwcHgnO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5pZCA9IGB4TWFwT3ZlcmxheSR7aWR9YDtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBjYW52YXMgdG8gdGhlIG92ZXJsYXkuXHJcbiAgICAgICAgdGhpcy5TZXRDYW52YXNFbGVtZW50KHRoaXMuX2NhbnZhcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW52YXNPdmVybGF5IGxvYWRlZCwgYXR0YWNoIG1hcCBldmVudHMgZm9yIHVwZGF0aW5nIGNhbnZhcy5cclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IE9uTG9hZCgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB0aGUgQ2FudmFzTGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAsIHJlbGVhc2UgcmVzb3VyY2VzLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIE9uUmVtb3ZlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuU2V0Q2FudmFzRWxlbWVudChudWxsKTtcclxuICAgICAgICB0aGlzLlJlbW92ZUV2ZW50SGFuZGxlcnMoKTtcclxuICAgICAgICB0aGlzLl9jYW52YXMgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVkcmF3cyB0aGUgY2FudmFzIGZvciB0aGUgY3VycmVudCBtYXAgdmlldy5cclxuICAgICAqIEBwYXJhbSBjbGVhciAtIFRydWUgdG8gY2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZy5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBSZWRyYXcoY2xlYXI6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FudmFzID09IG51bGwpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGNhbnZhcyBieSB1cGRhdGluZyBkaW1lbnNpb25zLiBUaGlzIGFsc28gZW5zdXJlcyBjYW52YXMgc3RheXMgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgbWFwLlxyXG4gICAgICAgIGlmIChjbGVhcikgeyB0aGlzLlJlc2l6ZSgpOyB9XHJcblxyXG4gICAgICAgIC8vIENhbGwgdGhlIGRyYXdpbmcgY2FsbGJhY2sgZnVuY3Rpb24gaWYgc3BlY2lmaWVkLlxyXG4gICAgICAgIGlmICh0aGlzLl9kcmF3Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy5fZHJhd0NhbGxiYWNrKHRoaXMuX2NhbnZhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFwIGZvciB0aGUgbGFiZWwuIFNldHRpbmdzIHRoaXMgdG8gbnVsbCByZW1vdmUgdGhlIGxhYmVsIGZyb20gaHRlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwIC0gQSBuYXRpdmUgbWFwIG9iamVjdCBmb3IgdGhlIHVuZGVybHlpbmcgaW1wbGVtZW50YXRpb24uIEltcGxlbWVudGluZyBkZXJpdmF0aXZlcyBzaG91bGQgcmV0dXJuIHRoZVxyXG4gICAgICogYWN0dWFsIG5hdGl2ZSBvYmplY3QuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0TWFwKG1hcDogYW55KTogdm9pZDtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm90ZWN0ZWQgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyB0aGUgY2FudmFzIHRvIHRoZSBtYXAuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgU2V0Q2FudmFzRWxlbWVudChlbDogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHRoZSBtYXAgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBSZW1vdmVFdmVudEhhbmRsZXJzKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBDYW52YXMgc2l6ZSBiYXNlZCBvbiB0aGUgbWFwIHNpemUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBSZXNpemUoKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIENhbnZhcy5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBVcGRhdGVDYW52YXMoKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbXBsZSBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgdGhlIENTUyBwb3NpdGlvbiBhbmQgZGltZW5zaW9ucyBvZiB0aGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIHggVGhlIGhvcml6b250YWwgb2Zmc2V0IHBvc2l0aW9uIG9mIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0geSBUaGUgdmVydGljYWwgb2Zmc2V0IHBvc2l0aW9uIG9mIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSBoIFRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcy5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBVcGRhdGVQb3NpdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgdzogbnVtYmVyLCBoOiBudW1iZXIpIHtcclxuICAgICAgICAvLyBVcGRhdGUgQ1NTIHBvc2l0aW9uLlxyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5sZWZ0ID0geCArICdweCc7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgQ1NTIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLndpZHRoID0gdyArICdweCc7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBlYWNoU2VyaWVzLCBuZXh0VGljayB9IGZyb20gJ2FzeW5jJztcclxuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2xheWVyJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbWFya2VyJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uL3BvbHlsaW5lJztcclxuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9tYXAuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgYSBtYXAgbGF5ZXIgZm9yIHRoZSBCaW5nIE1hcCBQcm92aWRlci5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJpbmdMYXllciBpbXBsZW1lbnRzIExheWVyIHtcclxuXHJcbiAgICBwcml2YXRlIF9wZW5kaW5nRW50aXRpZXM6IEFycmF5PE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmU+ID0gbmV3IEFycmF5PE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmU+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVmaW5pdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBuYXRpdmUgcHJpbWl0aXZlIHVuZGVybmVhdGggdGhlIGFic3RyYWN0aW9uIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIE1pY3Jvc29mdC5NYXBzLkxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBhbnkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcjtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBCaW5nQ2x1c3RlckxheWVyIGNsYXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBfbGF5ZXIgTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlckxheWVyLiBOYXRpdmUgQmluZyBDbHVzdGVyIExheWVyIHN1cHBvcnRpbmcgdGhlIGNsdXN0ZXIgbGF5ZXIuXHJcbiAgICAgKiBAcGFyYW0gX21hcHMgTWFwU2VydmljZS4gTWFwU2VydmljZSBpbXBsZW1lbnRhdGlvbiB0byBsZXZlcmFnZSBmb3IgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbGF5ZXI6IE1pY3Jvc29mdC5NYXBzLkxheWVyLCBwcml2YXRlIF9tYXBzOiBNYXBTZXJ2aWNlKSB7IH1cclxuXHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHMsIExheWVyIGludGVyZmFjZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSBzdHJpbmcuIFR5cGUgb2YgZXZlbnQgdG8gYWRkIChjbGljaywgbW91c2VvdmVyLCBldGMpLiBZb3UgY2FuIHVzZSBhbnkgZXZlbnQgdGhhdCB0aGUgdW5kZXJseWluZyBuYXRpdmVcclxuICAgICAqIGxheWVyIHN1cHBvcnRzLlxyXG4gICAgICogQHBhcmFtIGZuIGZ1bmN0aW9uLiBIYW5kbGVyIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9sYXllciwgZXZlbnRUeXBlLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBmbihlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZW50aXR5IHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmUuIEVudGl0eSB0byBhZGQgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZEVudGl0eShlbnRpdHk6IE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmUpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZW50aXR5ICYmIGVudGl0eS5OYXRpdmVQcmltaXR2ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5HZXRWaXNpYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyLmFkZChlbnRpdHkuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0VudGl0aWVzLnB1c2goZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBudW1iZXIgb2YgZW50aXRpZXMgdG8gdGhlIGxheWVyLiBFbnRpdGllcyBpbiB0aGlzIGNvbnRleHQgc2hvdWxkIGJlIG1vZGVsIGFic3RyYWN0aW9ucyBvZiBjb25jZXJlZCBtYXAgZnVuY3Rpb25hbGl0eSAoc3VjaFxyXG4gICAgICogYXMgbWFya2VyLCBpbmZvd2luZG93LCBwb2x5bGluZSwgcG9seWdvbiwgZXRjLi4pXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudGl0aWVzIEFycmF5PE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmU+LiBFbnRpdGllcyB0byBhZGQgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPik6IHZvaWQge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gdXNlIGVhY2hTZXJpZXMgYXMgb3Bwb3NlZCB0byBfbGF5ZXIuYWRkKFtdKSB0byBwcm92aWRlIGEgbm9uLWJsb2NraW5nIGV4cGVyaWVuY2UgZm9yIGxhcmdlciBkYXRhIHNldHMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBpZiAoZW50aXRpZXMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KGVudGl0aWVzKSAmJiBlbnRpdGllcy5sZW5ndGggIT09IDAgKSB7XHJcbiAgICAgICAgICAgIGVhY2hTZXJpZXMoWy4uLmVudGl0aWVzXSwgKGUsIG5leHQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLkdldFZpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyLmFkZChlLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdFbnRpdGllcy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV4dFRpY2soKCkgPT4gbmV4dCgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX21hcHMuRGVsZXRlTGF5ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIGdvdmVybmluZyB0aGUgYmVoYXZpb3Igb2YgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIElDbHVzdGVyT3B0aW9ucy4gVGhlIGxheWVyIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0T3B0aW9ucygpOiBJTGF5ZXJPcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvOiBJTGF5ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogTnVtYmVyKHRoaXMuX2xheWVyLmdldElkKCkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZpc2liaWxpdHkgc3RhdGUgb2YgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEJvb2xlYW4uIFRydWUgaXMgdGhlIGxheWVyIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRWaXNpYmxlKCk6IGJvb2xlYW4gIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXIuZ2V0VmlzaWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBlbnRpdHkgZnJvbSB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmUgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBSZW1vdmVFbnRpdHkoZW50aXR5OiBNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGVudGl0eS5OYXRpdmVQcmltaXR2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllci5yZW1vdmUoZW50aXR5Lk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBlbnRpdGllcyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudGl0aWVzIEFycmF5PE1hcmtlcj58QXJyYXk8SW5mb1dpbmRvdz58QXJyYXk8UG9seWdvbj58QXJyYXk8UG9seWxpbmU+IGNvbnRhaW5pbmcgdGhlIGVudGl0aWVzIHRvIGFkZCB0byB0aGUgY2x1c3Rlci5cclxuICAgICAqIFRoaXMgcmVwbGFjZXMgYW55IGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXI+fEFycmF5PEluZm9XaW5kb3c+fEFycmF5PFBvbHlnb24+fEFycmF5PFBvbHlsaW5lPik6IHZvaWQge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gd2UgYXJlIHVzaW5nIHJlbW92YWwgYW5kIGFkZCBhcyBvcHBvc2VkIHRvIHNldCBhcyBmb3IgbGFyZ2UgbnVtYmVyIG9mIG9iamVjdHMgaXQgeWllbGRzIGEgbm9uLWJsb2NraW5nLCBzbW9vdGhlciBwZXJmb3JtYW5jZS4uLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0UHJpbWl0aXZlcyhbXSk7XHJcbiAgICAgICAgdGhpcy5BZGRFbnRpdGllcyhlbnRpdGllcyk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgb3B0aW9ucyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgSUNsdXN0ZXJPcHRpb25zIGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMgZW51bWVyYXRpb24gY29udHJvbGxpbmcgdGhlIGxheWVyIGJlaGF2aW9yLiBUaGUgc3VwcGxpZWQgb3B0aW9uc1xyXG4gICAgICogYXJlIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0L2V4aXN0aW5nIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJTGF5ZXJPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXIubWV0YWRhdGEuaWQgPSBvcHRpb25zLmlkLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUb2dnbGVzIHRoZSBjbHVzdGVyIGxheWVyIHZpc2liaWxpdHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZpc2libGUgQm9vbGVhbiB0cnVlIHRvIG1ha2UgdGhlIGxheWVyIHZpc2libGUsIGZhbHNlIHRvIGhpZGUgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2xheWVyLnNldFZpc2libGUodmlzaWJsZSk7XHJcbiAgICAgICAgaWYgKHZpc2libGUgJiYgdGhpcy5fcGVuZGluZ0VudGl0aWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5BZGRFbnRpdGllcyh0aGlzLl9wZW5kaW5nRW50aXRpZXMuc3BsaWNlKDApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IElNYXBPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFwLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJQm94IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pYm94JztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuaW1wb3J0IHsgSUluZm9XaW5kb3dBY3Rpb24gfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1hY3Rpb24nO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvaW50JztcclxuaW1wb3J0IHsgTWFwVHlwZUlkIH0gZnJvbSAnLi4vLi4vbW9kZWxzL21hcC10eXBlLWlkJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL21hcmtlcic7XHJcbmltcG9ydCB7IENsdXN0ZXJQbGFjZW1lbnRNb2RlIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2NsdXN0ZXItcGxhY2VtZW50LW1vZGUnO1xyXG5pbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4vYmluZy1tYXAuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBjb250YWlucyBoZWxwZXJmdW5jdGlvbnMgdG8gbWFwIHZhcmlvdXMgaW50ZXJmYWNlcyB1c2VkIHRvIHJlcHJlc2VudCBvcHRpb25zIGFuZCBzdHJ1Y3R1cmVzIGludG8gdGhlXHJcbiAqIGNvcnJlc3BvbmRpbmcgQmluZyBNYXBzIFY4IHNwZWNpZmljIGltcGxlbWVudGF0aW9ucy5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJpbmdDb252ZXJzaW9ucyB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBvcHRpb24gYXR0cmlidXRlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgZm9yIGNvbnZlcnNpb24gdG8gQmluZyBNYXAgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX21hcE9wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcclxuICAgICAgICAnYmFja2dyb3VuZENvbG9yJyxcclxuICAgICAgICAnY3JlZGVudGlhbHMnLFxyXG4gICAgICAgICdjdXN0b21pemVPdmVybGF5cycsXHJcbiAgICAgICAgJ2N1c3RvbU1hcFN0eWxlJyxcclxuICAgICAgICAnZGlzYWJsZUJpcmRzZXllJyxcclxuICAgICAgICAnZGlzYWJsZUtleWJvYXJkSW5wdXQnLFxyXG4gICAgICAgICdkaXNhYmxlTW91c2VJbnB1dCcsXHJcbiAgICAgICAgJ2Rpc2FibGVQYW5uaW5nJyxcclxuICAgICAgICAnZGlzYWJsZVRvdWNoSW5wdXQnLFxyXG4gICAgICAgICdkaXNhYmxlVXNlcklucHV0JyxcclxuICAgICAgICAnZGlzYWJsZVpvb21pbmcnLFxyXG4gICAgICAgICdkaXNhYmxlU3RyZWV0c2lkZScsXHJcbiAgICAgICAgJ2VuYWJsZUNsaWNrYWJsZUxvZ28nLFxyXG4gICAgICAgICdlbmFibGVTZWFyY2hMb2dvJyxcclxuICAgICAgICAnZml4ZWRNYXBQb3NpdGlvbicsXHJcbiAgICAgICAgJ2hlaWdodCcsXHJcbiAgICAgICAgJ2luZXJ0aWFJbnRlbnNpdHknLFxyXG4gICAgICAgICduYXZpZ2F0aW9uQmFyTW9kZScsXHJcbiAgICAgICAgJ3Nob3dCcmVhZGNydW1iJyxcclxuICAgICAgICAnc2hvd0NvcHlyaWdodCcsXHJcbiAgICAgICAgJ3Nob3dEYXNoYm9hcmQnLFxyXG4gICAgICAgICdzaG93TWFwVHlwZVNlbGVjdG9yJyxcclxuICAgICAgICAnc2hvd1NjYWxlYmFyJyxcclxuICAgICAgICAndGhlbWUnLFxyXG4gICAgICAgICd0aWxlQnVmZmVyJyxcclxuICAgICAgICAndXNlSW5lcnRpYScsXHJcbiAgICAgICAgJ3dpZHRoJyxcclxuICAgICAgICAnY2VudGVyJyxcclxuICAgICAgICAnem9vbScsXHJcbiAgICAgICAgJ21hcFR5cGVJZCcsXHJcbiAgICAgICAgJ2xpdGVNb2RlJ1xyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZpZXcgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEJpbmcgTWFwIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF92aWV3T3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdhbmltYXRlJyxcclxuICAgICAgICAnYm91bmRzJyxcclxuICAgICAgICAnY2VudGVyJyxcclxuICAgICAgICAnY2VudGVyT2Zmc2V0JyxcclxuICAgICAgICAnaGVhZGluZycsXHJcbiAgICAgICAgJ2xhYmVsT3ZlcmxheScsXHJcbiAgICAgICAgJ21hcFR5cGVJZCcsXHJcbiAgICAgICAgJ3BhZGRpbmcnLFxyXG4gICAgICAgICd6b29tJ1xyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZm9XaW5kb3cgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEJpbmcgTWFwIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9pbmZvV2luZG93T3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdhY3Rpb25zJyxcclxuICAgICAgICAnZGVzY3JpcHRpb24nLFxyXG4gICAgICAgICdodG1sQ29udGVudCcsXHJcbiAgICAgICAgJ2lkJyxcclxuICAgICAgICAncG9zaXRpb24nLFxyXG4gICAgICAgICdwaXhlbE9mZnNldCcsXHJcbiAgICAgICAgJ3Nob3dDbG9zZUJ1dHRvbicsXHJcbiAgICAgICAgJ3Nob3dQb2ludGVyJyxcclxuICAgICAgICAncHVzaHBpbicsXHJcbiAgICAgICAgJ3RpdGxlJyxcclxuICAgICAgICAndGl0bGVDbGlja0hhbmRsZXInLFxyXG4gICAgICAgICd0eXBlTmFtZScsXHJcbiAgICAgICAgJ3Zpc2libGUnLFxyXG4gICAgICAgICd3aWR0aCcsXHJcbiAgICAgICAgJ2hlaWdodCdcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXJrZXIgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEJpbmcgTWFwIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9tYXJrZXJPcHRpb25zQXR0cmlidXRlczogc3RyaW5nW10gPSBbXHJcbiAgICAgICAgJ2FuY2hvcicsXHJcbiAgICAgICAgJ2RyYWdnYWJsZScsXHJcbiAgICAgICAgJ2hlaWdodCcsXHJcbiAgICAgICAgJ2h0bWxDb250ZW50JyxcclxuICAgICAgICAnaWNvbicsXHJcbiAgICAgICAgJ2luZm9ib3gnLFxyXG4gICAgICAgICdzdGF0ZScsXHJcbiAgICAgICAgJ3RpdGxlJyxcclxuICAgICAgICAndGV4dE9mZnNldCcsXHJcbiAgICAgICAgJ3R5cGVOYW1lJyxcclxuICAgICAgICAndmlzaWJsZScsXHJcbiAgICAgICAgJ3dpZHRoJyxcclxuICAgICAgICAnekluZGV4J1xyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvbHlnb24gb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEJpbmcgTWFwIFBvbHlnb24gcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3BvbHlnb25PcHRpb25zQXR0cmlidXRlczogc3RyaW5nW10gPSBbXHJcbiAgICAgICAgJ2N1cnNvcicsXHJcbiAgICAgICAgJ2ZpbGxDb2xvcicsXHJcbiAgICAgICAgJ2ZpbGxPcGFjaXR5JyxcclxuICAgICAgICAnc3Ryb2tlQ29sb3InLFxyXG4gICAgICAgICdzdHJva2VPcGFjaXR5JyxcclxuICAgICAgICAnc3Ryb2tlV2VpZ2h0JyxcclxuICAgICAgICAndmlzaWJsZSdcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb2x5bGluZSBvcHRpb24gYXR0cmlidXRlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgZm9yIGNvbnZlcnNpb24gdG8gQmluZyBNYXAgUG9seWxpbmUgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdjdXJzb3InLFxyXG4gICAgICAgICdzdHJva2VDb2xvcicsXHJcbiAgICAgICAgJ3N0cm9rZU9wYWNpdHknLFxyXG4gICAgICAgICdzdHJva2VXZWlnaHQnLFxyXG4gICAgICAgICd2aXNpYmxlJ1xyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsdXN0ZXIgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEJpbmcgTWFwIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9jbHVzdGVyT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdjYWxsYmFjaycsXHJcbiAgICAgICAgJ2NsdXN0ZXJlZFBpbkNhbGxiYWNrJyxcclxuICAgICAgICAnY2x1c3RlcmluZ0VuYWJsZWQnLFxyXG4gICAgICAgICdncmlkU2l6ZScsXHJcbiAgICAgICAgJ2xheWVyT2Zmc2V0JyxcclxuICAgICAgICAncGxhY2VtZW50TW9kZScsXHJcbiAgICAgICAgJ3Zpc2libGUnLFxyXG4gICAgICAgICd6SW5kZXgnXHJcbiAgICBdO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSUluZm9XaW5kb3dBY3Rpb24gdG8gYSBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveEFjdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTmF2dGl2ZSBtYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVBY3Rpb24oYWN0aW9uOiBJSW5mb1dpbmRvd0FjdGlvbik6IE1pY3Jvc29mdC5NYXBzLklJbmZvYm94QWN0aW9ucyB7XHJcbiAgICAgICAgY29uc3QgYTogTWljcm9zb2Z0Lk1hcHMuSUluZm9ib3hBY3Rpb25zID0ge1xyXG4gICAgICAgICAgICBldmVudEhhbmRsZXI6IGFjdGlvbi5ldmVudEhhbmRsZXIsXHJcbiAgICAgICAgICAgIGxhYmVsOiBhY3Rpb24ubGFiZWxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBBcnJheSBvZiBJSW5mb1dpbmRvd0FjdGlvbiB0byBhbiBBcnJheSBvZiBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveEFjdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9ucyAtIEFycmF5IG9mIG9iamVjdHMgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiBtYXBwZWQgb2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlQWN0aW9ucyhhY3Rpb25zOiBBcnJheTxJSW5mb1dpbmRvd0FjdGlvbj4pOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5JSW5mb2JveEFjdGlvbnM+IHtcclxuICAgICAgICBjb25zdCBhOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5JSW5mb2JveEFjdGlvbnM+ID0gbmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLklJbmZvYm94QWN0aW9ucz4oKTtcclxuICAgICAgICBhY3Rpb25zLmZvckVhY2goeCA9PiBhLnB1c2goQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUFjdGlvbih4KSkpO1xyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBJQm94IG9iamVjdCB0byBhIE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uUmVjdCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJveCAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUJvdW5kcyhib3g6IElCb3gpOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvblJlY3Qge1xyXG4gICAgICAgIGNvbnN0IHI6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uUmVjdCA9XHJcbiAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uUmVjdC5mcm9tRWRnZXMoYm94Lm1heExhdGl0dWRlLCBib3gubWluTG9uZ2l0dWRlLCBib3gubWluTGF0aXR1ZGUsIGJveC5tYXhMb25naXR1ZGUpO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBJQ2x1c3Rlck9wdGlvbnMgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuSUNsdXN0ZXJMYXllck9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlQ2x1c3Rlck9wdGlvbnMob3B0aW9uczogSUNsdXN0ZXJPcHRpb25zKTogTWljcm9zb2Z0Lk1hcHMuSUNsdXN0ZXJMYXllck9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklDbHVzdGVyTGF5ZXJPcHRpb25zIHwgYW55ID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcclxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEJpbmdDb252ZXJzaW9ucy5fY2x1c3Rlck9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdsYXllck9mZnNldCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLmxheWVyT2Zmc2V0ID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvaW50KG9wdGlvbnMubGF5ZXJPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdwbGFjZW1lbnRNb2RlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBsYWNlbWVudE1vZGUgPT09IENsdXN0ZXJQbGFjZW1lbnRNb2RlLkZpcnN0UGluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucGxhY2VtZW50TW9kZSA9IE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJQbGFjZW1lbnRUeXBlLkZpcnN0TG9jYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvLnBsYWNlbWVudE1vZGUgPSBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUGxhY2VtZW50VHlwZS5NZWFuQXZlcmFnZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBJSW5mb1dpbmRvd09wdGlvbnMgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuSUluZm9ib3hPcHRpb25zIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUluZm9Cb3hPcHRpb25zKG9wdGlvbnM6IElJbmZvV2luZG93T3B0aW9ucyk6IE1pY3Jvc29mdC5NYXBzLklJbmZvYm94T3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSUluZm9ib3hPcHRpb25zIHwgYW55ID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcclxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEJpbmdDb252ZXJzaW9ucy5faW5mb1dpbmRvd09wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdwaXhlbE9mZnNldCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLm9mZnNldCA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2ludChvcHRpb25zLnBpeGVsT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdwb3NpdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLmxvY2F0aW9uID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKG9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ2FjdGlvbnMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5hY3Rpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUFjdGlvbnMob3B0aW9ucy5hY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ba10gPSAoPGFueT5vcHRpb25zKVtrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGFuIElNYXBPcHRpb25zIG9iamVjdCB0byBhIE1pY3Jvc29mdC5NYXBzLklNYXBMb2FkT3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVMb2FkT3B0aW9ucyhvcHRpb25zOiBJTWFwT3B0aW9ucyk6IE1pY3Jvc29mdC5NYXBzLklNYXBMb2FkT3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSU1hcExvYWRPcHRpb25zIHwgYW55ID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcclxuICAgICAgICAgICAgLmZpbHRlcihrID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBCaW5nQ29udmVyc2lvbnMuX21hcE9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xIHx8IEJpbmdDb252ZXJzaW9ucy5fdmlld09wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5jZW50ZXIgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24ob3B0aW9ucy5jZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ21hcFR5cGVJZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tYXBUeXBlSWQgPT09IE1hcFR5cGVJZC5oeWJyaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5tYXBUeXBlSWQgPSBNaWNyb3NvZnQuTWFwcy5NYXBUeXBlSWQuYWVyaWFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvLmxhYmVsT3ZlcmxheSA9IE1pY3Jvc29mdC5NYXBzLkxhYmVsT3ZlcmxheS52aXNpYmxlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm1hcFR5cGVJZCA9PT0gTWFwVHlwZUlkLmFlcmlhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvLm1hcFR5cGVJZCA9IE1pY3Jvc29mdC5NYXBzLk1hcFR5cGVJZC5hZXJpYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ubGFiZWxPdmVybGF5ID0gTWljcm9zb2Z0Lk1hcHMuTGFiZWxPdmVybGF5LmhpZGRlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ubWFwVHlwZUlkID0gTWljcm9zb2Z0Lk1hcHMuTWFwVHlwZUlkWyg8YW55Pk1hcFR5cGVJZClbb3B0aW9ucy5tYXBUeXBlSWRdXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrID09PSAnYm91bmRzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uYm91bmRzID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUJvdW5kcyhvcHRpb25zLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBJTGF0TG9uZyBvYmplY3QgdG8gYSBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhdGxvbmcgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVMb2NhdGlvbihsYXRsb25nOiBJTGF0TG9uZyk6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uIHtcclxuICAgICAgICBjb25zdCBsOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbihsYXRsb25nLmxhdGl0dWRlLCBsYXRsb25nLmxvbmdpdHVkZSk7XHJcbiAgICAgICAgcmV0dXJuIGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGFuIElNYXJrZXJPcHRpb25zIG9iamVjdCB0byBhIE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgbWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcclxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEJpbmdDb252ZXJzaW9ucy5fbWFya2VyT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ2FuY2hvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLmFuY2hvciA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2ludChvcHRpb25zLmFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAoPGFueT5vKVtrXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSU1hcE9wdGlvbnMgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuSU1hcE9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlT3B0aW9ucyhvcHRpb25zOiBJTWFwT3B0aW9ucyk6IE1pY3Jvc29mdC5NYXBzLklNYXBPcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JTWFwT3B0aW9ucyB8IGFueSA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBCaW5nQ29udmVyc2lvbnMuX21hcE9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5jZW50ZXIgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24ob3B0aW9ucy5jZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ21hcFR5cGVJZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLm1hcFR5cGVJZCA9IE1pY3Jvc29mdC5NYXBzLk1hcFR5cGVJZFsoPGFueT5NYXBUeXBlSWQpW29wdGlvbnMubWFwVHlwZUlkXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlcyBhbiBhcnJheSBvZiBsb2NhdGlvbnMgb3IgYW4gYXJyYXkgb3IgYXJyYXlzIG9mIGxvY2F0aW9uIHRvIGFuZCBhcnJheSBvZiBhcnJheXMgb2YgQmluZyBNYXAgTG9jYXRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGhzIC0gSUxhdExvbmcgYmFzZWQgbG9jYXRpb25zIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIGNvbnZlcnRlZCBsb2NhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZVBhdGhzKHBhdGhzOiBBcnJheTxJTGF0TG9uZz4gfCBBcnJheTxBcnJheTxJTGF0TG9uZz4+KTogQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PiB7XHJcbiAgICAgICAgY29uc3QgcDogQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PiA9IG5ldyBBcnJheTxBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4+KCk7XHJcbiAgICAgICAgaWYgKHBhdGhzID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkocGF0aHMpIHx8IHBhdGhzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBwLnB1c2gobmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoc1swXSkpIHtcclxuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIGFycmF5c1xyXG4gICAgICAgICAgICAvLyB1cyBmb3IgbG9vcCBmb3IgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgY29uc3QgcDEgPSA8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5wYXRocztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgX3A6IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPiA9IG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4oKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcDFbaV0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBfcC5wdXNoKG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbihwMVtpXVtqXS5sYXRpdHVkZSwgcDFbaV1bal0ubG9uZ2l0dWRlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwLnB1c2goX3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXIgaXMgYSBzaW1wbGUgYXJyYXkuLi4uXHJcbiAgICAgICAgICAgIGNvbnN0IHk6IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPiA9IG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4oKTtcclxuICAgICAgICAgICAgY29uc3QgcDEgPSA8QXJyYXk8SUxhdExvbmc+PnBhdGhzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB5LnB1c2gobmV3IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uKHAxW2ldLmxhdGl0dWRlLCBwMVtpXS5sb25naXR1ZGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwLnB1c2goeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogIE1hcHMgYW4gSVBvaW50IG9iamVjdCB0byBhIE1pY3Jvc29mdC5NYXBzLlBvaW50IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVQb2ludChwb2ludDogSVBvaW50KTogTWljcm9zb2Z0Lk1hcHMuUG9pbnQge1xyXG4gICAgICAgIGNvbnN0IHA6IE1pY3Jvc29mdC5NYXBzLlBvaW50ID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvaW50KHBvaW50LngsIHBvaW50LnkpO1xyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogIE1hcHMgYW4gSVBvbHlnb25PcHRpb25zIG9iamVjdCB0byBhIE1pY3Jvc29mdC5NYXBzLklQb2x5Z29uT3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZVBvbHlnb25PcHRpb25zKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IE1pY3Jvc29mdC5NYXBzLklQb2x5Z29uT3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVBvbHlnb25PcHRpb25zID0ge307XHJcbiAgICAgICAgY29uc3QgZjogKHM6IHN0cmluZywgYTogbnVtYmVyKSA9PiBzdHJpbmcgPSAocywgYSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtID0gL3JnYmE/XFwoKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKigsXFxzKlxcZCtbXFwuXFxkK10qKSpcXCkvZy5leGVjKHMpO1xyXG4gICAgICAgICAgICBpZiAobSAmJiBtLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICAgICAgICAgIGEgPSBhID4gMSA/IChhIC8gMTAwKSA6IGE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIFttWzFdLCBtWzJdLCBtWzNdLCBhXS5qb2luKCcsJykgKyAnKSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc1swXSA9PT0gJyMnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4OiBudW1iZXIgPSBhID4gMSA/IGEgOiBNYXRoLmZsb29yKGEgKiAyNTUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgejogc3RyaW5nID0gcy5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByOiBudW1iZXIgPSBwYXJzZUludCh6LnN1YnN0cigwLCAyKSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZzogbnVtYmVyID0gcGFyc2VJbnQoei5zdWJzdHIoMiwgMiksIDE2KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGI6IG51bWJlciA9IHBhcnNlSW50KHouc3Vic3RyKDQsIDIpLCAxNik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIFtyICwgZywgYiwgYV0uam9pbignLCcpICsgJyknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGsgPT4gQmluZ0NvbnZlcnNpb25zLl9wb2x5Z29uT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ3N0cm9rZVdlaWdodCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLnN0cm9rZVRoaWNrbmVzcyA9IG9wdGlvbnMuc3Ryb2tlV2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ3N0cm9rZUNvbG9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0cm9rZU9wYWNpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5zdHJva2VDb2xvciA9IGYob3B0aW9ucy5zdHJva2VDb2xvciwgb3B0aW9ucy5zdHJva2VPcGFjaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uc3Ryb2tlQ29sb3IgPSBvcHRpb25zLnN0cm9rZUNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdzdHJva2VPcGFjaXR5Jykge31cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdmaWxsQ29sb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlsbE9wYWNpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5maWxsQ29sb3IgPSBmKG9wdGlvbnMuZmlsbENvbG9yLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uZmlsbENvbG9yID0gb3B0aW9ucy5maWxsQ29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ2ZpbGxPcGFjaXR5Jykge31cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICg8YW55Pm8pW2tdID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogIE1hcHMgYW4gSVBvbHlsaW5lT3B0aW9ucyBvYmplY3QgdG8gYSBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlUG9seWxpbmVPcHRpb25zKG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zIHwgYW55ID0ge307XHJcbiAgICAgICAgY29uc3QgZjogKHM6IHN0cmluZywgYTogbnVtYmVyKSA9PiBzdHJpbmcgPSAocywgYSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtID0gL3JnYmE/XFwoKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKigsXFxzKlxcZCtbXFwuXFxkK10qKSpcXCkvZy5leGVjKHMpO1xyXG4gICAgICAgICAgICBpZiAobSAmJiBtLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICAgICAgICAgIGEgPSBhID4gMSA/IChhIC8gMTAwKSA6IGE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIFttWzFdLCBtWzJdLCBtWzNdLCBhXS5qb2luKCcsJykgKyAnKSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc1swXSA9PT0gJyMnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4OiBudW1iZXIgPSBhID4gMSA/IGEgOiBNYXRoLmZsb29yKGEgKiAyNTUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgejogc3RyaW5nID0gcy5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByOiBudW1iZXIgPSBwYXJzZUludCh6LnN1YnN0cigwLCAyKSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZzogbnVtYmVyID0gcGFyc2VJbnQoei5zdWJzdHIoMiwgMiksIDE2KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGI6IG51bWJlciA9IHBhcnNlSW50KHouc3Vic3RyKDQsIDIpLCAxNik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIFtyICwgZywgYiwgYV0uam9pbignLCcpICsgJyknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBCaW5nQ29udmVyc2lvbnMuX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ3N0cm9rZVdlaWdodCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLnN0cm9rZVRoaWNrbmVzcyA9IG9wdGlvbnMuc3Ryb2tlV2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrID09PSAnc3Ryb2tlQ29sb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3Ryb2tlT3BhY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvLnN0cm9rZUNvbG9yID0gZihvcHRpb25zLnN0cm9rZUNvbG9yLCBvcHRpb25zLnN0cm9rZU9wYWNpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5zdHJva2VDb2xvciA9IG9wdGlvbnMuc3Ryb2tlQ29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ3N0cm9rZU9wYWNpdHknKSB7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBJTWFwT3B0aW9ucyBvYmplY3QgdG8gYSBNaWNyb3NvZnQuTWFwcy5JVmlld09wdGlvbnMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlVmlld09wdGlvbnMob3B0aW9uczogSU1hcE9wdGlvbnMpOiBNaWNyb3NvZnQuTWFwcy5JVmlld09wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklWaWV3T3B0aW9ucyB8IGFueSA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBCaW5nQ29udmVyc2lvbnMuX3ZpZXdPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSlcclxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChrID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uY2VudGVyID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKG9wdGlvbnMuY2VudGVyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2JvdW5kcycpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLmJvdW5kcyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVCb3VuZHMob3B0aW9ucy5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrID09PSAnY2VudGVyT2Zmc2V0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uY2VudGVyT2Zmc2V0ID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvaW50KG9wdGlvbnMuY2VudGVyT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ21hcFR5cGVJZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLm1hcFR5cGVJZCA9IE1pY3Jvc29mdC5NYXBzLk1hcFR5cGVJZFsoPGFueT5NYXBUeXBlSWQpW29wdGlvbnMubWFwVHlwZUlkXV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ba10gPSAoPGFueT5vcHRpb25zKVtrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvaW50JztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uL21hcmtlcic7XHJcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLW1hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0NvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLWNvbnZlcnNpb25zJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIE1hcmtlcn0gY29udHJhY3QgZm9yIHRoZSBCaW5nIE1hcHMgVjggbWFwIGFyY2hpdGVjdHVyZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJpbmdNYXJrZXIgaW1wbGVtZW50cyBNYXJrZXIge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX21ldGFkYXRhOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcclxuICAgIHByaXZhdGUgX2lzRmlyc3QgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2lzTGFzdCA9IHRydWU7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVmaW5pdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIG1hcmtlciBpcyB0aGUgZmlyc3QgbWFya2VyIGluIGEgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJc0ZpcnN0KCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faXNGaXJzdDsgfVxyXG4gICAgcHVibGljIHNldCBJc0ZpcnN0KHZhbDogYm9vbGVhbikgeyB0aGlzLl9pc0ZpcnN0ID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgbWFya2VyIGlzIHRoZSBsYXN0IG1hcmtlciBpbiB0aGUgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJc0xhc3QoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9pc0xhc3Q7IH1cclxuICAgIHB1YmxpYyBzZXQgSXNMYXN0KHZhbDogYm9vbGVhbikgeyB0aGlzLl9pc0xhc3QgPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIExvY2F0aW9uIG9mIHRoZSBtYXJrZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTG9jYXRpb24oKTogSUxhdExvbmcge1xyXG4gICAgICAgIGNvbnN0IGw6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uID0gdGhpcy5fcHVzaHBpbi5nZXRMb2NhdGlvbigpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxhdGl0dWRlOiBsLmxhdGl0dWRlLFxyXG4gICAgICAgICAgICBsb25naXR1ZGU6IGwubG9uZ2l0dWRlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1hcmtlciBtZXRhZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTWV0YWRhdGEoKTogTWFwPHN0cmluZywgYW55PiB7IHJldHVybiB0aGlzLl9tZXRhZGF0YTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIHByaW1pdHZlIGltcGxlbWVudGluZyB0aGUgbWFya2VyLCBpbiB0aGlzIGNhc2Uge0BsaW5rIE1pY3Jvc29mdC5NYXBzLlB1c2hwaW59XHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueSB7IHJldHVybiB0aGlzLl9wdXNocGluOyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nTWFya2VyLlxyXG4gICAgICogQHBhcmFtIF9wdXNocGluIC0gVGhlIHtAbGluayBNaWNyb3NvZnQuTWFwcy5QdXNocGlufSB1bmRlcmx5aW5nIHRoZSBtb2RlbC5cclxuICAgICAqIEBwYXJhbSBfbWFwIC0gVGhlIGNvbnRleHQgbWFwLlxyXG4gICAgICogQHBhcmFtIF9sYXllciAtIFRoZSBjb250ZXh0IGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3B1c2hwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4sIHByb3RlY3RlZCBfbWFwOiBNaWNyb3NvZnQuTWFwcy5NYXAsIHByb3RlY3RlZCBfbGF5ZXI6IE1pY3Jvc29mdC5NYXBzLkxheWVyKSB7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgbGlzdGVuZXIgKGUuZy4gXCJjbGlja1wiKVxyXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9wdXNocGluLCBldmVudFR5cGUsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGZuKGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVNYXJrZXIoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9tYXAgJiYgIXRoaXMuX2xheWVyKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmICh0aGlzLl9sYXllcikgeyB0aGlzLl9sYXllci5yZW1vdmUodGhpcy5OYXRpdmVQcmltaXR2ZSk7IH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwLmVudGl0aWVzLnJlbW92ZSh0aGlzLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXJrZXIgbGFiZWxcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TGFiZWwoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaHBpbi5nZXRUZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIG1hcmtlciBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgbWFya2VyIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0VmlzaWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaHBpbi5nZXRWaXNpYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBhbmNob3IgZm9yIHRoZSBtYXJrZXIuIFVzZSB0aGlzIHRvIGFkanVzdCB0aGUgcm9vdCBsb2NhdGlvbiBmb3IgdGhlIG1hcmtlciB0byBhY2NvbW9kYXRlIHZhcmlvdXMgbWFya2VyIGltYWdlIHNpemVzLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGFuY2hvciAtIFBvaW50IGNvb3JkaW5hdGVzIGZvciB0aGUgbWFya2VyIGFuY2hvci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0QW5jaG9yKGFuY2hvcjogSVBvaW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0ge307XHJcbiAgICAgICAgby5hbmNob3IgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KTtcclxuICAgICAgICB0aGlzLl9wdXNocGluLnNldE9wdGlvbnMobyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBkcmFnZ2FiaWxpdHkgb2YgYSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZHJhZ2dhYmxlIC0gVHJ1ZSB0byBtYXJrIHRoZSBtYXJrZXIgYXMgZHJhZ2dhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvLmRyYWdnYWJsZSA9IGRyYWdnYWJsZTtcclxuICAgICAgICB0aGlzLl9wdXNocGluLnNldE9wdGlvbnMobyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBpY29uIGZvciB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGljb24gLSBTdHJpbmcgY29udGFpbmluZyB0aGUgaWNvbiBpbiB2YXJpb3VzIGZvcm1zICh1cmwsIGRhdGEgdXJsLCBldGMuKVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRJY29uKGljb246IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIG8uaWNvbiA9IGljb247XHJcbiAgICAgICAgdGhpcy5fcHVzaHBpbi5zZXRPcHRpb25zKG8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFya2VyIGxhYmVsLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxhYmVsIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGxhYmVsIHRvIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0TGFiZWwobGFiZWw6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIG8udGV4dCA9IGxhYmVsO1xyXG4gICAgICAgIHRoaXMuX3B1c2hwaW4uc2V0T3B0aW9ucyhvKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1hcmtlciBwb3NpdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXRMbmcgLSBHZW8gY29vcmRpbmF0ZXMgdG8gc2V0IHRoZSBtYXJrZXIgcG9zaXRpb24gdG8uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFBvc2l0aW9uKGxhdExuZzogSUxhdExvbmcpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihsYXRMbmcpO1xyXG4gICAgICAgIHRoaXMuX3B1c2hwaW4uc2V0TG9jYXRpb24ocCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgdGl0bGUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gdGl0bGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgdGl0bGUgdG8gc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRUaXRsZSh0aXRsZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zIHwgYW55ID0ge307XHJcbiAgICAgICAgby50aXRsZSA9IHRpdGxlO1xyXG4gICAgICAgIHRoaXMuX3B1c2hwaW4uc2V0T3B0aW9ucyhvKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1hcmtlciBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSU1hcmtlck9wdGlvbnN9IG9iamVjdCBjb250YWluaW5nIHRoZSBtYXJrZXIgb3B0aW9ucyB0byBzZXQuIFRoZSBzdXBwbGllZCBvcHRpb25zIGFyZVxyXG4gICAgICogbWVyZ2VkIHdpdGggdGhlIHVuZGVybHlpbmcgbWFya2VyIG9wdGlvbnMuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRPcHRpb25zKG9wdGlvbnM6IElNYXJrZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0gIEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVNYXJrZXJPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX3B1c2hwaW4uc2V0T3B0aW9ucyhvKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0aGUgbWFya2VyIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZpc2libGUgLSBUcnVlIHRvIHNldCB0aGUgbWFya2VyIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnMgfCBhbnkgPSB7fTtcclxuICAgICAgICBvLnZpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgICAgIHRoaXMuX3B1c2hwaW4uc2V0T3B0aW9ucyhvKTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgQmluZ01hcmtlciB9IGZyb20gJy4vYmluZy1tYXJrZXInO1xyXG5pbXBvcnQgeyBTcGlkZXJDbHVzdGVyTWFya2VyIH0gZnJvbSAnLi4vc3BpZGVyLWNsdXN0ZXItbWFya2VyJztcclxuXHJcbmV4cG9ydCBjbGFzcyBCaW5nU3BpZGVyQ2x1c3Rlck1hcmtlciBleHRlbmRzIEJpbmdNYXJrZXIgaW1wbGVtZW50cyBTcGlkZXJDbHVzdGVyTWFya2VyIHtcclxuXHJcbiAgICAvKiogVGhlIHBhcmVudCBwdXNocGluIGluIHdoaWNoIHRoZSBzcGlkZXIgcHVzaHBpbiBpcyBkZXJpdmVkIGZyb20uICovXHJcbiAgICBwdWJsaWMgUGFyZW50TWFya2VyOiBCaW5nTWFya2VyO1xyXG5cclxuICAgIC8qKiBUaGUgc3RpY2sgdGhhdCBjb25uZWN0cyB0aGUgc3BpZGVyIHB1c2hwaW4gdG8gdGhlIGNsdXN0ZXIuICovXHJcbiAgICBwdWJsaWMgU3RpY2s6IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lO1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJU3BpZGVyQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lzcGlkZXItY2x1c3Rlci1vcHRpb25zJztcclxuaW1wb3J0IHsgQmluZ0NvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLWNvbnZlcnNpb25zJztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2xheWVyJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbWFya2VyJztcclxuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXIgfSBmcm9tICcuL2Jpbmctc3BpZGVyLWNsdXN0ZXItbWFya2VyJztcclxuaW1wb3J0IHsgQmluZ01hcmtlciB9IGZyb20gJy4vYmluZy1tYXJrZXInO1xyXG5cclxuLyoqXHJcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIGEgY2x1c3RlcmluZyBsYXllciBmb3IgdGhlIEJpbmcgTWFwIFByb3ZpZGVyLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmluZ0NsdXN0ZXJMYXllciBpbXBsZW1lbnRzIExheWVyIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfaXNDbHVzdGVyaW5nID0gdHJ1ZTtcclxuICAgIHByaXZhdGUgX21hcmtlcnM6IEFycmF5PE1hcmtlcj4gPSBuZXcgQXJyYXk8TWFya2VyPigpO1xyXG4gICAgcHJpdmF0ZSBfbWFya2VyTG9va3VwOiBNYXA8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiwgTWFya2VyPiA9IG5ldyBNYXA8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiwgTWFya2VyPigpO1xyXG4gICAgcHJpdmF0ZSBfcGVuZGluZ01hcmtlcnM6IEFycmF5PE1hcmtlcj4gPSBuZXcgQXJyYXk8TWFya2VyPigpO1xyXG4gICAgcHJpdmF0ZSBfc3BpZGVyTWFya2VyczogQXJyYXk8QmluZ1NwaWRlckNsdXN0ZXJNYXJrZXI+ID0gbmV3IEFycmF5PEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyPigpO1xyXG4gICAgcHJpdmF0ZSBfc3BpZGVyTWFya2VyTG9va3VwOiBNYXA8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiwgQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXI+ID1cclxuICAgICAgICAgICAgICAgICAgICAgbmV3IE1hcDxNaWNyb3NvZnQuTWFwcy5QdXNocGluLCBCaW5nU3BpZGVyQ2x1c3Rlck1hcmtlcj4oKTtcclxuICAgIHByaXZhdGUgX3VzZVNwaWRlckNsdXN0ZXIgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX21hcGNsaWNrcyA9IDA7XHJcbiAgICBwcml2YXRlIF9zcGlkZXJMYXllcjogTWljcm9zb2Z0Lk1hcHMuTGF5ZXI7XHJcbiAgICBwcml2YXRlIF9ldmVudHM6IEFycmF5PE1pY3Jvc29mdC5NYXBzLklIYW5kbGVySWQ+ID0gbmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLklIYW5kbGVySWQ+KCk7XHJcbiAgICBwcml2YXRlIF9jdXJyZW50Wm9vbSA9IDA7XHJcbiAgICBwcml2YXRlIF9zcGlkZXJPcHRpb25zOiBJU3BpZGVyQ2x1c3Rlck9wdGlvbnMgPSB7XHJcbiAgICAgICAgY2lyY2xlU3BpcmFsU3dpdGNob3ZlcjogOSxcclxuICAgICAgICBjb2xsYXBzZUNsdXN0ZXJPbk1hcENoYW5nZTogZmFsc2UsXHJcbiAgICAgICAgY29sbGFwc2VDbHVzdGVyT25OdGhDbGljazogMSxcclxuICAgICAgICBpbnZva2VDbGlja09uSG92ZXI6IHRydWUsXHJcbiAgICAgICAgbWluQ2lyY2xlTGVuZ3RoOiA2MCxcclxuICAgICAgICBtaW5TcGlyYWxBbmdsZVNlcGVyYXRpb246IDI1LFxyXG4gICAgICAgIHNwaXJhbERpc3RhbmNlRmFjdG9yOiA1LFxyXG4gICAgICAgIHN0aWNrU3R5bGU6IHtcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6ICdibGFjaycsXHJcbiAgICAgICAgICAgIHN0cm9rZVRoaWNrbmVzczogMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RpY2tIb3ZlclN0eWxlOiB7IHN0cm9rZUNvbG9yOiAncmVkJyB9LFxyXG4gICAgICAgIG1hcmtlclNlbGVjdGVkOiBudWxsLFxyXG4gICAgICAgIG1hcmtlclVuU2VsZWN0ZWQ6IG51bGxcclxuICAgIH07XHJcbiAgICBwcml2YXRlIF9jdXJyZW50Q2x1c3RlcjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4gPSBudWxsO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbmF0aXZlIHByaW1pdGl2ZSB1bmRlcm5lYXRoIHRoZSBhYnN0cmFjdGlvbiBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyTGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBhbnkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcjtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBCaW5nQ2x1c3RlckxheWVyIGNsYXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBfbGF5ZXIgTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlckxheWVyLiBOYXRpdmUgQmluZyBDbHVzdGVyIExheWVyIHN1cHBvcnRpbmcgdGhlIGNsdXN0ZXIgbGF5ZXIuXHJcbiAgICAgKiBAcGFyYW0gX21hcHMgTWFwU2VydmljZS4gTWFwU2VydmljZSBpbXBsZW1lbnRhdGlvbiB0byBsZXZlcmFnZSBmb3IgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2xheWVyOiBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyTGF5ZXIsIHByaXZhdGUgX21hcHM6IE1hcFNlcnZpY2UpIHsgfVxyXG5cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kcywgTGF5ZXIgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIHN0cmluZy4gVHlwZSBvZiBldmVudCB0byBhZGQgKGNsaWNrLCBtb3VzZW92ZXIsIGV0YykuIFlvdSBjYW4gdXNlIGFueSBldmVudCB0aGF0IHRoZSB1bmRlcmx5aW5nIG5hdGl2ZVxyXG4gICAgICogbGF5ZXIgc3VwcG9ydHMuXHJcbiAgICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24uIEhhbmRsZXIgdG8gY2FsbCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9sYXllciwgZXZlbnRUeXBlLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBmbihlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZW50aXR5IHRvIHRoZSBsYXllci4gVXNlIHRoaXMgbWV0aG9kIHdpdGggY2F1dGlvbiBhcyBpdCB3aWxsXHJcbiAgICAgKiB0cmlnZ2VyIGEgcmVjYWx1YXRpb24gb2YgdGhlIGNsdXN0ZXJzIChhbmQgYXNzb2NpYXRlZCBtYXJrZXJzIGlmIGFwcHJvcHJpdGUpIGZvclxyXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBJZiB5b3UgdXNlIHRoaXMgbWV0aG9kIHRvIGFkZCBtYW55IG1hcmtlcnMgdG8gdGhlIGNsdXN0ZXIsIHVzZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyLiBFbnRpdHkgdG8gYWRkIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkRW50aXR5KGVudGl0eTogTWFya2VyKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGlzTWFya2VyOiBib29sZWFuID0gZW50aXR5IGluc3RhbmNlb2YgTWFya2VyO1xyXG4gICAgICAgIGlzTWFya2VyID0gZW50aXR5IGluc3RhbmNlb2YgQmluZ01hcmtlciB8fCBpc01hcmtlcjtcclxuICAgICAgICBpZiAoaXNNYXJrZXIpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eS5Jc0ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlN0b3BDbHVzdGVyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVudGl0eS5OYXRpdmVQcmltaXR2ZSAmJiBlbnRpdHkuTG9jYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ2x1c3RlcmluZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj4gPSB0aGlzLl9sYXllci5nZXRQdXNocGlucygpO1xyXG4gICAgICAgICAgICAgICAgcC5wdXNoKGVudGl0eS5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllci5zZXRQdXNocGlucyhwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtlckxvb2t1cC5zZXQoZW50aXR5Lk5hdGl2ZVByaW1pdHZlLCBlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNNYXJrZXIpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eS5Jc0xhc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuU3RhcnRDbHVzdGVyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbnVtYmVyIG9mIG1hcmtlcnMgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdGllcyBBcnJheTxNYXJrZXI+LiBFbnRpdGllcyB0byBhZGQgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRFbnRpdGllcyhlbnRpdGllczogQXJyYXk8TWFya2VyPik6IHZvaWQge1xyXG4gICAgICAgIGlmIChlbnRpdGllcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoZW50aXRpZXMpICYmIGVudGl0aWVzLmxlbmd0aCAhPT0gMCApIHtcclxuICAgICAgICAgICAgY29uc3QgZTogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj4gPSBlbnRpdGllcy5tYXAocCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJMb29rdXAuc2V0KHAuTmF0aXZlUHJpbWl0dmUsIHApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuTmF0aXZlUHJpbWl0dmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNDbHVzdGVyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5QdXNocGluPiA9IHRoaXMuX2xheWVyLmdldFB1c2hwaW5zKCk7XHJcbiAgICAgICAgICAgICAgICBwLnB1c2goLi4uZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllci5zZXRQdXNocGlucyhwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaCguLi5lbnRpdGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nTWFya2Vycy5wdXNoKC4uLmVudGl0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHNwaWRlciBiZWhhdmlvciBmb3IgdGhlIGNsdXNlcmluZyBsYXllciAod2hlbiBhIGNsdXN0ZXIgbWFrZXIgaXMgY2xpY2tlZCwgaXQgZXhwbG9kZXMgaW50byBhIHNwaWRlciBvZiB0aGVcclxuICAgICAqIGluZGl2aWR1YWwgdW5kZXJseWluZyBwaW5zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIElTcGlkZXJDbHVzdGVyT3B0aW9ucy4gT3B0aW9uYWwuIE9wdGlvbnMgZ292ZXJuaW5nIHRoZSBiZWhhdmlvciBvZiB0aGUgc3BpZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBJbml0aWFsaXplU3BpZGVyQ2x1c3RlclN1cHBvcnQob3B0aW9ucz86IElTcGlkZXJDbHVzdGVyT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl91c2VTcGlkZXJDbHVzdGVyKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGNvbnN0IG06IE1pY3Jvc29mdC5NYXBzLk1hcCA9ICg8QmluZ01hcFNlcnZpY2U+dGhpcy5fbWFwcykuTWFwSW5zdGFuY2U7XHJcbiAgICAgICAgdGhpcy5fdXNlU3BpZGVyQ2x1c3RlciA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fc3BpZGVyTGF5ZXIgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuTGF5ZXIoKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Wm9vbSA9IG0uZ2V0Wm9vbSgpO1xyXG4gICAgICAgIHRoaXMuU2V0U3BpZGVyT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICBtLmxheWVycy5pbnNlcnQodGhpcy5fc3BpZGVyTGF5ZXIpO1xyXG5cclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gQWRkIHNwaWRlciByZWxhdGVkIGV2ZW50cy4uLi5cclxuICAgICAgICAvLy9cclxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihtLCAnY2xpY2snLCBlID0+IHRoaXMuT25NYXBDbGljayhlKSkpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKG0sICd2aWV3Y2hhbmdlc3RhcnQnLCBlID0+IHRoaXMuT25NYXBWaWV3Q2hhbmdlU3RhcnQoZSkpKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihtLCAndmlld2NoYW5nZWVuZCcsIGUgPT4gdGhpcy5Pbk1hcFZpZXdDaGFuZ2VFbmQoZSkpKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9sYXllciwgJ2NsaWNrJywgZSA9PiB0aGlzLk9uTGF5ZXJDbGljayhlKSkpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX3NwaWRlckxheWVyLCAnY2xpY2snLCBlID0+IHRoaXMuT25MYXllckNsaWNrKGUpKSk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fc3BpZGVyTGF5ZXIsICdtb3VzZW92ZXInLCBlID0+IHRoaXMuT25TcGlkZXJNb3VzZU92ZXIoZSkpKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9zcGlkZXJMYXllciwgJ21vdXNlb3V0JywgZSA9PiB0aGlzLk9uU3BpZGVyTW91c2VPdXQoZSkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIGNsdXN0ZXJpbmcgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fdXNlU3BpZGVyQ2x1c3Rlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGlkZXJMYXllci5jbGVhcigpO1xyXG4gICAgICAgICAgICAoPEJpbmdNYXBTZXJ2aWNlPnRoaXMuX21hcHMpLk1hcFByb21pc2UudGhlbihtID0+IHtcclxuICAgICAgICAgICAgICAgIG0ubGF5ZXJzLnJlbW92ZSh0aGlzLl9zcGlkZXJMYXllcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJMYXllciA9IG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaChlID0+IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKGUpKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnNwbGljZSgwKTtcclxuICAgICAgICAgICAgdGhpcy5fdXNlU3BpZGVyQ2x1c3RlciA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tYXJrZXJzLnNwbGljZSgwKTtcclxuICAgICAgICB0aGlzLl9zcGlkZXJNYXJrZXJzLnNwbGljZSgwKTtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nTWFya2Vycy5zcGxpY2UoMCk7XHJcbiAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fbWFwcy5EZWxldGVMYXllcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGFic3RyYWN0IG1hcmtlciB1c2VkIHRvIHdyYXAgdGhlIEJpbmcgUHVzaHBpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBNYXJrZXIuIFRoZSBhYnN0cmFjdCBtYXJrZXIgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcHVzaHBpbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TWFya2VyRnJvbUJpbmdNYXJrZXIocGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluKTogTWFya2VyIHtcclxuICAgICAgICBjb25zdCBtOiBNYXJrZXIgPSB0aGlzLl9tYXJrZXJMb29rdXAuZ2V0KHBpbik7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIGdvdmVybmluZyB0aGUgYmVoYXZpb3Igb2YgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIElDbHVzdGVyT3B0aW9ucy4gVGhlIGxheWVyIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldE9wdGlvbnMoKTogSUNsdXN0ZXJPcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JQ2x1c3RlckxheWVyT3B0aW9ucyA9IHRoaXMuX2xheWVyLmdldE9wdGlvbnMoKTtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBJQ2x1c3Rlck9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGlkOiAwLFxyXG4gICAgICAgICAgICBncmlkU2l6ZTogby5ncmlkU2l6ZSxcclxuICAgICAgICAgICAgbGF5ZXJPZmZzZXQ6IG8ubGF5ZXJPZmZzZXQsXHJcbiAgICAgICAgICAgIGNsdXN0ZXJpbmdFbmFibGVkOiBvLmNsdXN0ZXJpbmdFbmFibGVkLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogby5jYWxsYmFjayxcclxuICAgICAgICAgICAgY2x1c3RlcmVkUGluQ2FsbGJhY2s6IG8uY2x1c3RlcmVkUGluQ2FsbGJhY2ssXHJcbiAgICAgICAgICAgIHZpc2libGU6IG8udmlzaWJsZSxcclxuICAgICAgICAgICAgekluZGV4OiBvLnpJbmRleFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuLiBUcnVlIGlzIHRoZSBsYXllciBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyLmdldE9wdGlvbnMoKS52aXNpYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYWJzdHJhY3QgbWFya2VyIHVzZWQgdG8gd3JhcCB0aGUgQmluZyBQdXNocGluLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVGhlIGFic3RyYWN0IG1hcmtlciBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwdXNocGluLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRTcGlkZXJNYXJrZXJGcm9tQmluZ01hcmtlcihwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4pOiBCaW5nU3BpZGVyQ2x1c3Rlck1hcmtlciB7XHJcbiAgICAgICAgY29uc3QgbTogQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXIgPSB0aGlzLl9zcGlkZXJNYXJrZXJMb29rdXAuZ2V0KHBpbik7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGVudGl0eSBmcm9tIHRoZSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyIC0gRW50aXR5IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFJlbW92ZUVudGl0eShlbnRpdHk6IE1hcmtlcik6IHZvaWQge1xyXG4gICAgICAgIGlmIChlbnRpdHkuTmF0aXZlUHJpbWl0dmUgJiYgZW50aXR5LkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGo6IG51bWJlciA9IHRoaXMuX21hcmtlcnMuaW5kZXhPZihlbnRpdHkpO1xyXG4gICAgICAgICAgICBjb25zdCBrOiBudW1iZXIgPSB0aGlzLl9wZW5kaW5nTWFya2Vycy5pbmRleE9mKGVudGl0eSk7XHJcbiAgICAgICAgICAgIGlmIChqID4gLTEpIHsgdGhpcy5fbWFya2Vycy5zcGxpY2UoaiwgMSk7IH1cclxuICAgICAgICAgICAgaWYgKGsgPiAtMSkgeyB0aGlzLl9wZW5kaW5nTWFya2Vycy5zcGxpY2UoaywgMSk7IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ2x1c3RlcmluZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj4gPSB0aGlzLl9sYXllci5nZXRQdXNocGlucygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaTogbnVtYmVyID0gcC5pbmRleE9mKGVudGl0eS5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuc2V0UHVzaHBpbnMocCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLmRlbGV0ZShlbnRpdHkuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVudGl0aWVzIGZvciB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyPiBjb250YWluaW5nXHJcbiAgICAgKiB0aGUgZW50aXRpZXMgdG8gYWRkIHRvIHRoZSBjbHVzdGVyLiBUaGlzIHJlcGxhY2VzIGFueSBleGlzdGluZyBlbnRpdGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0RW50aXRpZXMoZW50aXRpZXM6IEFycmF5PE1hcmtlcj4pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5QdXNocGluPiA9IG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5QdXNocGluPigpO1xyXG4gICAgICAgIHRoaXMuX21hcmtlcnMuc3BsaWNlKDApO1xyXG4gICAgICAgIHRoaXMuX21hcmtlckxvb2t1cC5jbGVhcigpO1xyXG4gICAgICAgIGVudGl0aWVzLmZvckVhY2goKGU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5OYXRpdmVQcmltaXR2ZSAmJiBlLkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJMb29rdXAuc2V0KGUuTmF0aXZlUHJpbWl0dmUsIGUpO1xyXG4gICAgICAgICAgICAgICAgcC5wdXNoKDxNaWNyb3NvZnQuTWFwcy5QdXNocGluPmUuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0UHVzaHBpbnMocCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBvcHRpb25zIGZvciB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJQ2x1c3Rlck9wdGlvbnMgY29udGFpbmluZyB0aGUgb3B0aW9ucyBlbnVtZXJhdGlvbiBjb250cm9sbGluZyB0aGUgbGF5ZXIgYmVoYXZpb3IuIFRoZSBzdXBwbGllZCBvcHRpb25zXHJcbiAgICAgKiBhcmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQvZXhpc3Rpbmcgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJQ2x1c3Rlck9wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JQ2x1c3RlckxheWVyT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVDbHVzdGVyT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9sYXllci5zZXRPcHRpb25zKG8pO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnNwaWRlckNsdXN0ZXJPcHRpb25zKSB7IHRoaXMuU2V0U3BpZGVyT3B0aW9ucyhvcHRpb25zLnNwaWRlckNsdXN0ZXJPcHRpb25zKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVG9nZ2xlcyB0aGUgY2x1c3RlciBsYXllciB2aXNpYmlsaXR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2aXNpYmxlIEJvb2xlYW4gdHJ1ZSB0byBtYWtlIHRoZSBsYXllciB2aXNpYmxlLCBmYWxzZSB0byBoaWRlIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSUNsdXN0ZXJMYXllck9wdGlvbnMgPSB0aGlzLl9sYXllci5nZXRPcHRpb25zKCk7XHJcbiAgICAgICAgby52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICB0aGlzLl9sYXllci5zZXRPcHRpb25zKG8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgdG8gYWN0dWFsbHkgY2x1c3RlciB0aGUgZW50aXRpZXMgaW4gYSBjbHVzdGVyIGxheWVyLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoZSBpbml0aWFsIHNldCBvZiBlbnRpdGllc1xyXG4gICAgICogaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBjbHVzdGVyLiBUaGlzIG1ldGhvZCBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIGFzIGFkZGluZyBhbiBlbnRpdGl5IHdpbGwgcmVjYWxjdWxhdGUgYWxsIGNsdXN0ZXJzLlxyXG4gICAgICogQXMgc3VjaCwgU3RvcENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgYWRkaW5nIG1hbnkgZW50aXRpZXMgYW5kIFN0YXJ0Q2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIG9uY2UgYWRkaW5nIGlzXHJcbiAgICAgKiBjb21wbGV0ZSB0byByZWNhbGN1bGF0ZSB0aGUgY2x1c3RlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFN0YXJ0Q2x1c3RlcmluZygpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5faXNDbHVzdGVyaW5nKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICBjb25zdCBwOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5QdXNocGluPiA9IG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5QdXNocGluPigpO1xyXG4gICAgICAgIHRoaXMuX21hcmtlcnMuZm9yRWFjaChlID0+IHtcclxuICAgICAgICAgICAgaWYgKGUuTmF0aXZlUHJpbWl0dmUgJiYgZS5Mb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcC5wdXNoKDxNaWNyb3NvZnQuTWFwcy5QdXNocGluPmUuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMuZm9yRWFjaChlID0+IHtcclxuICAgICAgICAgICAgaWYgKGUuTmF0aXZlUHJpbWl0dmUgJiYgZS5Mb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcC5wdXNoKDxNaWNyb3NvZnQuTWFwcy5QdXNocGluPmUuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0UHVzaHBpbnMocCk7XHJcbiAgICAgICAgdGhpcy5fbWFya2VycyA9IHRoaXMuX21hcmtlcnMuY29uY2F0KHRoaXMuX3BlbmRpbmdNYXJrZXJzLnNwbGljZSgwKSk7XHJcbiAgICAgICAgdGhpcy5faXNDbHVzdGVyaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3AgdG8gYWN0dWFsbHkgY2x1c3RlciB0aGUgZW50aXRpZXMgaW4gYSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBhcyBhZGRpbmcgYW4gZW50aXRpeSB3aWxsIHJlY2FsY3VsYXRlIGFsbCBjbHVzdGVycy5cclxuICAgICAqIEFzIHN1Y2gsIFN0b3BDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGFkZGluZyBtYW55IGVudGl0aWVzIGFuZCBTdGFydENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIGFkZGluZyBpc1xyXG4gICAgICogY29tcGxldGUgdG8gcmVjYWxjdWxhdGUgdGhlIGNsdXN0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTdG9wQ2x1c3RlcmluZygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzQ2x1c3RlcmluZykgeyByZXR1cm47IH1cclxuICAgICAgICB0aGlzLl9pc0NsdXN0ZXJpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIGEgcHVzaHBpbnMgYmFzaWMgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGluIFB1c2hwaW4gdG8gY29weSBvcHRpb25zIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgY29weSBvZiBhIHB1c2hwaW5zIGJhc2ljIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBHZXRCYXNpY1B1c2hwaW5PcHRpb25zKHBpbjogTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbik6IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyB7XHJcbiAgICAgICAgcmV0dXJuIDxNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnM+e1xyXG4gICAgICAgICAgICBhbmNob3I6IHBpbi5nZXRBbmNob3IoKSxcclxuICAgICAgICAgICAgY29sb3I6IHBpbi5nZXRDb2xvcigpLFxyXG4gICAgICAgICAgICBjdXJzb3I6IHBpbi5nZXRDdXJzb3IoKSxcclxuICAgICAgICAgICAgaWNvbjogcGluLmdldEljb24oKSxcclxuICAgICAgICAgICAgcm91bmRDbGlja2FibGVBcmVhOiBwaW4uZ2V0Um91bmRDbGlja2FibGVBcmVhKCksXHJcbiAgICAgICAgICAgIHN1YlRpdGxlOiBwaW4uZ2V0U3ViVGl0bGUoKSxcclxuICAgICAgICAgICAgdGV4dDogcGluLmdldFRleHQoKSxcclxuICAgICAgICAgICAgdGV4dE9mZnNldDogcGluLmdldFRleHRPZmZzZXQoKSxcclxuICAgICAgICAgICAgdGl0bGU6IHBpbi5nZXRUaXRsZSgpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBzcGlkZXIgY2x1c3RlciBhbmQgcmVzb3RyZXMgdGhlIG9yaWdpbmFsIHBpbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIEhpZGVTcGlkZXJDbHVzdGVyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX21hcGNsaWNrcyA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRDbHVzdGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwaWRlckxheWVyLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwaWRlck1hcmtlcnMuc3BsaWNlKDApO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGlkZXJNYXJrZXJMb29rdXAuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudENsdXN0ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBjbGlja3MgPSAtMTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NwaWRlck9wdGlvbnMubWFya2VyVW5TZWxlY3RlZCkgeyB0aGlzLl9zcGlkZXJPcHRpb25zLm1hcmtlclVuU2VsZWN0ZWQoKTsgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsaWNrIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gYSBzaGFwZSBpbiB0aGUgY2x1c3RlciBsYXllciBpcyBjbGlja2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlIFRoZSBtb3VzZSBldmVudCBhcmd1cm1lbnQgZnJvbSB0aGUgY2xpY2sgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBPbkxheWVyQ2xpY2soZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGUucHJpbWl0aXZlIGluc3RhbmNlb2YgTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4pIHtcclxuICAgICAgICAgICAgY29uc3QgY3A6IE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJQdXNocGluID0gPE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJQdXNocGluPmUucHJpbWl0aXZlO1xyXG4gICAgICAgICAgICBjb25zdCBzaG93TmV3Q2x1c3RlcjogYm9vbGVhbiA9IGNwICE9PSB0aGlzLl9jdXJyZW50Q2x1c3RlcjtcclxuICAgICAgICAgICAgdGhpcy5IaWRlU3BpZGVyQ2x1c3RlcigpO1xyXG4gICAgICAgICAgICBpZiAoc2hvd05ld0NsdXN0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuU2hvd1NwaWRlckNsdXN0ZXIoPE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJQdXNocGluPmUucHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBpbjogTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiA9IDxNaWNyb3NvZnQuTWFwcy5QdXNocGluPmUucHJpbWl0aXZlO1xyXG4gICAgICAgICAgICBpZiAocGluLm1ldGFkYXRhICYmIHBpbi5tZXRhZGF0YS5pc0NsdXN0ZXJNYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG06IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyID0gdGhpcy5HZXRTcGlkZXJNYXJrZXJGcm9tQmluZ01hcmtlcihwaW4pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDogQmluZ01hcmtlciA9IG0uUGFyZW50TWFya2VyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHBpbjogTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiA9IHAuTmF0aXZlUHJpbWl0dmU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3BpZGVyT3B0aW9ucy5tYXJrZXJTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlck9wdGlvbnMubWFya2VyU2VsZWN0ZWQocCwgbmV3IEJpbmdNYXJrZXIodGhpcy5fY3VycmVudENsdXN0ZXIsIG51bGwsIG51bGwpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChNaWNyb3NvZnQuTWFwcy5FdmVudHMuaGFzSGFuZGxlcihwcGluLCAnY2xpY2snKSkgeyBNaWNyb3NvZnQuTWFwcy5FdmVudHMuaW52b2tlKHBwaW4sICdjbGljaycsIGUpOyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBjbGlja3MgPSAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NwaWRlck9wdGlvbnMubWFya2VyU2VsZWN0ZWQpIHsgdGhpcy5fc3BpZGVyT3B0aW9ucy5tYXJrZXJTZWxlY3RlZCh0aGlzLkdldE1hcmtlckZyb21CaW5nTWFya2VyKHBpbiksIG51bGwpOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAoTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmhhc0hhbmRsZXIocGluLCAnY2xpY2snKSkgeyBNaWNyb3NvZnQuTWFwcy5FdmVudHMuaW52b2tlKHBpbiwgJ2NsaWNrJywgZSk7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGVnYXRlIGhhbmRsaW5nIHRoZSBjbGljayBldmVudCBvbiB0aGUgbWFwIChvdXRzaWRlIGEgc3BpZGVyIGNsdXN0ZXIpLiBEZXBlbmRpbmcgb24gdGhlXHJcbiAgICAgKiBzcGlkZXIgb3B0aW9ucywgY2xvc2VzIHRoZSBjbHVzdGVyIG9yIGluY3JlbWVudHMgdGhlIGNsaWNrIGNvdW50ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGUgLSBNb3VzZSBldmVudFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgT25NYXBDbGljayhlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MgfCBNaWNyb3NvZnQuTWFwcy5JTWFwVHlwZUNoYW5nZUV2ZW50QXJncyk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXBjbGlja3MgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2UgaWYgKCsrdGhpcy5fbWFwY2xpY2tzID49IHRoaXMuX3NwaWRlck9wdGlvbnMuY29sbGFwc2VDbHVzdGVyT25OdGhDbGljaykge1xyXG4gICAgICAgICAgICB0aGlzLkhpZGVTcGlkZXJDbHVzdGVyKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZG8gbm90aGluZyBhcyB0aGlzLl9tYXBjbGlja3MgaGFzIGFscmVhZHkgYmVlbiBpbmNyZW1lbnRlZCBhYm92ZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGVnYXRlIGhhbmRsaW5nIHRoZSBtYXAgdmlldyBjaGFuZ2VkIGVuZCBldmVudC4gSGlkZXMgdGhlIHNwaWRlciBjbHVzdGVyIGlmIHRoZSB6b29tIGxldmVsIGhhcyBjaGFuZ2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlIC0gTW91c2UgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBPbk1hcFZpZXdDaGFuZ2VFbmQoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzIHwgTWljcm9zb2Z0Lk1hcHMuSU1hcFR5cGVDaGFuZ2VFdmVudEFyZ3MpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB6OiBudW1iZXIgPSAoPE1pY3Jvc29mdC5NYXBzLk1hcD5lLnRhcmdldCkuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IGhhc1pvb21DaGFuZ2VkOiBib29sZWFuID0gKHogIT09IHRoaXMuX2N1cnJlbnRab29tKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Wm9vbSA9IHo7XHJcbiAgICAgICAgaWYgKGhhc1pvb21DaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuSGlkZVNwaWRlckNsdXN0ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyB0aGUgbWFwIHZpZXcgY2hhbmdlIHN0YXJ0IGV2ZW50LiBEZXBlbmRpbmcgb24gdGhlIHNwaWRlciBvcHRpb25zLCBoaWRlcyB0aGVcclxuICAgICAqIHRoZSBleHBsb2RlZCBzcGlkZXIgb3IgZG9lcyBub3RoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlIC0gTW91c2UgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBPbk1hcFZpZXdDaGFuZ2VTdGFydChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MgfCBNaWNyb3NvZnQuTWFwcy5JTWFwVHlwZUNoYW5nZUV2ZW50QXJncyk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zcGlkZXJPcHRpb25zLmNvbGxhcHNlQ2x1c3Rlck9uTWFwQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuSGlkZVNwaWRlckNsdXN0ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBpbnZva2VkIG9uIG1vdXNlIG91dCBvbiBhbiBleHBsb2RlZCBzcGlkZXIgbWFya2VyLiBSZXNldHMgdGhlIGhvdmVyIHN0eWxlIG9uIHRoZSBzdGljay5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIE1vdXNlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIE9uU3BpZGVyTW91c2VPdXQoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluID0gPE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+ZS5wcmltaXRpdmU7XHJcbiAgICAgICAgaWYgKHBpbiBpbnN0YW5jZW9mIE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gJiYgcGluLm1ldGFkYXRhICYmIHBpbi5tZXRhZGF0YS5pc0NsdXN0ZXJNYXJrZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgbTogQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXIgPSB0aGlzLkdldFNwaWRlck1hcmtlckZyb21CaW5nTWFya2VyKHBpbik7XHJcbiAgICAgICAgICAgIG0uU3RpY2suc2V0T3B0aW9ucyh0aGlzLl9zcGlkZXJPcHRpb25zLnN0aWNrU3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludm9rZWQgb24gbW91c2Ugb3ZlciBvbiBhbiBleHBsb2RlZCBzcGlkZXIgbWFya2VyLiBTZXRzIHRoZSBob3ZlciBzdHlsZSBvbiB0aGUgc3RpY2suIEFsc28gaW52b2tlcyB0aGUgY2xpY2sgZXZlbnRcclxuICAgICAqIG9uIHRoZSB1bmRlcmx5aW5nIG9yaWdpbmFsIG1hcmtlciBkZXBlbmRlbnQgb24gdGhlIHNwaWRlciBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlIC0gTW91c2UgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgT25TcGlkZXJNb3VzZU92ZXIoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluID0gPE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+ZS5wcmltaXRpdmU7XHJcbiAgICAgICAgaWYgKHBpbiBpbnN0YW5jZW9mIE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gJiYgcGluLm1ldGFkYXRhICYmIHBpbi5tZXRhZGF0YS5pc0NsdXN0ZXJNYXJrZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgbTogQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXIgPSB0aGlzLkdldFNwaWRlck1hcmtlckZyb21CaW5nTWFya2VyKHBpbik7XHJcbiAgICAgICAgICAgIG0uU3RpY2suc2V0T3B0aW9ucyh0aGlzLl9zcGlkZXJPcHRpb25zLnN0aWNrSG92ZXJTdHlsZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGlkZXJPcHRpb25zLmludm9rZUNsaWNrT25Ib3Zlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDogQmluZ01hcmtlciA9IG0uUGFyZW50TWFya2VyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHBpbjogTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiA9IHAuTmF0aXZlUHJpbWl0dmU7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmhhc0hhbmRsZXIocHBpbiwgJ2NsaWNrJykpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmludm9rZShwcGluLCAnY2xpY2snLCBlKTsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgb3B0aW9ucyBmb3Igc3BpZGVyIGJlaGF2aW9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIElTcGlkZXJDbHVzdGVyT3B0aW9ucyBjb250YWluaW5nIHRoZSBvcHRpb25zIGVudW1lcmF0aW9uIGNvbnRyb2xsaW5nIHRoZSBzcGlkZXIgY2x1c3RlciBiZWhhdmlvci4gVGhlIHN1cHBsaWVkIG9wdGlvbnNcclxuICAgICAqIGFyZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdC9leGlzdGluZyBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgU2V0U3BpZGVyT3B0aW9ucyhvcHRpb25zOiBJU3BpZGVyQ2x1c3Rlck9wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2lyY2xlU3BpcmFsU3dpdGNob3ZlciA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlck9wdGlvbnMuY2lyY2xlU3BpcmFsU3dpdGNob3ZlciA9IG9wdGlvbnMuY2lyY2xlU3BpcmFsU3dpdGNob3ZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29sbGFwc2VDbHVzdGVyT25NYXBDaGFuZ2UgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5jb2xsYXBzZUNsdXN0ZXJPbk1hcENoYW5nZSA9IG9wdGlvbnMuY29sbGFwc2VDbHVzdGVyT25NYXBDaGFuZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbGxhcHNlQ2x1c3Rlck9uTnRoQ2xpY2sgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLmNvbGxhcHNlQ2x1c3Rlck9uTnRoQ2xpY2sgPSBvcHRpb25zLmNvbGxhcHNlQ2x1c3Rlck9uTnRoQ2xpY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmludm9rZUNsaWNrT25Ib3ZlciA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLmludm9rZUNsaWNrT25Ib3ZlciA9IG9wdGlvbnMuaW52b2tlQ2xpY2tPbkhvdmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5taW5TcGlyYWxBbmdsZVNlcGVyYXRpb24gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLm1pblNwaXJhbEFuZ2xlU2VwZXJhdGlvbiA9IG9wdGlvbnMubWluU3BpcmFsQW5nbGVTZXBlcmF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zcGlyYWxEaXN0YW5jZUZhY3RvciA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlck9wdGlvbnMuc3BpcmFsRGlzdGFuY2VGYWN0b3IgPSBvcHRpb25zLnNwaXJhbERpc3RhbmNlRmFjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5taW5DaXJjbGVMZW5ndGggPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLm1pbkNpcmNsZUxlbmd0aCA9IG9wdGlvbnMubWluQ2lyY2xlTGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0aWNrSG92ZXJTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5zdGlja0hvdmVyU3R5bGUgPSBvcHRpb25zLnN0aWNrSG92ZXJTdHlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGlja1N0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLnN0aWNrU3R5bGUgPSBvcHRpb25zLnN0aWNrU3R5bGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFya2VyU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlck9wdGlvbnMubWFya2VyU2VsZWN0ZWQgPSBvcHRpb25zLm1hcmtlclNlbGVjdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1hcmtlclVuU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlck9wdGlvbnMubWFya2VyVW5TZWxlY3RlZCA9IG9wdGlvbnMubWFya2VyVW5TZWxlY3RlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudmlzaWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLnZpc2libGUgPSBvcHRpb25zLnZpc2libGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5TZXRPcHRpb25zKDxJQ2x1c3Rlck9wdGlvbnM+b3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwYW5kcyBhIGNsdXN0ZXIgaW50byBpdCdzIG9wZW4gc3BpZGVyIGxheW91dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2x1c3RlciBUaGUgY2x1c3RlciB0byBzaG93IGluIGl0J3Mgb3BlbiBzcGlkZXIgbGF5b3V0Li5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIFNob3dTcGlkZXJDbHVzdGVyKGNsdXN0ZXI6IE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJQdXNocGluKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5IaWRlU3BpZGVyQ2x1c3RlcigpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRDbHVzdGVyID0gY2x1c3RlcjtcclxuXHJcbiAgICAgICAgaWYgKGNsdXN0ZXIgJiYgY2x1c3Rlci5jb250YWluZWRQdXNocGlucykge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgc3BpZGVyIGRhdGEuXHJcbiAgICAgICAgICAgIGNvbnN0IG06IE1pY3Jvc29mdC5NYXBzLk1hcCA9ICg8QmluZ01hcFNlcnZpY2U+dGhpcy5fbWFwcykuTWFwSW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGNvbnN0IHBpbnM6IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+ID0gY2x1c3Rlci5jb250YWluZWRQdXNocGlucztcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IGNsdXN0ZXIuZ2V0TG9jYXRpb24oKTtcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyUG9pbnQ6IE1pY3Jvc29mdC5NYXBzLlBvaW50ID1cclxuICAgICAgICAgICAgICAgIDxNaWNyb3NvZnQuTWFwcy5Qb2ludD5tLnRyeUxvY2F0aW9uVG9QaXhlbChjZW50ZXIsIE1pY3Jvc29mdC5NYXBzLlBpeGVsUmVmZXJlbmNlLmNvbnRyb2wpO1xyXG4gICAgICAgICAgICBsZXQgc3RpY2s6IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lO1xyXG4gICAgICAgICAgICBsZXQgYW5nbGUgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBtYWtlU3BpcmFsOiBib29sZWFuID0gcGlucy5sZW5ndGggPiB0aGlzLl9zcGlkZXJPcHRpb25zLmNpcmNsZVNwaXJhbFN3aXRjaG92ZXI7XHJcbiAgICAgICAgICAgIGxldCBsZWdQaXhlbExlbmd0aDogbnVtYmVyO1xyXG4gICAgICAgICAgICBsZXQgc3RlcEFuZ2xlOiBudW1iZXI7XHJcbiAgICAgICAgICAgIGxldCBzdGVwTGVuZ3RoOiBudW1iZXI7XHJcblxyXG4gICAgICAgICAgICBpZiAobWFrZVNwaXJhbCkge1xyXG4gICAgICAgICAgICAgICAgbGVnUGl4ZWxMZW5ndGggPSB0aGlzLl9zcGlkZXJPcHRpb25zLm1pbkNpcmNsZUxlbmd0aCAvIE1hdGguUEk7XHJcbiAgICAgICAgICAgICAgICBzdGVwTGVuZ3RoID0gMiAqIE1hdGguUEkgKiB0aGlzLl9zcGlkZXJPcHRpb25zLnNwaXJhbERpc3RhbmNlRmFjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RlcEFuZ2xlID0gMiAqIE1hdGguUEkgLyBwaW5zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGxlZ1BpeGVsTGVuZ3RoID0gKHRoaXMuX3NwaWRlck9wdGlvbnMuc3BpcmFsRGlzdGFuY2VGYWN0b3IgLyBzdGVwQW5nbGUgLyBNYXRoLlBJIC8gMikgKiBwaW5zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChsZWdQaXhlbExlbmd0aCA8IHRoaXMuX3NwaWRlck9wdGlvbnMubWluQ2lyY2xlTGVuZ3RoKSB7IGxlZ1BpeGVsTGVuZ3RoID0gdGhpcy5fc3BpZGVyT3B0aW9ucy5taW5DaXJjbGVMZW5ndGg7IH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBpbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzcGlkZXIgcGluIGxvY2F0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFtYWtlU3BpcmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBzdGVwQW5nbGUgKiBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgKz0gdGhpcy5fc3BpZGVyT3B0aW9ucy5taW5TcGlyYWxBbmdsZVNlcGVyYXRpb24gLyBsZWdQaXhlbExlbmd0aCArIGkgKiAwLjAwMDU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVnUGl4ZWxMZW5ndGggKz0gc3RlcExlbmd0aCAvIGFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQ6IE1pY3Jvc29mdC5NYXBzLlBvaW50ID1cclxuICAgICAgICAgICAgICAgICAgICBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9pbnQoY2VudGVyUG9pbnQueCArIGxlZ1BpeGVsTGVuZ3RoICogTWF0aC5jb3MoYW5nbGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJQb2ludC55ICsgbGVnUGl4ZWxMZW5ndGggKiBNYXRoLnNpbihhbmdsZSkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9XHJcbiAgICAgICAgICAgICAgICAgICAgPE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPm0udHJ5UGl4ZWxUb0xvY2F0aW9uKHBvaW50LCBNaWNyb3NvZnQuTWFwcy5QaXhlbFJlZmVyZW5jZS5jb250cm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgc3RpY2sgdG8gcGluLlxyXG4gICAgICAgICAgICAgICAgc3RpY2sgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmUoW2NlbnRlciwgbG9jXSwgdGhpcy5fc3BpZGVyT3B0aW9ucy5zdGlja1N0eWxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlckxheWVyLmFkZChzdGljayk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHBpbiBpbiBzcGlyYWwgdGhhdCBjb250YWlucyBzYW1lIG1ldGFkYXRhIGFzIHBhcmVudCBwaW4uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbihsb2MpO1xyXG4gICAgICAgICAgICAgICAgcGluLm1ldGFkYXRhID0gcGluc1tpXS5tZXRhZGF0YSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHBpbi5tZXRhZGF0YS5pc0NsdXN0ZXJNYXJrZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcGluLnNldE9wdGlvbnModGhpcy5HZXRCYXNpY1B1c2hwaW5PcHRpb25zKHBpbnNbaV0pKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlckxheWVyLmFkZChwaW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNwaWRlck1hcmtlcjogQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXIgPSBuZXcgQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXIocGluLCBudWxsLCB0aGlzLl9zcGlkZXJMYXllcik7XHJcbiAgICAgICAgICAgICAgICBzcGlkZXJNYXJrZXIuU3RpY2sgPSBzdGljaztcclxuICAgICAgICAgICAgICAgIHNwaWRlck1hcmtlci5QYXJlbnRNYXJrZXIgPSA8QmluZ01hcmtlcj50aGlzLkdldE1hcmtlckZyb21CaW5nTWFya2VyKHBpbnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyTWFya2Vycy5wdXNoKHNwaWRlck1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJNYXJrZXJMb29rdXAuc2V0KHBpbiwgc3BpZGVyTWFya2VyKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbWFwY2xpY2tzID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vaW5mby13aW5kb3cnO1xyXG5pbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1jb252ZXJzaW9ucyc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHtAbGluayBJbmZvV2luZG93fSBjb250cmFjdCBmb3IgdGhlIEJpbmcgTWFwcyBWOCBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmluZ0luZm9XaW5kb3cgaW1wbGVtZW50cyBJbmZvV2luZG93IHtcclxuXHJcbiAgICBwcml2YXRlIF9pc09wZW46IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGluZm8gYm94IGlzIGN1cnJlbnRseSBvcGVuLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdJbmZvV2luZG93XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSXNPcGVuKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9pbmZvQm94ICYmIHRoaXMuX2luZm9Cb3guZ2V0T3B0aW9ucygpLnZpc2libGUgPT09IHRydWUpIHsgcmV0dXJuIHRydWU7IH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG5hdGl2ZSBwcmltaXR2ZSB1bmRlcmx5aW5nIHRoZSBtb2RlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9XaW5kb3dcclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTmF0aXZlUHJpbWl0dmUoKTogTWljcm9zb2Z0Lk1hcHMuSW5mb2JveCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9Cb3g7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdJbmZvV2luZG93LlxyXG4gICAgICogQHBhcmFtIF9pbmZvQm94IC0gQSB7QGxpbmsgTWljcm9zb2Z0Lk1hcHMuSW5mb2JveH0gaW5zdGFuY2UgdW5kZXJseWluZyB0aGUgbW9kZWxcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nSW5mb1dpbmRvd1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pbmZvQm94OiBNaWNyb3NvZnQuTWFwcy5JbmZvYm94KSB7XHJcbiAgICAgICAgdGhpcy5faXNPcGVuID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBJbmZvV2luZG93LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgZXZlbnQgZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBsaXN0ZW5lciAoZS5nLiBcImNsaWNrXCIpXHJcbiAgICAgKiBAcGFyYW0gZm4gLSBEZWxlZ2F0ZSBpbnZva2VkIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9XaW5kb3dcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9pbmZvQm94LCBldmVudFR5cGUsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLmV2ZW50TmFtZSA9PT0gJ2luZm9ib3hDaGFuZ2VkJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZm9Cb3guZ2V0T3B0aW9ucygpLnZpc2libGUgPT09IHRydWUpIHsgdGhpcy5faXNPcGVuID0gdHJ1ZTsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZm9Cb3guZ2V0T3B0aW9ucygpLnZpc2libGUgPT09IGZhbHNlICYmIHRoaXMuX2lzT3BlbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm4oZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm4oZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyB0aGUgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdJbmZvV2luZG93XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDbG9zZSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveE9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pbmZvQm94LnNldE9wdGlvbnMobyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBSZXR1cm5zIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIGluZm8gd2luZG93LlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdJbmZvV2luZG93XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRQb3NpdGlvbigpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgY29uc3QgcDogSUxhdExvbmcgPSB7XHJcbiAgICAgICAgICAgIGxhdGl0dWRlOiB0aGlzLl9pbmZvQm94LmdldExvY2F0aW9uKCkubGF0aXR1ZGUsXHJcbiAgICAgICAgICAgIGxvbmdpdHVkZTogdGhpcy5faW5mb0JveC5nZXRMb2NhdGlvbigpLmxvbmdpdHVkZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyB0aGUgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdJbmZvV2luZG93XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBPcGVuKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklJbmZvYm94T3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIG8udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5faW5mb0JveC5zZXRPcHRpb25zKG8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaW5mbyB3aW5kb3cgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEluZm8gd2luZG93IG9wdGlvbnMgdG8gc2V0LiBUaGUgb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIGFueSBleGlzdGluZyBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nSW5mb1dpbmRvd1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveE9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlSW5mb0JveE9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5faW5mb0JveC5zZXRPcHRpb25zKG8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaW5mbyB3aW5kb3cgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIC0gR2VvIGNvb3JkaW5hdGVzIHRvIG1vdmUgdGhlIGFuY2hvciBvZiB0aGUgaW5mbyB3aW5kb3cgdG8uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdJbmZvV2luZG93XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRQb3NpdGlvbihwb3NpdGlvbjogSUxhdExvbmcpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBsOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5faW5mb0JveC5zZXRMb2NhdGlvbihsKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJTGFiZWxPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGFiZWwtb3B0aW9ucyc7XHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgYmFzZSBpbXBsZW1lbnRpbmcgYSBsYWJlbCB0byBiZSBwbGFjZWQgb24gdGhlIG1hcC5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNYXBMYWJlbCB7XHJcbi8vIGV4cG9ydCBjbGFzcyBNYXBMYWJlbCBleHRlbmRzIE1pY3Jvc29mdC5NYXBzLkN1c3RvbU92ZXJsYXkge1xyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByb3RlY3RlZCBfY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgbGFiZWwgc3R5bGUgZm9yIHRoZSBwbGF0Zm9ybVxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBEZWZhdWx0TGFiZWxTdHlsZSgpOiBJTGFiZWxPcHRpb25zO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWFwTGFiZWxcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIHByb3BlcnRpZXMgdG8gc2V0LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XHJcbiAgICAgICAgdGhpcy5TZXQoJ2ZvbnRGYW1pbHknLCAnc2Fucy1zZXJpZicpO1xyXG4gICAgICAgIHRoaXMuU2V0KCdmb250U2l6ZScsIDEyKTtcclxuICAgICAgICB0aGlzLlNldCgnZm9udENvbG9yJywgJyNmZmZmZmYnKTtcclxuICAgICAgICB0aGlzLlNldCgnc3Ryb2tlV2VpZ2h0JywgNCk7XHJcbiAgICAgICAgdGhpcy5TZXQoJ3N0cm9rZUNvbG9yJywgJyMwMDAwMDAnKTtcclxuICAgICAgICB0aGlzLlNldCgnYWxpZ24nLCAnY2VudGVyJyk7XHJcbiAgICAgICAgdGhpcy5TZXRWYWx1ZXMob3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgbGFiZWwgZnJvbSB0aGUgbWFwLiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBhdHVhbGx5IGRlbGV0ZSB0aGUgbGFiZWwgaXRzZWxmLCBzb1xyXG4gICAgICogaXQgY2FuIGJlIHJlYWRkZWQgdG8gbWFwIGxhdGVyLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5TZXRNYXAobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBjYWxsZWQgd2hlbiB1bmRlcmx5aW5nIHByb3BlcnRpZXMgY2hhbmdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm9wIC0gVGhlIHByb3BlcnR5IG9yIHByb3BlcnRpZXMgdGhhdCBoYXZlIGNoYW5nZWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIENoYW5nZWQocHJvcDogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPik6IHZvaWQge1xyXG4gICAgICAgIGxldCBzaG91bGRSdW5EcmF3Q2FudmFzID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHNob3VsZFJ1bkRyYXcgPSBmYWxzZTtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcCkpIHsgcHJvcCA9IFtwcm9wXTsgfVxyXG4gICAgICAgIHByb3AuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgc3dpdGNoIChwKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdmb250RmFtaWx5JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZvbnRTaXplJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZvbnRDb2xvcic6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJva2VXZWlnaHQnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3Ryb2tlQ29sb3InOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnYWxpZ24nOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUnVuRHJhd0NhbnZhcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtYXhab29tJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21pblpvb20nOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnb2Zmc2V0JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2hpZGRlbic6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdwb3NpdGlvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUnVuRHJhdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoc2hvdWxkUnVuRHJhd0NhbnZhcykgeyB0aGlzLkRyYXdDYW52YXMoKTsgfVxyXG4gICAgICAgIGlmIChzaG91bGRSdW5EcmF3KSB7IHRoaXMuRHJhdygpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHNldHRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSBzcGVjaWZ5aW5nIHRoZSBzZXR0aW5nLlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgdmFsdWUgb2YgdGhlIHNldHRpbmcuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0KGtleTogc3RyaW5nKTogYW55O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbWFwIGFzc29jaXRlZCB3aXRoIHRoZSBsYWJlbC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgbmF0aXZlIG1hcCBvYmplY3QgZm9yIHRoZSB1bmRlcmx5aW5nIGltcGxlbWVudGF0aW9uLiBJbXBsZW1lbnRpbmcgZGVyaXZhdGl2ZXMgc2hvdWxkIHJldHVybiB0aGVcclxuICAgICAqIGFjdHVhbCBuYXRpdmUgb2JqZWN0LlxyXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldE1hcCgpOiBhbnk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGZvciBhIHNldHRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSBzcGVjaWZ5aW5nIHRoZSBzZXR0aW5nLlxyXG4gICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0KGtleTogc3RyaW5nLCB2YWw6IGFueSk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXAgZm9yIHRoZSBsYWJlbC4gU2V0dGluZ3MgdGhpcyB0byBudWxsIHJlbW92ZSB0aGUgbGFiZWwgZnJvbSBodGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSBBIG5hdGl2ZSBtYXAgb2JqZWN0IGZvciB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbi4gSW1wbGVtZW50aW5nIGRlcml2YXRpdmVzIHNob3VsZCByZXR1cm4gdGhlXHJcbiAgICAgKiBhY3R1YWwgbmF0aXZlIG9iamVjdC5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0TWFwKG1hcDogYW55KTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgc2V0dGluZ3MgdG8gdGhlIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNldHRpbmdzIGtleSB2YWx1ZSBwYWlycy5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYWJlbFxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRWYWx1ZXMob3B0aW9uczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IHZvaWQ7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvdGVjdGVkIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsYWJlbC4gVmlzaWJpbGl0eSBkZXBlbmRzIG9uIFpvb20gc2V0dGluZ3MuXHJcbiAgICAgKiBAcmV0dXJucyAtIGJsYW5rIHN0cmluZyBpZiB2aXNpYmxlLCAnaGlkZGVuJyBpZiBpbnZpc2libGUuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBHZXRWaXNpYmxlKCkge1xyXG4gICAgICAgIGNvbnN0IG1pblpvb206IG51bWJlciA9IHRoaXMuR2V0KCdtaW5ab29tJyk7XHJcbiAgICAgICAgY29uc3QgbWF4Wm9vbTogbnVtYmVyID0gdGhpcy5HZXQoJ21heFpvb20nKTtcclxuICAgICAgICBjb25zdCBoaWRkZW46IGJvb2xlYW4gPSB0aGlzLkdldCgnaGlkZGVuJyk7XHJcblxyXG4gICAgICAgIGlmIChoaWRkZW4pIHtyZXR1cm4gJ2hpZGRlbic7IH1cclxuICAgICAgICBpZiAobWluWm9vbSA9PT0gdW5kZWZpbmVkICYmIG1heFpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gJyc7IH1cclxuICAgICAgICBpZiAoIXRoaXMuR2V0TWFwKCkpIHsgcmV0dXJuICcnOyB9XHJcblxyXG4gICAgICAgIGNvbnN0IG1hcFpvb206IG51bWJlciA9IHRoaXMuR2V0TWFwKCkuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGlmIChtYXBab29tIDwgbWluWm9vbSB8fCBtYXBab29tID4gbWF4Wm9vbSkgeyByZXR1cm4gJ2hpZGRlbic7IH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgbGFiZWwgb24gdGhlIG1hcC5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgRHJhdygpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIGxhYmVsIHRvIHRoZSBjYW52YXMgMmQgY29udGV4dC5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgRHJhd0NhbnZhcyAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jYW52YXMpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uID0gdGhpcy5fY2FudmFzLnN0eWxlO1xyXG4gICAgICAgIHN0eWxlLnpJbmRleCA9IHRoaXMuR2V0KCd6SW5kZXgnKTtcclxuXHJcbiAgICAgICAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5HZXQoJ3N0cm9rZUNvbG9yJyk7XHJcbiAgICAgICAgY3R4LmZvbnQgPSB0aGlzLkdldCgnZm9udFNpemUnKSArICdweCAnICsgdGhpcy5HZXQoJ2ZvbnRGYW1pbHknKTtcclxuXHJcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZENvbG9yOiBzdHJpbmcgPSB0aGlzLkdldCgnYmFja2dyb3VuZENvbG9yJyk7XHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlV2VpZ2h0OiBudW1iZXIgPSBOdW1iZXIodGhpcy5HZXQoJ3N0cm9rZVdlaWdodCcpKTtcclxuICAgICAgICBjb25zdCB0ZXh0OiBzdHJpbmcgPSB0aGlzLkdldCgndGV4dCcpO1xyXG4gICAgICAgIGNvbnN0IHRleHRNZWFzdXJlOiBUZXh0TWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcclxuICAgICAgICBjb25zdCB0ZXh0V2lkdGg6IG51bWJlciA9IHRleHRNZWFzdXJlLndpZHRoO1xyXG4gICAgICAgIGlmICh0ZXh0ICYmIHN0cm9rZVdlaWdodCAmJiBzdHJva2VXZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQodGV4dCwgNCwgNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IgJiYgYmFja2dyb3VuZENvbG9yICE9PSAnJykge1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGV4dFdpZHRoICsgOCwgKHBhcnNlSW50KGN0eC5mb250LCAxMCkgKiAyKSAtIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5HZXQoJ2ZvbnRDb2xvcicpO1xyXG4gICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCA0LCA0KTtcclxuXHJcbiAgICAgICAgc3R5bGUubWFyZ2luTGVmdCA9IHRoaXMuR2V0TWFyZ2luTGVmdCh0ZXh0V2lkdGgpICsgJ3B4JztcclxuICAgICAgICBzdHlsZS5tYXJnaW5Ub3AgPSAnLTAuNGVtJztcclxuICAgICAgICBzdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAvLyBCcmluZyBhY3R1YWwgdGV4dCB0b3AgaW4gbGluZSB3aXRoIGRlc2lyZWQgbGF0aXR1ZGUuXHJcbiAgICAgICAgICAgIC8vIENoZWFwZXIgdGhhbiBjYWxjdWxhdGluZyBoZWlnaHQgb2YgdGV4dC5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIG1hcmdpbi1sZWZ0IGZvciB0aGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIHRleHRXaWR0aCAgLSBUaGUgd2lkdGggb2YgdGhlIHRleHQsIGluIHBpeGVscy5cclxuICAgICAqIEByZXR1cm5zIC0gVGhlIG1hcmdpbi1sZWZ0LCBpbiBwaXhlbHMuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIEdldE1hcmdpbkxlZnQodGV4dFdpZHRoOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5HZXQoJ2FsaWduJykpIHtcclxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6ICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6ICAgcmV0dXJuIC10ZXh0V2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0V2lkdGggLyAtMjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGVnYXRlIGNhbGxlZCB3aGVuIHRoZSBsYWJlbCBpcyBhZGRlZCB0byB0aGUgbWFwLiBHZW5lcmF0ZXMgYW5kIGNvbmZpZ3VyZXNcclxuICAgICAqIHRoZSBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IE9uQWRkKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbGFiZWwgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIE9uUmVtb3ZlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYW52YXMgJiYgdGhpcy5fY2FudmFzLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImV4cG9ydCBjbGFzcyBFeHRlbmRlciB7XHJcblxyXG4gICAgcHJpdmF0ZSBfb2JqOiBhbnk7XHJcbiAgICBwcml2YXRlIF9wcm90bzogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG9iajogYW55KSB7XHJcbiAgICAgICAgdGhpcy5fb2JqID0gb2JqO1xyXG4gICAgICAgIHRoaXMuX3Byb3RvID0gb2JqLnByb3RvdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBFeHRlbmQobmV3T2JqOiBhbnkpOiBFeHRlbmRlciB7XHJcblxyXG4gICAgICAgIHRoaXMuU2V0KCdwcm90b3R5cGUnLCBuZXdPYmosIHRoaXMuX29iaik7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgeSBpbiB0aGlzLl9wcm90bykge1xyXG4gICAgICAgICAgICBpZiAoKDxhbnk+dGhpcy5fcHJvdG8pW3ldICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuU2V0KHksICh0aGlzLl9wcm90bylbeV0sICg8YW55PnRoaXMuX29iai5wcm90b3R5cGUpW3ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgU2V0KHByb3BlcnR5OiBzdHJpbmcsIG5ld09iajogYW55LCBvYmo/OiBhbnkpOiBFeHRlbmRlciB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPYmogPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IHRoaXMuX3Byb3RvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIG5ld09iaik7XHJcbiAgICB9XHJcblxyXG4gICAgTWFwKHByb3BlcnR5OiBzdHJpbmcsIG5ld1Byb3BlcnR5OiBzdHJpbmcpOiBFeHRlbmRlciB7XHJcbiAgICAgICAgdGhpcy5TZXQocHJvcGVydHksIHRoaXMuX3Byb3RvW25ld1Byb3BlcnR5XSwgdGhpcy5fb2JqLnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1jb252ZXJzaW9ucyc7XHJcbmltcG9ydCB7IElMYWJlbE9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYWJlbC1vcHRpb25zJztcclxuaW1wb3J0IHsgTWFwTGFiZWwgfSBmcm9tICcuLi9tYXAtbGFiZWwnO1xyXG5pbXBvcnQgeyBFeHRlbmRlciB9IGZyb20gJy4uL2V4dGVuZGVyJztcclxuXHJcbmxldCBpZDogbnVtYmVyID0gMDtcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIG1hcCBhIGxhYmxlZCB0byBiZSBwbGFjZWQgb24gdGhlIG1hcC5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJpbmdNYXBMYWJlbCBleHRlbmRzIE1hcExhYmVsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgbGFiZWwgc3R5bGUgZm9yIHRoZSBwbGF0Zm9ybVxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcExhYmVsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgRGVmYXVsdExhYmVsU3R5bGUoKTogSUxhYmVsT3B0aW9ucyB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxyXG4gICAgICAgICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXHJcbiAgICAgICAgICAgIGZvbnRDb2xvcjogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDIsXHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAnIzAwMDAwMCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWFwTGFiZWxcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIHByb3BlcnRpZXMgdG8gc2V0LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XHJcbiAgICAgICAgb3B0aW9ucy5mb250U2l6ZSA9IG9wdGlvbnMuZm9udFNpemUgfHwgMTI7XHJcbiAgICAgICAgb3B0aW9ucy5mb250Q29sb3IgPSBvcHRpb25zLmZvbnRDb2xvciB8fCAnI2ZmZmZmZic7XHJcbiAgICAgICAgb3B0aW9ucy5zdHJva2VXZWlnaHQgPSBvcHRpb25zLnN0cm9rZVdlaWdodCB8fCAyO1xyXG4gICAgICAgIG9wdGlvbnMuc3Ryb2tlQ29sb3IgPSBvcHRpb25zLnN0cm9rZUNvbG9yIHx8ICcjMDAwMDAwJztcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICAoPGFueT50aGlzKS5fb3B0aW9ucy5iZW5lYXRoTGFiZWxzID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdmFsdWUgb2YgYSBzZXR0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgc3BlY2lmeWluZyB0aGUgc2V0dGluZy5cclxuICAgICAqIEByZXR1cm5zIC0gVGhlIHZhbHVlIG9mIHRoZSBzZXR0aW5nLlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0KGtleTogc3RyaW5nKTogYW55IHtcclxuICAgICAgICByZXR1cm4gKDxhbnk+dGhpcylba2V5XTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1hcCBhc3NvY2l0ZWQgd2l0aCB0aGUgbGFiZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TWFwKCk6IE1pY3Jvc29mdC5NYXBzLk1hcCB7XHJcbiAgICAgICAgcmV0dXJuICg8YW55PnRoaXMpLmdldE1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgYSBzZXR0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgc3BlY2lmeWluZyB0aGUgc2V0dGluZy5cclxuICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0KGtleTogc3RyaW5nLCB2YWw6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgJiYgIXZhbC5oYXNPd25Qcm9wZXJ0eSgnYWx0aXR1ZGUnKSAmJiB2YWwuaGFzT3duUHJvcGVydHkoJ2xhdGl0dWRlJykgJiYgdmFsLmhhc093blByb3BlcnR5KCdsb25naXR1ZGUnKSkge1xyXG4gICAgICAgICAgICB2YWwgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24odmFsLmxhdGl0dWRlLCB2YWwubG9uZ2l0dWRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuR2V0KGtleSkgIT09IHZhbCkge1xyXG4gICAgICAgICAgICAoPGFueT50aGlzKVtrZXldID0gdmFsO1xyXG4gICAgICAgICAgICB0aGlzLkNoYW5nZWQoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXAgZm9yIHRoZSBsYWJlbC4gU2V0dGluZ3MgdGhpcyB0byBudWxsIHJlbW92ZSB0aGUgbGFiZWwgZnJvbSBodGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSBNYXAgdG8gYXNzb2NpYXRlZCB3aXRoIHRoZSBsYWJlbC5cclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE1hcChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG06IE1pY3Jvc29mdC5NYXBzLk1hcCA9IHRoaXMuR2V0TWFwKCk7XHJcbiAgICAgICAgaWYgKG1hcCA9PT0gbSkgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICBtLmxheWVycy5yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXAgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtYXAubGF5ZXJzLmluc2VydCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHNldHRpbmdzIHRvIHRoZSBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXR0aW5ncyBrZXkgdmFsdWUgcGFpcnMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRWYWx1ZXMob3B0aW9uczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PHN0cmluZz4gPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKGtleSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgJiYgIW9wdGlvbnNba2V5XS5oYXNPd25Qcm9wZXJ0eSgnYWx0aXR1ZGUnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XS5oYXNPd25Qcm9wZXJ0eSgnbGF0aXR1ZGUnKSAmJiBvcHRpb25zW2tleV0uaGFzT3duUHJvcGVydHkoJ2xvbmdpdHVkZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gbmV3IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uKG9wdGlvbnNba2V5XS5sYXRpdHVkZSwgb3B0aW9uc1trZXldLmxvbmdpdHVkZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5HZXQoa2V5KSAhPT0gb3B0aW9uc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxhbnk+dGhpcylba2V5XSA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBwLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5sZW5ndGggPiAwKSB7IHRoaXMuQ2hhbmdlZChwKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBsYWJlbCBvbiB0aGUgbWFwLlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgRHJhdygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB2aXNpYmlsaXR5OiBzdHJpbmcgPSB0aGlzLkdldFZpc2libGUoKTtcclxuICAgICAgICBjb25zdCBtOiBNaWNyb3NvZnQuTWFwcy5NYXAgPSB0aGlzLkdldE1hcCgpO1xyXG4gICAgICAgIGlmICghdGhpcy5fY2FudmFzKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmICghbSkgeyByZXR1cm47IH1cclxuICAgICAgICBjb25zdCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9IHRoaXMuX2NhbnZhcy5zdHlsZTtcclxuICAgICAgICBpZiAodmlzaWJpbGl0eSAhPT0gJycpIHtcclxuICAgICAgICAgICAgLy8gbGFiZWwgaXMgbm90IHZpc2libGUsIGRvbid0IGNhbGN1bGF0ZSBwb3NpdGlvbnMgZXRjLlxyXG4gICAgICAgICAgICBzdHlsZVsndmlzaWJpbGl0eSddID0gdmlzaWJpbGl0eTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG9mZnNldDogTWljcm9zb2Z0Lk1hcHMuUG9pbnQgPSB0aGlzLkdldCgnb2Zmc2V0Jyk7XHJcbiAgICAgICAgY29uc3QgbGF0TG5nOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IHRoaXMuR2V0KCdwb3NpdGlvbicpO1xyXG4gICAgICAgIGlmICghbGF0TG5nKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmICghb2Zmc2V0KSB7IG9mZnNldCA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2ludCgwLCAwKTsgfVxyXG5cclxuICAgICAgICBjb25zdCBwb3M6IE1pY3Jvc29mdC5NYXBzLlBvaW50ID0gPE1pY3Jvc29mdC5NYXBzLlBvaW50Pm0udHJ5TG9jYXRpb25Ub1BpeGVsKFxyXG4gICAgICAgICAgICBsYXRMbmcsXHJcbiAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLlBpeGVsUmVmZXJlbmNlLmNvbnRyb2wpO1xyXG4gICAgICAgIHN0eWxlWyd0b3AnXSA9IChwb3MueSArIG9mZnNldC55KSArICdweCc7XHJcbiAgICAgICAgc3R5bGVbJ2xlZnQnXSA9IChwb3MueCArIG9mZnNldC54KSArICdweCc7XHJcbiAgICAgICAgc3R5bGVbJ3Zpc2liaWxpdHknXSA9IHZpc2liaWxpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBjYWxsZWQgd2hlbiB0aGUgbGFiZWwgaXMgYWRkZWQgdG8gdGhlIG1hcC4gR2VuZXJhdGVzIGFuZCBjb25maWd1cmVzXHJcbiAgICAgKiB0aGUgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIE9uQWRkKCkge1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5pZCA9IGB4TWFwTGFiZWwke2lkKyt9YDtcclxuICAgICAgICBjb25zdCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9IHRoaXMuX2NhbnZhcy5zdHlsZTtcclxuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcblxyXG4gICAgICAgIGNvbnN0IGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcclxuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XHJcblxyXG4gICAgICAgICg8YW55PnRoaXMpLnNldEh0bWxFbGVtZW50KHRoaXMuX2NhbnZhcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGVnYXRlIGNhbGxsZWQgd2hlbiB0aGUgbGFiZWwgaXMgbG9hZGVkXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgT25Mb2FkKCkge1xyXG4gICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuR2V0TWFwKCksICd2aWV3Y2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLkNoYW5nZWQoJ3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5EcmF3Q2FudmFzKCk7XHJcbiAgICAgICAgdGhpcy5EcmF3KCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZXh0ZW5kIHRoZSBDdXN0b21PdmVybGF5IGludG8gdGhlIE1hcExhYmVsXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQG1ldGhvZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE1peGluTWFwTGFiZWxXaXRoT3ZlcmxheVZpZXcoKSB7XHJcbiAgICBuZXcgRXh0ZW5kZXIoQmluZ01hcExhYmVsKVxyXG4gICAgLkV4dGVuZChuZXcgTWljcm9zb2Z0Lk1hcHMuQ3VzdG9tT3ZlcmxheSgpKVxyXG4gICAgLk1hcCgnb25BZGQnLCAnT25BZGQnKVxyXG4gICAgLk1hcCgnb25Mb2FkJywgJ09uTG9hZCcpXHJcbiAgICAuTWFwKCdvblJlbW92ZScsICdPblJlbW92ZScpO1xyXG59XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5Z29uRXZlbnQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLWV2ZW50JztcclxuaW1wb3J0IHsgQmluZ0NvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLWNvbnZlcnNpb25zJztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vcG9seWdvbic7XHJcbmltcG9ydCB7IEJpbmdNYXBMYWJlbCB9IGZyb20gJy4vYmluZy1sYWJlbCc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gZm9yIGEgcG9seWdvbiBtb2RlbCBmb3IgQmluZyBNYXBzIFY4LlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmluZ1BvbHlnb24gZXh0ZW5kcyBQb2x5Z29uIGltcGxlbWVudHMgUG9seWdvbiB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX21hcDogTWljcm9zb2Z0Lk1hcHMuTWFwID0gbnVsbDtcclxuICAgIHByaXZhdGUgX2lzRWRpdGFibGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3RpdGxlOiBzdHJpbmcgPSAnJztcclxuICAgIHByaXZhdGUgX21heFpvb206IG51bWJlciA9IC0xO1xyXG4gICAgcHJpdmF0ZSBfbWluWm9vbTogbnVtYmVyID0gLTE7XHJcbiAgICBwcml2YXRlIF9zaG93TGFiZWw6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3Nob3dUb29sdGlwOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9sYWJlbDogQmluZ01hcExhYmVsID0gbnVsbDtcclxuICAgIHByaXZhdGUgX3Rvb2x0aXA6IEJpbmdNYXBMYWJlbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9oYXNUb29sVGlwUmVjZWl2ZXI6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3Rvb2x0aXBWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9tb3VzZU92ZXJMaXN0ZW5lcjogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcclxuICAgIHByaXZhdGUgX21vdXNlTW92ZUxpc3RlbmVyOiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xyXG4gICAgcHJpdmF0ZSBfbW91c2VPdXRMaXN0ZW5lcjogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcclxuICAgIHByaXZhdGUgX21ldGFkYXRhOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcclxuICAgIHByaXZhdGUgX29yaWdpbmFsUGF0aDogQXJyYXk8QXJyYXk8SUxhdExvbmc+PjtcclxuICAgIHByaXZhdGUgX2VkaXRpbmdDb21wbGV0ZUVtaXR0ZXI6IChldmVudDogSVBvbHlnb25FdmVudCkgPT4gdm9pZDtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHpvb20gYXQgd2hpY2ggdGhlIGxhYmVsIGlzIGRpc3BsYXllZC4gSWdub3JlZCBvciBTaG93TGFiZWwgaXMgZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IExhYmVsTWF4Wm9vbSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fbWF4Wm9vbTsgfVxyXG4gICAgcHVibGljIHNldCBMYWJlbE1heFpvb20odmFsOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9tYXhab29tID0gdmFsO1xyXG4gICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSB6b29tIGF0IHdoaWNoIHRoZSBsYWJlbCBpcyBkaXNwbGF5ZWQuIElnbm9yZWQgb3IgU2hvd0xhYmVsIGlzIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBMYWJlbE1pblpvb20oKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX21pblpvb207IH1cclxuICAgIHB1YmxpYyBzZXQgTGFiZWxNaW5ab29tKHZhbDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5fbWluWm9vbSA9IHZhbDtcclxuICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uIG1ldGFkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTWV0YWRhdGEoKTogTWFwPHN0cmluZywgYW55PiB7IHJldHVybiB0aGlzLl9tZXRhZGF0YTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIHByaW1pdHZlIGltcGxlbWVudGluZyB0aGUgcG9seWdvbiwgaW4gdGhpcyBjYXNlIHtAbGluayBNaWNyb3NvZnQuTWFwcy5Qb2x5Z29ufVxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTmF0aXZlUHJpbWl0dmUoKTogTWljcm9zb2Z0Lk1hcHMuUG9seWdvbiB7IHJldHVybiB0aGlzLl9wb2x5Z29uOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0byBzaG93IHRoZSBsYWJlbFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBTaG93TGFiZWwoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9zaG93TGFiZWw7IH1cclxuICAgIHB1YmxpYyBzZXQgU2hvd0xhYmVsKHZhbDogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuX3Nob3dMYWJlbCA9IHZhbDtcclxuICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0byBzaG93IHRoZSB0b29sdGlwXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IFNob3dUb29sdGlwKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc2hvd1Rvb2x0aXA7IH1cclxuICAgIHB1YmxpYyBzZXQgU2hvd1Rvb2x0aXAodmFsOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXAgPSB2YWw7XHJcbiAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHRpdGxlIG9mZiB0aGUgcG9seWdvblxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBUaXRsZSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fdGl0bGU7IH1cclxuICAgIHB1YmxpYyBzZXQgVGl0bGUodmFsOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl90aXRsZSA9IHZhbDtcclxuICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XHJcbiAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gY29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nUG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBfcG9seWdvbiAtIFRoZSB7QGxpbmsgTWljcm9zb2Z0Lk1hcHMuUG9seWdvbn0gdW5kZXJseWluZyB0aGUgbW9kZWwuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgSW5zdGFuY2Ugb2YgdGhlIE1hcCBTZXJ2aWNlLlxyXG4gICAgICogQHBhcmFtIF9sYXllciAtIFRoZSBjb250ZXh0IGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgX3BvbHlnb246IE1pY3Jvc29mdC5NYXBzLlBvbHlnb24sXHJcbiAgICAgICAgcHJvdGVjdGVkIF9tYXBTZXJ2aWNlOiBCaW5nTWFwU2VydmljZSxcclxuICAgICAgICBwcm90ZWN0ZWQgX2xheWVyOiBNaWNyb3NvZnQuTWFwcy5MYXllcixcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbWFwID0gdGhpcy5fbWFwU2VydmljZS5NYXBJbnN0YW5jZTtcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbFBhdGggPSB0aGlzLkdldFBhdGhzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgZGVsZWdhdGUgZm9yIGFuIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgZXZlbnQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG5cclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEV2ZW50cyA9IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnZHJhZycsICdkcmFnZW5kJywgJ2RyYWdzdGFydCcsICdtb3VzZWRvd24nLCAnbW91c2VvdXQnLCAnbW91c2VvdmVyJywgJ21vdXNldXAnXTtcclxuICAgICAgICBpZiAoc3VwcG9ydGVkRXZlbnRzLmluZGV4T2YoZXZlbnRUeXBlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fcG9seWdvbiwgZXZlbnRUeXBlLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm4oZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRUeXBlID09PSAnbW91c2Vtb3ZlJykge1xyXG4gICAgICAgICAgICBsZXQgaGFuZGxlcklkOiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xyXG4gICAgICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9wb2x5Z29uLCAnbW91c2VvdmVyJywgZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVySWQgPSBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9tYXAsICdtb3VzZW1vdmUnLCBtID0+IGZuKG0pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX3BvbHlnb24sICdtb3VzZW91dCcsIGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJJZCkgeyBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcihoYW5kbGVySWQpOyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gaWYgKGV2ZW50VHlwZSA9PT0gJ3BhdGhjaGFuZ2VkJykge1xyXG4gICAgICAgICAgICB0aGlzLl9lZGl0aW5nQ29tcGxldGVFbWl0dGVyID0gPChldmVudDogSVBvbHlnb25FdmVudCkgPT4gdm9pZD5mbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVkIHRoZSBwb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXllcikgeyB0aGlzLl9sYXllci5yZW1vdmUodGhpcy5OYXRpdmVQcmltaXR2ZSk7IH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwLmVudGl0aWVzLnJlbW92ZSh0aGlzLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7IHRoaXMuX2xhYmVsLkRlbGV0ZSgpOyB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXApIHsgdGhpcy5fdG9vbHRpcC5EZWxldGUoKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIGRyYWdnYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBvbHlnb24gaXMgZHJhZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldERyYWdnYWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gQmluZyBwb2x5Z29ucyBhcmUgbm90IGRyYWdnYWJsZSBieSBkZWZhdWx0LlxyXG4gICAgICAgIC8vLyBTZWUgaHR0cHM6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9lbi1VUy9cclxuICAgICAgICAvLy8gICAgIDdhYWFlNzQ4LTRkNWYtNGJlNS1hN2JiLTkwNDk4ZTA4YjQxYy9ob3ctY2FuLWktbWFrZS1wb2x5Z29ucG9seWxpbmUtZHJhZ2dhYmxlLWluLWJpbmctbWFwcy04P1xyXG4gICAgICAgIC8vLyAgICAgZm9ydW09YmluZ21hcHNcclxuICAgICAgICAvLy8gZm9yIGEgcG9zc2libGUgYXBwcm9hY2ggdG8gYmUgaW1wbGVtZW50ZWQgaW4gdGhlIG1vZGVsLlxyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWdvbiBwYXRoIGNhbiBiZSBlZGl0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwYXRoIGNhbiBiZSBlZGl0ZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldEVkaXRhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0VkaXRhYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9seWdvbiBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfSBvYmplY3RzIGRlc2NyaWJpbmcgdGhlIHBvbHlnb24gcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFBhdGgoKTogQXJyYXk8SUxhdExvbmc+IHtcclxuICAgICAgICBjb25zdCBwOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4gPSB0aGlzLl9wb2x5Z29uLmdldExvY2F0aW9ucygpO1xyXG4gICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PElMYXRMb25nPiA9IG5ldyBBcnJheTxJTGF0TG9uZz4oKTtcclxuICAgICAgICBwLmZvckVhY2gobCA9PiBwYXRoLnB1c2goeyBsYXRpdHVkZTogbC5sYXRpdHVkZSwgbG9uZ2l0dWRlOiBsLmxvbmdpdHVkZSB9KSk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uIHBhdGhzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gQXJyYXkgb2YgQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfSBvYmplY3RzIGRlc2NyaWJpbmcgbXVsdGlwbGUgcG9seWdvbiBwYXRocy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFBhdGhzKCk6IEFycmF5PEFycmF5PElMYXRMb25nPj4ge1xyXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4gPSB0aGlzLl9wb2x5Z29uLmdldFJpbmdzKCk7XHJcbiAgICAgICAgY29uc3QgcGF0aHM6IEFycmF5PEFycmF5PElMYXRMb25nPj4gPSBuZXcgQXJyYXk8QXJyYXk8SUxhdExvbmc+PigpO1xyXG4gICAgICAgIHAuZm9yRWFjaCh4ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aDogQXJyYXk8SUxhdExvbmc+ID0gbmV3IEFycmF5PElMYXRMb25nPigpO1xyXG4gICAgICAgICAgICB4LmZvckVhY2goeSA9PiBwYXRoLnB1c2goeyBsYXRpdHVkZTogeS5sYXRpdHVkZSwgbG9uZ2l0dWRlOiB5LmxvbmdpdHVkZSB9KSk7XHJcbiAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5Z29uIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb24uZ2V0VmlzaWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIGRyYWdhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkcmFnZ2FibGUgLSBUcnVlIHRvIG1ha2UgdGhlIHBvbHlnb24gZHJhZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gQmluZyBwb2x5Z29ucyBhcmUgbm90IGRyYWdnYWJsZSBieSBkZWZhdWx0LlxyXG4gICAgICAgIC8vLyBTZWUgaHR0cHM6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9lbi1VUy9cclxuICAgICAgICAvLy8gICAgIDdhYWFlNzQ4LTRkNWYtNGJlNS1hN2JiLTkwNDk4ZTA4YjQxYy9ob3ctY2FuLWktbWFrZS1wb2x5Z29ucG9seWxpbmUtZHJhZ2dhYmxlLWluLWJpbmctbWFwcy04XHJcbiAgICAgICAgLy8gICAgICA/Zm9ydW09YmluZ21hcHNcclxuICAgICAgICAvLy8gZm9yIGEgcG9zc2libGUgYXBwcm9hY2ggdG8gYmUgaW1wbGVtZW50ZWQgaW4gdGhlIG1vZGVsLlxyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1RoZSBiaW5nIG1hcHMgaW1wbGVtZW50YXRpb24gY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgZHJhZ2dhYmxlIHBvbHlnb25zLicpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2V0aGVyIHRoZSBwb2x5Z29uIHBhdGggaXMgZWRpdGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVkaXRhYmxlIC0gVHJ1ZSB0byBtYWtlIHBvbHlnb24gcGF0aCBlZGl0YWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0RWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBpc0NoYW5nZWQgPSB0aGlzLl9pc0VkaXRhYmxlICE9PSBlZGl0YWJsZTtcclxuICAgICAgICB0aGlzLl9pc0VkaXRhYmxlID0gZWRpdGFibGU7XHJcbiAgICAgICAgaWYgKCFpc0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRWRpdGFibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxQYXRoID0gdGhpcy5HZXRQYXRocygpO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkdldERyYXdpbmdUb29scygpLnRoZW4odCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0LmVkaXQodGhpcy5fcG9seWdvbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5HZXREcmF3aW5nVG9vbHMoKS50aGVuKHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgdC5maW5pc2goKGVkaXRlZFBvbHlnb246IE1pY3Jvc29mdC5NYXBzLlBvbHlnb24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdGVkUG9seWdvbiAhPT0gdGhpcy5fcG9seWdvbiB8fCAhdGhpcy5fZWRpdGluZ0NvbXBsZXRlRW1pdHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhdGg6IEFycmF5PEFycmF5PElMYXRMb25nPj4gPSB0aGlzLkdldFBhdGhzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRoOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID0gdGhpcy5fb3JpZ2luYWxQYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuU2V0UGF0aHMobmV3UGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciB0aGUgbmV3IHBhdGggdG8gcGVyc2lzdCBpdCBhcHBlYXJzLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VkaXRpbmdDb21wbGV0ZUVtaXR0ZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDbGljazogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvbjogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgT3JpZ2luYWxQYXRoOiBvcmlnaW5hbFBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE5ld1BhdGg6IG5ld1BhdGhcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb2x5Z29uIG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIFRoZSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBodGUgb25lc1xyXG4gICAgICogYWxyZWFkeSBvbiB0aGUgdW5kZXJseWluZyBtb2RlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWdvbk9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWdvbk9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRPcHRpb25zKG8pO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnZpc2libGUgIT0gbnVsbCAmJiB0aGlzLl9zaG93TGFiZWwgJiYgdGhpcy5fbGFiZWwpIHsgdGhpcy5fbGFiZWwuU2V0KCdoaWRkZW4nLCAhb3B0aW9ucy52aXNpYmxlKTsgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWRpdGFibGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuU2V0RWRpdGFibGUob3B0aW9ucy5lZGl0YWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9seWdvbiBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gQW4gQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfSAob3IgYXJyYXkgb2YgYXJyYXlzKSBkZXNjcmliaW5nIHRoZSBwb2x5Z29ucyBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0UGF0aChwYXRoOiBBcnJheTxJTGF0TG9uZz4pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4gPSBuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+KCk7XHJcbiAgICAgICAgcGF0aC5mb3JFYWNoKHggPT4gcC5wdXNoKG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbih4LmxhdGl0dWRlLCB4LmxvbmdpdHVkZSkpKTtcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbFBhdGggPSBbcGF0aF07XHJcbiAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRMb2NhdGlvbnMocCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NlbnRyb2lkID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5NYW5hZ2VMYWJlbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcG9seWdvbiBwYXRoIG9yIHBhdGhzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoc1xyXG4gICAgICogQW4gQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfSAob3IgYXJyYXkgb2YgYXJyYXlzKSBkZXNjcmliaW5nIHRoZSBwb2x5Z29ucyBwYXRoKHMpLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0UGF0aHMocGF0aHM6IEFycmF5PEFycmF5PElMYXRMb25nPj4gfCBBcnJheTxJTGF0TG9uZz4pOiB2b2lkIHtcclxuICAgICAgICBpZiAocGF0aHMgPT0gbnVsbCkgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aHMpKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRSaW5ncyhuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+KCkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLkRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aHNbMF0pKSB7XHJcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvciBhcnJheXNcclxuICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PiA9IG5ldyBBcnJheTxBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4+KCk7XHJcbiAgICAgICAgICAgICg8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5wYXRocykuZm9yRWFjaChwYXRoID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IF9wOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4gPSBuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+KCk7XHJcbiAgICAgICAgICAgICAgICBwYXRoLmZvckVhY2goeCA9PiBfcC5wdXNoKG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbih4LmxhdGl0dWRlLCB4LmxvbmdpdHVkZSkpKTtcclxuICAgICAgICAgICAgICAgIHAucHVzaChfcCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFBhdGggPSA8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5wYXRocztcclxuICAgICAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRSaW5ncyhwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jZW50cm9pZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlciBpcyBhIHNpbXBsZSBhcnJheS4uLi5cclxuICAgICAgICAgICAgdGhpcy5TZXRQYXRoKDxBcnJheTxJTGF0TG9uZz4+cGF0aHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0aGUgcG9seWdvbiBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2aXNpYmxlIC0gVHJ1ZSB0byBzZXQgdGhlIHBvbHlnb24gdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRPcHRpb25zKDxNaWNyb3NvZnQuTWFwcy5JUG9seWdvbk9wdGlvbnM+eyB2aXNpYmxlOiB2aXNpYmxlIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLl9zaG93TGFiZWwgJiYgdGhpcy5fbGFiZWwpIHsgdGhpcy5fbGFiZWwuU2V0KCdoaWRkZW4nLCAhdmlzaWJsZSk7IH1cclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uZmlndXJlcyB0aGUgbGFiZWwgZm9yIHRoZSBwb2x5Z29uXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIE1hbmFnZUxhYmVsKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLkdldFBhdGggPT0gbnVsbCB8fCB0aGlzLkdldFBhdGgoKS5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dMYWJlbCAmJiB0aGlzLl90aXRsZSAhPSBudWxsICYmIHRoaXMuX3RpdGxlICE9PSAnJykge1xyXG4gICAgICAgICAgICBjb25zdCBvOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fdGl0bGUsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKHRoaXMuQ2VudHJvaWQpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChvLnBvc2l0aW9uID09IG51bGwpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9taW5ab29tICE9PSAtMSkgeyBvLm1pblpvb20gPSB0aGlzLl9taW5ab29tOyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXhab29tICE9PSAtMSkgeyBvLm1heFpvb20gPSB0aGlzLl9tYXhab29tOyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG5ldyBCaW5nTWFwTGFiZWwobyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5TZXRNYXAodGhpcy5fbWFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLlNldFZhbHVlcyhvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5TZXQoJ2hpZGRlbicsICF0aGlzLkdldFZpc2libGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLlNldE1hcChudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHRvb2x0aXAgZm9yIHRoZSBwb2x5Z29uXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIE1hbmFnZVRvb2x0aXAoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUb29sdGlwICYmIHRoaXMuX3RpdGxlICE9IG51bGwgJiYgdGhpcy5fdGl0bGUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLl90aXRsZSxcclxuICAgICAgICAgICAgICAgIGFsaWduOiAnbGVmdCcsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2ludCgwLCAyNSksXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiaXNxdWUnLFxyXG4gICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDEyLFxyXG4gICAgICAgICAgICAgICAgZm9udENvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXAgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcCA9IG5ldyBCaW5nTWFwTGFiZWwobyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldE1hcCh0aGlzLl9tYXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXRWYWx1ZXMobyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyID0gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9seWdvbiwgJ21vdXNlb3ZlcicsIChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ3Bvc2l0aW9uJywgZS5sb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIgPSBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcCwgJ21vdXNlbW92ZScsIChtOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUgJiYgbS5sb2NhdGlvbiAmJiBtLnByaW1pdGl2ZSA9PT0gdGhpcy5fcG9seWdvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBtLmxvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlT3V0TGlzdGVuZXIgPSBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2x5Z29uLCAnbW91c2VvdXQnLCAoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIodGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoIXRoaXMuX3Nob3dUb29sdGlwIHx8IHRoaXMuX3RpdGxlID09PSAnJyB8fCB0aGlzLl90aXRsZSA9PSBudWxsKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VPdXRMaXN0ZW5lcikgeyBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcih0aGlzLl9tb3VzZU91dExpc3RlbmVyKTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyKSB7IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyKTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyKSB7IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyKTsgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0TWFwKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcclxuaW1wb3J0IHsgQmluZ0NvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLWNvbnZlcnNpb25zJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi9wb2x5bGluZSc7XHJcbmltcG9ydCB7IEJpbmdNYXBMYWJlbCB9IGZyb20gJy4vYmluZy1sYWJlbCc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gZm9yIGEgcG9seWxpbmUgbW9kZWwgZm9yIEJpbmcgTWFwcyBWOC5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJpbmdQb2x5bGluZSBleHRlbmRzIFBvbHlsaW5lIGltcGxlbWVudHMgUG9seWxpbmUge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9pc0VkaXRhYmxlOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfdGl0bGU6IHN0cmluZyA9ICcnO1xyXG4gICAgcHJpdmF0ZSBfc2hvd1Rvb2x0aXA6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3Rvb2x0aXA6IEJpbmdNYXBMYWJlbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9oYXNUb29sVGlwUmVjZWl2ZXI6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3Rvb2x0aXBWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9tb3VzZU92ZXJMaXN0ZW5lcjogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcclxuICAgIHByaXZhdGUgX21vdXNlTW92ZUxpc3RlbmVyOiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xyXG4gICAgcHJpdmF0ZSBfbW91c2VPdXRMaXN0ZW5lcjogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcclxuICAgIHByaXZhdGUgX21ldGFkYXRhOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlsaW5lIG1ldGFkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE1ldGFkYXRhKCk6IE1hcDxzdHJpbmcsIGFueT4geyByZXR1cm4gdGhpcy5fbWV0YWRhdGE7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIE5hdml0dmUgUG9seWxpbmUgdW5kZXJseWluZyB0aGUgbW9kZWxcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZSB7IHJldHVybiB0aGlzLl9wb2x5bGluZTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gc2hvdyB0aGUgdG9vbHRpcFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgU2hvd1Rvb2x0aXAoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9zaG93VG9vbHRpcDsgfVxyXG4gICAgcHVibGljIHNldCBTaG93VG9vbHRpcCh2YWw6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLl9zaG93VG9vbHRpcCA9IHZhbDtcclxuICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgdGl0bGUgb2ZmIHRoZSBwb2x5bGluZVxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgVGl0bGUoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX3RpdGxlOyB9XHJcbiAgICBwdWJsaWMgc2V0IFRpdGxlKHZhbDogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fdGl0bGUgPSB2YWw7XHJcbiAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gY29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nUG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBfcG9seWxpbmUgLSBUaGUge0BsaW5rIE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lfSB1bmRlcmx5aW5nIHRoZSBtb2RlbC5cclxuICAgICAqIEBwYXJhbSBfbWFwIC0gVGhlIGNvbnRleHQgbWFwLlxyXG4gICAgICogQHBhcmFtIF9sYXllciAtIFRoZSBjb250ZXh0IGxheWVyLlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wb2x5bGluZTogTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmUsIHByb3RlY3RlZCBfbWFwOiBNaWNyb3NvZnQuTWFwcy5NYXAsIHByb3RlY3RlZCBfbGF5ZXI6IE1pY3Jvc29mdC5NYXBzLkxheWVyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBkZWxlZ2F0ZSBmb3IgYW4gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBuYW1lLlxyXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkRXZlbnRzID0gWydjbGljaycsICdkYmxjbGljaycsICdkcmFnJywgJ2RyYWdlbmQnLCAnZHJhZ3N0YXJ0JywgJ21vdXNlZG93bicsICdtb3VzZW91dCcsICdtb3VzZW92ZXInLCAnbW91c2V1cCcgXTtcclxuICAgICAgICBpZiAoc3VwcG9ydGVkRXZlbnRzLmluZGV4T2YoZXZlbnRUeXBlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fcG9seWxpbmUsIGV2ZW50VHlwZSwgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGZuKGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcclxuICAgICAgICAgICAgbGV0IGhhbmRsZXJJZDogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcclxuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fcG9seWxpbmUsICdtb3VzZW92ZXInLCBlID0+IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJJZCA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX21hcCwgJ21vdXNlbW92ZScsIG0gPT4gZm4obSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fcG9seWxpbmUsICdtb3VzZW91dCcsIGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJJZCkgeyBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcihoYW5kbGVySWQpOyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZWQgdGhlIHBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fbGF5ZXIpIHsgdGhpcy5fbGF5ZXIucmVtb3ZlKHRoaXMuTmF0aXZlUHJpbWl0dmUpOyB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcC5lbnRpdGllcy5yZW1vdmUodGhpcy5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl90b29sdGlwKSB7IHRoaXMuX3Rvb2x0aXAuRGVsZXRlKCk7IH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWxpbmUgaXMgZHJhZ2dhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcG9seWxpbmUgaXMgZHJhZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXREcmFnZ2FibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgLy8vIEJpbmcgcG9seWdvbnMgYXJlIG5vdCBkcmFnZ2FibGUgYnkgZGVmYXVsdC5cclxuICAgICAgICAvLy8gU2VlIGh0dHBzOi8vc29jaWFsLm1zZG4ubWljcm9zb2Z0LmNvbS9Gb3J1bXMvZW4tVVMvXHJcbiAgICAgICAgLy8vICAgICA3YWFhZTc0OC00ZDVmLTRiZTUtYTdiYi05MDQ5OGUwOGI0MWMvaG93LWNhbi1pLW1ha2UtcG9seWdvbnBvbHlsaW5lLWRyYWdnYWJsZS1pbi1iaW5nLW1hcHMtOFxyXG4gICAgICAgIC8vLyAgICAgP2ZvcnVtPWJpbmdtYXBzXHJcbiAgICAgICAgLy8vIGZvciBhIHBvc3NpYmxlIGFwcHJvYWNoIHRvIGJlIGltcGxlbWVudGVkIGluIHRoZSBtb2RlbC5cclxuICAgICAgICAvLy9cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIHBhdGggY2FuIGJlIGVkaXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBhdGggY2FuIGJlIGVkaXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldEVkaXRhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0VkaXRhYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9seWxpbmUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0cyBkZXNjcmliaW5nIHRoZSBwb2x5bGluZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFBhdGgoKTogQXJyYXk8SUxhdExvbmc+IHtcclxuICAgICAgICBjb25zdCBwOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4gPSB0aGlzLl9wb2x5bGluZS5nZXRMb2NhdGlvbnMoKTtcclxuICAgICAgICBjb25zdCBwYXRoOiBBcnJheTxJTGF0TG9uZz4gPSBuZXcgQXJyYXk8SUxhdExvbmc+KCk7XHJcbiAgICAgICAgcC5mb3JFYWNoKGwgPT4gcGF0aC5wdXNoKHsgbGF0aXR1ZGU6IGwubGF0aXR1ZGUsIGxvbmdpdHVkZTogbC5sb25naXR1ZGUgfSkpO1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcG9seWxpbmUgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lLmdldFZpc2libGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0aGUgcG9seWxpbmUgaXMgZHJhZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFrZSB0aGUgcG9seWxpbmUgZHJhZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgLy8vIEJpbmcgcG9seWdvbnMgYXJlIG5vdCBkcmFnZ2FibGUgYnkgZGVmYXVsdC5cclxuICAgICAgICAvLy8gU2VlIGh0dHBzOi8vc29jaWFsLm1zZG4ubWljcm9zb2Z0LmNvbS9Gb3J1bXMvZW4tVVMvXHJcbiAgICAgICAgLy8vICAgICA3YWFhZTc0OC00ZDVmLTRiZTUtYTdiYi05MDQ5OGUwOGI0MWMvaG93LWNhbi1pLW1ha2UtcG9seWdvbnBvbHlsaW5lLWRyYWdnYWJsZS1pbi1iaW5nLW1hcHMtOFxyXG4gICAgICAgIC8vLyAgICAgP2ZvcnVtPWJpbmdtYXBzXHJcbiAgICAgICAgLy8vIGZvciBhIHBvc3NpYmxlIGFwcHJvYWNoIHRvIGJlIGltcGxlbWVudGVkIGluIHRoZSBtb2RlbC5cclxuICAgICAgICAvLy9cclxuICAgICAgICB0aHJvdyhuZXcgRXJyb3IoJ1RoZSBiaW5nIG1hcHMgaW1wbGVtZW50YXRpb24gY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgZHJhZ2dhYmxlIHBvbHlsaW5lcy4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdldGhlciB0aGUgcG9seWxpbmUgcGF0aCBpcyBlZGl0YWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZWRpdGFibGUgLSBUcnVlIHRvIG1ha2UgcG9seWxpbmUgcGF0aCBlZGl0YWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldEVkaXRhYmxlKGVkaXRhYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5faXNFZGl0YWJsZSA9IGVkaXRhYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9seWxpbmUgb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElMYXRMb25nfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gVGhlIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGh0ZSBvbmVzXHJcbiAgICAgKiBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQb2x5bGluZU9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWxpbmVPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucGF0aCkge1xyXG4gICAgICAgICAgICB0aGlzLlNldFBhdGgoPEFycmF5PElMYXRMb25nPj5vcHRpb25zLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvbHlsaW5lIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlsaW5lcyBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFBhdGgocGF0aDogQXJyYXk8SUxhdExvbmc+KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+ID0gbmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPigpO1xyXG4gICAgICAgIHBhdGguZm9yRWFjaCh4ID0+IHAucHVzaChuZXcgTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24oeC5sYXRpdHVkZSwgeC5sb25naXR1ZGUpKSk7XHJcbiAgICAgICAgdGhpcy5fcG9seWxpbmUuc2V0TG9jYXRpb25zKHApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2aXNpYmxlIC0gVHJ1ZSB0byBzZXQgdGhlIHBvbHlsaW5lIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZS5zZXRPcHRpb25zKDxNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zPnsgdmlzaWJsZTogdmlzaWJsZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uZmlndXJlcyB0aGUgdG9vbHRpcCBmb3IgdGhlIHBvbHlnb25cclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgTWFuYWdlVG9vbHRpcCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fc2hvd1Rvb2x0aXAgJiYgdGhpcy5fdGl0bGUgIT0gbnVsbCAmJiB0aGlzLl90aXRsZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgY29uc3QgbzogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3RpdGxlLFxyXG4gICAgICAgICAgICAgICAgYWxpZ246ICdsZWZ0JyxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogbmV3IE1pY3Jvc29mdC5NYXBzLlBvaW50KDAsIDI1KSxcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2Jpc3F1ZScsXHJcbiAgICAgICAgICAgICAgICBoaWRkZW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgICAgICBmb250Q29sb3I6ICcjMDAwMDAwJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwID0gbmV3IEJpbmdNYXBMYWJlbChvKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0TWFwKHRoaXMuX21hcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldFZhbHVlcyhvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VPdmVyTGlzdGVuZXIgPSBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9seWxpbmUsICdtb3VzZW92ZXInLCAoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ3Bvc2l0aW9uJywgZS5sb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90b29sdGlwVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lciA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLCAnbW91c2Vtb3ZlJywgKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwVmlzaWJsZSAmJiBlLmxvY2F0aW9uICYmIGUucHJpbWl0aXZlID09PSB0aGlzLl9wb2x5bGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBlLmxvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlT3V0TGlzdGVuZXIgPSBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lLCAnbW91c2VvdXQnLCAoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCghdGhpcy5fc2hvd1Rvb2x0aXAgfHwgdGhpcy5fdGl0bGUgPT09ICcnIHx8IHRoaXMuX3RpdGxlID09IG51bGwpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU91dExpc3RlbmVyKSB7IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKHRoaXMuX21vdXNlT3V0TGlzdGVuZXIpIDsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyKSB7IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyKTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyKSB7IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyKTsgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0TWFwKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSU1hcEV2ZW50TG9va3VwIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFwLWV2ZW50LWxvb2t1cCc7XHJcblxyXG4vKipcclxuICogVGhpcyBjb250c3RhbnQgdHJhbnNsYXRlcyB0aGUgYWJzdHJhY3QgbWFwIGV2ZW50cyBpbnRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgYmluZyBtYXBcclxuICogZXF1aXZhbGVudHMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQmluZ01hcEV2ZW50c0xvb2t1cDogSU1hcEV2ZW50TG9va3VwID0ge1xyXG4gICAgY2xpY2sgOiAgICAgICAgICAgICAnY2xpY2snLFxyXG4gICAgZGJsY2xpY2sgOiAgICAgICAgICAnZGJsY2xpY2snLFxyXG4gICAgcmlnaHRjbGljayA6ICAgICAgICAncmlnaHRjbGljaycsXHJcbiAgICByZXNpemUgOiAgICAgICAgICAgICdyZXNpemUnLFxyXG4gICAgYm91bmRzY2hhbmdlZCA6ICAgICAndmlld2NoYW5nZWVuZCcsXHJcbiAgICBjZW50ZXJjaGFuZ2VkIDogICAgICd2aWV3Y2hhbmdlZW5kJyxcclxuICAgIHpvb21jaGFuZ2VkIDogICAgICAgJ3ZpZXdjaGFuZ2VlbmQnLFxyXG4gICAgbW91c2VvdmVyOiAgICAgICAgICAnbW91c2VvdmVyJyxcclxuICAgIG1vdXNlb3V0IDogICAgICAgICAgJ21vdXNlb3V0JyxcclxuICAgIG1vdXNlbW92ZSA6ICAgICAgICAgJ21vdXNlbW92ZScsXHJcbiAgICBpbmZvd2luZG93Y2xvc2U6ICAgICdpbmZvYm94Q2hhbmdlZCdcclxufTtcclxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgQmluZ0NvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLWNvbnZlcnNpb25zJztcclxuaW1wb3J0IHsgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uL2NhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgTWFwTGFiZWwgfSBmcm9tICcuLi9tYXAtbGFiZWwnO1xyXG5pbXBvcnQgeyBCaW5nTWFwTGFiZWwgfSBmcm9tICcuL2JpbmctbGFiZWwnO1xyXG5pbXBvcnQgeyBFeHRlbmRlciB9IGZyb20gJy4uL2V4dGVuZGVyJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRpbmcgYSBjYW52YXMgb3ZlcmxheSB0byBiZSBwbGFjZWQgb24gdGhlIG1hcCBmb3IgQmluZyBNYXBzLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmluZ0NhbnZhc092ZXJsYXkgZXh0ZW5kcyBDYW52YXNPdmVybGF5IHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBmaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfdmlld0NoYW5nZUV2ZW50OiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xyXG4gICAgcHJpdmF0ZSBfdmlld0NoYW5nZUVuZEV2ZW50OiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xyXG4gICAgcHJpdmF0ZSBfbWFwUmVzaXplRXZlbnQ6IE1pY3Jvc29mdC5NYXBzLklIYW5kbGVySWQ7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQmluZ0NhbnZhc092ZXJsYXkgY2xhc3MuXHJcbiAgICAgKiBAcGFyYW0gZHJhd0NhbGxiYWNrIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlYWR5IHRvIGJlXHJcbiAgICAgKiByZW5kZXJlZCBmb3IgdGhlIGN1cnJlbnQgbWFwIHZpZXcuXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NhbnZhc092ZXJsYXlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZCkge1xyXG4gICAgICAgIHN1cGVyKGRyYXdDYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBjbGljayBsb2NhdGlvblxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuIEV4cGVjdGVkIHRvIGltcGxlbWVudCB7QGxpbmsgTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzfS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElMYXRMb25nfSBjb250YWluaW5nIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIGNsaWNrZWQgbWFya2VyLlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDYW52YXNPdmVybGF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRDb29yZGluYXRlc0Zyb21DbGljayhlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgcmV0dXJuIHsgbGF0aXR1ZGU6IGUubG9jYXRpb24ubGF0aXR1ZGUsIGxvbmdpdHVkZTogZS5sb2NhdGlvbi5sb25naXR1ZGUgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1hcCBhc3NvY2l0ZWQgd2l0aCB0aGUgbGFiZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRNYXAoKTogTWljcm9zb2Z0Lk1hcHMuTWFwIHtcclxuICAgICAgICByZXR1cm4gKDxhbnk+dGhpcykuZ2V0TWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTWFwTGFiZWwgaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50IHBsYXRmb3JtIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSB0b29sdGlwLlxyXG4gICAgICogVGhpcyBtZXRob2Qgb25seSBnZW5lcmF0ZXMgdGhlIG1hcCBsYWJlbC4gQ29udGVudCBhbmQgcGxhY2VtZW50IGlzIHRoZSByZXNwb25zaWJpbGl0eVxyXG4gICAgICogb2YgdGhlIGNhbGxlci4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHJldHVybnMgbnVsbCB1bnRpbCBPbkxvYWQgaGFzIGJlZW4gY2FsbGVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVGhlIGxhYmVsIHRvIGJlIHVzZWQgZm9yIHRoZSB0b29sdGlwLlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRUb29sVGlwT3ZlcmxheSgpOiBNYXBMYWJlbCB7XHJcbiAgICAgICAgY29uc3QgbzogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHtcclxuICAgICAgICAgICAgYWxpZ246ICdsZWZ0JyxcclxuICAgICAgICAgICAgb2Zmc2V0OiBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9pbnQoMCwgMjUpLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiaXNxdWUnLFxyXG4gICAgICAgICAgICBoaWRkZW46IHRydWUsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcclxuICAgICAgICAgICAgZm9udENvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgbGFiZWw6IE1hcExhYmVsID0gbmV3IEJpbmdNYXBMYWJlbChvKTtcclxuICAgICAgICBsYWJlbC5TZXRNYXAodGhpcy5HZXRNYXAoKSk7XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FudmFzT3ZlcmxheSBsb2FkZWQsIGF0dGFjaCBtYXAgZXZlbnRzIGZvciB1cGRhdGluZyBjYW52YXMuXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2FudmFzT3ZlcmxheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgT25Mb2FkKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwID0gKDxhbnk+dGhpcykuZ2V0TWFwKCk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBtYXAgdmlldyBpbmZvcm1hdGlvbi5cclxuICAgICAgICB0aGlzLl96b29tU3RhcnQgPSBtYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIHRoaXMuX2NlbnRlclN0YXJ0ID0gPElMYXRMb25nPm1hcC5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICAgICAgLy8gUmVkcmF3IHRoZSBjYW52YXMuXHJcbiAgICAgICAgdGhpcy5SZWRyYXcodHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIFdoZW4gdGhlIG1hcCBtb3ZlcywgbW92ZSB0aGUgY2FudmFzIGFjY29yZGluZ2x5LlxyXG4gICAgICAgIHRoaXMuX3ZpZXdDaGFuZ2VFdmVudCA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKG1hcCwgJ3ZpZXdjaGFuZ2UnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWFwLmdldE1hcFR5cGVJZCgpID09PSBNaWNyb3NvZnQuTWFwcy5NYXBUeXBlSWQuc3RyZWV0c2lkZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc2hvdyB0aGUgY2FudmFzIGlmIHRoZSBtYXAgaXMgaW4gU3RyZWV0c2lkZSBtb2RlLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZS1kcmF3aW5nIHRoZSBjYW52YXMgYXMgaXQgbW92ZXMgd291bGQgYmUgdG9vIHNsb3cuIEluc3RlYWQsIHNjYWxlIGFuZCB0cmFuc2xhdGUgY2FudmFzIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB6b29tQ3VycmVudDogbnVtYmVyID0gbWFwLmdldFpvb20oKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlckN1cnJlbnQ6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uID0gbWFwLmdldENlbnRlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBtYXAgc2NhbGUgYmFzZWQgb24gem9vbSBsZXZlbCBkaWZmZXJlbmNlLlxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGU6IG51bWJlciA9IE1hdGgucG93KDIsIHpvb21DdXJyZW50IC0gdGhpcy5fem9vbVN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNjYWxlZCBkaW1lbnNpb25zIG9mIHRoZSBjYW52YXMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdXaWR0aDogbnVtYmVyID0gbWFwLmdldFdpZHRoKCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodDogbnVtYmVyID0gbWFwLmdldEhlaWdodCgpICogc2NhbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG9mZnNldCBvZiBjYW52YXMgYmFzZWQgb24gem9vbSBhbmQgY2VudGVyIG9mZnNldHMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbFBvaW50czogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUG9pbnQ+ID0gPEFycmF5PE1pY3Jvc29mdC5NYXBzLlBvaW50Pj5tYXAudHJ5TG9jYXRpb25Ub1BpeGVsKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKHRoaXMuX2NlbnRlclN0YXJ0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyQ3VycmVudFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIE1pY3Jvc29mdC5NYXBzLlBpeGVsUmVmZXJlbmNlLmNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyT2Zmc2V0WDogbnVtYmVyID0gcGl4ZWxQb2ludHNbMV0ueCAtIHBpeGVsUG9pbnRzWzBdLng7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJPZmZzZXRZOiBudW1iZXIgPSBwaXhlbFBvaW50c1sxXS55IC0gcGl4ZWxQb2ludHNbMF0ueTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHg6IG51bWJlciA9ICgtKG5ld1dpZHRoIC0gbWFwLmdldFdpZHRoKCkpIC8gMikgLSBjZW50ZXJPZmZzZXRYO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeTogbnVtYmVyID0gKC0obmV3SGVpZ2h0IC0gbWFwLmdldEhlaWdodCgpKSAvIDIpIC0gY2VudGVyT2Zmc2V0WTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNhbnZhcyBDU1MgcG9zaXRpb24gYW5kIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgICAgICAgICB0aGlzLlVwZGF0ZVBvc2l0aW9uKHgsIHksIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFdoZW4gdGhlIG1hcCBzdG9wcyBtb3ZpbmcsIHJlbmRlciBuZXcgZGF0YSBvbiB0aGUgY2FudmFzLlxyXG4gICAgICAgIHRoaXMuX3ZpZXdDaGFuZ2VFbmRFdmVudCA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKG1hcCwgJ3ZpZXdjaGFuZ2VlbmQnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLlVwZGF0ZUNhbnZhcygpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxyXG4gICAgICAgIHRoaXMuX21hcFJlc2l6ZUV2ZW50ID0gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIobWFwLCAnbWFwcmVzaXplJywgKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5VcGRhdGVDYW52YXMoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHRoZSBvdmVybGF5IHRvIHJlYWR5IHN0YXRlXHJcbiAgICAgICAgdGhpcy5fcmVhZHlSZXNvbHZlcih0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1hcCBmb3IgdGhlIGxhYmVsLiBTZXR0aW5ncyB0aGlzIHRvIG51bGwgcmVtb3ZlIHRoZSBsYWJlbCBmcm9tIGh0ZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAtIE1hcCB0byBhc3NvY2lhdGVkIHdpdGggdGhlIGxhYmVsLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE1hcChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG06IE1pY3Jvc29mdC5NYXBzLk1hcCA9IHRoaXMuR2V0TWFwKCk7XHJcbiAgICAgICAgaWYgKG1hcCA9PT0gbSkgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICBtLmxheWVycy5yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXAgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtYXAubGF5ZXJzLmluc2VydCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvdGVjdGVkIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoZXMgdGhlIGNhbnZhcyB0byB0aGUgbWFwLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIFNldENhbnZhc0VsZW1lbnQoZWw6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCB7XHJcbiAgICAgICAgKDxhbnk+dGhpcykuc2V0SHRtbEVsZW1lbnQoZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHRoZSBtYXAgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgUmVtb3ZlRXZlbnRIYW5kbGVycygpOiB2b2lkIHtcclxuICAgICAgICAvLyBSZW1vdmUgYWxsIGV2ZW50IGhhbmRsZXJzIGZyb20gdGhlIG1hcC5cclxuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcih0aGlzLl92aWV3Q2hhbmdlRXZlbnQpO1xyXG4gICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKHRoaXMuX3ZpZXdDaGFuZ2VFbmRFdmVudCk7XHJcbiAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIodGhpcy5fbWFwUmVzaXplRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgQ2FudmFzIHNpemUgYmFzZWQgb24gdGhlIG1hcCBzaXplLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIFJlc2l6ZSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCA9ICg8YW55PnRoaXMpLmdldE1hcCgpO1xyXG5cclxuICAgICAgICAvLyBDbGVhciBjYW52YXMgYnkgdXBkYXRpbmcgZGltZW5zaW9ucy4gVGhpcyBhbHNvIGVuc3VyZXMgY2FudmFzIHN0YXlzIHRoZSBzYW1lIHNpemUgYXMgdGhlIG1hcC5cclxuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBtYXAuZ2V0V2lkdGgoKTtcclxuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gbWFwLmdldEhlaWdodCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgQ2FudmFzLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIFVwZGF0ZUNhbnZhcygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCA9ICg8YW55PnRoaXMpLmdldE1hcCgpO1xyXG5cclxuICAgICAgICAvLyBPbmx5IHJlbmRlciB0aGUgY2FudmFzIGlmIGl0IGlzbid0IGluIHN0cmVldHNpZGUgbW9kZS5cclxuICAgICAgICBpZiAobWFwLmdldE1hcFR5cGVJZCgpICE9PSBNaWNyb3NvZnQuTWFwcy5NYXBUeXBlSWQuc3RyZWV0c2lkZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzZXQgQ1NTIHBvc2l0aW9uIGFuZCBkaW1lbnNpb25zIG9mIGNhbnZhcy5cclxuICAgICAgICAgICAgdGhpcy5VcGRhdGVQb3NpdGlvbigwLCAwLCBtYXAuZ2V0V2lkdGgoKSwgbWFwLmdldEhlaWdodCgpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlZHJhdyB0aGUgY2FudmFzLlxyXG4gICAgICAgICAgICB0aGlzLlJlZHJhdyh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBtYXAgdmlldyBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgdGhpcy5fem9vbVN0YXJ0ID0gbWFwLmdldFpvb20oKTtcclxuICAgICAgICAgICAgdGhpcy5fY2VudGVyU3RhcnQgPSA8SUxhdExvbmc+bWFwLmdldENlbnRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBleHRlbmQgdGhlIE92ZXJsYXlWaWV3IGludG8gdGhlIENhbnZhc092ZXJsYXlcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAbWV0aG9kXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTWl4aW5DYW52YXNPdmVybGF5KCkge1xyXG5cclxuICAgIG5ldyBFeHRlbmRlcihCaW5nQ2FudmFzT3ZlcmxheSlcclxuICAgIC5FeHRlbmQobmV3IE1pY3Jvc29mdC5NYXBzLkN1c3RvbU92ZXJsYXkoKSlcclxuICAgIC5NYXAoJ29uQWRkJywgJ09uQWRkJylcclxuICAgIC5NYXAoJ29uTG9hZCcsICdPbkxvYWQnKVxyXG4gICAgLk1hcCgnb25SZW1vdmUnLCAnT25SZW1vdmUnKTtcclxufVxyXG4iLCJleHBvcnQgbGV0IGdvb2dsZTogYW55O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHb29nbGVNYXAgZXh0ZW5kcyBNVkNPYmplY3Qge1xyXG4gIGRhdGE/OiBEYXRhO1xyXG4gIGNvbnN0cnVjdG9yKGVsOiBIVE1MRWxlbWVudCwgb3B0cz86IE1hcE9wdGlvbnMpOiB2b2lkO1xyXG4gIHBhblRvKGxhdExuZzogTGF0TG5nfExhdExuZ0xpdGVyYWwpOiB2b2lkO1xyXG4gIHNldFpvb20oem9vbTogbnVtYmVyKTogdm9pZDtcclxuICBnZXRDZW50ZXIoKTogTGF0TG5nO1xyXG4gIHNldENlbnRlcihsYXRMbmc6IExhdExuZ3xMYXRMbmdMaXRlcmFsKTogdm9pZDtcclxuICBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzO1xyXG4gIGdldFpvb20oKTogbnVtYmVyO1xyXG4gIGdldERpdigpOiBIVE1MRGl2RWxlbWVudDtcclxuICBnZXRQcm9qZWN0aW9uKCk6IGFueTtcclxuICBzZXRPcHRpb25zKG9wdGlvbnM6IE1hcE9wdGlvbnMpOiB2b2lkO1xyXG4gIHBhblRvQm91bmRzKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzfExhdExuZ0JvdW5kc0xpdGVyYWwpOiB2b2lkO1xyXG4gIGZpdEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kc3xMYXRMbmdCb3VuZHNMaXRlcmFsKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMYXRMbmcge1xyXG4gIGNvbnN0cnVjdG9yKGxhdDogbnVtYmVyLCBsbmc6IG51bWJlcik6IHZvaWQ7XHJcbiAgbGF0KCk6IG51bWJlcjtcclxuICBsbmcoKTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1hcmtlciBleHRlbmRzIE1WQ09iamVjdCB7XHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IE1hcmtlck9wdGlvbnMpOiB2b2lkO1xyXG4gIHNldE1hcChtYXA6IEdvb2dsZU1hcCk6IHZvaWQ7XHJcbiAgc2V0UG9zaXRpb24obGF0TG5nOiBMYXRMbmd8TGF0TG5nTGl0ZXJhbCk6IHZvaWQ7XHJcbiAgc2V0VGl0bGUodGl0bGU6IHN0cmluZyk6IHZvaWQ7XHJcbiAgc2V0TGFiZWwobGFiZWw6IHN0cmluZ3xNYXJrZXJMYWJlbCk6IHZvaWQ7XHJcbiAgc2V0UG9zaXRpb24obGF0bG5nOiBMYXRMbmd8TGF0TG5nTGl0ZXJhbCk6IHZvaWQ7XHJcbiAgc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcbiAgc2V0SWNvbihpY29uOiBzdHJpbmcpOiB2b2lkO1xyXG4gIHNldE9wYWNpdHkob3BhY2l0eTogbnVtYmVyKTogdm9pZDtcclxuICBzZXRPcHRpb25zKG9wdGlvbnM6IE1hcmtlck9wdGlvbnMpOiB2b2lkO1xyXG4gIHNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcbiAgc2V0WkluZGV4KHpJbmRleDogbnVtYmVyKTogdm9pZDtcclxuICBnZXRMYWJlbCgpOiBNYXJrZXJMYWJlbDtcclxuICBnZXRQb3NpdGlvbigpOiBMYXRMbmc7XHJcbiAgZ2V0VmlzaWJsZSgpOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1hcmtlck9wdGlvbnMge1xyXG4gIHBvc2l0aW9uOiBMYXRMbmd8TGF0TG5nTGl0ZXJhbDtcclxuICB0aXRsZT86IHN0cmluZztcclxuICBtYXA/OiBHb29nbGVNYXA7XHJcbiAgbGFiZWw/OiBzdHJpbmd8TWFya2VyTGFiZWw7XHJcbiAgZHJhZ2dhYmxlPzogYm9vbGVhbjtcclxuICBjbGlja2FibGU/OiBib29sZWFuO1xyXG4gIGljb24/OiBzdHJpbmc7XHJcbiAgb3BhY2l0eT86IG51bWJlcjtcclxuICB2aXNpYmxlPzogYm9vbGVhbjtcclxuICB6SW5kZXg/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFya2VyTGFiZWwge1xyXG4gIGNvbG9yOiBzdHJpbmc7XHJcbiAgZm9udEZhbWlseTogc3RyaW5nO1xyXG4gIGZvbnRTaXplOiBzdHJpbmc7XHJcbiAgZm9udFdlaWdodDogc3RyaW5nO1xyXG4gIHRleHQ6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDbHVzdGVyU3R5bGUge1xyXG4gIHVybD86IHN0cmluZztcclxuICBoZWlnaHQ/OiBudW1iZXI7XHJcbiAgd2lkdGg/OiBudW1iZXI7XHJcbiAgYW5jaG9yPzogQXJyYXk8bnVtYmVyPjtcclxuICB0ZXh0Q29sb3I/OiBzdHJpbmc7XHJcbiAgdGV4dFNpemU/OiBudW1iZXI7XHJcbiAgYmFja2dyb3VuZFBvc2l0aW9uPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1hcmtlckNsdXN0ZXJlciB7XHJcbiAgaXNab29tT25DbGljaygpOiBib29sZWFuO1xyXG4gIGlzQXZlcmFnZUNlbnRlcigpOiBib29sZWFuO1xyXG4gIGdldE1hcmtlcnMoKTogQXJyYXk8TWFya2VyPjtcclxuICBnZXRUb3RhbE1hcmtlcnMoKTogbnVtYmVyO1xyXG4gIHNldE1heFpvb20obWF4Wm9vbTogbnVtYmVyKTogdm9pZDtcclxuICBnZXRNYXhab29tKCk6IG51bWJlcjtcclxuICBhZGRNYXJrZXJzKG1hcmtlcnM6IEFycmF5PE1hcmtlcj4sIG9wdF9ub2RyYXc/OiBib29sZWFuKTogdm9pZDtcclxuICBhZGRNYXJrZXIobWFya2VyOiBNYXJrZXIsIG9wdF9ub2RyYXc/OiBib29sZWFuKTogdm9pZDtcclxuICByZW1vdmVNYXJrZXJzKG1hcmtlcnM6IEFycmF5PE1hcmtlcj4sIG9wdF9ub2RyYXc/OiBib29sZWFuKTogdm9pZDtcclxuICByZW1vdmVNYXJrZXIobWFya2VyOiBNYXJrZXIsIG9wdF9ub2RyYXc/OiBib29sZWFuKTogdm9pZDtcclxuICBnZXRUb3RhbENsdXN0ZXJzKCk6IG51bWJlcjtcclxuICBnZXRNYXAoKTogR29vZ2xlTWFwO1xyXG4gIHNldE1hcChtYXA6IEdvb2dsZU1hcCk6IHZvaWQ7XHJcbiAgZ2V0R3JpZFNpemUoKTogbnVtYmVyO1xyXG4gIHNldEdyaWRTaXplKGdyaWRTaXplOiBudW1iZXIpOiB2b2lkO1xyXG4gIGdldE1pbkNsdXN0ZXJTaXplKCk6IG51bWJlcjtcclxuICBzZXRNaW5DbHVzdGVyU2l6ZShtaW5DbHVzdGVyU2l6ZTogbnVtYmVyKTogdm9pZDtcclxuICBjbGVhck1hcmtlcnMoKTogdm9pZDtcclxuICBzZXRTdHlsZXMoc3R5bGVzOiBBcnJheTxDbHVzdGVyU3R5bGU+KTogdm9pZDtcclxuICBnZXRTdHlsZXMoKTogQXJyYXk8Q2x1c3RlclN0eWxlPjtcclxuICBzZXRDYWxjdWxhdG9yKGNhbGxiYWNrOiAobWFya2VyczogQXJyYXk8TWFya2VyPiwgbnVtU3R5bGVzOiBudW1iZXIpID0+IHsgdGV4dDogc3RyaW5nLCBpbmRleDogbnVtYmVyfSk6IHZvaWQ7XHJcbiAgZ2V0Q2FsY3VsYXRvcigpOiAobWFya2VyczogQXJyYXk8TWFya2VyPiwgbnVtU3R5bGVzOiBudW1iZXIpID0+IHsgdGV4dDogc3RyaW5nLCBpbmRleDogbnVtYmVyfTtcclxuICByZXNldFZpZXdwb3J0KGhpZGU/OiBib29sZWFuKTogdm9pZDtcclxuICByZWRyYXcoKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDaXJjbGUgZXh0ZW5kcyBNVkNPYmplY3Qge1xyXG4gIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHM7XHJcbiAgZ2V0Q2VudGVyKCk6IExhdExuZztcclxuICBnZXREcmFnZ2FibGUoKTogYm9vbGVhbjtcclxuICBnZXRFZGl0YWJsZSgpOiBib29sZWFuO1xyXG4gIGdldE1hcCgpOiBHb29nbGVNYXA7XHJcbiAgZ2V0UmFkaXVzKCk6IG51bWJlcjtcclxuICBnZXRWaXNpYmxlKCk6IGJvb2xlYW47XHJcbiAgc2V0Q2VudGVyKGNlbnRlcjogTGF0TG5nfExhdExuZ0xpdGVyYWwpOiB2b2lkO1xyXG4gIHNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkO1xyXG4gIHNldEVkaXRhYmxlKGVkaXRhYmxlOiBib29sZWFuKTogdm9pZDtcclxuICBzZXRNYXAobWFwOiBHb29nbGVNYXApOiB2b2lkO1xyXG4gIHNldE9wdGlvbnMob3B0aW9uczogQ2lyY2xlT3B0aW9ucyk6IHZvaWQ7XHJcbiAgc2V0UmFkaXVzKHJhZGl1czogbnVtYmVyKTogdm9pZDtcclxuICBzZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENpcmNsZU9wdGlvbnMge1xyXG4gIGNlbnRlcj86IExhdExuZ3xMYXRMbmdMaXRlcmFsO1xyXG4gIGNsaWNrYWJsZT86IGJvb2xlYW47XHJcbiAgZHJhZ2dhYmxlPzogYm9vbGVhbjtcclxuICBlZGl0YWJsZT86IGJvb2xlYW47XHJcbiAgZmlsbENvbG9yPzogc3RyaW5nO1xyXG4gIGZpbGxPcGFjaXR5PzogbnVtYmVyO1xyXG4gIG1hcD86IEdvb2dsZU1hcDtcclxuICByYWRpdXM/OiBudW1iZXI7XHJcbiAgc3Ryb2tlQ29sb3I/OiBzdHJpbmc7XHJcbiAgc3Ryb2tlT3BhY2l0eT86IG51bWJlcjtcclxuICBzdHJva2VQb3NpdGlvbj86ICdDRU5URVInfCdJTlNJREUnfCdPVVRTSURFJztcclxuICBzdHJva2VXZWlnaHQ/OiBudW1iZXI7XHJcbiAgdmlzaWJsZT86IGJvb2xlYW47XHJcbiAgekluZGV4PzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIExhdExuZ0JvdW5kcyB7XHJcbiAgY29udGFpbnMobGF0TG5nOiBMYXRMbmcpOiBib29sZWFuO1xyXG4gIGVxdWFscyhvdGhlcjogTGF0TG5nQm91bmRzfExhdExuZ0JvdW5kc0xpdGVyYWwpOiBib29sZWFuO1xyXG4gIGV4dGVuZChwb2ludDogTGF0TG5nKTogdm9pZDtcclxuICBnZXRDZW50ZXIoKTogTGF0TG5nO1xyXG4gIGdldE5vcnRoRWFzdCgpOiBMYXRMbmc7XHJcbiAgZ2V0U291dGhXZXN0KCk6IExhdExuZztcclxuICBpbnRlcnNlY3RzKG90aGVyOiBMYXRMbmdCb3VuZHN8TGF0TG5nQm91bmRzTGl0ZXJhbCk6IGJvb2xlYW47XHJcbiAgaXNFbXB0eSgpOiBib29sZWFuO1xyXG4gIHRvSlNPTigpOiBMYXRMbmdCb3VuZHNMaXRlcmFsO1xyXG4gIHRvU3BhbigpOiBMYXRMbmc7XHJcbiAgdG9TdHJpbmcoKTogc3RyaW5nO1xyXG4gIHRvVXJsVmFsdWUocHJlY2lzaW9uPzogbnVtYmVyKTogc3RyaW5nO1xyXG4gIHVuaW9uKG90aGVyOiBMYXRMbmdCb3VuZHN8TGF0TG5nQm91bmRzTGl0ZXJhbCk6IExhdExuZ0JvdW5kcztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMYXRMbmdCb3VuZHNMaXRlcmFsIHtcclxuICBlYXN0OiBudW1iZXI7XHJcbiAgbm9ydGg6IG51bWJlcjtcclxuICBzb3V0aDogbnVtYmVyO1xyXG4gIHdlc3Q6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMYXRMbmdMaXRlcmFsIHtcclxuICBsYXQ6IG51bWJlcjtcclxuICBsbmc6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNb3VzZUV2ZW50IHsgbGF0TG5nOiBMYXRMbmc7IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFwT3B0aW9ucyB7XHJcbiAgY2VudGVyPzogTGF0TG5nfExhdExuZ0xpdGVyYWw7XHJcbiAgem9vbT86IG51bWJlcjtcclxuICBtaW5ab29tPzogbnVtYmVyO1xyXG4gIG1heFpvb20/OiBudW1iZXI7XHJcbiAgZGlzYWJsZURvdWJsZUNsaWNrWm9vbT86IGJvb2xlYW47XHJcbiAgZGlzYWJsZURlZmF1bHRVST86IGJvb2xlYW47XHJcbiAgc2Nyb2xsd2hlZWw/OiBib29sZWFuO1xyXG4gIGJhY2tncm91bmRDb2xvcj86IHN0cmluZztcclxuICBkcmFnZ2FibGU/OiBib29sZWFuO1xyXG4gIGRyYWdnYWJsZUN1cnNvcj86IHN0cmluZztcclxuICBkcmFnZ2luZ0N1cnNvcj86IHN0cmluZztcclxuICBrZXlib2FyZFNob3J0Y3V0cz86IGJvb2xlYW47XHJcbiAgc3R5bGVzPzogTWFwVHlwZVN0eWxlW107XHJcbiAgem9vbUNvbnRyb2w/OiBib29sZWFuO1xyXG4gIHpvb21Db250cm9sT3B0aW9ucz86IFpvb21Db250cm9sT3B0aW9ucztcclxuICBzdHJlZXRWaWV3Q29udHJvbD86IGJvb2xlYW47XHJcbiAgc3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zPzogU3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zO1xyXG4gIHNjYWxlQ29udHJvbD86IGJvb2xlYW47XHJcbiAgc2NhbGVDb250cm9sT3B0aW9ucz86IFNjYWxlQ29udHJvbE9wdGlvbnM7XHJcbiAgbWFwVHlwZUNvbnRyb2w/OiBib29sZWFuO1xyXG4gIG1hcFR5cGVDb250cm9sT3B0aW9ucz86IE1hcFR5cGVDb250cm9sT3B0aW9ucztcclxuICBwYW5Db250cm9sPzogYm9vbGVhbjtcclxuICBwYW5Db250cm9sT3B0aW9ucz86IFBhbkNvbnRyb2xPcHRpb25zO1xyXG4gIHJvdGF0ZUNvbnRyb2w/OiBib29sZWFuO1xyXG4gIHJvdGF0ZUNvbnRyb2xPcHRpb25zPzogUm90YXRlQ29udHJvbE9wdGlvbnM7XHJcbiAgZnVsbHNjcmVlbkNvbnRyb2w/OiBib29sZWFuO1xyXG4gIGZ1bGxzY3JlZW5Db250cm9sT3B0aW9ucz86IEZ1bGxzY3JlZW5Db250cm9sT3B0aW9ucztcclxuICBtYXBUeXBlSWQ/OiBzdHJpbmd8TWFwVHlwZUlkO1xyXG4gIGNsaWNrYWJsZUljb25zPzogYm9vbGVhbjtcclxuICBnZXN0dXJlSGFuZGxpbmc/OiAnY29vcGVyYXRpdmUnfCdncmVlZHknfCdub25lJ3wnYXV0byc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFwVHlwZVN0eWxlIHtcclxuICBlbGVtZW50VHlwZT86ICdhbGwnfCdnZW9tZXRyeSd8J2dlb21ldHJ5LmZpbGwnfCdnZW9tZXRyeS5zdHJva2UnfCdsYWJlbHMnfCdsYWJlbHMuaWNvbid8XHJcbiAgICAgICdsYWJlbHMudGV4dCd8J2xhYmVscy50ZXh0LmZpbGwnfCdsYWJlbHMudGV4dC5zdHJva2UnO1xyXG4gIGZlYXR1cmVUeXBlPzogJ2FkbWluaXN0cmF0aXZlJ3wnYWRtaW5pc3RyYXRpdmUuY291bnRyeSd8J2FkbWluaXN0cmF0aXZlLmxhbmRfcGFyY2VsJ3xcclxuICAgICAgJ2FkbWluaXN0cmF0aXZlLmxvY2FsaXR5J3wnYWRtaW5pc3RyYXRpdmUubmVpZ2hib3Job29kJ3wnYWRtaW5pc3RyYXRpdmUucHJvdmluY2UnfCdhbGwnfFxyXG4gICAgICAnbGFuZHNjYXBlJ3wnbGFuZHNjYXBlLm1hbl9tYWRlJ3wnbGFuZHNjYXBlLm5hdHVyYWwnfCdsYW5kc2NhcGUubmF0dXJhbC5sYW5kY292ZXInfFxyXG4gICAgICAnbGFuZHNjYXBlLm5hdHVyYWwudGVycmFpbid8J3BvaSd8J3BvaS5hdHRyYWN0aW9uJ3wncG9pLmJ1c2luZXNzJ3wncG9pLmdvdmVybm1lbnQnfFxyXG4gICAgICAncG9pLm1lZGljYWwnfCdwb2kucGFyayd8J3BvaS5wbGFjZV9vZl93b3JzaGlwJ3wncG9pLnNjaG9vbCd8J3BvaS5zcG9ydHNfY29tcGxleCd8J3JvYWQnfFxyXG4gICAgICAncm9hZC5hcnRlcmlhbCd8J3JvYWQuaGlnaHdheSd8J3JvYWQuaGlnaHdheS5jb250cm9sbGVkX2FjY2Vzcyd8J3JvYWQubG9jYWwnfCd0cmFuc2l0J3xcclxuICAgICAgJ3RyYW5zaXQubGluZSd8J3RyYW5zaXQuc3RhdGlvbid8J3RyYW5zaXQuc3RhdGlvbi5haXJwb3J0J3wndHJhbnNpdC5zdGF0aW9uLmJ1cyd8XHJcbiAgICAgICd0cmFuc2l0LnN0YXRpb24ucmFpbCd8J3dhdGVyJztcclxuICBzdHlsZXJzOiBNYXBUeXBlU3R5bGVyW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAgSWYgbW9yZSB0aGFuIG9uZSBrZXkgaXMgc3BlY2lmaWVkIGluIGEgc2luZ2xlIE1hcFR5cGVTdHlsZXIsIGFsbCBidXQgb25lIHdpbGwgYmUgaWdub3JlZC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFwVHlwZVN0eWxlciB7XHJcbiAgY29sb3I/OiBzdHJpbmc7XHJcbiAgZ2FtbWE/OiBudW1iZXI7XHJcbiAgaHVlPzogc3RyaW5nO1xyXG4gIGludmVydF9saWdodG5lc3M/OiBib29sZWFuO1xyXG4gIGxpZ2h0bmVzcz86IG51bWJlcjtcclxuICBzYXR1cmF0aW9uPzogbnVtYmVyO1xyXG4gIHZpc2liaWxpdHk/OiBzdHJpbmc7XHJcbiAgd2VpZ2h0PzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEluZm9XaW5kb3cgZXh0ZW5kcyBNVkNPYmplY3Qge1xyXG4gIGNvbnN0cnVjdG9yKG9wdHM/OiBJbmZvV2luZG93T3B0aW9ucyk6IHZvaWQ7XHJcbiAgY2xvc2UoKTogdm9pZDtcclxuICBnZXRDb250ZW50KCk6IHN0cmluZ3xOb2RlO1xyXG4gIGdldFBvc2l0aW9uKCk6IExhdExuZztcclxuICBnZXRaSW5kZXgoKTogbnVtYmVyO1xyXG4gIG9wZW4obWFwPzogR29vZ2xlTWFwLCBhbmNob3I/OiBNVkNPYmplY3QpOiB2b2lkO1xyXG4gIHNldENvbnRlbnQoY29udGVudDogc3RyaW5nfE5vZGUpOiB2b2lkO1xyXG4gIHNldE9wdGlvbnMob3B0aW9uczogSW5mb1dpbmRvd09wdGlvbnMpOiB2b2lkO1xyXG4gIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBMYXRMbmd8TGF0TG5nTGl0ZXJhbCk6IHZvaWQ7XHJcbiAgc2V0WkluZGV4KHpJbmRleDogbnVtYmVyKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNVkNPYmplY3QgeyBhZGRMaXN0ZW5lcihldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24pOiBNYXBzRXZlbnRMaXN0ZW5lcjsgfVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXBzRXZlbnRMaXN0ZW5lciB7IHJlbW92ZSgpOiB2b2lkOyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNpemUge1xyXG4gIGhlaWdodDogbnVtYmVyO1xyXG4gIHdpZHRoOiBudW1iZXI7XHJcbiAgY29uc3RydWN0b3Iod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHdpZHRoVW5pdD86IHN0cmluZywgaGVpZ2h0VW5pdD86IHN0cmluZyk6IHZvaWQ7XHJcbiAgZXF1YWxzKG90aGVyOiBTaXplKTogYm9vbGVhbjtcclxuICB0b1N0cmluZygpOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSW5mb1dpbmRvd09wdGlvbnMge1xyXG4gIGNvbnRlbnQ/OiBzdHJpbmd8Tm9kZTtcclxuICBkaXNhYmxlQXV0b1Bhbj86IGJvb2xlYW47XHJcbiAgbWF4V2lkdGg/OiBudW1iZXI7XHJcbiAgcGl4ZWxPZmZzZXQ/OiBTaXplO1xyXG4gIHBvc2l0aW9uPzogTGF0TG5nfExhdExuZ0xpdGVyYWw7XHJcbiAgekluZGV4PzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBvaW50IHtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG4gIGVxdWFscyhvdGhlcjogUG9pbnQpOiBib29sZWFuO1xyXG4gIHRvU3RyaW5nKCk6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHb29nbGVTeW1ib2wge1xyXG4gIGFuY2hvcj86IFBvaW50O1xyXG4gIGZpbGxDb2xvcj86IHN0cmluZztcclxuICBmaWxsT3BhY2l0eT86IHN0cmluZztcclxuICBsYWJlbE9yaWdpbj86IFBvaW50O1xyXG4gIHBhdGg/OiBzdHJpbmc7XHJcbiAgcm90YXRpb24/OiBudW1iZXI7XHJcbiAgc2NhbGU/OiBudW1iZXI7XHJcbiAgc3Ryb2tlQ29sb3I/OiBzdHJpbmc7XHJcbiAgc3Ryb2tlT3BhY2l0eT86IG51bWJlcjtcclxuICBzdHJva2VXZWlnaHQ/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSWNvblNlcXVlbmNlIHtcclxuICBmaXhlZFJvdGF0aW9uPzogYm9vbGVhbjtcclxuICBpY29uPzogR29vZ2xlU3ltYm9sO1xyXG4gIG9mZnNldD86IHN0cmluZztcclxuICByZXBlYXQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUG9seWxpbmVPcHRpb25zIHtcclxuICBjbGlja2FibGU/OiBib29sZWFuO1xyXG4gIGRyYWdnYWJsZT86IGJvb2xlYW47XHJcbiAgZWRpdGFibGU/OiBib29sZWFuO1xyXG4gIGdlb2Rlc2ljPzogYm9vbGVhbjtcclxuICBpY29uPzogQXJyYXk8SWNvblNlcXVlbmNlPjtcclxuICBtYXA/OiBHb29nbGVNYXA7XHJcbiAgcGF0aD86IEFycmF5PExhdExuZz58QXJyYXk8TGF0TG5nfExhdExuZ0xpdGVyYWw+O1xyXG4gIHN0cm9rZUNvbG9yPzogc3RyaW5nO1xyXG4gIHN0cm9rZU9wYWNpdHk/OiBudW1iZXI7XHJcbiAgc3Ryb2tlV2VpZ2h0PzogbnVtYmVyO1xyXG4gIHZpc2libGU/OiBib29sZWFuO1xyXG4gIHpJbmRleD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQb2x5bGluZSBleHRlbmRzIE1WQ09iamVjdCB7XHJcbiAgZ2V0RHJhZ2dhYmxlKCk6IGJvb2xlYW47XHJcbiAgZ2V0RWRpdGFibGUoKTogYm9vbGVhbjtcclxuICBnZXRNYXAoKTogR29vZ2xlTWFwO1xyXG4gIGdldFBhdGgoKTogQXJyYXk8TGF0TG5nPjtcclxuICBnZXRWaXNpYmxlKCk6IGJvb2xlYW47XHJcbiAgc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcbiAgc2V0RWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4pOiB2b2lkO1xyXG4gIHNldE1hcChtYXA6IEdvb2dsZU1hcCk6IHZvaWQ7XHJcbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBQb2x5bGluZU9wdGlvbnMpOiB2b2lkO1xyXG4gIHNldFBhdGgocGF0aDogQXJyYXk8TGF0TG5nfExhdExuZ0xpdGVyYWw+KTogdm9pZDtcclxuICBzZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogUG9seU1vdXNlRXZlbnQgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgdHJpZ2dlcnMgbW91c2UgZXZlbnRzIG9uIGEgcG9seWxpbmUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFBvbHlNb3VzZUV2ZW50IGV4dGVuZHMgTW91c2VFdmVudCB7XHJcbiAgZWRnZTogbnVtYmVyO1xyXG4gIHBhdGg6IG51bWJlcjtcclxuICB2ZXJ0ZXg6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQb2x5Z29uT3B0aW9ucyB7XHJcbiAgY2xpY2thYmxlPzogYm9vbGVhbjtcclxuICBkcmFnZ2FibGU/OiBib29sZWFuO1xyXG4gIGVkaXRhYmxlPzogYm9vbGVhbjtcclxuICBmaWxsQ29sb3I/OiBzdHJpbmc7XHJcbiAgZmlsbE9wYWNpdHk/OiBudW1iZXI7XHJcbiAgZ2VvZGVzaWM/OiBib29sZWFuO1xyXG4gIGljb24/OiBBcnJheTxJY29uU2VxdWVuY2U+O1xyXG4gIG1hcD86IEdvb2dsZU1hcDtcclxuICBwYXRocz86IEFycmF5PExhdExuZ3xMYXRMbmdMaXRlcmFsPnxBcnJheTxBcnJheTxMYXRMbmd8TGF0TG5nTGl0ZXJhbD4+O1xyXG4gIHN0cm9rZUNvbG9yPzogc3RyaW5nO1xyXG4gIHN0cm9rZU9wYWNpdHk/OiBudW1iZXI7XHJcbiAgc3Ryb2tlV2VpZ2h0PzogbnVtYmVyO1xyXG4gIHZpc2libGU/OiBib29sZWFuO1xyXG4gIHpJbmRleD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQb2x5Z29uIGV4dGVuZHMgTVZDT2JqZWN0IHtcclxuICB6SW5kZXg6IG51bWJlcjtcclxuICBnZXREcmFnZ2FibGUoKTogYm9vbGVhbjtcclxuICBnZXRFZGl0YWJsZSgpOiBib29sZWFuO1xyXG4gIGdldE1hcCgpOiBHb29nbGVNYXA7XHJcbiAgZ2V0UGF0aCgpOiBBcnJheTxMYXRMbmc+O1xyXG4gIGdldFBhdGhzKCk6IEFycmF5PEFycmF5PExhdExuZz4+O1xyXG4gIGdldFZpc2libGUoKTogYm9vbGVhbjtcclxuICBzZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZDtcclxuICBzZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcbiAgc2V0TWFwKG1hcDogR29vZ2xlTWFwKTogdm9pZDtcclxuICBzZXRQYXRoKHBhdGg6IEFycmF5PExhdExuZz58QXJyYXk8TGF0TG5nfExhdExuZ0xpdGVyYWw+KTogdm9pZDtcclxuICBzZXRPcHRpb25zKG9wdGlvbnM6IFBvbHlnb25PcHRpb25zKTogdm9pZDtcclxuICBzZXRQYXRocyhwYXRoczogQXJyYXk8QXJyYXk8TGF0TG5nfExhdExuZ0xpdGVyYWw+PnxBcnJheTxMYXRMbmd8TGF0TG5nTGl0ZXJhbD4pOiB2b2lkO1xyXG4gIHNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgS21sTGF5ZXIgZXh0ZW5kcyBNVkNPYmplY3Qge1xyXG4gIGdldERlZmF1bHRWaWV3cG9ydCgpOiBMYXRMbmdCb3VuZHM7XHJcbiAgZ2V0TWFwKCk6IEdvb2dsZU1hcDtcclxuICBnZXRNZXRhZGF0YSgpOiBLbWxMYXllck1ldGFkYXRhO1xyXG4gIGdldFN0YXR1cygpOiBLbWxMYXllclN0YXR1cztcclxuICBnZXRVcmwoKTogc3RyaW5nO1xyXG4gIGdldFpJbmRleCgpOiBudW1iZXI7XHJcbiAgc2V0TWFwKG1hcDogR29vZ2xlTWFwKTogdm9pZDtcclxuICBzZXRPcHRpb25zKG9wdGlvbnM6IEttbExheWVyT3B0aW9ucyk6IHZvaWQ7XHJcbiAgc2V0VXJsKHVybDogc3RyaW5nKTogdm9pZDtcclxuICBzZXRaSW5kZXgoekluZGV4OiBudW1iZXIpOiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogU2VlOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2U/aGw9ZGUjS21sTGF5ZXJTdGF0dXNcclxuICovXHJcbmV4cG9ydCB0eXBlIEttbExheWVyU3RhdHVzID0gJ0RPQ1VNRU5UX05PVF9GT1VORCcgfFxyXG4gICAgJ0RPQ1VNRU5UX1RPT19MQVJHRScgfCAnRkVUQ0hfRVJST1InIHwgJ0lOVkFMSURfRE9DVU1FTlQnIHwgJ0lOVkFMSURfUkVRVUVTVCcgfFxyXG4gICAgJ0xJTUlUU19FWENFRURFRCcgfCAnT0snIHwgJ1RJTUVEX09VVCcgfCAnVU5LTk9XTic7XHJcblxyXG4vKipcclxuICogU2VlOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2U/aGw9ZGUjS21sTGF5ZXJNZXRhZGF0YVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBLbWxMYXllck1ldGFkYXRhIHtcclxuICBhdXRob3I6IEttbEF1dGhvcjtcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIGhhc1NjcmVlbk92ZXJsYXlzOiBib29sZWFuO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBzbmlwcGV0OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgS21sQXV0aG9yIHtcclxuICBlbWFpbDogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICB1cmk6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBLbWxMYXllck9wdGlvbnMge1xyXG4gIGNsaWNrYWJsZT86IGJvb2xlYW47XHJcbiAgbWFwPzogR29vZ2xlTWFwO1xyXG4gIHByZXNlcnZlVmlld3BvcnQ/OiBib29sZWFuO1xyXG4gIHNjcmVlbk92ZXJsYXlzPzogYm9vbGVhbjtcclxuICBzdXBwcmVzc0luZm9XaW5kb3dzPzogYm9vbGVhbjtcclxuICB1cmw/OiBzdHJpbmc7XHJcbiAgekluZGV4PzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEttbEZlYXR1cmVEYXRhIHtcclxuICBhdXRob3I6IEttbEF1dGhvcjtcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgaW5mb1dpbmRvd0h0bWw6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgc25pcHBldDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEttbE1vdXNlRXZlbnQgZXh0ZW5kcyBNb3VzZUV2ZW50IHtcclxuICBmZWF0dXJlRGF0YTogS21sRmVhdHVyZURhdGE7XHJcbiAgcGl4ZWxPZmZzZXQ6IFNpemU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YSBleHRlbmRzIE1WQ09iamVjdCB7XHJcbiAgZmVhdHVyZXM6IEZlYXR1cmVbXTtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzogRGF0YU9wdGlvbnMpOiB2b2lkO1xyXG4gIGFkZEdlb0pzb24oZ2VvSnNvbjogT2JqZWN0LCBvcHRpb25zPzogR2VvSnNvbk9wdGlvbnMpOiBGZWF0dXJlW107XHJcbiAgcmVtb3ZlKGZlYXR1cmU6IEZlYXR1cmUpOiB2b2lkO1xyXG4gIHNldENvbnRyb2xQb3NpdGlvbihjb250cm9sUG9zaXRpb246IENvbnRyb2xQb3NpdGlvbik6IHZvaWQ7XHJcbiAgc2V0Q29udHJvbHMoY29udHJvbHM6IHN0cmluZ1tdKTogdm9pZDtcclxuICBzZXREcmF3aW5nTW9kZShkcmF3aW5nTW9kZTogc3RyaW5nKTogdm9pZDtcclxuICBzZXRNYXAobWFwOiBHb29nbGVNYXApOiB2b2lkO1xyXG4gIC8qIHRzbGludDpkaXNhYmxlICovXHJcbiAgLypcclxuICAqIFRzbGludCBjb25maWd1cmF0aW9uIGNoZWNrLXBhcmFtZXRlcnMgd2lsbCBwcm9tcHQgZXJyb3JzIGZvciB0aGVzZSBsaW5lcyBvZiBjb2RlLlxyXG4gICogaHR0cHM6Ly9wYWxhbnRpci5naXRodWIuaW8vdHNsaW50L3J1bGVzL25vLXVudXNlZC12YXJpYWJsZS9cclxuICAqL1xyXG4gIHNldFN0eWxlKHN0eWxlOiAoKSA9PiB2b2lkKTogdm9pZDtcclxuICBmb3JFYWNoKGNhbGxiYWNrOiAoZmVhdHVyZTogRmVhdHVyZSkgPT4gdm9pZCk6IHZvaWQ7XHJcbiAgLyogdHNsaW50OmVuYWJsZSAqL1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZlYXR1cmUgZXh0ZW5kcyBNVkNPYmplY3Qge1xyXG4gIGlkPzogbnVtYmVyfHN0cmluZ3x1bmRlZmluZWQ7XHJcbiAgZ2VvbWV0cnk6IEdlb21ldHJ5O1xyXG4gIHByb3BlcnRpZXM6IGFueTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEYXRhT3B0aW9ucyB7XHJcbiAgY29udHJvbFBvc2l0aW9uPzogQ29udHJvbFBvc2l0aW9uO1xyXG4gIGNvbnRyb2xzPzogc3RyaW5nW107XHJcbiAgZHJhd2luZ01vZGU/OiBzdHJpbmc7XHJcbiAgZmVhdHVyZUZhY3Rvcnk/OiAoZ2VvbWV0cnk6IEdlb21ldHJ5KSA9PiBGZWF0dXJlO1xyXG4gIG1hcD86IEdvb2dsZU1hcDtcclxuICBzdHlsZT86ICgpID0+IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YU1vdXNlRXZlbnQgZXh0ZW5kcyBNb3VzZUV2ZW50IHtcclxuICBmZWF0dXJlOiBGZWF0dXJlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdlb0pzb25PcHRpb25zIHtcclxuICBpZFByb3BlcnR5TmFtZTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdlb21ldHJ5IHtcclxuICB0eXBlOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJZGVudGlmaWVycyB1c2VkIHRvIHNwZWNpZnkgdGhlIHBsYWNlbWVudCBvZiBjb250cm9scyBvbiB0aGUgbWFwLiBDb250cm9scyBhcmVcclxuICogcG9zaXRpb25lZCByZWxhdGl2ZSB0byBvdGhlciBjb250cm9scyBpbiB0aGUgc2FtZSBsYXlvdXQgcG9zaXRpb24uIENvbnRyb2xzIHRoYXRcclxuICogYXJlIGFkZGVkIGZpcnN0IGFyZSBwb3NpdGlvbmVkIGNsb3NlciB0byB0aGUgZWRnZSBvZiB0aGUgbWFwLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gQ29udHJvbFBvc2l0aW9uIHtcclxuICBCT1RUT01fQ0VOVEVSLFxyXG4gIEJPVFRPTV9MRUZULFxyXG4gIEJPVFRPTV9SSUdIVCxcclxuICBMRUZUX0JPVFRPTSxcclxuICBMRUZUX0NFTlRFUixcclxuICBMRUZUX1RPUCxcclxuICBSSUdIVF9CT1RUT00sXHJcbiAgUklHSFRfQ0VOVEVSLFxyXG4gIFJJR0hUX1RPUCxcclxuICBUT1BfQ0VOVEVSLFxyXG4gIFRPUF9MRUZULFxyXG4gIFRPUF9SSUdIVFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBNYXBUeXBlSWQge1xyXG4gIC8qKiBUaGlzIG1hcCB0eXBlIGRpc3BsYXlzIGEgdHJhbnNwYXJlbnQgbGF5ZXIgb2YgbWFqb3Igc3RyZWV0cyBvbiBzYXRlbGxpdGUgaW1hZ2VzLiAqL1xyXG4gIGh5YnJpZCxcclxuICAvKiogVGhpcyBtYXAgdHlwZSBkaXNwbGF5cyBhIG5vcm1hbCBzdHJlZXQgbWFwLiAqL1xyXG4gIHJvYWRtYXAsXHJcbiAgLyoqIFRoaXMgbWFwIHR5cGUgZGlzcGxheXMgc2F0ZWxsaXRlIGltYWdlcy4gKi9cclxuICBzYXRlbGxpdGUsXHJcbiAgLyoqIFRoaXMgbWFwIHR5cGUgZGlzcGxheXMgbWFwcyB3aXRoIHBoeXNpY2FsIGZlYXR1cmVzIHN1Y2ggYXMgdGVycmFpbiBhbmQgdmVnZXRhdGlvbi4gKi9cclxuICB0ZXJyYWluXHJcbn1cclxuXHJcbi8qKioqKiBDb250cm9scyAqKioqKi9cclxuLyoqIE9wdGlvbnMgZm9yIHRoZSByZW5kZXJpbmcgb2YgdGhlIG1hcCB0eXBlIGNvbnRyb2wuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFwVHlwZUNvbnRyb2xPcHRpb25zIHtcclxuICAvKiogSURzIG9mIG1hcCB0eXBlcyB0byBzaG93IGluIHRoZSBjb250cm9sLiAqL1xyXG4gIG1hcFR5cGVJZHM/OiAoTWFwVHlwZUlkfHN0cmluZylbXTtcclxuICAvKipcclxuICAgKiBQb3NpdGlvbiBpZC4gVXNlZCB0byBzcGVjaWZ5IHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCBvbiB0aGUgbWFwLlxyXG4gICAqIFRoZSBkZWZhdWx0IHBvc2l0aW9uIGlzIFRPUF9SSUdIVC5cclxuICAgKi9cclxuICBwb3NpdGlvbj86IENvbnRyb2xQb3NpdGlvbjtcclxuICAvKiogU3R5bGUgaWQuIFVzZWQgdG8gc2VsZWN0IHdoYXQgc3R5bGUgb2YgbWFwIHR5cGUgY29udHJvbCB0byBkaXNwbGF5LiAqL1xyXG4gIHN0eWxlPzogTWFwVHlwZUNvbnRyb2xTdHlsZTtcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWFwVHlwZUNvbnRyb2xTdHlsZSB7XHJcbiAgREVGQVVMVCxcclxuICBEUk9QRE9XTl9NRU5VLFxyXG4gIEhPUklaT05UQUxfQkFSXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT3ZlcnZpZXdNYXBDb250cm9sT3B0aW9ucyB7XHJcbiAgb3BlbmVkPzogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqIE9wdGlvbnMgZm9yIHRoZSByZW5kZXJpbmcgb2YgdGhlIHBhbiBjb250cm9sLiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFBhbkNvbnRyb2xPcHRpb25zIHtcclxuICAvKipcclxuICAgKiBQb3NpdGlvbiBpZC4gVXNlZCB0byBzcGVjaWZ5IHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCBvbiB0aGUgbWFwLlxyXG4gICAqIFRoZSBkZWZhdWx0IHBvc2l0aW9uIGlzIFRPUF9MRUZULlxyXG4gICAqL1xyXG4gIHBvc2l0aW9uPzogQ29udHJvbFBvc2l0aW9uO1xyXG59XHJcblxyXG4vKiogT3B0aW9ucyBmb3IgdGhlIHJlbmRlcmluZyBvZiB0aGUgcm90YXRlIGNvbnRyb2wuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUm90YXRlQ29udHJvbE9wdGlvbnMge1xyXG4gIC8qKlxyXG4gICAqIFBvc2l0aW9uIGlkLiBVc2VkIHRvIHNwZWNpZnkgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIG9uIHRoZSBtYXAuXHJcbiAgICogVGhlIGRlZmF1bHQgcG9zaXRpb24gaXMgVE9QX0xFRlQuXHJcbiAgICovXHJcbiAgcG9zaXRpb24/OiBDb250cm9sUG9zaXRpb247XHJcbn1cclxuXHJcbi8qKiBPcHRpb25zIGZvciB0aGUgcmVuZGVyaW5nIG9mIHRoZSBzY2FsZSBjb250cm9sLiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFNjYWxlQ29udHJvbE9wdGlvbnMge1xyXG4gIC8qKiBTdHlsZSBpZC4gVXNlZCB0byBzZWxlY3Qgd2hhdCBzdHlsZSBvZiBzY2FsZSBjb250cm9sIHRvIGRpc3BsYXkuICovXHJcbiAgc3R5bGU/OiBTY2FsZUNvbnRyb2xTdHlsZTtcclxufVxyXG5cclxuZXhwb3J0IGVudW0gU2NhbGVDb250cm9sU3R5bGUge1xyXG4gIERFRkFVTFRcclxufVxyXG5cclxuLyoqIE9wdGlvbnMgZm9yIHRoZSByZW5kZXJpbmcgb2YgdGhlIFN0cmVldCBWaWV3IHBlZ21hbiBjb250cm9sIG9uIHRoZSBtYXAuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zIHtcclxuICAvKipcclxuICAgKiBQb3NpdGlvbiBpZC4gVXNlZCB0byBzcGVjaWZ5IHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCBvbiB0aGUgbWFwLiBUaGVcclxuICAgKiBkZWZhdWx0IHBvc2l0aW9uIGlzIGVtYmVkZGVkIHdpdGhpbiB0aGUgbmF2aWdhdGlvbiAoem9vbSBhbmQgcGFuKSBjb250cm9scy5cclxuICAgKiBJZiB0aGlzIHBvc2l0aW9uIGlzIGVtcHR5IG9yIHRoZSBzYW1lIGFzIHRoYXQgc3BlY2lmaWVkIGluIHRoZVxyXG4gICAqIHpvb21Db250cm9sT3B0aW9ucyBvciBwYW5Db250cm9sT3B0aW9ucywgdGhlIFN0cmVldCBWaWV3IGNvbnRyb2wgd2lsbCBiZVxyXG4gICAqIGRpc3BsYXllZCBhcyBwYXJ0IG9mIHRoZSBuYXZpZ2F0aW9uIGNvbnRyb2xzLiBPdGhlcndpc2UsIGl0IHdpbGwgYmUgZGlzcGxheWVkXHJcbiAgICogc2VwYXJhdGVseS5cclxuICAgKi9cclxuICBwb3NpdGlvbj86IENvbnRyb2xQb3NpdGlvbjtcclxufVxyXG5cclxuLyoqIE9wdGlvbnMgZm9yIHRoZSByZW5kZXJpbmcgb2YgdGhlIHpvb20gY29udHJvbC4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBab29tQ29udHJvbE9wdGlvbnMge1xyXG4gIC8qKlxyXG4gICAqIFBvc2l0aW9uIGlkLiBVc2VkIHRvIHNwZWNpZnkgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIG9uIHRoZSBtYXAuXHJcbiAgICogVGhlIGRlZmF1bHQgcG9zaXRpb24gaXMgVE9QX0xFRlQuXHJcbiAgICovXHJcbiAgcG9zaXRpb24/OiBDb250cm9sUG9zaXRpb247XHJcbiAgc3R5bGU/OiBab29tQ29udHJvbFN0eWxlO1xyXG59XHJcblxyXG5leHBvcnQgZW51bSBab29tQ29udHJvbFN0eWxlIHtcclxuICBERUZBVUxULFxyXG4gIExBUkdFLFxyXG4gIFNNQUxMXHJcbn1cclxuXHJcbi8qKiBPcHRpb25zIGZvciB0aGUgcmVuZGVyaW5nIG9mIHRoZSBmdWxsc2NyZWVuIGNvbnRyb2wuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRnVsbHNjcmVlbkNvbnRyb2xPcHRpb25zIHtcclxuICAvKipcclxuICAgKiBQb3NpdGlvbiBpZC4gVXNlZCB0byBzcGVjaWZ5IHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCBvbiB0aGUgbWFwLlxyXG4gICAqIFRoZSBkZWZhdWx0IHBvc2l0aW9uIGlzIFJJR0hUX1RPUC5cclxuICAgKi9cclxuICBwb3NpdGlvbj86IENvbnRyb2xQb3NpdGlvbjtcclxufVxyXG5cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgT3ZlcmxheVZpZXcge1xyXG4gICAgcHVibGljIHNldChrZXk6IHN0cmluZywgdmFsdWU6IGFueSk6IHZvaWQ7XHJcbiAgICBwdWJsaWMgZ2V0KGtleTogc3RyaW5nKTogYW55O1xyXG4gICAgcHVibGljIHNldFZhbHVlcyhvcHRpb25zOiBhbnkpOiB2b2lkO1xyXG4gICAgcHVibGljIGdldFBhbmVzKCk6IGFueTtcclxuICAgIHB1YmxpYyBnZXRQcm9qZWN0aW9uKCk6IGFueTtcclxuICAgIHB1YmxpYyBnZXRNYXAoKTogR29vZ2xlTWFwO1xyXG59XHJcbiIsImltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJQm94IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pYm94JztcclxuaW1wb3J0IHsgSU1hcE9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXAtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCAqIGFzIEdvb2dsZU1hcFR5cGVzIGZyb20gJy4vZ29vZ2xlLW1hcC10eXBlcyc7XHJcbmltcG9ydCB7IE1hcFR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXAtdHlwZS1pZCc7XHJcblxyXG5kZWNsYXJlIHZhciBnb29nbGU6IGFueTtcclxuXHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBjb250YWlucyBoZWxwZXJmdW5jdGlvbnMgdG8gbWFwIHZhcmlvdXMgaW50ZXJmYWNlcyB1c2VkIHRvIHJlcHJlc2VudCBvcHRpb25zIGFuZCBzdHJ1Y3R1cmVzIGludG8gdGhlXHJcbiAqIGNvcnJlc3BvbmRpbmcgR29vZ2xlIE1hcHMgc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR29vZ2xlQ29udmVyc2lvbnMge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEdvb2dsZSBNYXAgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfbWFwT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdiYWNrZ3JvdW5kQ29sb3InLFxyXG4gICAgICAgICdjZW50ZXInLFxyXG4gICAgICAgICdjbGlja2FibGVJY29ucycsXHJcbiAgICAgICAgJ2N1c3RvbU1hcFN0eWxlR29vZ2xlJyxcclxuICAgICAgICAnZGlzYWJsZURlZmF1bHRVSScsXHJcbiAgICAgICAgJ2Rpc2FibGVEb3VibGVDbGlja1pvb20nLFxyXG4gICAgICAgICdkcmFnZ2FibGUnLFxyXG4gICAgICAgICdkcmFnZ2FibGVDdXJzb3InLFxyXG4gICAgICAgICdkcmFnZ2luZ0N1cnNvcicsXHJcbiAgICAgICAgJ2Rpc2FibGVab29taW5nJyxcclxuICAgICAgICAnZnVsbHNjcmVlbkNvbnRyb2wnLFxyXG4gICAgICAgICdmdWxsc2NyZWVuQ29udHJvbE9wdGlvbnMnLFxyXG4gICAgICAgICdnZXN0dXJlSGFuZGxpbmcnLFxyXG4gICAgICAgICdoZWFkaW5nJyxcclxuICAgICAgICAna2V5Ym9hcmRTaG9ydGN1dHMnLFxyXG4gICAgICAgICdtYXBUeXBlQ29udHJvbCcsXHJcbiAgICAgICAgJ21hcFR5cGVDb250cm9sT3B0aW9ucycsXHJcbiAgICAgICAgJ21hcFR5cGVJZCcsXHJcbiAgICAgICAgJ21heFpvb20nLFxyXG4gICAgICAgICdtaW5ab29tJyxcclxuICAgICAgICAnbm9DbGVhcicsXHJcbiAgICAgICAgJ3BhbkNvbnRyb2wnLFxyXG4gICAgICAgICdwYW5Db250cm9sT3B0aW9ucycsXHJcbiAgICAgICAgJ3JvdGF0ZUNvbnRyb2wnLFxyXG4gICAgICAgICdyb3RhdGVDb250cm9sT3B0aW9ucycsXHJcbiAgICAgICAgJ3NjYWxlQ29udHJvbCcsXHJcbiAgICAgICAgJ3NjYWxlQ29udHJvbE9wdGlvbnMnLFxyXG4gICAgICAgICdzY3JvbGx3aGVlbCcsXHJcbiAgICAgICAgJ3Nob3dNYXBUeXBlU2VsZWN0b3InLFxyXG4gICAgICAgICdzdHJlZXRWaWV3JyxcclxuICAgICAgICAnc3RyZWV0Vmlld0NvbnRyb2wnLFxyXG4gICAgICAgICdzdHJlZXRWaWV3Q29udHJvbE9wdGlvbnMnLFxyXG4gICAgICAgICdzdHlsZXMnLFxyXG4gICAgICAgICd0aWx0JyxcclxuICAgICAgICAnem9vbScsXHJcbiAgICAgICAgJ3pvb21Db250cm9sJyxcclxuICAgICAgICAnem9vbUNvbnRyb2xPcHRpb25zJ1xyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZm9XaW5kb3cgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEdvb2dsZSBNYXAgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfaW5mb1dpbmRvd09wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcclxuICAgICAgICAnYWN0aW9ucycsXHJcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcclxuICAgICAgICAnaHRtbENvbnRlbnQnLFxyXG4gICAgICAgICdpZCcsXHJcbiAgICAgICAgJ3Bvc2l0aW9uJyxcclxuICAgICAgICAncGl4ZWxPZmZzZXQnLFxyXG4gICAgICAgICdzaG93Q2xvc2VCdXR0b24nLFxyXG4gICAgICAgICdzaG93UG9pbnRlcicsXHJcbiAgICAgICAgJ3B1c2hwaW4nLFxyXG4gICAgICAgICd0aXRsZScsXHJcbiAgICAgICAgJ3RpdGxlQ2xpY2tIYW5kbGVyJyxcclxuICAgICAgICAndHlwZU5hbWUnLFxyXG4gICAgICAgICd2aXNpYmxlJyxcclxuICAgICAgICAnd2lkdGgnLFxyXG4gICAgICAgICdoZWlnaHQnXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFya2VyIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBHb29nbGUgTWFwIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX21hcmtlck9wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcclxuICAgICAgICAnYW5jaG9yJyxcclxuICAgICAgICAncG9zaXRpb24nLFxyXG4gICAgICAgICd0aXRsZScsXHJcbiAgICAgICAgJ3RleHQnLFxyXG4gICAgICAgICdsYWJlbCcsXHJcbiAgICAgICAgJ2RyYWdnYWJsZScsXHJcbiAgICAgICAgJ2ljb24nLFxyXG4gICAgICAgICd3aWR0aCcsXHJcbiAgICAgICAgJ2hlaWdodCcsXHJcbiAgICAgICAgJ2ljb25JbmZvJyxcclxuICAgICAgICAnbWV0YWRhdGEnLFxyXG4gICAgICAgICd2aXNpYmxlJ1xyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsdXN0ZXIgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEdvb2dsZSBNYXAgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfY2x1c3Rlck9wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcclxuICAgICAgICAnY2FsbGJhY2snLFxyXG4gICAgICAgICdjbHVzdGVyZWRQaW5DYWxsYmFjaycsXHJcbiAgICAgICAgJ2NsdXN0ZXJpbmdFbmFibGVkJyxcclxuICAgICAgICAnZ3JpZFNpemUnLFxyXG4gICAgICAgICdsYXllck9mZnNldCcsXHJcbiAgICAgICAgJ3BsYWNlbWVudE1vZGUnLFxyXG4gICAgICAgICd2aXNpYmxlJyxcclxuICAgICAgICAnekluZGV4J1xyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvbHlnb24gb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEdvb2dsZSBNYXAgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfcG9seWdvbk9wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcclxuICAgICAgICAnY2xpY2thYmxlJyxcclxuICAgICAgICAnZHJhZ2dhYmxlJyxcclxuICAgICAgICAnZWRpdGFibGUnLFxyXG4gICAgICAgICdmaWxsQ29sb3InLFxyXG4gICAgICAgICdmaWxsT3BhY2l0eScsXHJcbiAgICAgICAgJ2dlb2Rlc2ljJyxcclxuICAgICAgICAncGF0aHMnLFxyXG4gICAgICAgICdzdHJva2VDb2xvcicsXHJcbiAgICAgICAgJ3N0cm9rZU9wYWNpdHknLFxyXG4gICAgICAgICdzdHJva2VXZWlnaHQnLFxyXG4gICAgICAgICd2aXNpYmxlJyxcclxuICAgICAgICAnekluZGV4J1xyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvbHlsaW5lIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBHb29nbGUgTWFwIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdjbGlja2FibGUnLFxyXG4gICAgICAgICdkcmFnZ2FibGUnLFxyXG4gICAgICAgICdlZGl0YWJsZScsXHJcbiAgICAgICAgJ2dlb2Rlc2ljJyxcclxuICAgICAgICAnc3Ryb2tlQ29sb3InLFxyXG4gICAgICAgICdzdHJva2VPcGFjaXR5JyxcclxuICAgICAgICAnc3Ryb2tlV2VpZ2h0JyxcclxuICAgICAgICAndmlzaWJsZScsXHJcbiAgICAgICAgJ3pJbmRleCdcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGFuIElCb3ggb2JqZWN0IHRvIGEgR29vZ2xlTWFwVHlwZXMuTGF0TG5nQm91bmRzTGl0ZXJhbCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJvdW5kcyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlQm91bmRzKGJvdW5kczogSUJveCk6IEdvb2dsZU1hcFR5cGVzLkxhdExuZ0JvdW5kc0xpdGVyYWwge1xyXG4gICAgICAgIGNvbnN0IGI6IEdvb2dsZU1hcFR5cGVzLkxhdExuZ0JvdW5kc0xpdGVyYWwgPSB7XHJcbiAgICAgICAgICAgIGVhc3Q6IGJvdW5kcy5tYXhMb25naXR1ZGUsXHJcbiAgICAgICAgICAgIG5vcnRoOiBib3VuZHMubWF4TGF0aXR1ZGUsXHJcbiAgICAgICAgICAgIHNvdXRoOiBib3VuZHMubWluTGF0aXR1ZGUsXHJcbiAgICAgICAgICAgIHdlc3Q6IGJvdW5kcy5taW5Mb25naXR1ZGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gYjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSUluZm9XaW5kb3dPcHRpb25zIG9iamVjdCB0byBhIEdvb2dsZU1hcFR5cGVzLkluZm9XaW5kb3dPcHRpb25zIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlSW5mb1dpbmRvd09wdGlvbnMob3B0aW9uczogSUluZm9XaW5kb3dPcHRpb25zKTogR29vZ2xlTWFwVHlwZXMuSW5mb1dpbmRvd09wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLkluZm9XaW5kb3dPcHRpb25zIHwgYW55ID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcclxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEdvb2dsZUNvbnZlcnNpb25zLl9pbmZvV2luZG93T3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ2h0bWxDb250ZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uY29udGVudCA9ICg8YW55Pm9wdGlvbnMpW2tdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChvLmNvbnRlbnQgPT0gbnVsbCB8fCBvLmNvbnRlbnQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlICE9PSAnJyAmJiBvcHRpb25zLmRlc2NyaXB0aW9uICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgby5jb250ZW50ID0gYCR7b3B0aW9ucy50aXRsZX06ICR7b3B0aW9ucy5kZXNjcmlwdGlvbn1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZGVzY3JpcHRpb24gIT09ICcnKSB7IG8uY29udGVudCA9IG9wdGlvbnMuZGVzY3JpcHRpb247IH1cclxuICAgICAgICAgICAgZWxzZSB7IG8uY29udGVudCA9IG9wdGlvbnMudGl0bGU7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGFuIElMYXRMb25nIG9iamVjdCB0byBhIEdvb2dsZU1hcFR5cGVzLkxhdExuZ0xpdGVyYWwgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXRsb25nIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVMb2NhdGlvbihsYXRsb25nOiBJTGF0TG9uZyk6IEdvb2dsZU1hcFR5cGVzLkxhdExuZ0xpdGVyYWwge1xyXG4gICAgICAgIGNvbnN0IGw6IEdvb2dsZU1hcFR5cGVzLkxhdExuZ0xpdGVyYWwgPSB7IGxhdDogbGF0bG9uZy5sYXRpdHVkZSwgbG5nOiBsYXRsb25nLmxvbmdpdHVkZSB9O1xyXG4gICAgICAgIHJldHVybiBsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBHb29nbGVNYXBUeXBlcy5MYXRMbmdMaXRlcmFsIG9iamVjdCB0byBhIElMYXRMb25nIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF0bG5nIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVMYXRMbmcobGF0bG5nOiBHb29nbGVNYXBUeXBlcy5MYXRMbmdMaXRlcmFsKTogSUxhdExvbmcge1xyXG4gICAgICAgIGNvbnN0IGw6IElMYXRMb25nID0geyBsYXRpdHVkZTogbGF0bG5nLmxhdCwgbG9uZ2l0dWRlOiBsYXRsbmcubG5nIH07XHJcbiAgICAgICAgcmV0dXJuIGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGFuIElMYXRMb25nIG9iamVjdCB0byBhIEdvb2dsZU1hcFR5cGVzLkxhdExuZyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhdGxvbmcgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0KGxhdGxvbmc6IElMYXRMb25nKTogR29vZ2xlTWFwVHlwZXMuTGF0TG5nIHtcclxuICAgICAgICBjb25zdCBsOiBHb29nbGVNYXBUeXBlcy5MYXRMbmcgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxhdGxvbmcubGF0aXR1ZGUsIGxhdGxvbmcubG9uZ2l0dWRlKTtcclxuICAgICAgICByZXR1cm4gbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gR29vZ2xlTWFwVHlwZXMuTGF0TG5nIG9iamVjdCB0byBhIElMYXRMb25nIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF0bG5nIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVMYXRMbmdPYmplY3QobGF0bG5nOiBHb29nbGVNYXBUeXBlcy5MYXRMbmcpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgY29uc3QgbDogSUxhdExvbmcgPSB7IGxhdGl0dWRlOiBsYXRsbmcubGF0KCksIGxvbmdpdHVkZTogbGF0bG5nLmxuZygpIH07XHJcbiAgICAgICAgcmV0dXJuIGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGFuIElMYXRMb25nIGFycmF5IHRvIGEgYXJyYXkgb2YgR29vZ2xlTWFwVHlwZXMuTGF0TG5nIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF0bG9uZ0FycmF5IC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVMb2NhdGlvbk9iamVjdEFycmF5KGxhdGxvbmdBcnJheTogQXJyYXk8SUxhdExvbmc+KTogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPiB7XHJcbiAgICAgICAgLy8gdXNlIGZvciBsb29wIGZvciBwZXJmb3JtYW5jZSBpbiBjYXNlIHdlIGRlYWwgd2l0aCBsYXJnZSBudW1iZXJzIG9mIHBvaW50cyBhbmQgcGF0aHMuLi5cclxuICAgICAgICBjb25zdCBwOiBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+ID0gbmV3IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4oKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhdGxvbmdBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwLnB1c2goR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb25PYmplY3QobGF0bG9uZ0FycmF5W2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhIE1hcFR5cGVJZCBvYmplY3QgdG8gYSBHb29nbGUgbWFwdHlwZSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcFR5cGVJZCAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlTWFwVHlwZUlkKG1hcFR5cGVJZDogTWFwVHlwZUlkKTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKG1hcFR5cGVJZCkge1xyXG4gICAgICAgICAgICBjYXNlIE1hcFR5cGVJZC5yb2FkOiByZXR1cm4gR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkW0dvb2dsZU1hcFR5cGVzLk1hcFR5cGVJZC5yb2FkbWFwXTtcclxuICAgICAgICAgICAgY2FzZSBNYXBUeXBlSWQuZ3JheXNjYWxlOiByZXR1cm4gR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkW0dvb2dsZU1hcFR5cGVzLk1hcFR5cGVJZC50ZXJyYWluXTtcclxuICAgICAgICAgICAgY2FzZSBNYXBUeXBlSWQuaHlicmlkOiByZXR1cm4gR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkW0dvb2dsZU1hcFR5cGVzLk1hcFR5cGVJZC5oeWJyaWRdO1xyXG4gICAgICAgICAgICBjYXNlIE1hcFR5cGVJZC5vcmRuYW5jZVN1cnZleTogcmV0dXJuIEdvb2dsZU1hcFR5cGVzLk1hcFR5cGVJZFtHb29nbGVNYXBUeXBlcy5NYXBUeXBlSWQudGVycmFpbl07XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBHb29nbGVNYXBUeXBlcy5NYXBUeXBlSWRbR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkLnNhdGVsbGl0ZV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBJTWFya2VyT3B0aW9ucyBvYmplY3QgdG8gYSBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgdGhhdCB3aGVuIHJlc29sdmVkIGNvbnRhaW5zIHRoZSBtYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZU1hcmtlck9wdGlvbnMob3B0aW9uczogSU1hcmtlck9wdGlvbnMpOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zIHwgYW55ID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcclxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEdvb2dsZUNvbnZlcnNpb25zLl9tYXJrZXJPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSlcclxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChrID09PSAncG9zaXRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0bG5nID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb25PYmplY3Qob3B0aW9uc1trXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgby5wb3NpdGlvbiA9IGxhdGxuZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ba10gPSAoPGFueT5vcHRpb25zKVtrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGFuIElNYXBPcHRpb25zIG9iamVjdCB0byBhIEdvb2dsZU1hcFR5cGVzLk1hcE9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVPcHRpb25zKG9wdGlvbnM6IElNYXBPcHRpb25zKTogR29vZ2xlTWFwVHlwZXMuTWFwT3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFwT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBHb29nbGVDb252ZXJzaW9ucy5fbWFwT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLmNlbnRlciA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKG9wdGlvbnMuY2VudGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdtYXBUeXBlSWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5tYXBUeXBlSWQgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVNYXBUeXBlSWQob3B0aW9ucy5tYXBUeXBlSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ2Rpc2FibGVab29taW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uZ2VzdHVyZUhhbmRsaW5nID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgICAgIG8uem9vbUNvbnRyb2wgPSAgZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrID09PSAnc2hvd01hcFR5cGVTZWxlY3RvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLm1hcFR5cGVDb250cm9sID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrID09PSAnY3VzdG9tTWFwU3R5bGVHb29nbGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5zdHlsZXMgPSA8R29vZ2xlTWFwVHlwZXMuTWFwVHlwZVN0eWxlW10+PGFueT4gb3B0aW9ucy5jdXN0b21NYXBTdHlsZUdvb2dsZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxhbnk+bylba10gPSAoPGFueT5vcHRpb25zKVtrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGVzIGFuIGFycmF5IG9mIGxvY2F0aW9ucyBvciBhbiBhcnJheSBvciBhcnJheXMgb2YgbG9jYXRpb24gdG8gYW5kIGFycmF5IG9mIGFycmF5cyBvZiBCaW5nIE1hcCBMb2NhdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aHMgLSBJTGF0TG9uZyBiYXNlZCBsb2NhdGlvbnMgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIC0gY29udmVydGVkIGxvY2F0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVQYXRocyhwYXRoczogQXJyYXk8SUxhdExvbmc+IHwgQXJyYXk8QXJyYXk8SUxhdExvbmc+Pik6IEFycmF5PEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4+IHtcclxuICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+PiA9IG5ldyBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+PigpO1xyXG4gICAgICAgIGlmIChwYXRocyA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHBhdGhzKSB8fCBwYXRocy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcC5wdXNoKG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGhzWzBdKSkge1xyXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3IgYXJyYXlzXHJcbiAgICAgICAgICAgIC8vIHVzZSBmb3IgbG9vcCBmb3IgcGVyZm9ybWFuY2UgaW4gY2FzZSB3ZSBkZWFsIHdpdGggbGFyZ2UgbnVtYmVycyBvZiBwb2ludHMgYW5kIHBhdGhzLi4uXHJcbiAgICAgICAgICAgIGNvbnN0IHAxID0gPEFycmF5PEFycmF5PElMYXRMb25nPj4+cGF0aHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcDEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHAucHVzaChHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbk9iamVjdEFycmF5KHAxW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlciBpcyBhIHNpbXBsZSBhcnJheS4uLi5cclxuICAgICAgICAgICAgcC5wdXNoKEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0QXJyYXkoPEFycmF5PElMYXRMb25nPj5wYXRocykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICBNYXBzIGFuIElQb2x5Z29uT3B0aW9ucyBvYmplY3QgdG8gYSBHb29nbGVNYXBUeXBlcy5Qb2x5Z29uT3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlUG9seWdvbk9wdGlvbnMob3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogR29vZ2xlTWFwVHlwZXMuUG9seWdvbk9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLlBvbHlnb25PcHRpb25zIHwgYW55ID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcclxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEdvb2dsZUNvbnZlcnNpb25zLl9wb2x5Z29uT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ3BhdGhzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGhzKSkgeyByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYXRocy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5wYXRocyA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRoc1swXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5wYXRocyA9IG5ldyBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmdMaXRlcmFsPj4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGZvciBsb29wIGZvciBwZXJmb3JtYW5jZSBpbiBjYXNlIHdlIGRlYWwgd2l0aCBsYXJnZSBudW1iZXJzIG9mIHBvaW50cyBhbmQgcGF0aHMuLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwMSA9IDxBcnJheTxBcnJheTxJTGF0TG9uZz4+Pm9wdGlvbnMucGF0aHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcDEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8ucGF0aHNbaV0gPSBuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbD4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcDFbaV0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnBhdGhzW2ldW2pdID0ge2xhdDogcDFbaV1bal0ubGF0aXR1ZGUsIGxuZzogcDFbaV1bal0ubG9uZ2l0dWRlfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5wYXRocyA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmdMaXRlcmFsPigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgZm9yIGxvb3AgZm9yIHBlcmZvcm1hbmNlIGluIGNhc2Ugd2UgZGVhbCB3aXRoIGxhcmdlIG51bWJlcnMgb2YgcG9pbnRzIGFuZCBwYXRocy4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAxID0gPEFycmF5PElMYXRMb25nPj5vcHRpb25zLnBhdGhzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnBhdGhzW2ldID0ge2xhdDogcDFbaV0ubGF0aXR1ZGUsIGxuZzogcDFbaV0ubG9uZ2l0dWRlfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ba10gPSAoPGFueT5vcHRpb25zKVtrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgTWFwcyBhbiBJUG9seWxpbmVPcHRpb25zIG9iamVjdCB0byBhIEdvb2dsZU1hcFR5cGVzLlBvbHlsaW5lT3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlUG9seWxpbmVPcHRpb25zKG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZU9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLlBvbHlsaW5lT3B0aW9ucyB8IGFueSA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBHb29nbGVDb252ZXJzaW9ucy5fcG9seWxpbmVPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSlcclxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcclxuICAgICAgICAgICAgICAgIG9ba10gPSAoPGFueT5vcHRpb25zKVtrXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSUluZm9XaW5kb3dPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctb3B0aW9ucyc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IEdvb2dsZUNvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1jb252ZXJzaW9ucyc7XHJcbmltcG9ydCB7IEdvb2dsZU1hcFNlcnZpY2V9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vaW5mby13aW5kb3cnO1xyXG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuLi8uLi9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC10eXBlcyc7XHJcblxyXG5kZWNsYXJlIHZhciBnb29nbGU6IGFueTtcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBmb3IgYSB7QGxpbmsgSW5mb1dpbmRvd319IG1vZGVsIGZvciBHb29nbGUgTWFwcy5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdvb2dsZUluZm9XaW5kb3cgaW1wbGVtZW50cyBJbmZvV2luZG93IHtcclxuXHJcbiAgICBwcml2YXRlIF9pc09wZW46IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGluZm8gYm94IGlzIGN1cnJlbnRseSBvcGVuLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEluZm9XR29vZ2xlSW5mb1dpbmRvd2luZG93XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSXNPcGVuKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc09wZW4gPT09IHRydWUpIHsgcmV0dXJuIHRydWU7IH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5mb1dpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBjb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZUluZm9XaW5kb3cuXHJcbiAgICAgKiBAcGFyYW0gX2luZm9XaW5kb3cgLSBBIHtAbGluayBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93fSBpbnN0YW5jZSB1bmRlcmx5aW5nIHRoZSBtb2RlbC5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0uXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb1dpbmRvd1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pbmZvV2luZG93OiBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93LCBwcml2YXRlIF9tYXBTZXJ2aWNlOiBHb29nbGVNYXBTZXJ2aWNlKSB7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAvKipcclxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIEluZm9XaW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGxpc3RlbmVyIChlLmcuIFwiY2xpY2tcIilcclxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGludm9rZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvV2luZG93XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5faW5mb1dpbmRvdy5hZGRMaXN0ZW5lcihldmVudFR5cGUsIChlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ2Nsb3NlY2xpY2snKSB7IHRoaXMuX2lzT3BlbiA9IGZhbHNlOyB9XHJcbiAgICAgICAgICAgIGZuKGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIENsb3NlcyB0aGUgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9XaW5kb3dcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIENsb3NlKCkge1xyXG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2luZm9XaW5kb3cuY2xvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBpbmZvIHdpbmRvd1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9XaW5kb3dcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFBvc2l0aW9uKCk6IElMYXRMb25nIHtcclxuICAgICAgICByZXR1cm4gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTGF0TG5nT2JqZWN0KHRoaXMuX2luZm9XaW5kb3cuZ2V0UG9zaXRpb24oKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyB0aGUgaW5mbyB3aW5kb3dcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW2FuY2hvcl0gLSBPcHRpb25hbCBBbmNob3IuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9XaW5kb3dcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIE9wZW4oYW5jaG9yPzogYW55KSB7XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5NYXBQcm9taXNlLnRoZW4obSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzT3BlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2luZm9XaW5kb3cub3BlbihtLCBhbmNob3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaW5mbyB3aW5kb3cgb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gc2V0LiBUaGlzIG9iamVjdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvV2luZG93XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRPcHRpb25zKG9wdGlvbnM6IElJbmZvV2luZG93T3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLkluZm9XaW5kb3dPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlSW5mb1dpbmRvd09wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5faW5mb1dpbmRvdy5zZXRPcHRpb25zKG8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaW5mbyB3aW5kb3cgcG9zaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gLSBHZW8gY29vcmRpbmF0ZXMgYXQgd2hpY2ggdG8gYW5jaG9yIHRoZSBpbmZvIHdpbmRvdy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb1dpbmRvd1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0UG9zaXRpb24ocG9zaXRpb246IElMYXRMb25nKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbDogR29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbCA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKHBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl9pbmZvV2luZG93LnNldFBvc2l0aW9uKGwpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEdvb2dsZUNvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1jb252ZXJzaW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi9tYXJrZXInO1xyXG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuLi8uLi9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC10eXBlcyc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHtAbGluayBNYXJrZXJ9IGNvbnRyYWN0IGZvciB0aGUgR29vZ2xlIE1hcHMgbWFwIGFyY2hpdGVjdHVyZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdvb2dsZU1hcmtlciBpbXBsZW1lbnRzIE1hcmtlciB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX21ldGFkYXRhOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcclxuICAgIHByaXZhdGUgX2lzRmlyc3QgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2lzTGFzdCA9IHRydWU7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIHByb3BlcnRpZXNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIG1hcmtlciBpcyB0aGUgZmlyc3QgbWFya2VyIGluIGEgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJc0ZpcnN0KCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faXNGaXJzdDsgfVxyXG4gICAgcHVibGljIHNldCBJc0ZpcnN0KHZhbDogYm9vbGVhbikgeyB0aGlzLl9pc0ZpcnN0ID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgbWFya2VyIGlzIHRoZSBsYXN0IG1hcmtlciBpbiB0aGUgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJc0xhc3QoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9pc0xhc3Q7IH1cclxuICAgIHB1YmxpYyBzZXQgSXNMYXN0KHZhbDogYm9vbGVhbikgeyB0aGlzLl9pc0xhc3QgPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1hcmtlciBtZXRhZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTWV0YWRhdGEoKTogTWFwPHN0cmluZywgYW55PiB7IHJldHVybiB0aGlzLl9tZXRhZGF0YTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIHByaW1pdHZlIGltcGxlbWVudGluZyB0aGUgbWFya2VyLCBpbiB0aGlzIGNhc2Uge0BsaW5rIE1pY3Jvc29mdC5NYXBzLlB1c2hwaW59XHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTmF0aXZlUHJpbWl0dmUoKTogR29vZ2xlTWFwVHlwZXMuTWFya2VyIHsgcmV0dXJuIHRoaXMuX21hcmtlcjsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgTG9jYXRpb24gb2YgdGhlIG1hcmtlclxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IExvY2F0aW9uKCk6IElMYXRMb25nIHtcclxuICAgICAgICBjb25zdCBsOiBHb29nbGVNYXBUeXBlcy5MYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0UG9zaXRpb24oKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsYXRpdHVkZTogbC5sYXQoKSxcclxuICAgICAgICAgICAgbG9uZ2l0dWRlOiBsLmxuZygpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvcnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVNYXJrZXIuXHJcbiAgICAgKiBAcGFyYW0gX21hcmtlclxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFya2VyOiBHb29nbGVNYXBUeXBlcy5NYXJrZXIpIHsgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgbGlzdGVuZXIgKGUuZy4gXCJjbGlja1wiKVxyXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX21hcmtlci5hZGRMaXN0ZW5lcihldmVudFR5cGUsIGZuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlTWFya2VyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX21hcmtlci5zZXRNYXAobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXJrZXIgbGFiZWxcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRMYWJlbCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXIuZ2V0TGFiZWwoKS50ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBtYXJrZXIgaXMgdmlzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIG1hcmtlciBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0VmlzaWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2VyLmdldFZpc2libGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGFuY2hvciBmb3IgdGhlIG1hcmtlci4gVXNlIHRoaXMgdG8gYWRqdXN0IHRoZSByb290IGxvY2F0aW9uIGZvciB0aGUgbWFya2VyIHRvIGFjY29tb2RhdGUgdmFyaW91cyBtYXJrZXIgaW1hZ2Ugc2l6ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFuY2hvciAtIFBvaW50IGNvb3JkaW5hdGVzIGZvciB0aGUgbWFya2VyIGFuY2hvci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRBbmNob3IoYW5jaG9yOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICAvLyBub3QgaW1wbGVtZW50ZWRcclxuICAgICAgICAvLyBUT0RPOiB3ZSBuZWVkIHRvIHN3aXRjaCB0aGUgbW9kZWwgdG8gY29tcGxleCBpY29ucyBmb3IgZ29vZ2xlIHRvXHJcbiAgICAgICAgLy8gc3VwcG9ydCBhbmNob3JzLCBzaXplcyBhbmQgb3JpZ2lucy5cclxuICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9tYXJrZXJzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBkcmFnZ2FiaWxpdHkgb2YgYSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFyayB0aGUgbWFya2VyIGFzIGRyYWdnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9tYXJrZXIuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBpY29uIGZvciB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpY29uIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGljb24gaW4gdmFyaW91cyBmb3JtcyAodXJsLCBkYXRhIHVybCwgZXRjLilcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRJY29uKGljb246IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX21hcmtlci5zZXRJY29uKGljb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFya2VyIGxhYmVsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYWJlbCAtIFN0cmluZyBjb250YWluaW5nIHRoZSBsYWJlbCB0byBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0TGFiZWwobGFiZWw6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX21hcmtlci5zZXRMYWJlbChsYWJlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhdExuZyAtIEdlbyBjb29yZGluYXRlcyB0byBzZXQgdGhlIG1hcmtlciBwb3NpdGlvbiB0by5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRQb3NpdGlvbihsYXRMbmc6IElMYXRMb25nKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcDogR29vZ2xlTWFwVHlwZXMuTGF0TG5nID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb25PYmplY3QobGF0TG5nKTtcclxuICAgICAgICB0aGlzLl9tYXJrZXIuc2V0UG9zaXRpb24ocCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgdGl0bGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpdGxlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIHRpdGxlIHRvIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRUaXRsZSh0aXRsZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbWFya2VyLnNldFRpdGxlKHRpdGxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1hcmtlciBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElNYXJrZXJPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgbWFya2VyIG9wdGlvbnMgdG8gc2V0LiBUaGUgc3VwcGxpZWQgb3B0aW9ucyBhcmVcclxuICAgICAqIG1lcmdlZCB3aXRoIHRoZSB1bmRlcmx5aW5nIG1hcmtlciBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSU1hcmtlck9wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9tYXJrZXIuc2V0T3B0aW9ucyhvKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0aGUgbWFya2VyIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZpc2libGUgLSBUcnVlIHRvIHNldCB0aGUgbWFya2VyIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9tYXJrZXIuc2V0VmlzaWJsZSh2aXNpYmxlKTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5pbXBvcnQgeyBNYXBMYWJlbCB9IGZyb20gJy4uL21hcC1sYWJlbCc7XHJcbmltcG9ydCB7IElMYWJlbE9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYWJlbC1vcHRpb25zJztcclxuaW1wb3J0IHsgRXh0ZW5kZXIgfSBmcm9tICcuLi9leHRlbmRlcic7XHJcblxyXG5cclxuZGVjbGFyZSB2YXIgZ29vZ2xlOiBhbnk7XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyBtYXAgYSBsYWJsZWQgdG8gYmUgcGxhY2VkIG9uIHRoZSBtYXAuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBMYWJlbCBleHRlbmRzIE1hcExhYmVsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgbGFiZWwgc3R5bGUgZm9yIHRoZSBwbGF0Zm9ybVxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwTGFiZWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBEZWZhdWx0TGFiZWxTdHlsZSgpOiBJTGFiZWxPcHRpb25zIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcclxuICAgICAgICAgICAgZm9udENvbG9yOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMyxcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6ICcjMDAwMDAwJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNYXBMYWJlbFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgcHJvcGVydGllcyB0byBzZXQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IHsgW2tleTogc3RyaW5nXTogYW55IH0pIHtcclxuICAgICAgICBvcHRpb25zLmZvbnRTaXplID0gb3B0aW9ucy5mb250U2l6ZSB8fCAxMjtcclxuICAgICAgICBvcHRpb25zLmZvbnRDb2xvciA9IG9wdGlvbnMuZm9udENvbG9yIHx8ICcjZmZmZmZmJztcclxuICAgICAgICBvcHRpb25zLnN0cm9rZVdlaWdodCA9IG9wdGlvbnMuc3Ryb2tlV2VpZ2h0IHx8IDM7XHJcbiAgICAgICAgb3B0aW9ucy5zdHJva2VDb2xvciA9IG9wdGlvbnMuc3Ryb2tlQ29sb3IgfHwgJyMwMDAwMDAnO1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIGEgc2V0dGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gS2V5IHNwZWNpZnlpbmcgdGhlIHNldHRpbmcuXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSB2YWx1ZSBvZiB0aGUgc2V0dGluZy5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0KGtleTogc3RyaW5nKTogYW55IHtcclxuICAgICAgICByZXR1cm4gKDxhbnk+dGhpcykuZ2V0KGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXAgYXNzb2NpdGVkIHdpdGggdGhlIGxhYmVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TWFwKCk6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCB7XHJcbiAgICAgICAgcmV0dXJuICg8YW55PnRoaXMpLmdldE1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgYSBzZXR0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgc3BlY2lmeWluZyB0aGUgc2V0dGluZy5cclxuICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXQoa2V5OiBzdHJpbmcsIHZhbDogYW55KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJyAmJiB2YWwuaGFzT3duUHJvcGVydHkoJ2xhdGl0dWRlJykgJiYgdmFsLmhhc093blByb3BlcnR5KCdsb25naXR1ZGUnKSkge1xyXG4gICAgICAgICAgICB2YWwgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHZhbC5sYXRpdHVkZSwgdmFsLmxvbmdpdHVkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLkdldChrZXkpICE9PSB2YWwpIHtcclxuICAgICAgICAgICAgKDxhbnk+dGhpcykuc2V0KGtleSwgdmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXAgZm9yIHRoZSBsYWJlbC4gU2V0dGluZ3MgdGhpcyB0byBudWxsIHJlbW92ZSB0aGUgbGFiZWwgZnJvbSBodGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSBNYXAgdG8gYXNzb2NpYXRlZCB3aXRoIHRoZSBsYWJlbC5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0TWFwKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKTogdm9pZCB7XHJcbiAgICAgICAgKDxhbnk+dGhpcykuc2V0TWFwKG1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHNldHRpbmdzIHRvIHRoZSBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXR0aW5ncyBrZXkgdmFsdWUgcGFpcnMuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFZhbHVlcyhvcHRpb25zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogdm9pZCB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJyAmJiAgb3B0aW9uc1trZXldLmhhc093blByb3BlcnR5KCdsYXRpdHVkZScpICYmICBvcHRpb25zW2tleV0uaGFzT3duUHJvcGVydHkoJ2xvbmdpdHVkZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyggb3B0aW9uc1trZXldLmxhdGl0dWRlLCAgb3B0aW9uc1trZXldLmxvbmdpdHVkZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5HZXQoa2V5KSA9PT0gb3B0aW9uc1trZXldKSB7IGRlbGV0ZSBvcHRpb25zW2tleV07IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAoPGFueT50aGlzKS5zZXRWYWx1ZXMob3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvdGVjdGVkIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIGxhYmVsIG9uIHRoZSBtYXAuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIERyYXcoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbiA9ICg8YW55PnRoaXMpLmdldFByb2plY3Rpb24oKTtcclxuICAgICAgICBjb25zdCB2aXNpYmlsaXR5OiBzdHJpbmcgPSB0aGlzLkdldFZpc2libGUoKTtcclxuICAgICAgICBpZiAoIXByb2plY3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gVGhlIG1hcCBwcm9qZWN0aW9uIGlzIG5vdCByZWFkeSB5ZXQgc28gZG8gbm90aGluZ1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fY2FudmFzKSB7XHJcbiAgICAgICAgICAgIC8vIG9uQWRkIGhhcyBub3QgYmVlbiBjYWxsZWQgeWV0LlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uID0gdGhpcy5fY2FudmFzLnN0eWxlO1xyXG4gICAgICAgIGlmICh2aXNpYmlsaXR5ICE9PSAnJykge1xyXG4gICAgICAgICAgICAvLyBsYWJlbCBpcyBub3QgdmlzaWJsZSwgZG9uJ3QgY2FsY3VsYXRlIHBvc2l0aW9ucyBldGMuXHJcbiAgICAgICAgICAgIHN0eWxlWyd2aXNpYmlsaXR5J10gPSB2aXNpYmlsaXR5O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgb2Zmc2V0OiBHb29nbGVNYXBUeXBlcy5Qb2ludCA9IHRoaXMuR2V0KCdvZmZzZXQnKTtcclxuICAgICAgICBsZXQgbGF0TG5nOiBHb29nbGVNYXBUeXBlcy5MYXRMbmd8R29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbCA9IHRoaXMuR2V0KCdwb3NpdGlvbicpO1xyXG4gICAgICAgIGlmICghbGF0TG5nKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmICghKGxhdExuZyBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykpIHsgbGF0TG5nID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsYXRMbmcubGF0LCBsYXRMbmcubG5nKTsgfVxyXG4gICAgICAgIGlmICghb2Zmc2V0KSB7IG9mZnNldCA9IG5ldyBnb29nbGUubWFwcy5Qb2ludCgwLCAwKTsgfVxyXG5cclxuICAgICAgICBjb25zdCBwb3MgPSBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKGxhdExuZyk7XHJcbiAgICAgICAgc3R5bGVbJ3RvcCddID0gKHBvcy55ICsgb2Zmc2V0LnkpICsgJ3B4JztcclxuICAgICAgICBzdHlsZVsnbGVmdCddID0gKHBvcy54ICsgb2Zmc2V0LngpICsgJ3B4JztcclxuICAgICAgICBzdHlsZVsndmlzaWJpbGl0eSddID0gdmlzaWJpbGl0eTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGVnYXRlIGNhbGxlZCB3aGVuIHRoZSBsYWJlbCBpcyBhZGRlZCB0byB0aGUgbWFwLiBHZW5lcmF0ZXMgYW5kIGNvbmZpZ3VyZXNcclxuICAgICAqIHRoZSBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBPbkFkZCgpIHtcclxuICAgICAgICB0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjb25zdCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9IHRoaXMuX2NhbnZhcy5zdHlsZTtcclxuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcblxyXG4gICAgICAgIGNvbnN0IGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcclxuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XHJcblxyXG4gICAgICAgIHRoaXMuRHJhd0NhbnZhcygpO1xyXG4gICAgICAgIGNvbnN0IHBhbmVzID0gKDxhbnk+dGhpcykuZ2V0UGFuZXMoKTtcclxuICAgICAgICBpZiAocGFuZXMpIHtcclxuICAgICAgICAgICAgcGFuZXMub3ZlcmxheUxheWVyLmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICAvLyA0OiBmbG9hdFBhbmUgKGluZm93aW5kb3cpXHJcbiAgICAgICAgICAgICAgICAvLyAzOiBvdmVybGF5TW91c2VUYXJnZXQgKG1vdXNlIGV2ZW50cylcclxuICAgICAgICAgICAgICAgIC8vIDI6IG1hcmtlckxheWVyIChtYXJrZXIgaW1hZ2VzKVxyXG4gICAgICAgICAgICAgICAgLy8gMTogb3ZlcmxheUxheWVyIChwb2x5Z29ucywgcG9seWxpbmVzLCBncm91bmQgb3ZlcmxheXMsIHRpbGUgbGF5ZXIgb3ZlcmxheXMpXHJcbiAgICAgICAgICAgICAgICAvLyAwOiBtYXBQYW5lIChsb3dlc3QgcGFuZSBhYm92ZSB0aGUgbWFwIHRpbGVzKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBleHRlbmQgdGhlIE92ZXJsYXlWaWV3IGludG8gdGhlIE1hcExhYmVsXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQG1ldGhvZFxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTWl4aW5NYXBMYWJlbFdpdGhPdmVybGF5VmlldygpIHtcclxuXHJcbiAgICBuZXcgRXh0ZW5kZXIoR29vZ2xlTWFwTGFiZWwpXHJcbiAgICAgICAgLkV4dGVuZChuZXcgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcpXHJcbiAgICAgICAgLk1hcCgnY2hhbmdlZCcsICdDaGFuZ2VkJylcclxuICAgICAgICAuTWFwKCdvbkFkZCcsICdPbkFkZCcpXHJcbiAgICAgICAgLk1hcCgnZHJhdycsICdEcmF3JylcclxuICAgICAgICAuTWFwKCdvblJlbW92ZScsICdPblJlbW92ZScpO1xyXG59XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5Z29uRXZlbnQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLWV2ZW50JztcclxuaW1wb3J0IHsgR29vZ2xlQ29udmVyc2lvbnMgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWNvbnZlcnNpb25zJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBHb29nbGVNYXBMYWJlbCB9IGZyb20gJy4vZ29vZ2xlLWxhYmVsJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5cclxuZGVjbGFyZSB2YXIgZ29vZ2xlOiBhbnk7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gZm9yIGEgcG9seWdvbiBtb2RlbCBmb3IgR29vZ2xlIE1hcHMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVQb2x5Z29uIGV4dGVuZHMgUG9seWdvbiBpbXBsZW1lbnRzIFBvbHlnb24ge1xyXG5cclxuICAgIHByaXZhdGUgX3RpdGxlOiBzdHJpbmcgPSAnJztcclxuICAgIHByaXZhdGUgX3Nob3dMYWJlbDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfc2hvd1Rvb2x0aXA6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX21heFpvb206IG51bWJlciA9IC0xO1xyXG4gICAgcHJpdmF0ZSBfbWluWm9vbTogbnVtYmVyID0gLTE7XHJcbiAgICBwcml2YXRlIF9sYWJlbDogR29vZ2xlTWFwTGFiZWwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcDogR29vZ2xlTWFwTGFiZWwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2hhc1Rvb2xUaXBSZWNlaXZlcjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfb3JpZ2luYWxQYXRoOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+O1xyXG4gICAgcHJpdmF0ZSBfbW91c2VPdmVyTGlzdGVuZXI6IEdvb2dsZU1hcFR5cGVzLk1hcHNFdmVudExpc3RlbmVyID0gbnVsbDtcclxuICAgIHByaXZhdGUgX21vdXNlT3V0TGlzdGVuZXI6IEdvb2dsZU1hcFR5cGVzLk1hcHNFdmVudExpc3RlbmVyID0gbnVsbDtcclxuICAgIHByaXZhdGUgX21vdXNlTW92ZUxpc3RlbmVyOiBHb29nbGVNYXBUeXBlcy5NYXBzRXZlbnRMaXN0ZW5lciA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9tZXRhZGF0YTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XHJcbiAgICBwcml2YXRlIF9lZGl0aW5nQ29tcGxldGVFbWl0dGVyOiAoZXZlbnQ6IElQb2x5Z29uRXZlbnQpID0+IHZvaWQgPSBudWxsO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gem9vbSBhdCB3aGljaCB0aGUgbGFiZWwgaXMgZGlzcGxheWVkLiBJZ25vcmVkIG9yIFNob3dMYWJlbCBpcyBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTGFiZWxNYXhab29tKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9tYXhab29tOyB9XHJcbiAgICBwdWJsaWMgc2V0IExhYmVsTWF4Wm9vbSh2YWw6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX21heFpvb20gPSB2YWw7XHJcbiAgICAgICAgdGhpcy5NYW5hZ2VMYWJlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHpvb20gYXQgd2hpY2ggdGhlIGxhYmVsIGlzIGRpc3BsYXllZC4gSWdub3JlZCBvciBTaG93TGFiZWwgaXMgZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IExhYmVsTWluWm9vbSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fbWluWm9vbTsgfVxyXG4gICAgcHVibGljIHNldCBMYWJlbE1pblpvb20odmFsOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9taW5ab29tID0gdmFsO1xyXG4gICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlnb24gbWV0YWRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgR29vbGVQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTWV0YWRhdGEoKTogTWFwPHN0cmluZywgYW55PiB7IHJldHVybiB0aGlzLl9tZXRhZGF0YTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIHByaW1pdHZlIGltcGxlbWVudGluZyB0aGUgcG9seWdvbiwgaW4gdGhpcyBjYXNlIHtAbGluayBHb29nbGVNYXBUeXBlcy5Qb2x5Z29ufVxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBHb29nbGVNYXBUeXBlcy5Qb2x5Z29uIHsgcmV0dXJuIHRoaXMuX3BvbHlnb247IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRvIHNob3cgdGhlIGxhYmVsXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgU2hvd0xhYmVsKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc2hvd0xhYmVsOyB9XHJcbiAgICBwdWJsaWMgc2V0IFNob3dMYWJlbCh2YWw6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLl9zaG93TGFiZWwgPSB2YWw7XHJcbiAgICAgICAgdGhpcy5NYW5hZ2VMYWJlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gc2hvdyB0aGUgdG9vbHRpcFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IFNob3dUb29sdGlwKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc2hvd1Rvb2x0aXA7IH1cclxuICAgIHB1YmxpYyBzZXQgU2hvd1Rvb2x0aXAodmFsOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXAgPSB2YWw7XHJcbiAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHRpdGxlIG9mZiB0aGUgcG9seWdvblxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IFRpdGxlKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl90aXRsZTsgfVxyXG4gICAgcHVibGljIHNldCBUaXRsZSh2YWw6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3RpdGxlID0gdmFsO1xyXG4gICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcclxuICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBjb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZVBvbHlnb24uXHJcbiAgICAgKiBAcGFyYW0gX3BvbHlnb24gLSBUaGUge0BsaW5rIEdvb2dsZU1hcFR5cGVzLlBvbHlnb259IHVuZGVybHlpbmcgdGhlIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BvbHlnb246IEdvb2dsZU1hcFR5cGVzLlBvbHlnb24pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsUGF0aCA9IHRoaXMuR2V0UGF0aHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBkZWxlZ2F0ZSBmb3IgYW4gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBuYW1lLlxyXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcblxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBzdXBwb3J0ZWRFdmVudHMgPSBbXHJcbiAgICAgICAgICAgICdjbGljaycsXHJcbiAgICAgICAgICAgICdkYmxjbGljaycsXHJcbiAgICAgICAgICAgICdkcmFnJywgJ2RyYWdlbmQnLFxyXG4gICAgICAgICAgICAnZHJhZ3N0YXJ0JyxcclxuICAgICAgICAgICAgJ21vdXNlZG93bicsXHJcbiAgICAgICAgICAgICdtb3VzZW1vdmUnLFxyXG4gICAgICAgICAgICAnbW91c2VvdXQnLFxyXG4gICAgICAgICAgICAnbW91c2VvdmVyJyxcclxuICAgICAgICAgICAgJ21vdXNldXAnLFxyXG4gICAgICAgICAgICAncmlnaHRjbGljaydcclxuICAgICAgICBdO1xyXG4gICAgICAgIGlmIChzdXBwb3J0ZWRFdmVudHMuaW5kZXhPZihldmVudFR5cGUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29uLmFkZExpc3RlbmVyKGV2ZW50VHlwZSwgZm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRUeXBlID09PSAncGF0aGNoYW5nZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VkaXRpbmdDb21wbGV0ZUVtaXR0ZXIgPSA8KGV2ZW50OiBJUG9seWdvbkV2ZW50KSA9PiB2b2lkPmZuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZWQgdGhlIHBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wb2x5Z29uLnNldE1hcChudWxsKTtcclxuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHsgdGhpcy5fbGFiZWwuRGVsZXRlKCk7IH1cclxuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCkgeyB0aGlzLl90b29sdGlwLkRlbGV0ZSgpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgZHJhZ2dhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcG9seWdvbiBpcyBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXREcmFnZ2FibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb24uZ2V0RHJhZ2dhYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gcGF0aCBjYW4gYmUgZWRpdGVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcGF0aCBjYW4gYmUgZWRpdGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldEVkaXRhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29uLmdldEVkaXRhYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IG9iamVjdHMgZGVzY3JpYmluZyB0aGUgcG9seWdvbiBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRQYXRoKCk6IEFycmF5PElMYXRMb25nPiB7XHJcbiAgICAgICAgY29uc3QgcDogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPiA9IHRoaXMuX3BvbHlnb24uZ2V0UGF0aCgpO1xyXG4gICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PElMYXRMb25nPiA9IG5ldyBBcnJheTxJTGF0TG9uZz4oKTtcclxuICAgICAgICBwLmZvckVhY2goeCA9PiBwYXRoLnB1c2goeyBsYXRpdHVkZTogeC5sYXQoKSwgbG9uZ2l0dWRlOiB4LmxuZygpIH0pKTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlnb24gcGF0aHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IG9iamVjdHMgZGVzY3JpYmluZyBtdWx0aXBsZSBwb2x5Z29uIHBhdGhzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRQYXRocygpOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+IHtcclxuICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+PiA9IHRoaXMuX3BvbHlnb24uZ2V0UGF0aHMoKTtcclxuICAgICAgICBjb25zdCBwYXRoczogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiA9IG5ldyBBcnJheTxBcnJheTxJTGF0TG9uZz4+KCk7XHJcbiAgICAgICAgcC5mb3JFYWNoKHggPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoOiBBcnJheTxJTGF0TG9uZz4gPSBuZXcgQXJyYXk8SUxhdExvbmc+KCk7XHJcbiAgICAgICAgICAgIHguZm9yRWFjaCh5ID0+IHBhdGgucHVzaCh7IGxhdGl0dWRlOiB5LmxhdCgpLCBsb25naXR1ZGU6IHkubG5nKCkgfSkpO1xyXG4gICAgICAgICAgICBwYXRocy5wdXNoKHBhdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwYXRocztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWdvbiBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcG9seWdvbiBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb24uZ2V0VmlzaWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIGRyYWdhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkcmFnZ2FibGUgLSBUcnVlIHRvIG1ha2UgdGhlIHBvbHlnb24gZHJhZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3BvbHlnb24uc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdldGhlciB0aGUgcG9seWdvbiBwYXRoIGlzIGVkaXRhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlZGl0YWJsZSAtIFRydWUgdG8gbWFrZSBwb2x5Z29uIHBhdGggZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0RWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX3BvbHlnb24uZ2V0RWRpdGFibGUoKTtcclxuICAgICAgICB0aGlzLl9wb2x5Z29uLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcclxuICAgICAgICBpZiAocHJldmlvdXMgJiYgIWVkaXRhYmxlICYmIHRoaXMuX2VkaXRpbmdDb21wbGV0ZUVtaXR0ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZWRpdGluZ0NvbXBsZXRlRW1pdHRlcih7XHJcbiAgICAgICAgICAgICAgICBDbGljazogbnVsbCxcclxuICAgICAgICAgICAgICAgIFBvbHlnb246IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBPcmlnaW5hbFBhdGg6IHRoaXMuX29yaWdpbmFsUGF0aCxcclxuICAgICAgICAgICAgICAgIE5ld1BhdGg6IHRoaXMuR2V0UGF0aHMoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxQYXRoID0gdGhpcy5HZXRQYXRocygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvbHlnb24gb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElMYXRMb25nfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gVGhlIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGh0ZSBvbmVzXHJcbiAgICAgKiBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRPcHRpb25zKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLlBvbHlnb25PcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWdvbk9wdGlvbnMob3B0aW9ucyk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygby5lZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5TZXRFZGl0YWJsZShvLmVkaXRhYmxlKTtcclxuICAgICAgICAgICAgZGVsZXRlIG8uZWRpdGFibGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9wb2x5Z29uLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmlzaWJsZSAhPSBudWxsICYmIHRoaXMuX3Nob3dMYWJlbCAmJiB0aGlzLl9sYWJlbCkgeyB0aGlzLl9sYWJlbC5TZXQoJ2hpZGRlbicsICFvcHRpb25zLnZpc2libGUpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb2x5Z29uIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlnb25zIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFBhdGgocGF0aDogQXJyYXk8SUxhdExvbmc+KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcDogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPiA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+KCk7XHJcbiAgICAgICAgcGF0aC5mb3JFYWNoKHggPT4gcC5wdXNoKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoeC5sYXRpdHVkZSwgeC5sb25naXR1ZGUpKSk7XHJcbiAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRQYXRoKHApO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsUGF0aCA9IFtwYXRoXTtcclxuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2VudHJvaWQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwb2x5Z29uIHBhdGggb3IgcGF0aHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGhzIEFuIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ31cclxuICAgICAqIChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlnb25zIHBhdGgocykuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFBhdGhzKHBhdGhzOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+IHwgQXJyYXk8SUxhdExvbmc+KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHBhdGhzID09IG51bGwpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhzKSkgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAocGF0aHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvbHlnb24uc2V0UGF0aHMobmV3IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4oKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwuRGVsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoc1swXSkpIHtcclxuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIGFycmF5c1xyXG4gICAgICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+PiA9IG5ldyBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+PigpO1xyXG4gICAgICAgICAgICAoPEFycmF5PEFycmF5PElMYXRMb25nPj4+cGF0aHMpLmZvckVhY2gocGF0aCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBfcDogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPiA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+KCk7XHJcbiAgICAgICAgICAgICAgICBwYXRoLmZvckVhY2goeCA9PiBfcC5wdXNoKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoeC5sYXRpdHVkZSwgeC5sb25naXR1ZGUpKSk7XHJcbiAgICAgICAgICAgICAgICBwLnB1c2goX3ApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRQYXRocyhwKTtcclxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxQYXRoID0gPEFycmF5PEFycmF5PElMYXRMb25nPj4+cGF0aHM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2VudHJvaWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5NYW5hZ2VMYWJlbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIGlzIGEgc2ltcGxlIGFycmF5Li4uLlxyXG4gICAgICAgICAgICB0aGlzLlNldFBhdGgoPEFycmF5PElMYXRMb25nPj5wYXRocyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZpc2libGUgLSBUcnVlIHRvIHNldCB0aGUgcG9seWdvbiB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3BvbHlnb24uc2V0VmlzaWJsZSh2aXNpYmxlKTtcclxuICAgICAgICBpZiAodGhpcy5fc2hvd0xhYmVsICYmIHRoaXMuX2xhYmVsKSB7IHRoaXMuX2xhYmVsLlNldCgnaGlkZGVuJywgIXZpc2libGUpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGxhYmVsIGZvciB0aGUgcG9seWdvblxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBNYW5hZ2VMYWJlbCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5HZXRQYXRoID09IG51bGwgfHwgdGhpcy5HZXRQYXRoKCkubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmICh0aGlzLl9zaG93TGFiZWwgJiYgdGhpcy5fdGl0bGUgIT0gbnVsbCAmJiB0aGlzLl90aXRsZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgY29uc3QgbzogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3RpdGxlLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0KHRoaXMuQ2VudHJvaWQpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChvLnBvc2l0aW9uID09IG51bGwpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9taW5ab29tICE9PSAtMSkgeyBvLm1pblpvb20gPSB0aGlzLl9taW5ab29tOyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXhab29tICE9PSAtMSkgeyBvLm1heFpvb20gPSB0aGlzLl9tYXhab29tOyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBvLm1hcCA9IHRoaXMuTmF0aXZlUHJpbWl0dmUuZ2V0TWFwKCk7XHJcbiAgICAgICAgICAgICAgICBvLnpJbmRleCA9IHRoaXMuTmF0aXZlUHJpbWl0dmUuekluZGV4ID8gdGhpcy5OYXRpdmVQcmltaXR2ZS56SW5kZXggKyAxIDogMTAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBuZXcgR29vZ2xlTWFwTGFiZWwobyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5TZXRWYWx1ZXMobyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGFiZWwuU2V0KCdoaWRkZW4nLCAhdGhpcy5HZXRWaXNpYmxlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5TZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25maWd1cmVzIHRoZSB0b29sdGlwIGZvciB0aGUgcG9seWdvblxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBNYW5hZ2VUb29sdGlwKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zaG93VG9vbHRpcCAmJiB0aGlzLl90aXRsZSAhPSBudWxsICYmIHRoaXMuX3RpdGxlICE9PSAnJykge1xyXG4gICAgICAgICAgICBjb25zdCBvOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fdGl0bGUsXHJcbiAgICAgICAgICAgICAgICBhbGlnbjogJ2xlZnQnLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoMCwgMjUpLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmlzcXVlJyxcclxuICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcclxuICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogJyMwMDAwMDAnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG8ubWFwID0gdGhpcy5OYXRpdmVQcmltaXR2ZS5nZXRNYXAoKTtcclxuICAgICAgICAgICAgICAgIG8uekluZGV4ID0gMTAwMDAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcCA9IG5ldyBHb29nbGVNYXBMYWJlbChvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0VmFsdWVzKG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU92ZXJMaXN0ZW5lciA9IHRoaXMuTmF0aXZlUHJpbWl0dmUuYWRkTGlzdGVuZXIoJ21vdXNlb3ZlcicsIChlOiBHb29nbGVNYXBUeXBlcy5Nb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ3Bvc2l0aW9uJywgZS5sYXRMbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIgPSB0aGlzLk5hdGl2ZVByaW1pdHZlLmFkZExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZTogR29vZ2xlTWFwVHlwZXMuTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwVmlzaWJsZSkgeyB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBlLmxhdExuZyk7IH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VPdXRMaXN0ZW5lciA9IHRoaXMuTmF0aXZlUHJpbWl0dmUuYWRkTGlzdGVuZXIoJ21vdXNlb3V0JywgKGU6IEdvb2dsZU1hcFR5cGVzLk1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKCF0aGlzLl9zaG93VG9vbHRpcCB8fCB0aGlzLl90aXRsZSA9PT0gJycgfHwgdGhpcy5fdGl0bGUgPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlT3V0TGlzdGVuZXIpIHsgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5fbW91c2VPdXRMaXN0ZW5lcik7IH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU92ZXJMaXN0ZW5lcikgeyBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9tb3VzZU92ZXJMaXN0ZW5lcik7IH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcikgeyBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcik7IH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldE1hcChudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IEdvb2dsZUNvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1jb252ZXJzaW9ucyc7XHJcbmltcG9ydCAqIGFzIEdvb2dsZU1hcFR5cGVzIGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLXR5cGVzJztcclxuaW1wb3J0IHsgR29vZ2xlTWFwTGFiZWwgfSBmcm9tICcuL2dvb2dsZS1sYWJlbCc7XHJcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vcG9seWxpbmUnO1xyXG5cclxuZGVjbGFyZSB2YXIgZ29vZ2xlOiBhbnk7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gZm9yIGEgcG9seWxpbmUgbW9kZWwgZm9yIEdvb2dsZSBNYXBzLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR29vZ2xlUG9seWxpbmUgZXh0ZW5kcyBQb2x5bGluZSBpbXBsZW1lbnRzIFBvbHlsaW5lIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfdGl0bGU6IHN0cmluZyA9ICcnO1xyXG4gICAgcHJpdmF0ZSBfc2hvd1Rvb2x0aXA6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3Rvb2x0aXA6IEdvb2dsZU1hcExhYmVsID0gbnVsbDtcclxuICAgIHByaXZhdGUgX3Rvb2x0aXBWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9oYXNUb29sVGlwUmVjZWl2ZXI6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX21vdXNlT3Zlckxpc3RlbmVyOiBHb29nbGVNYXBUeXBlcy5NYXBzRXZlbnRMaXN0ZW5lciA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9tb3VzZU91dExpc3RlbmVyOiBHb29nbGVNYXBUeXBlcy5NYXBzRXZlbnRMaXN0ZW5lciA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9tb3VzZU1vdmVMaXN0ZW5lcjogR29vZ2xlTWFwVHlwZXMuTWFwc0V2ZW50TGlzdGVuZXIgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfbWV0YWRhdGE6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5bGluZSBtZXRhZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE1ldGFkYXRhKCk6IE1hcDxzdHJpbmcsIGFueT4geyByZXR1cm4gdGhpcy5fbWV0YWRhdGE7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBwcmltaXR2ZSBpbXBsZW1lbnRpbmcgdGhlIG1hcmtlciwgaW4gdGhpcyBjYXNlIHtAbGluayBHb29nbGVNQXBUeXBlcy5Qb2x5bGluZX1cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTmF0aXZlUHJpbWl0dmUoKTogR29vZ2xlTWFwVHlwZXMuUG9seWxpbmUgeyByZXR1cm4gdGhpcy5fcG9seWxpbmU7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRvIHNob3cgdGhlIHRvb2x0aXBcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBTaG93VG9vbHRpcCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3Nob3dUb29sdGlwOyB9XHJcbiAgICBwdWJsaWMgc2V0IFNob3dUb29sdGlwKHZhbDogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuX3Nob3dUb29sdGlwID0gdmFsO1xyXG4gICAgICAgIHRoaXMuTWFuYWdlVG9vbHRpcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB0aXRsZSBvZmYgdGhlIHBvbHlnb25cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBUaXRsZSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fdGl0bGU7IH1cclxuICAgIHB1YmxpYyBzZXQgVGl0bGUodmFsOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl90aXRsZSA9IHZhbDtcclxuICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBjb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVQb2x5Z29uLlxyXG4gICAgICogQHBhcmFtIF9wb2x5bGluZSAtIFRoZSB7QGxpbmsgR29vZ2xlTUFwVHlwZXMuUG9seWxpbmV9IHVuZGVybHlpbmcgdGhlIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wb2x5bGluZTogR29vZ2xlTWFwVHlwZXMuUG9seWxpbmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGRlbGVnYXRlIGZvciBhbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gZm4gLSBEZWxlZ2F0ZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEV2ZW50cyA9IFtcclxuICAgICAgICAgICAgJ2NsaWNrJyxcclxuICAgICAgICAgICAgJ2RibGNsaWNrJyxcclxuICAgICAgICAgICAgJ2RyYWcnLCAnZHJhZ2VuZCcsXHJcbiAgICAgICAgICAgICdkcmFnc3RhcnQnLFxyXG4gICAgICAgICAgICAnbW91c2Vkb3duJyxcclxuICAgICAgICAgICAgJ21vdXNlbW92ZScsXHJcbiAgICAgICAgICAgICdtb3VzZW91dCcsXHJcbiAgICAgICAgICAgICdtb3VzZW92ZXInLFxyXG4gICAgICAgICAgICAnbW91c2V1cCcsXHJcbiAgICAgICAgICAgICdyaWdodGNsaWNrJ1xyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKHN1cHBvcnRlZEV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lLmFkZExpc3RlbmVyKGV2ZW50VHlwZSwgZm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZWQgdGhlIHBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZS5zZXRNYXAobnVsbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXApIHsgdGhpcy5fdG9vbHRpcC5EZWxldGUoKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyBkcmFnZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5bGluZSBpcyBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0RHJhZ2dhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5bGluZS5nZXREcmFnZ2FibGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWxpbmUgcGF0aCBjYW4gYmUgZWRpdGVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcGF0aCBjYW4gYmUgZWRpdGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRFZGl0YWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWxpbmUuZ2V0RWRpdGFibGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlsaW5lIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IG9iamVjdHMgZGVzY3JpYmluZyB0aGUgcG9seWxpbmUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFBhdGgoKTogQXJyYXk8SUxhdExvbmc+IHtcclxuICAgICAgICBjb25zdCBwOiBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+ID0gdGhpcy5fcG9seWxpbmUuZ2V0UGF0aCgpO1xyXG4gICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PElMYXRMb25nPiA9IG5ldyBBcnJheTxJTGF0TG9uZz4oKTtcclxuICAgICAgICBwLmZvckVhY2goeCA9PiBwYXRoLnB1c2goeyBsYXRpdHVkZTogeC5sYXQoKSwgbG9uZ2l0dWRlOiB4LmxuZygpIH0pKTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWxpbmUgaXMgdmlzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBvbHlsaW5lIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lLmdldFZpc2libGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0aGUgcG9seWxpbmUgaXMgZHJhZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFrZSB0aGUgcG9seWxpbmUgZHJhZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2V0aGVyIHRoZSBwb2x5bGluZSBwYXRoIGlzIGVkaXRhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlZGl0YWJsZSAtIFRydWUgdG8gbWFrZSBwb2x5bGluZSBwYXRoIGVkaXRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvbHlsaW5lIG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIFRoZSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBodGUgb25lc1xyXG4gICAgICogYWxyZWFkeSBvbiB0aGUgdW5kZXJseWluZyBtb2RlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLlBvbHlsaW5lT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlsaW5lT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZS5zZXRPcHRpb25zKG8pO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnBhdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5TZXRQYXRoKDxBcnJheTxJTGF0TG9uZz4+b3B0aW9ucy5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb2x5bGluZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gQW4gQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfSAob3IgYXJyYXkgb2YgYXJyYXlzKSBkZXNjcmliaW5nIHRoZSBwb2x5bGluZXMgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFBhdGgocGF0aDogQXJyYXk8SUxhdExvbmc+KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcDogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPiA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+KCk7XHJcbiAgICAgICAgcGF0aC5mb3JFYWNoKHggPT4gcC5wdXNoKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoeC5sYXRpdHVkZSwgeC5sb25naXR1ZGUpKSk7XHJcbiAgICAgICAgdGhpcy5fcG9seWxpbmUuc2V0UGF0aChwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0aGUgcG9seWxpbmUgaXMgdmlzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSAtIFRydWUgdG8gc2V0IHRoZSBwb2x5bGluZSB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZS5zZXRWaXNpYmxlKHZpc2libGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHRvb2x0aXAgZm9yIHRoZSBwb2x5bGluZVxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgTWFuYWdlVG9vbHRpcCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fc2hvd1Rvb2x0aXAgJiYgdGhpcy5fdGl0bGUgIT0gbnVsbCAmJiB0aGlzLl90aXRsZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgY29uc3QgbzogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3RpdGxlLFxyXG4gICAgICAgICAgICAgICAgYWxpZ246ICdsZWZ0JyxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogbmV3IGdvb2dsZS5tYXBzLlBvaW50KDAsIDI1KSxcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2Jpc3F1ZScsXHJcbiAgICAgICAgICAgICAgICBoaWRkZW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgICAgICBmb250Q29sb3I6ICcjMDAwMDAwJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBvLm1hcCA9IHRoaXMuTmF0aXZlUHJpbWl0dmUuZ2V0TWFwKCk7XHJcbiAgICAgICAgICAgICAgICBvLnpJbmRleCA9IDEwMDAwMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAgPSBuZXcgR29vZ2xlTWFwTGFiZWwobyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldFZhbHVlcyhvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VPdmVyTGlzdGVuZXIgPSB0aGlzLk5hdGl2ZVByaW1pdHZlLmFkZExpc3RlbmVyKCdtb3VzZW92ZXInLCAoZTogR29vZ2xlTWFwVHlwZXMuTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGUubGF0TG5nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyID0gdGhpcy5OYXRpdmVQcmltaXR2ZS5hZGRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGU6IEdvb2dsZU1hcFR5cGVzLk1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHsgdGhpcy5fdG9vbHRpcC5TZXQoJ3Bvc2l0aW9uJywgZS5sYXRMbmcpOyB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlT3V0TGlzdGVuZXIgPSB0aGlzLk5hdGl2ZVByaW1pdHZlLmFkZExpc3RlbmVyKCdtb3VzZW91dCcsIChlOiBHb29nbGVNYXBUeXBlcy5Nb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCghdGhpcy5fc2hvd1Rvb2x0aXAgfHwgdGhpcy5fdGl0bGUgPT09ICcnIHx8IHRoaXMuX3RpdGxlID09IG51bGwpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU91dExpc3RlbmVyKSB7IGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX21vdXNlT3V0TGlzdGVuZXIpOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VPdmVyTGlzdGVuZXIpIHsgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5fbW91c2VPdmVyTGlzdGVuZXIpOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpIHsgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpOyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSU1hcEV2ZW50TG9va3VwIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFwLWV2ZW50LWxvb2t1cCc7XHJcblxyXG4vKipcclxuICogVGhpcyBjb250c3RhbnQgdHJhbnNsYXRlcyB0aGUgYWJzdHJhY3QgbWFwIGV2ZW50cyBpbnRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgZ29vZ2xlIG1hcFxyXG4gKiBlcXVpdmFsZW50cy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBHb29nbGVNYXBFdmVudHNMb29rdXA6IElNYXBFdmVudExvb2t1cCA9IHtcclxuICAgIGNsaWNrIDogICAgICAgICAgICAgJ2NsaWNrJyxcclxuICAgIGRibGNsaWNrIDogICAgICAgICAgJ2RibGNsaWNrJyxcclxuICAgIHJpZ2h0Y2xpY2sgOiAgICAgICAgJ3JpZ2h0Y2xpY2snLFxyXG4gICAgcmVzaXplIDogICAgICAgICAgICAncmVzaXplJyxcclxuICAgIGJvdW5kc2NoYW5nZWQgOiAgICAgJ2JvdW5kc19jaGFuZ2VkJyxcclxuICAgIGNlbnRlcmNoYW5nZWQgOiAgICAgJ2NlbnRlcl9jaGFuZ2VkJyxcclxuICAgIHpvb21jaGFuZ2VkIDogICAgICAgJ3pvb21fY2hhbmdlZCcsXHJcbiAgICBtb3VzZW92ZXI6ICAgICAgICAgICdtb3VzZW92ZXInLFxyXG4gICAgbW91c2VvdXQgOiAgICAgICAgICAnbW91c2VvdXQnLFxyXG4gICAgbW91c2Vtb3ZlIDogICAgICAgICAnbW91c2Vtb3ZlJyxcclxuICAgIGluZm93aW5kb3djbG9zZTogICAgJ2Nsb3NlY2xpY2snXHJcbn07XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IEdvb2dsZUNvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1jb252ZXJzaW9ucyc7XHJcbmltcG9ydCB7IENhbnZhc092ZXJsYXkgfSBmcm9tICcuLi9jYW52YXMtb3ZlcmxheSc7XHJcbmltcG9ydCB7IE1hcExhYmVsIH0gZnJvbSAnLi4vbWFwLWxhYmVsJztcclxuaW1wb3J0IHsgR29vZ2xlTWFwTGFiZWwgfSBmcm9tICcuL2dvb2dsZS1sYWJlbCc7XHJcbmltcG9ydCAqIGFzIEdvb2dsZU1hcFR5cGVzIGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLXR5cGVzJztcclxuaW1wb3J0IHsgRXh0ZW5kZXIgfSBmcm9tICcuLi9leHRlbmRlcic7XHJcbmRlY2xhcmUgdmFyIGdvb2dsZTogYW55O1xyXG5cclxuLyoqXHJcbiAqIENvbmNyZXRlIGltcGxlbWVudGluZyBhIGNhbnZhcyBvdmVybGF5IHRvIGJlIHBsYWNlZCBvbiB0aGUgbWFwIGZvciBHb29nbGUgTWFwcy5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdvb2dsZUNhbnZhc092ZXJsYXkgZXh0ZW5kcyBDYW52YXNPdmVybGF5IHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBmaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfdmlld0NoYW5nZUVuZEV2ZW50OiBHb29nbGVNYXBUeXBlcy5NYXBzRXZlbnRMaXN0ZW5lcjtcclxuICAgIHByaXZhdGUgX21hcFJlc2l6ZUV2ZW50OiBHb29nbGVNYXBUeXBlcy5NYXBzRXZlbnRMaXN0ZW5lcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEdvb2dsZUNhbnZhc092ZXJsYXkgY2xhc3MuXHJcbiAgICAgKiBAcGFyYW0gZHJhd0NhbGxiYWNrIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlYWR5IHRvIGJlXHJcbiAgICAgKiByZW5kZXJlZCBmb3IgdGhlIGN1cnJlbnQgbWFwIHZpZXcuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2FudmFzT3ZlcmxheVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihkcmF3Q2FsbGJhY2s6IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB2b2lkKSB7XHJcbiAgICAgICAgc3VwZXIoZHJhd0NhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDYW52YXNPdmVybGF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRDb29yZGluYXRlc0Zyb21DbGljayhlOiBHb29nbGVNYXBUeXBlcy5Nb3VzZUV2ZW50KTogSUxhdExvbmcge1xyXG4gICAgICAgIGlmICghZSkgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgICAgIGlmICghZS5sYXRMbmcpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICBpZiAoIWUubGF0TG5nLmxhdCB8fCAhZS5sYXRMbmcubG5nKSB7IHJldHVybiBudWxsOyB9XHJcbiAgICAgICAgcmV0dXJuIHsgbGF0aXR1ZGU6IGUubGF0TG5nLmxhdCgpLCBsb25naXR1ZGU6IGUubGF0TG5nLmxuZygpIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXAgYXNzb2NpdGVkIHdpdGggdGhlIGxhYmVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRNYXAoKTogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwIHtcclxuICAgICAgICByZXR1cm4gKDxhbnk+dGhpcykuZ2V0TWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTWFwTGFiZWwgaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50IHBsYXRmb3JtIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSB0b29sdGlwLlxyXG4gICAgICogVGhpcyBtZXRob2Qgb25seSBnZW5lcmF0ZXMgdGhlIG1hcCBsYWJlbC4gQ29udGVudCBhbmQgcGxhY2VtZW50IGlzIHRoZSByZXNwb25zaWJpbGl0eVxyXG4gICAgICogb2YgdGhlIGNhbGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBsYWJlbCB0byBiZSB1c2VkIGZvciB0aGUgdG9vbHRpcC5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRUb29sVGlwT3ZlcmxheSgpOiBNYXBMYWJlbCB7XHJcbiAgICAgICAgY29uc3QgbzogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHtcclxuICAgICAgICAgICAgYWxpZ246ICdsZWZ0JyxcclxuICAgICAgICAgICAgb2Zmc2V0OiBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoMCwgMjUpLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiaXNxdWUnLFxyXG4gICAgICAgICAgICBoaWRkZW46IHRydWUsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcclxuICAgICAgICAgICAgZm9udENvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgby56SW5kZXggPSAxMDAwMDA7XHJcbiAgICAgICAgY29uc3QgbGFiZWw6IE1hcExhYmVsID0gbmV3IEdvb2dsZU1hcExhYmVsKG8pO1xyXG4gICAgICAgIGxhYmVsLlNldE1hcCh0aGlzLkdldE1hcCgpKTtcclxuICAgICAgICByZXR1cm4gbGFiZWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY3VzdG9tIG92ZXJsYXkgaXMgYWRkZWQgdG8gdGhlIG1hcC4gVHJpZ2dlcnMgT25sb2FkLi4uLlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNhbnZhc092ZXJsYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIE9uQWRkKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLk9uQWRkKCk7XHJcbiAgICAgICAgdGhpcy5PbkxvYWQoKTtcclxuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuekluZGV4ID0gJzEwMCc7XHJcbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIGNhbnZhcyBhYm92ZSBwcmltaXRpdmVzIHN1Y2ggYXMgcG9seWdvbnMuXHJcblxyXG4gICAgICAgIC8vIHNldCB0aGUgb3ZlcmxheSB0byByZWFkeSBzdGF0ZVxyXG4gICAgICAgIHRoaXMuX3JlYWR5UmVzb2x2ZXIodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIGNhbnZhcyBuZWVkcyB0byBiZSByZWRyYXduLiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBkbyB0aGUgYWN0dWFsXHJcbiAgICAgKiB1cGRhdGUsIGl0IHNpbXBseSBzY2FsZXMgdGhlIGNhbnZhcy4gVGhlIGFjdHVhbCByZWRyYXcgaGFwcGVucyBvbmNlIHRoZSBtYXAgaXMgaWRsZS5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDYW52YXNPdmVybHlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIE9uRHJhdygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBpc1N0cmVldFZpZXc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCA9IHRoaXMuR2V0TWFwKCk7XHJcblxyXG4gICAgICAgIGlmIChpc1N0cmVldFZpZXcpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3Qgc2hvdyB0aGUgY2FudmFzIGlmIHRoZSBtYXAgaXMgaW4gU3RyZWV0c2lkZSBtb2RlLlxyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJlLWRyYXdpbmcgdGhlIGNhbnZhcyBhcyBpdCBtb3ZlcyB3b3VsZCBiZSB0b28gc2xvdy4gSW5zdGVhZCwgc2NhbGUgYW5kIHRyYW5zbGF0ZSBjYW52YXMgZWxlbWVudC5cclxuICAgICAgICAgICAgLy8gVXBvbiBpZGxlIG9yIGRyYWcgZW5kLCB3ZSBjYW4gdGhlbiByZWRyYXcgdGhlIGNhbnZhcy4uLi5cclxuICAgICAgICAgICAgY29uc3Qgem9vbUN1cnJlbnQ6IG51bWJlciA9IG1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlckN1cnJlbnQ6IEdvb2dsZU1hcFR5cGVzLkxhdExuZyA9IG1hcC5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBtYXAgc2NhbGUgYmFzZWQgb24gem9vbSBsZXZlbCBkaWZmZXJlbmNlLlxyXG4gICAgICAgICAgICBjb25zdCBzY2FsZTogbnVtYmVyID0gTWF0aC5wb3coMiwgem9vbUN1cnJlbnQgLSB0aGlzLl96b29tU3RhcnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzY2FsZWQgZGltZW5zaW9ucyBvZiB0aGUgY2FudmFzLlxyXG4gICAgICAgICAgICBjb25zdCBlbDogSFRNTERpdkVsZW1lbnQgPSBtYXAuZ2V0RGl2KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHc6IG51bWJlciA9IGVsLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBoOiBudW1iZXIgPSBlbC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1dpZHRoOiBudW1iZXIgPSB3ICogc2NhbGU7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodDogbnVtYmVyID0gaCAqIHNjYWxlO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG9mZnNldCBvZiBjYW52YXMgYmFzZWQgb24gem9vbSBhbmQgY2VudGVyIG9mZnNldHMuXHJcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSAoPGFueT50aGlzKS5nZXRQcm9qZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNjID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbChjZW50ZXJDdXJyZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY2FudmFzIENTUyBwb3NpdGlvbiBhbmQgZGltZW5zaW9ucy5cclxuICAgICAgICAgICAgdGhpcy5VcGRhdGVQb3NpdGlvbihjYy54IC0gbmV3V2lkdGggLyAyLCBjYy55IC0gbmV3SGVpZ2h0IC8gMiwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FudmFzT3ZlcmxheSBsb2FkZWQsIGF0dGFjaCBtYXAgZXZlbnRzIGZvciB1cGRhdGluZyBjYW52YXMuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2FudmFzT3ZlcmxheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgT25Mb2FkKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGlzU3RyZWV0VmlldzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwID0gKDxhbnk+dGhpcykuZ2V0TWFwKCk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBtYXAgdmlldyBpbmZvcm1hdGlvbi5cclxuICAgICAgICB0aGlzLl96b29tU3RhcnQgPSBtYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IGM6IEdvb2dsZU1hcFR5cGVzLkxhdExuZyA9IG1hcC5nZXRDZW50ZXIoKTtcclxuICAgICAgICB0aGlzLl9jZW50ZXJTdGFydCA9IHtcclxuICAgICAgICAgICAgbGF0aXR1ZGU6IGMubGF0KCksXHJcbiAgICAgICAgICAgIGxvbmdpdHVkZTogYy5sbmcoKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFdoZW4gdGhlIG1hcCBzdG9wcyBtb3ZpbmcsIHJlbmRlciBuZXcgZGF0YSBvbiB0aGUgY2FudmFzLlxyXG4gICAgICAgIHRoaXMuX3ZpZXdDaGFuZ2VFbmRFdmVudCA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ2lkbGUnLCAoZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuVXBkYXRlQ2FudmFzKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcbiAgICAgICAgdGhpcy5fbWFwUmVzaXplRXZlbnQgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdyZXNpemUnLCAoZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuVXBkYXRlQ2FudmFzKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBc3NvY2lhdGVzIHRoZSBjbmF2YXMgb3ZlcmxheSB3aXRoIGEgbWFwLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNhbnZhc092ZXJsYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE1hcChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCk6IHZvaWQge1xyXG4gICAgICAgICg8YW55PnRoaXMpLnNldE1hcChtYXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIHRoZSBjYW52YXMgdG8gdGhlIG1hcC5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBTZXRDYW52YXNFbGVtZW50KGVsOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHBhbmVzID0gKDxhbnk+dGhpcykuZ2V0UGFuZXMoKTtcclxuICAgICAgICBpZiAocGFuZXMpIHtcclxuICAgICAgICAgICAgaWYgKGVsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHBhbmVzLm92ZXJsYXlMYXllci5hcHBlbmRDaGlsZChlbCk7XHJcbiAgICAgICAgICAgICAgICAvLyA0OiBmbG9hdFBhbmUgKGluZm93aW5kb3cpXHJcbiAgICAgICAgICAgICAgICAvLyAzOiBvdmVybGF5TW91c2VUYXJnZXQgKG1vdXNlIGV2ZW50cylcclxuICAgICAgICAgICAgICAgIC8vIDI6IG1hcmtlckxheWVyIChtYXJrZXIgaW1hZ2VzKVxyXG4gICAgICAgICAgICAgICAgLy8gMTogb3ZlcmxheUxheWVyIChwb2x5Z29ucywgcG9seWxpbmVzLCBncm91bmQgb3ZlcmxheXMsIHRpbGUgbGF5ZXIgb3ZlcmxheXMpXHJcbiAgICAgICAgICAgICAgICAvLyAwOiBtYXBQYW5lIChsb3dlc3QgcGFuZSBhYm92ZSB0aGUgbWFwIHRpbGVzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFuZXMub3ZlcmxheUxheWVyLnJlbW92ZUNoaWxkKHRoaXMuX2NhbnZhcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgdGhlIG1hcCBldmVudCBoYW5kbGVycy5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBSZW1vdmVFdmVudEhhbmRsZXJzKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgZXZlbnQgaGFuZGxlcnMgZnJvbSB0aGUgbWFwLlxyXG4gICAgICAgIGlmICh0aGlzLl92aWV3Q2hhbmdlRW5kRXZlbnQpIHsgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5fdmlld0NoYW5nZUVuZEV2ZW50KTsgfVxyXG4gICAgICAgIGlmICh0aGlzLl9tYXBSZXNpemVFdmVudCkgeyBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9tYXBSZXNpemVFdmVudCk7IH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIENhbnZhcyBzaXplIGJhc2VkIG9uIHRoZSBtYXAgc2l6ZS5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBSZXNpemUoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXAgPSAoPGFueT50aGlzKS5nZXRNYXAoKTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgY2FudmFzIGJ5IHVwZGF0aW5nIGRpbWVuc2lvbnMuIFRoaXMgYWxzbyBlbnN1cmVzIGNhbnZhcyBzdGF5cyB0aGUgc2FtZSBzaXplIGFzIHRoZSBtYXAuXHJcbiAgICAgICAgY29uc3QgZWw6IEhUTUxEaXZFbGVtZW50ID0gbWFwLmdldERpdigpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IGVsLm9mZnNldFdpZHRoO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBDYW52YXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgVXBkYXRlQ2FudmFzKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwID0gKDxhbnk+dGhpcykuZ2V0TWFwKCk7XHJcblxyXG4gICAgICAgIC8vIE9ubHkgcmVuZGVyIHRoZSBjYW52YXMgaWYgaXQgaXNuJ3QgaW4gc3RyZWV0c2lkZSBtb2RlLlxyXG4gICAgICAgIGlmICh0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXNldCBDU1MgcG9zaXRpb24gYW5kIGRpbWVuc2lvbnMgb2YgY2FudmFzLlxyXG4gICAgICAgICAgICBjb25zdCBlbDogSFRNTERpdkVsZW1lbnQgPSBtYXAuZ2V0RGl2KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHc6IG51bWJlciA9IGVsLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBoOiBudW1iZXIgPSBlbC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlclBvaW50ID0gKDxhbnk+dGhpcykuZ2V0UHJvamVjdGlvbigpLmZyb21MYXRMbmdUb0RpdlBpeGVsKG1hcC5nZXRDZW50ZXIoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuVXBkYXRlUG9zaXRpb24oKGNlbnRlclBvaW50LnggLSB3IC8gMiksIChjZW50ZXJQb2ludC55IC0gaCAvIDIpLCB3LCBoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlZHJhdyB0aGUgY2FudmFzLlxyXG4gICAgICAgICAgICB0aGlzLlJlZHJhdyh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBtYXAgdmlldyBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgdGhpcy5fem9vbVN0YXJ0ID0gbWFwLmdldFpvb20oKTtcclxuICAgICAgICAgICAgY29uc3QgYzogR29vZ2xlTWFwVHlwZXMuTGF0TG5nID0gbWFwLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9jZW50ZXJTdGFydCA9IHtcclxuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiBjLmxhdCgpLFxyXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBjLmxuZygpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGV4dGVuZCB0aGUgT3ZlcmxheVZpZXcgaW50byB0aGUgQ2FudmFzT3ZlcmxheVxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBtZXRob2RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBNaXhpbkNhbnZhc092ZXJsYXkoKSB7XHJcblxyXG4gICAgbmV3IEV4dGVuZGVyKEdvb2dsZUNhbnZhc092ZXJsYXkpXHJcbiAgICAgICAgLkV4dGVuZChuZXcgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcpXHJcbiAgICAgICAgLk1hcCgnb25BZGQnLCAnT25BZGQnKVxyXG4gICAgICAgIC5NYXAoJ2RyYXcnLCAnT25EcmF3JylcclxuICAgICAgICAuTWFwKCdvblJlbW92ZScsICdPblJlbW92ZScpO1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi9tYXJrZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEluZm9Cb3hTZXJ2aWNlIH0gZnJvbSAnLi9pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuL2xheWVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDbHVzdGVyU2VydmljZSB9IGZyb20gJy4vY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUG9seWdvblNlcnZpY2UgfSBmcm9tICcuL3BvbHlnb24uc2VydmljZSc7XHJcbmltcG9ydCB7IFBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4vcG9seWxpbmUuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyBhIGZhY3RvcnkgdG8gY3JlYXRlIGFsbCB0aGUgaW1wbGVtZW50YXRpb24gc3BlY2lmYyBzZXJ2aWNlcyBmb3IgYSBtYXAgaW1wbGVtZW50YXRpb25cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE1hcFNlcnZpY2VGYWN0b3J5IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIG1hcCBzZXJ2aWNlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50aW5nIGEgc3BlY2lmaWMgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDcmVhdGUoKTogTWFwU2VydmljZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIGNsdXN0ZXIgc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIENsdXN0ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZUZhY3RvcnlcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgQ3JlYXRlQ2x1c3RlclNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlKTogQ2x1c3RlclNlcnZpY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBpbmZvIGJveCBzZXJ2aWNlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFwIGFyY2h0aWN0dXJlLlxyXG4gICAgICogQHBhcmFtIG1hcmtlciAtIHtAbGluayBNYXJrZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFya2VyIGFyY2h0aWN0dXJlLlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSW5mb0JveFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDcmVhdGVJbmZvQm94U2VydmljZShtYXA6IE1hcFNlcnZpY2UsIG1hcmtlcjogTWFya2VyU2VydmljZSk6IEluZm9Cb3hTZXJ2aWNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgbGF5ZXIgc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIExheWVyU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZUxheWVyU2VydmljZShtYXA6IE1hcFNlcnZpY2UpOiBMYXllclNlcnZpY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBtYXJrZXIgc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqIEBwYXJhbSBjbHVzdGVycyAgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgTWFya2VyU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZU1hcmtlclNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSwgY2x1c3RlcnM6IENsdXN0ZXJTZXJ2aWNlKTogTWFya2VyU2VydmljZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIHBvbHlnb24gc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIFBvbHlnb25TZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZUZhY3RvcnlcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgQ3JlYXRlUG9seWdvblNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSk6IFBvbHlnb25TZXJ2aWNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgcG9seWxpbmUgc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIFBvbHlsaW5lU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZVBvbHlsaW5lU2VydmljZShtYXA6IE1hcFNlcnZpY2UsIGxheWVyczogTGF5ZXJTZXJ2aWNlKTogUG9seWxpbmVTZXJ2aWNlO1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJTWFwT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcC1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pc2l6ZSc7XHJcbmltcG9ydCB7IElCb3ggfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lib3gnO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlcic7XHJcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vbW9kZWxzL2xheWVyJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vbW9kZWxzL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uL21vZGVscy9jYW52YXMtb3ZlcmxheSc7XHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgY2xhc3MgdG8gaW1wbGVtZW50IG1hcCBhcGkuIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIGJlIGNyZWF0ZWQgZm9yIGVhY2hcclxuICogTWFwIHByb3ZpZGVyIHN1cHBvcnRlZCAoZS5nLiBCaW5nLCBHb29sZ2UsIEVTUkkpXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNYXBTZXJ2aWNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgcHJvcGVydGllc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBNYXAgY29udHJvbCBpbnN0YW5jZSB1bmRlcmx5aW5nIHRoZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0IE1hcEluc3RhbmNlKCk6IGFueTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBQcm9taXNlIGZvciBhIE1hcCBjb250cm9sIGluc3RhbmNlIHVuZGVybHlpbmcgdGhlIGltcGxlbWVudGF0aW9uLiBVc2UgdGhpcyBpbnN0ZWFkIG9mIHtAbGluayBNYXBJbnN0YW5jZX0gaWYgeW91XHJcbiAgICAgKiBhcmUgbm90IHN1cmUgaWYgYW5kIHdoZW4gdGhlIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0IE1hcFByb21pc2UoKTogUHJvbWlzZTxhbnk+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbWFwcyBwaHlzaWNhbCBzaXplLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBnZXQgTWFwU2l6ZSgpOiBJU2l6ZTtcclxuXHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHMgYW5kIE1hcFNlcnZpY2UgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSByYW5kb20gZ2VvIGxvY2F0aW9ucyBmaWxsaW5nIHRoZSBib3VuZGluZyBib3guXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvdW50IC0gbnVtYmVyIG9mIGxvY2F0aW9ucyB0byByZXR1cm5cclxuICAgICAqIEBwYXJhbSBib3VuZHMgIC0gYm91bmRpbmcgYm94LlxyXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiBnZW8gbG9jYXRpb25zLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHZXRSYW5kb25Mb2NhdGlvbnMoY291bnQ6IG51bWJlciwgYm91bmRzOiBJQm94KTogQXJyYXk8SUxhdExvbmc+IHtcclxuICAgICAgICBjb25zdCBhOiBBcnJheTxJTGF0TG9uZz4gPSBbXTtcclxuICAgICAgICBjb25zdCBfZ2V0UmFuZG9tTG9jYXRpb24gPSAoYjogSUJveCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsYXQ6IG51bWJlciA9IE1hdGgucmFuZG9tKCkgKiAoYi5tYXhMYXRpdHVkZSAtIGIubWluTGF0aXR1ZGUpICsgYi5taW5MYXRpdHVkZTtcclxuICAgICAgICAgICAgbGV0IGxuZzogbnVtYmVyID0gMDtcclxuICAgICAgICAgICAgaWYgKGNyb3NzZXNEYXRlTGluZSkge1xyXG4gICAgICAgICAgICAgICAgbG5nID0gTWF0aC5yYW5kb20oKSAqIChiLm1pbkxvbmdpdHVkZSArIDM2MCAtIGIubWF4TG9uZ2l0dWRlKSArIGIubWF4TG9uZ2l0dWRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxuZyA+IDE4MCkgeyBsbmcgPSBsbmcgLSAzNjA7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxuZyA9IE1hdGgucmFuZG9tKCkgKiAoYi5tYXhMb25naXR1ZGUgLSBiLm1pbkxvbmdpdHVkZSkgKyBiLm1pbkxvbmdpdHVkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwOiBJTGF0TG9uZyA9IHsgbGF0aXR1ZGU6IGxhdCwgbG9uZ2l0dWRlOiBsbmcgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgY3Jvc3Nlc0RhdGVMaW5lOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmIChib3VuZHMgPT0gbnVsbCkgeyBib3VuZHMgPSA8SUJveD57XHJcbiAgICAgICAgICAgICAgICBtYXhMYXRpdHVkZTogMzYwLFxyXG4gICAgICAgICAgICAgICAgbWluTGF0aXR1ZGU6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXhMb25naXR1ZGU6IDE3MCxcclxuICAgICAgICAgICAgICAgIG1pbkxvbmdpdHVkZTogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYm91bmRzLmNlbnRlci5sb25naXR1ZGUgPCBib3VuZHMubWluTG9uZ2l0dWRlICB8fCBib3VuZHMuY2VudGVyLmxvbmdpdHVkZSA+IGJvdW5kcy5tYXhMb25naXR1ZGUpIHsgY3Jvc3Nlc0RhdGVMaW5lID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmICghY291bnQgfHwgY291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW19nZXRSYW5kb21Mb2NhdGlvbihib3VuZHMpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBjb3VudDsgcisrKSB7IGEucHVzaChfZ2V0UmFuZG9tTG9jYXRpb24oYm91bmRzKSk7IH1cclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjYW52YXMgb3ZlcmxheSBsYXllciB0byBwZXJmb3JtIGN1c3RvbSBkcmF3aW5nIG92ZXIgdGhlIG1hcCB3aXRoIG91dFxyXG4gICAgICogc29tZSBvZiB0aGUgb3ZlcmhlYWQgYXNzb2NpYXRlZCB3aXRoIGdvaW5nIHRocm91Z2ggdGhlIE1hcCBvYmplY3RzLlxyXG4gICAgICogQHBhcmFtIGRyYXdDYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbnZhcyBpcyByZWFkeSB0byBiZVxyXG4gICAgICogcmVuZGVyZWQgZm9yIHRoZSBjdXJyZW50IG1hcCB2aWV3LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIENhbnZhc092ZXJsYXl9IG9iamVjdC5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IENyZWF0ZUNhbnZhc092ZXJsYXkoZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZCk6IFByb21pc2U8Q2FudmFzT3ZlcmxheT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGNsdXN0ZXIgbGF5ZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLiBTZWUge0BsaW5rIElDbHVzdGVyT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTGF5ZXJ9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBsYXllciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgQ3JlYXRlQ2x1c3RlckxheWVyKG9wdGlvbnM6IElMYXllck9wdGlvbnMpOiBQcm9taXNlPExheWVyPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5mb3JtYXRpb24gd2luZG93IGZvciBhIG1hcCBwb3NpdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBbb3B0aW9uc10gLSBJbmZvd2luZG93IG9wdGlvbnMuIFNlZSB7QGxpbmsgSUluZm9XaW5kb3dPcHRpb25zfVxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIEluZm9XaW5kb3d9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdHZpZSBpbmZvYm94IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDcmVhdGVJbmZvV2luZG93KG9wdGlvbnM/OiBJSW5mb1dpbmRvd09wdGlvbnMpOiBQcm9taXNlPEluZm9XaW5kb3c+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG1hcCBsYXllciB3aXRoaW4gdGhlIG1hcCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuIFNlZSB7QGxpbmsgSUxheWVyT3B0aW9uc31cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBMYXllcn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgbmF0aXZlIGxheWVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDcmVhdGVMYXllcihvcHRpb25zOiBJTGF5ZXJPcHRpb25zKTogUHJvbWlzZTxMYXllcj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVsIC0gSFRNTCBlbGVtZW50IHRvIGhvc3QgdGhlIG1hcC5cclxuICAgICAqIEBwYXJhbSBtYXBPcHRpb25zIC0gTWFwIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIG1hcCBoYXMgYmVlbiBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZU1hcChlbDogSFRNTEVsZW1lbnQsIG1hcE9wdGlvbnM6IElNYXBPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXAgbWFya2VyIHdpdGhpbiB0aGUgbWFwIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW29wdGlvbnM9PElNYXJrZXJPcHRpb25zPnt9XSAtIE9wdGlvbnMgZm9yIHRoZSBtYXJrZXIuIFNlZSB7QGxpbmsgSU1hcmtlck9wdGlvbnN9LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIE1hcmtlcn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgbmF0aXZlIHB1c2hwaW4gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZU1hcmtlcihvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IFByb21pc2U8TWFya2VyPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBwb2x5Z29uIHdpdGhpbiB0aGUgbWFwIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHBvbHlnb24uIFNlZSB7QGxpbmsgSVBvbHlnb25PcHRpb25zfS5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBQb2x5Z29ufSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBuYXRpdmUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDcmVhdGVQb2x5Z29uKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8UG9seWdvbj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcG9seWxpbmUgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcG9seWxpbmUuIFNlZSB7QGxpbmsgSVBvbHlsaW5lT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgUG9seWxpbmV9IG9iamVjdCAob3IgYW4gYXJyYXkgdGhlcmVvZiBmb3IgY29tcGxleCBwYXRocyksXHJcbiAgICAgKiB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgbmF0aXZlIHBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZVBvbHlsaW5lKG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGEgbGF5ZXIgZnJvbSB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIExheWVyIHRvIGRlbGV0ZS4gU2VlIHtAbGluayBMYXllcn0uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgZnVsbGZpbGxlZCB3aGVuIHRoZSBsYXllciBoYXMgYmVlbiByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IERlbGV0ZUxheWVyKGxheWVyOiBMYXllcik6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYW9zZSB0aGUgbWFwIGFuZCBhc3NvY2lhdGVkIHJlc291cmVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IERpc3Bvc2VNYXAoKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgbWFwIGJvdW5kc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHNjcmVlbi4gU2VlIHtAbGluayBJQm94fS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBHZXRCb3VuZHMoKTogUHJvbWlzZTxJQm94PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgbWFwIGNlbnRlclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBnb2UgbG9jYXRpb24gb2YgdGhlIGNlbnRlci4gU2VlIHtAbGluayBJTGF0TG9uZ30uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgR2V0Q2VudGVyKCk6IFByb21pc2U8SUxhdExvbmc+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHpvb20gbGV2ZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgR2V0Wm9vbSgpOiBQcm9taXNlPG51bWJlcj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aWRlcyBhIGNvbnZlcnNpb24gb2YgZ2VvIGNvb3JkaW5hdGVzIHRvIHBpeGVscyBvbiB0aGUgbWFwIGNvbnRyb2wuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvYyAtIFRoZSBnZW8gY29vcmRpbmF0ZXMgdG8gdHJhbnNsYXRlLlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGFuIHtAbGluayBJUG9pbnR9IGludGVyZmFjZSByZXByZXNlbnRpbmcgdGhlIHBpeGVscy4gVGhpcyBwcm9taXNlIHJlc29sdmVzIHRvIG51bGxcclxuICAgICAqIGlmIHRoZSBnb2UgY29vcmRpbmF0ZXMgYXJlIG5vdCBpbiB0aGUgdmlldyBwb3J0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IExvY2F0aW9uVG9Qb2ludChsb2M6IElMYXRMb25nKTogUHJvbWlzZTxJUG9pbnQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSBjb252ZXJzaW9uIG9mIGdlbyBjb29yZGluYXRlcyB0byBwaXhlbHMgb24gdGhlIG1hcCBjb250cm9sLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2MgLSBUaGUgZ2VvIGNvb3JkaW5hdGVzIHRvIHRyYW5zbGF0ZS5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhbiB7QGxpbmsgSVBvaW50fSBpbnRlcmZhY2UgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgTG9jYXRpb25zVG9Qb2ludHMobG9jczogQXJyYXk8SUxhdExvbmc+KTogUHJvbWlzZTxBcnJheTxJUG9pbnQ+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENlbnRlcnMgdGhlIG1hcCBvbiBhIGdlbyBsb2NhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF0TG5nIC0gR2VvQ29vcmRpbmF0ZXMgYXJvdW5kIHdoaWNoIHRvIGNlbnRlciB0aGUgbWFwLiBTZWUge0BsaW5rIElMYXRMb25nfVxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBjZW50ZXIgb3BlcmF0aW9ucyBoYXMgYmVlbiBjb21wbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgU2V0Q2VudGVyKGxhdExuZzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZ2VuZXJpYyBtYXAgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IFNldE1hcE9wdGlvbnMob3B0aW9uczogSU1hcE9wdGlvbnMpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmlldyBvcHRpb25zIG9mIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBTZXRWaWV3T3B0aW9ucyhvcHRpb25zOiBJTWFwT3B0aW9ucyk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHpvb20gLSBab29tIGxldmVsIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBQcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCBvbmNlIHRoZSB6b29tIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBTZXRab29tKHpvb206IG51bWJlcik6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGV2ZW50IHN1YnNjcmlwdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKGUuZy4gJ2NsaWNrJylcclxuICAgICAqIEByZXR1cm5zIC0gQW4gb2JzZXJ2YWJsZSBvZiB0cHllIEUgdGhhdCBmaXJlcyB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgU3Vic2NyaWJlVG9NYXBFdmVudDxFPihldmVudE5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8RT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyB0aGUgZ2l2ZW4gZXZlbnQgbmFtZSBvbiB0aGUgbWFwIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBFdmVudCB0byB0cmlnZ2VyLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIG9uY2UgdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBUcmlnZ2VyTWFwRXZlbnQoZXZlbnROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvaW50JztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlcic7XHJcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvbWFwLW1hcmtlcic7XHJcblxyXG4vKipcclxuICogVGhlIGFic3RyYWN0IGNsYXNzIHJlcHJlc2VudHMgdGhlIGNvbnRyYWN0IGRlZmludGlvbnMgZm9yIGEgbWFya2VyIHNlcnZpY2UgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYW4gYWN1dGFseSB1bmRlcmx5aW5nXHJcbiAqIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNYXJrZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBtYXJrZXIuIERlcGVuZGluZyBvbiB0aGUgbWFya2VyIGNvbnRleHQsIHRoZSBtYXJrZXIgd2lsbCBlaXRoZXIgYnkgYWRkZWQgdG8gdGhlIG1hcCBvciBhIGNvcnJlY3Nwb25kaW5nIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG1hcmtlciAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSB0byBiZSBhZGRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIChlLmcuICdjbGljaycpXHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0gVGhlIHtAbGluayBNYXBNYXJrZXJ9IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgYSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0ge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgbWFya2VyIGhhcyBiZWVuIGRlbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IERlbGV0ZU1hcmtlcihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlciBvbiB0aGUgY2xpY2sgbG9jYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnR8IGFueSk6IElMYXRMb25nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgbWFya2VyIG1vZGVsIGZvciB0aGUgbWFya2VyIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IGZvciB3aGljaCB0byBvYnRhaW4gdGhlIG1hcmtlciBtb2RlbC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSB7QGxpbmsgTWFya2VyfSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0TmF0aXZlTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTxNYXJrZXI+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgbWFya2VyIHBpeGVsIGxvY2F0aW9uIGZvciB0aGUgbWFya2VyIG9uIHRoZSBjbGljayBsb2NhdGlvblxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgcGl4ZWxzIG9mIHRoZSBtYXJrZXIgb24gdGhlIG1hcCBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldFBpeGVsc0Zyb21DbGljayhlOiBNb3VzZUV2ZW50fCBhbnkpOiBJUG9pbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIGdlbyBsb2NhdGlvbiB0byBhIHBpeGVsIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBtYXAgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHRhcmdldCAtIEVpdGhlciBhIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9yIGEge0BsaW5rIElMYXRMb25nfVxyXG4gICAgICogZm9yIHRoZSBiYXNpcyBvZiB0cmFuc2xhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIGEge0BsaW5rIElQb2ludH1cclxuICAgICAqIHdpdGggdGhlIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSBNYXBNYXJrZXJEaXJlY3RpdmUgb3IgSUxhdExvbmcgcmVsYXRpdmUgdG8gdGhlIG1hcCBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IExvY2F0aW9uVG9Qb2ludCh0YXJnZXQ6IE1hcE1hcmtlckRpcmVjdGl2ZSB8IElMYXRMb25nKTogUHJvbWlzZTxJUG9pbnQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYW5jaG9yIHBvc2l0aW9uIGZvciB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIGFuY2hvci5cclxuICAgICAqIEFuY2hvciBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBhbmNob3IgcG9zaXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlQW5jaG9yKG1ha2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB3aGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgZHJhZ2FiaWxpdHkuXHJcbiAgICAgKiBEcmFnYWJpbGl0eSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBtYXJrZXIgaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlRHJhZ2dhYmxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIEljb24gb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBpY29uLlxyXG4gICAgICogSWNvbiBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpY29uIGluZm9ybWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZUljb24obWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgbGFiZWwgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBsYWJlbC5cclxuICAgICAqIExhYmVsIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGxhYmVsIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZUxhYmVsKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBjb29yZGluYXRlcy5cclxuICAgICAqIENvb3JkaW5hdGUgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgcG9zaXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlTWFya2VyUG9zaXRpb24obWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgdGl0bGUgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSB0aXRsZS5cclxuICAgICAqIFRpdGxlIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIHRpdGxlIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZVRpdGxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZpc2liaWxpdHkgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSB2aXNpYmlsaXR5LlxyXG4gICAgICogVmlzaWJpbGl0eSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZVZpc2libGUobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSW5mb0JveENvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW5mb2JveCc7XHJcbmltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vbW9kZWxzL2luZm8td2luZG93JztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGRlZmluZXMgdGhlIGNvbnRyYWN0IGZvciBhbiBJbmZvQm94U2VydmljZS4gRWFjaCBNYXAgQXJjaGl0ZWN0dXJlIHByb3ZpZGVyIGlzIGV4cGVjdGVkIHRoZSBmdXJuaXNoIGEgY29uY3JldGUgaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbmZvQm94U2VydmljZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGluZm8gd2luZG93IHRvIHRoZSBtYXAgb3IgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgQWRkSW5mb1dpbmRvdyhpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyBhbiBpbmZvYm94IHRoYXQgaXMgb3Blbi5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGluZm9ib3ggaGFzIGJlZW4gY2xvc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDbG9zZShpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSB0byBldmVudHMgb24gdGhlIGluZm93aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIChlLmcuICdjbGljaycpXHJcbiAgICAgKiBAcGFyYW0gaW5mb0NvbXBvbmVudCAtIFRoZSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZUV2ZW50T2JzZXJ2YWJsZTxUPihldmVudDogc3RyaW5nLCBpbmZvQm94Q29tcG9uZW50OiBJbmZvQm94Q29tcG9uZW50KTogT2JzZXJ2YWJsZTxUPjtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGFuIGluZm9ib3guXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpbmZvYm94IGhhcyBiZWVuIGRlbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IERlbGV0ZUluZm9XaW5kb3coaW5mbzogSW5mb0JveENvbXBvbmVudCk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBhbiBpbmZvYm94IHRoYXQgaXMgY2xvc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGluZm8gLSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gY29tcG9uZW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluZm9ib3guXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBoYXMgYmVlbiBvcGVuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IE9wZW4oaW5mbzogSW5mb0JveENvbXBvbmVudCwgbG9jPzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaW5mb2JveCBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGluZm8gLSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gY29tcG9uZW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluZm9ib3guXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJSW5mb1dpbmRvd09wdGlvbnN9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zIHRvIHNldC4gT3B0aW9ucyBwcm92aWRlZCBhcmVcclxuICAgICAqIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBvcHRpb25zIG9mIHRoZSB1bmRlcmx5aW5nIGluZm9ib3guXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBvcHRpb25zIGhhdmUgYmVlbiB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBTZXRPcHRpb25zKGluZm86IEluZm9Cb3hDb21wb25lbnQsIG9wdGlvbnM6IElJbmZvV2luZG93T3B0aW9ucyk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBpbmZvYm94IGJhc2VkIG9uIHRoZSBwcm9wZXJ0aWVzIHNldCBvbiB0aGUgSW5mb0JveCBjb21wb25lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cclxuICAgICAqIEBwYXJhbSBsYXRsbmcgLSBUaGUgcG9zaXRpb24gdG8gc2V0XHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBwb3NpdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBTZXRQb3NpdGlvbihpbmZvOiBJbmZvQm94Q29tcG9uZW50LCBsYXRsbmc/OiBJTGF0TG9uZyk6IFByb21pc2U8dm9pZD47XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTWFya2VySWNvbkluZm8gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItaWNvbi1pbmZvJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlcic7XHJcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi9tb2RlbHMvcG9seWdvbic7XHJcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vbW9kZWxzL3BvbHlsaW5lJztcclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9tb2RlbHMvbGF5ZXInO1xyXG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvbWFwLWxheWVyJztcclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBjbGFzcyB0byB0byBkZWZpbmUgdGhlIGxheWVyIHNlcnZpY2UgY29udHJhY3QuIE11c3QgYmUgcmVhbGl6ZWQgYnkgaW1wbGVtZW50aW5nIHByb3ZpZGVyLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTGF5ZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBsYXllciB0byB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gTWFwTGF5ZXJEaXJlY3RpdmUgY29tcG9uZW50IG9iamVjdC5cclxuICAgICAqIEdlbmVyYWxseSwgTWFwTGF5ZXJEaXJlY3RpdmUgd2lsbCBiZSBpbmplY3RlZCB3aXRoIGFuIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgICogTGF5ZXJTZXJ2aWNlIGFuZCB0aGVuIHNlbGYgcmVnaXN0ZXIgb24gaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBtYXJrZXIgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIG1hcmtlci5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTWFya2VyIG9wdGlvbnMgZGVmaW5pbmcgdGhlIG1hcmtlci5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgTWFya2VyIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IENyZWF0ZU1hcmtlcihsYXllcjogbnVtYmVyLCBvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IFByb21pc2U8TWFya2VyPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBtYXJrZXJzLiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFycmF5cyBvZiBtYXJrZXJzIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTWFya2VyIG9wdGlvbnMgZGVmaW5pbmcgdGhlIG1hcmtlcnMuXHJcbiAgICAgKiBAcGFyYW0gbWFya2VySWNvbiAtIE9wdGlvbmFsIGluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGN1c3RvbSBtYXJrZXJzLiBUaGlzIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgbWFya2Vycy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIE1hcmtlciBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlTWFya2VycyhvcHRpb25zOiBBcnJheTxJTWFya2VyT3B0aW9ucz4sIG1hcmtlckljb24/OiBJTWFya2VySWNvbkluZm8pOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHBvbHlnb24gdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIGxpbmUuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlnb24gb3B0aW9ucyBkZWZpbmluZyB0aGUgbGluZS5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgUG9seWdvbiBtb2RlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBDcmVhdGVQb2x5Z29uKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8UG9seWdvbj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuYm91bmQgcG9seWdvbnMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIHBvbHlnb25zIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29ucy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIFBvbHlnb24gbW9kZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IENyZWF0ZVBvbHlnb25zKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBwb2x5bGluZSB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgbGluZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgbWFya2VyLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGluc3RhbmNlIG9mIHRoZSBQb2x5bGluZSAob3IgYW5cclxuICAgICAqIGFycmF5IG9mIHBvbHlsaW5lcyBmb3IgY29tcGxleCBwYXRocykgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlUG9seWxpbmUobGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIHBvbHlsaW5lcy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWxpbmVzIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWxpbmVzLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5bGluZSBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5bGluZXMuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBQb2x5bGluZSBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlUG9seWxpbmVzKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5bGluZU9wdGlvbnM+KTogUHJvbWlzZTxBcnJheTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIGxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbGF5ZXIgaGFzIGJlZW4gcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBEZWxldGVMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgTGF5ZXIgbW9kZWwgcmVwcmVzZW50ZWQgYnkgdGhpcyBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIE1hcExheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3Qgb3IgTWFwTGF5ZXJJZCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGxheWVyIG1vZGVsLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIHJlc29sdmVkIGNvbnRhaW5zIHRoZSBMYXllciBtb2RlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXROYXRpdmVMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmV8bnVtYmVyKTogUHJvbWlzZTxMYXllcj47XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgTWFwUG9seWdvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvbWFwLXBvbHlnb24nO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBhYnN0cmFjdCBjbGFzcyByZXByZXNlbnRzIHRoZSBjb250cmFjdCBkZWZpbnRpb25zIGZvciBhIHBvbHlnb24gc2VydmljZSB0byBiZSBpbXBsZW1lbnRlZCBieSBhbiBhY3V0YWx5IHVuZGVybHlpbmdcclxuICogbWFwIGFyY2hpdGVjdHVyZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBvbHlnb25TZXJ2aWNlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIHBvbHlnb24gdG8gYSBtYXAuIERlcGVuZGluZyBvbiB0aGUgcG9seWdvbiBjb250ZXh0LCB0aGUgcG9seWdvbiB3aWxsIGVpdGhlciBieSBhZGRlZCB0byB0aGUgbWFwIG9yIGFcclxuICAgKiBjb3JyZWNzcG9uZGluZyBsYXllci5cclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSBhZGRlZC5cclxuICAgKlxyXG4gICAqIEBtZW1iZXJvZiBQb2x5Z29uU2VydmljZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBhYnN0cmFjdCBBZGRQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGRlbGVnYXRlIGZvciBhIG1hcmtlci5cclxuICAgICpcclxuICAgICogQGFic3RyYWN0XHJcbiAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcclxuICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgZXZlbnQuXHJcbiAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAqXHJcbiAgICAqIEBtZW1iZXJvZiBQb2x5Z29uU2VydmljZVxyXG4gICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPjtcclxuXHJcbiAgLyoqXHJcbiAgICAqIERlbGV0ZXMgYSBwb2x5Z29uLlxyXG4gICAgKlxyXG4gICAgKiBAYWJzdHJhY3RcclxuICAgICogQHBhcmFtIHBvbHlnb24gLSB7QGxpbmsgTWFwUG9seWdvbkRpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cclxuICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIGhhcyBiZWVuIGRlbGV0ZWQuXHJcbiAgICAqXHJcbiAgICAqIEBtZW1iZXJvZiBQb2x5Z29uU2VydmljZVxyXG4gICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgRGVsZXRlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgLyoqXHJcbiAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIgb24gdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cclxuICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cclxuICAgKlxyXG4gICAqIEBtZW1iZXJvZiBNYXJrZXJTZXJ2aWNlXHJcbiAgICovXHJcbiAgcHVibGljIGFic3RyYWN0IEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnQgfCBhbnkpOiBJTGF0TG9uZztcclxuXHJcbiAgLyoqXHJcbiAgICogT2J0YWlucyB0aGUgcG9seWdvbiBtb2RlbCBmb3IgdGhlIHBvbHlnb24gYWxsb3dpbmcgYWNjZXNzIHRvIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBmdW5jdGlvbmF0aWxpeS5cclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gb2J0YWluIHRoZSBwb2x5Z29uIG1vZGVsLlxyXG4gICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSB7QGxpbmsgUG9seWdvbn0gaW1wbGVtZW50YXRpb24gb2YgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm0uXHJcbiAgICpcclxuICAgKiBAbWVtYmVyb2YgUG9seWdvblNlcnZpY2VcclxuICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgR2V0TmF0aXZlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5Z29uPjtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBwb2x5Z29uIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcGFyYW0gcG9seWdvbiAtIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElQb2x5Z29uT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcclxuICAgKiBvcHRpb25zIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0LlxyXG4gICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWdvbiBvcHRpb25zIGhhdmUgYmVlbiBzZXQuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyb2YgUG9seWdvblNlcnZpY2VcclxuICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgU2V0T3B0aW9ucyhwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlLCBvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBQb2x5Z29uIHBhdGhcclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwYXJhbSBwb2x5Z29uIC0ge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXHJcbiAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyb2YgUG9seWdvblNlcnZpY2VcclxuICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IE1hcFBvbHlsaW5lRGlyZWN0aXZlIH0gZnJvbSAnLi4vY29tcG9uZW50cy9tYXAtcG9seWxpbmUnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBhYnN0cmFjdCBjbGFzcyByZXByZXNlbnRzIHRoZSBjb250cmFjdCBkZWZpbnRpb25zIGZvciBhIHBvbHlsaW5lIHNlcnZpY2UgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYW4gYWN1dGFseSB1bmRlcmx5aW5nXHJcbiAqIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQb2x5bGluZVNlcnZpY2Uge1xyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gYSBtYXAuIERlcGVuZGluZyBvbiB0aGUgcG9seWxpbmUgY29udGV4dCwgdGhlIHBvbHlsaW5lIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxyXG4gICAqIGNvcnJlY3Nwb25kaW5nIGxheWVyLlxyXG4gICAqXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgYWRkZWQuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyb2YgUG9seWxpbmVTZXJ2aWNlXHJcbiAgICovXHJcbiAgcHVibGljIGFic3RyYWN0IEFkZFBvbHlsaW5lKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgZGVsZWdhdGUgZm9yIGEgbWFya2VyLlxyXG4gICAgKlxyXG4gICAgKiBAYWJzdHJhY3RcclxuICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxyXG4gICAgKiBAcGFyYW0gcG9seWxpbmUgLSBUaGUge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxyXG4gICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgKlxyXG4gICAgKiBAbWVtYmVyb2YgUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAqL1xyXG4gIHB1YmxpYyBhYnN0cmFjdCBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IE9ic2VydmFibGU8VD47XHJcblxyXG4gIC8qKlxyXG4gICAgKiBEZWxldGVzIGEgcG9seWxpbmUuXHJcbiAgICAqXHJcbiAgICAqIEBhYnN0cmFjdFxyXG4gICAgKiBAcGFyYW0gcG9seWxpbmUgLSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgaGFzIGJlZW4gZGVsZXRlZC5cclxuICAgICpcclxuICAgICogQG1lbWJlcm9mIFBvbHlsaW5lU2VydmljZVxyXG4gICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgRGVsZXRlUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgLyoqXHJcbiAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIgb24gdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cclxuICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cclxuICAgKlxyXG4gICAqIEBtZW1iZXJvZiBNYXJrZXJTZXJ2aWNlXHJcbiAgICovXHJcbiAgcHVibGljIGFic3RyYWN0IEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnQgfCBhbnkpOiBJTGF0TG9uZztcclxuXHJcbiAgLyoqXHJcbiAgICogT2J0YWlucyB0aGUgcG9seWxpbmUgbW9kZWwgZm9yIHRoZSBwb2x5bGluZSBhbGxvd2luZyBhY2Nlc3MgdG8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uYXRpbGl5LlxyXG4gICAqXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgcG9seWxpbmUgbW9kZWwuXHJcbiAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBQb2x5bGluZX0gaW1wbGVtZW50YXRpb24gKG9yIGFuXHJcbiAgICogYXJyYXkgb2YgcG9seWxpbmVzKSBmb3IgY29tcGxleCBwYXRocyBvZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybS5cclxuICAgKlxyXG4gICAqIEBtZW1iZXJvZiBQb2x5bGluZVNlcnZpY2VcclxuICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgR2V0TmF0aXZlUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+O1xyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHBvbHlsaW5lIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcGFyYW0gcG9seWxpbmUgLSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSVBvbHlsaW5lT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcclxuICAgKiBvcHRpb25zIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0LlxyXG4gICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgb3B0aW9ucyBoYXZlIGJlZW4gc2V0LlxyXG4gICAqXHJcbiAgICogQG1lbWJlcm9mIFBvbHlsaW5lU2VydmljZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBhYnN0cmFjdCBTZXRPcHRpb25zKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSwgb3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIFBvbHlsaW5lIHBhdGhcclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwYXJhbSBwb2x5bGluZSAtIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgdXBkYXRlZC5cclxuICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlsaW5lIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyb2YgUG9seWxpbmVTZXJ2aWNlXHJcbiAgICovXHJcbiAgcHVibGljIGFic3RyYWN0IFVwZGF0ZVBvbHlsaW5lKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD47XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTWFya2VySWNvbkluZm8gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItaWNvbi1pbmZvJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlcic7XHJcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vbW9kZWxzL2xheWVyJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuLi9jb21wb25lbnRzL2NsdXN0ZXItbGF5ZXInO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuL2xheWVyLnNlcnZpY2UnO1xyXG5cclxuLyoqXHJcbiAqIEFic3RyYWN0IGNsYXNzIHRvIHRvIGRlZmluZSB0ZWggY2x1c3RlciBsYXllciBzZXJ2aWNlIGNvbnRyYWN0LiBNdXN0IGJlIHJlYWxpemVkIGJ5IGltcGxlbWVudGluZyBwcm92aWRlci5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENsdXN0ZXJTZXJ2aWNlIGV4dGVuZHMgTGF5ZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgaW5pdGlhbCBzZXQgb2YgZW50aXRpZXNcclxuICAgICAqIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgY2x1c3Rlci4gVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBhcyBhZGRpbmcgYW4gZW50aXRpeSB3aWxsIHJlY2FsY3VsYXRlIGFsbCBjbHVzdGVycy5cclxuICAgICAqIEFzIHN1Y2gsIFN0b3BDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGFkZGluZyBtYW55IGVudGl0aWVzIGFuZCBTdGFydENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIGFkZGluZyBpc1xyXG4gICAgICogY29tcGxldGUgdG8gcmVjYWxjdWxhdGUgdGhlIGNsdXN0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIENsdXN0ZXJMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTdGFydENsdXN0ZXJpbmcobGF5ZXI6IENsdXN0ZXJMYXllckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgYXMgYWRkaW5nIGFuIGVudGl0aXkgd2lsbCByZWNhbGN1bGF0ZSBhbGwgY2x1c3RlcnMuXHJcbiAgICAgKiBBcyBzdWNoLCBTdG9wQ2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgbWFueSBlbnRpdGllcyBhbmQgU3RhcnRDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgb25jZSBhZGRpbmcgaXNcclxuICAgICAqIGNvbXBsZXRlIHRvIHJlY2FsY3VsYXRlIHRoZSBjbHVzdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgY29tcG9uZW50IG9iamVjdCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU3RvcENsdXN0ZXJpbmcobGF5ZXI6IENsdXN0ZXJMYXllckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD47XHJcblxyXG59XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vKipcclxuICogSW5mb0JveEFjdGlvbiByZW5kZXJzIGFuIGFjdGlvbiBpbiBhbiBpbmZvIHdpbmRvdyB7QGxpbmsgSW5mb0JveH1cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50LCBNYXBNYXJrZXJEaXJlY3RpdmUsIEluZm9Cb3hDb21wb25lbnQsIEluZm9Cb3hBY3Rpb25EaXJlY3RpdmV9IGZyb20gJy4uLic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcclxuICogIHN0eWxlczogW2BcclxuICogICAgLm1hcC1jb250YWluZXIgeyBoZWlnaHQ6IDMwMHB4OyB9XHJcbiAqICBgXSxcclxuICogIHRlbXBsYXRlOiBgXHJcbiAqICAgIDx4LW1hcCBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbWm9vbV09XCJ6b29tXCI+XHJcbiAqICAgICAgPHgtbWFwLW1hcmtlciBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbTGFiZWxdPVwiJ00nXCI+XHJcbiAqICAgICAgICA8eC1pbmZvLWJveD5cclxuICogICAgICAgICAgPHgtaW5mby1ib3gtYWN0aW9uIFtMYWJlbF09XCJhY3Rpb25sYWJlbFwiIChBY3Rpb25DbGlja2VkKT1cImFjdGlvbkNsaWNrZWQodGhpcylcIj48L3gtaW5mby1ib3gtYWN0aW9uPlxyXG4gKiAgICAgICAgPC94LWluZm8tYm94PlxyXG4gKiAgICAgIDwveC1tYXAtbWFya2VyPlxyXG4gKiAgICA8L3gtbWFwPlxyXG4gKiAgYFxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ3gtaW5mby1ib3gtYWN0aW9uJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGFiZWwgdG8gZGlzcGxheSBvbiB0aGUgYWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hBY3Rpb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgIExhYmVsOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBhY3Rpb24gaGFzIGJlZW4gY2xpY2tlZFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94QWN0aW9uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgQWN0aW9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gICAgQWZ0ZXJWaWV3SW5pdCxcclxuICAgIENvbXBvbmVudCxcclxuICAgIENvbnRlbnRDaGlsZHJlbixcclxuICAgIEVsZW1lbnRSZWYsXHJcbiAgICBFdmVudEVtaXR0ZXIsXHJcbiAgICBJbnB1dCxcclxuICAgIE9uQ2hhbmdlcyxcclxuICAgIE9uRGVzdHJveSxcclxuICAgIE91dHB1dCxcclxuICAgIFF1ZXJ5TGlzdCxcclxuICAgIFNpbXBsZUNoYW5nZSxcclxuICAgIFZpZXdDaGlsZCxcclxuICAgIFZpZXdFbmNhcHN1bGF0aW9uXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJbmZvQm94U2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2luZm9ib3guc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4vbWFwLW1hcmtlcic7XHJcbmltcG9ydCB7IEluZm9Cb3hBY3Rpb25EaXJlY3RpdmUgfSBmcm9tICcuL2luZm9ib3gtYWN0aW9uJztcclxuXHJcbi8qKlxyXG4gKiBpbnRlcm5hbCBjb3VudGVyIHRvIHVzZSBhcyBpZHMgZm9yIG11bHRpcGxlIGluZm9ib3hlcy5cclxuICovXHJcbmxldCBpbmZvQm94SWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIEluZm9Cb3ggcmVuZGVycyBhIGluZm8gd2luZG93IGluc2lkZSBhIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9yIHN0YW5kYWxvbmUuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG4gKiBpbXBvcnQge01hcENvbXBvbmVudCwgTWFwTWFya2VyRGlyZWN0aXZlLCBJbmZvQm94Q29tcG9uZW50LCBJbmZvQm94QWN0aW9uRGlyZWN0aXZlfSBmcm9tICcuLi4nO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXHJcbiAqICBzdHlsZXM6IFtgXHJcbiAqICAgIC5tYXAtY29udGFpbmVyIHsgaGVpZ2h0OiAzMDBweDsgfVxyXG4gKiBgXSxcclxuICogIHRlbXBsYXRlOiBgXHJcbiAqICAgIDx4LW1hcCBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbWm9vbV09XCJ6b29tXCI+XHJcbiAqICAgICAgPHgtbWFwLW1hcmtlciBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbTGFiZWxdPVwiJ00nXCI+XHJcbiAqICAgICAgICA8eC1pbmZvLWJveCBbRGlzYWJsZUF1dG9QYW5dPVwidHJ1ZVwiPlxyXG4gKiAgICAgICAgICBIaSwgdGhpcyBpcyB0aGUgY29udGVudCBvZiB0aGUgPHN0cm9uZz5pbmZvIHdpbmRvdzwvc3Ryb25nPlxyXG4gKiAgICAgICAgIDwveC1pbmZvLWJveD5cclxuICogICAgICAgPC94LW1hcC1tYXJrZXI+XHJcbiAqICAgICA8L3gtbWFwPlxyXG4gKiAgYFxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3gtaW5mby1ib3gnLFxyXG4gICAgdGVtcGxhdGU6IGBcclxuICAgICAgICA8ZGl2ICNpbmZvQm94Q29udGVudCBjbGFzcz0naW5mby1ib3gtY29udGVudCc+XHJcbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuICAgICAgICA8L2Rpdj5gLFxyXG4gICAgc3R5bGVzOiBbYFxyXG4gICAgICAgIHgtbWFwIC5NaWNyb3NvZnRNYXAgLkluZm9ib3ggLmluZm9ib3gtdGl0bGUgeyBwYWRkaW5nOiAxMHB4IDEwcHggNXB4IDEwcHggfVxyXG4gICAgICAgIHgtbWFwIC5NaWNyb3NvZnRNYXAgLkluZm9ib3ggLmluZm9ib3gtaW5mbyB7IHBhZGRpbmc6IDNweCAxMHB4IDEwcHggMTBweCB9XHJcbiAgICAgICAgeC1tYXAgLk1pY3Jvc29mdE1hcCAuSW5mb2JveCAuaW5mb2JveC1hY3Rpb25zIHsgaGVpZ2h0OiBhdXRvIH1cclxuICAgIGBdLFxyXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxyXG59KVxyXG5leHBvcnQgY2xhc3MgSW5mb0JveENvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0IHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfaW5mb0JveEFkZGVkVG9NYW5hZ2VyID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9pZDogc3RyaW5nID0gKGluZm9Cb3hJZCsrKS50b1N0cmluZygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSFRNTCBjb25lbnQgb2YgdGhlIGluZm9ib3hcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBAVmlld0NoaWxkKCdpbmZvQm94Q29udGVudCcpIHByaXZhdGUgX2NvbnRlbnQ6IEVsZW1lbnRSZWY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBaZXJvIG9yIG1vcmUgYWN0aW9ucyB0byBzaG93IG9uIHRoZSBpbmZvIHdpbmRvd1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBDb250ZW50Q2hpbGRyZW4oSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSkgcHVibGljIEluZm9XaW5kb3dBY3Rpb25zOiBRdWVyeUxpc3Q8SW5mb0JveEFjdGlvbkRpcmVjdGl2ZT47XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxhdGl0dWRlIHBvc2l0aW9uIG9mIHRoZSBpbmZvIHdpbmRvdyAob25seSB1c2VmdWxsIGlmIHlvdSB1c2UgaXQgb3VzaWRlIG9mIGEge0BsaW5rIE1hcE1hcmtlcn0pLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYXRpdHVkZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvbmdpdHVkZSBwb3NpdGlvbiBvZiB0aGUgaW5mbyB3aW5kb3cgKG9ubHkgdXNlZnVsbCBpZiB5b3UgdXNlIGl0IG91c2lkZSBvZiBhIHtAbGluayBNYXBNYXJrZXJ9KS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTG9uZ2l0dWRlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGl0bGUgdG8gZGlzcGxheSBpbiB0aGUgaW5mbyB3aW5kb3dcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVGl0bGU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiB0byBkaXNwbGF5IGluIHRoZSBpbmZvIHdpbmRvdy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgRGVzY3JpcHRpb246IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGUgYXV0by1wYW4gb24gb3Blbi4gQnkgZGVmYXVsdCwgdGhlIGluZm8gd2luZG93IHdpbGwgcGFuIHRoZSBtYXAgc28gdGhhdCBpdCBpcyBmdWxseVxyXG4gICAgICogdmlzaWJsZSB3aGVuIGl0IG9wZW5zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBEaXNhYmxlQXV0b1BhbjogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBNYXhpbXVtIHdpZHRoIG9mIHRoZSBpbmZvd2luZG93LCByZWdhcmRsZXNzIG9mIGNvbnRlbnQncyB3aWR0aC4gVGhpcyB2YWx1ZSBpcyBvbmx5IGNvbnNpZGVyZWRcclxuICAgICAqICBpZiBpdCBpcyBzZXQgYmVmb3JlIGEgY2FsbCB0byBvcGVuLiBUbyBjaGFuZ2UgdGhlIG1heGltdW0gd2lkdGggd2hlbiBjaGFuZ2luZyBjb250ZW50LCBjYWxsXHJcbiAgICAgKiAgY2xvc2UsIHVwZGF0ZSBtYXhXaWR0aCwgYW5kIHRoZW4gb3Blbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTWF4V2lkdGg6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZSB3aGV0aGVyIG9ubHkgb25lIGluZm9ib3ggY2FuIGJlIG9wZW4gYXQgYSB0aW1lLiBOb3RlIHRoYXQgQU5ZIGluZm8gYm94IHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBNb2RhbCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyB0aGUgbWFya2VyIHRoYXQgaXMgdGhlIGhvc3Qgb2YgdGhlIGluZm8gd2luZG93IChpZiBhdmFpbGFibGUpXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIEhvc3RNYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgdmlzaWJpbGl0eSBvZiBpbmZvYm94XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvcml6b250YWwgb2Zmc2V0IG9mIHRoZSBpbmZvYm94IGZyb20gdGhlIGhvc3QgbWFya2VyIGxhdC9sb25nIG9yIHRoZSBzZXBlY2lmaWVkIGNvb3JkaW5hdGVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyB4T2Zmc2V0OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJ0aWNhbCBvZmZzZXQgZm9yIHRoZSBpbmZvYm94IGZyb20gdGhlIGhvc3QgbWFya2VyIGxhdC9sb25nIG9yIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIHlPZmZzZXQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgaWYgb3RoZXIgaW5mbyBib3hlcyBzaG91bGQgYmUgY2xvc2VkIGJlZm9yZSBvcGVuaW5nIHRoaXMgb25lXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIENsb3NlSW5mb0JveGVzT25PcGVuID0gdHJ1ZTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBEZWxlZ2F0ZSBkZWZpbnRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIGluZm8gd2luZG93IGlzIGNsb3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgcHVibGljIEluZm9Cb3hDbG9zZTogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnMuXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgaW5mbyBib3guXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IEh0bWxDb250ZW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQubmF0aXZlRWxlbWVudCAmJiB0aGlzLl9jb250ZW50Lm5hdGl2ZUVsZW1lbnQuaW5uZXJUZXh0ICYmIHRoaXMuX2NvbnRlbnQubmF0aXZlRWxlbWVudC5pbm5lclRleHQudHJpbSgpICE9PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5uYXRpdmVFbGVtZW50Lm91dGVySFRNTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgSWQgb2YgdGhlIGluZm8gYm94IGFzIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5faWQ7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEluZm9Cb3hDb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gX2luZm9Cb3hTZXJ2aWNlIC0gQ29uY3JldGUge0BsaW5rIEluZm9Cb3hTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdW5kZXJseWluZyBNYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2luZm9Cb3hTZXJ2aWNlOiBJbmZvQm94U2VydmljZSkgeyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSBJbmZvYm94LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5mb0JveFNlcnZpY2UuQ2xvc2UodGhpcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuSW5mb0JveENsb3NlLmVtaXQodGhpcy5faWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIG9uIGFmdGVyIGNvbXBvbmVudCB2aWV3IGFzIGJlZW4gaW5pdGlhbGl6ZWQuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcclxuICAgICAgICB0aGlzLl9pbmZvQm94U2VydmljZS5BZGRJbmZvV2luZG93KHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2luZm9Cb3hBZGRlZFRvTWFuYWdlciA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5IYW5kbGVFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5nZXMgdG8gdGhlIGRhdGFib3VkIHByb3BlcnRpZXMgb2NjdXIuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gQ2hhbmdlcyB0aGF0IGhhdmUgb2NjdXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiB7IFtrZXk6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbmZvQm94QWRkZWRUb01hbmFnZXIpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKChjaGFuZ2VzWydsYXRpdHVkZSddIHx8IGNoYW5nZXNbJ2xvbmdpdHVkZSddKSAmJiB0eXBlb2YgdGhpcy5MYXRpdHVkZSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuTG9uZ2l0dWRlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLl9pbmZvQm94U2VydmljZS5TZXRQb3NpdGlvbih0aGlzLCB7XHJcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogY2hhbmdlc1snbGF0aXR1ZGUnXS5jdXJyZW50VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGNoYW5nZXNbJ2xvbmdpdHVkZSddLmN1cnJlbnRWYWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5TZXRJbmZvV2luZG93T3B0aW9ucyhjaGFuZ2VzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBvbiBjb21wb25lbnQgZGVzdHJ1Y3Rpb24uIEZyZWVzIHRoZSByZXNvdXJjZXMgdXNlZCBieSB0aGUgY29tcG9uZW50LiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHsgdGhpcy5faW5mb0JveFNlcnZpY2UuRGVsZXRlSW5mb1dpbmRvdyh0aGlzKTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBjbG9zZWQgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIFtsb2NdICAtIHtAbGluayBJTGF0TG9uZyB9IHJlcHJlc2VudGluZyBwb3NpdGlvbiBvbiB3aGljaCB0byBvcGVuIHRoZSB3aW5kb3cuXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGluZm9ib3ggaGFzIGJlZW4gb3BlbmVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBPcGVuKGxvYz86IElMYXRMb25nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9Cb3hTZXJ2aWNlLk9wZW4odGhpcywgbG9jKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluZm8gYm94LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbmZvIGJveC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVG9TdHJpbmcoKTogc3RyaW5nIHsgcmV0dXJuICdJbmZvQm94Q29tcG9uZW50LScgKyB0aGlzLl9pZDsgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyB0aGUgbWFwIGNsaWNrIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgSGFuZGxlRXZlbnRzKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2luZm9Cb3hTZXJ2aWNlLkNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnaW5mb3dpbmRvd2Nsb3NlJywgdGhpcykuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLkluZm9Cb3hDbG9zZS5lbWl0KHRoaXMuX2lkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2hhbmdlc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgU2V0SW5mb1dpbmRvd09wdGlvbnMoY2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IElJbmZvV2luZG93T3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGlmIChjaGFuZ2VzWyd0aXRsZSddKSB7IG9wdGlvbnMudGl0bGUgPSB0aGlzLlRpdGxlOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ2Rlc2NyaXB0aW9uJ10pIHsgb3B0aW9ucy5kZXNjcmlwdGlvbiA9IHRoaXMuRGVzY3JpcHRpb247IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snZGlzYWJsZUF1dG9QYW4nXSkgeyBvcHRpb25zLmRpc2FibGVBdXRvUGFuID0gdGhpcy5EaXNhYmxlQXV0b1BhbjsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWyd2aXNpYmxlJ10pIHsgb3B0aW9ucy52aXNpYmxlID0gdGhpcy5WaXNpYmxlOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ3hPZmZzZXQnXSB8fCBjaGFuZ2VzWyd5T2Zmc2V0J10pIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGl4ZWxPZmZzZXQgPT0gbnVsbCkgeyBvcHRpb25zLnBpeGVsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuICAgICAgICAgICAgb3B0aW9ucy5waXhlbE9mZnNldC54ID0gdGhpcy54T2Zmc2V0O1xyXG4gICAgICAgICAgICBvcHRpb25zLnBpeGVsT2Zmc2V0LnkgPSB0aGlzLnlPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2luZm9Cb3hTZXJ2aWNlLlNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICAgIERpcmVjdGl2ZSwgU2ltcGxlQ2hhbmdlLCBJbnB1dCwgT3V0cHV0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyxcclxuICAgIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBBZnRlckNvbnRlbnRJbml0LCBWaWV3Q29udGFpbmVyUmVmXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgdGltZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJTWFya2VyRXZlbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItZXZlbnQnO1xyXG5pbXBvcnQgeyBJTWFya2VySWNvbkluZm8gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItaWNvbi1pbmZvJztcclxuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSW5mb0JveENvbXBvbmVudCB9IGZyb20gJy4vaW5mb2JveCc7XHJcblxyXG4vKipcclxuICogaW50ZXJuYWwgY291bnRlciB0byB1c2UgYXMgaWRzIGZvciBtYXJrZXIuXHJcbiAqL1xyXG5sZXQgbWFya2VySWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIE1hcE1hcmtlckRpcmVjdGl2ZSByZW5kZXJzIGEgbWFwIG1hcmtlciBpbnNpZGUgYSB7QGxpbmsgTWFwQ29tcG9uZW50fS5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50LCBNYXBNYXJrZXJEaXJlY3RpdmV9IGZyb20gJy4uLic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcclxuICogIHN0eWxlczogW2BcclxuICogICAubWFwLWNvbnRhaW5lciB7XHJcbiAqICAgICBoZWlnaHQ6IDMwMHB4O1xyXG4gKiAgIH1cclxuICogYF0sXHJcbiAqIHRlbXBsYXRlOiBgXHJcbiAqICAgPHgtbWFwIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtab29tXT1cInpvb21cIj5cclxuICogICAgICA8eC1tYXAtbWFya2VyIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtMYWJlbF09XCInTSdcIj48L3gtbWFwLW1hcmtlcj5cclxuICogICA8L3gtbWFwPlxyXG4gKiBgXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAneC1tYXAtbWFya2VyJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTWFwTWFya2VyRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9jbGlja1RpbWVvdXQ6IFN1YnNjcmlwdGlvbiA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9ldmVudHM6IFN1YnNjcmlwdGlvbltdID0gW107XHJcbiAgICBwcml2YXRlIF9pZDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfaW5DbHVzdGVyTGF5ZXIgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2luQ3VzdG9tTGF5ZXIgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFueSBJbmZvQm94IHRoYXQgaXMgYSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhlIG1hcmtlclxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQENvbnRlbnRDaGlsZChJbmZvQm94Q29tcG9uZW50KSBwcm90ZWN0ZWQgX2luZm9Cb3g6IEluZm9Cb3hDb21wb25lbnQ7XHJcblxyXG4gICAgcHJpdmF0ZSBfbGF5ZXJJZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfbWFya2VyQWRkZWRUb01hbmdlciA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIEljb24gYW5jaG9yIHJlbGF0aXZlIHRvIG1hcmtlciByb290XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgQW5jaG9yOiBJUG9pbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERibENsaWNrOiBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyByZXBlYXRlZGx5IGZpcmVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgRHJhZzogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERyYWdFbmQ6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0cnVlLCB0aGUgbWFya2VyIGNhbiBiZSBkcmFnZ2VkLiBEZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIERyYWdnYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERyYWdTdGFydDogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiBhIG1hcmtlciBpY29uIGlzIGJlaW5nIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgcHVibGljIER5bmFtaWNNYXJrZXJDcmVhdGVkOiBFdmVudEVtaXR0ZXI8SU1hcmtlckljb25JbmZvPiA9IG5ldyBFdmVudEVtaXR0ZXI8SU1hcmtlckljb25JbmZvPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWNvbiBoZWlnaHRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBIZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZm9ybWF0aW9uIGZvciBkeW5hbWljLCBjdXN0b20gY3JlYXRlZCBpY29ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBJY29uSW5mbzogSU1hcmtlckljb25JbmZvO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWNvbiAodGhlIFVSTCBvZiB0aGUgaW1hZ2UpIGZvciB0aGUgZm9yZWdyb3VuZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBJY29uVXJsOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcnVlIHRvIGluZGljaWF0ZSB3aGV0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IG1hcmtlciBpbiBhIHNldC5cclxuICAgICAqIFVzZSB0aGlzIGZvciBidWxrIG9wZXJhdGlvbnMgKHBhcnRpY3VsYXJpbHkgY2x1c3RlcmluZykgdG8gZW5zdXJlIHBlcmZvcm1hbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIElzRmlyc3RJblNldCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJ1ZSB0byBpbmRpY2lhdGUgd2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IG1hcmtlciBpbiBhIHNldC5cclxuICAgICAqIFVzZSB0aGlzIGZvciBidWxrIG9wZXJhdGlvbnMgKHBhcnRpY3VsYXJpbHkgY2x1c3RlcmluZykgdG8gZW5zdXJlIHBlcmZvcm1hbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIElzTGFzdEluU2V0ID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsYWJlbCAoYSBzaW5nbGUgdXBwZXJjYXNlIGNoYXJhY3RlcikgZm9yIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWw6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsYXRpdHVkZSBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIExhdGl0dWRlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG9uZ2l0dWRlIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTG9uZ2l0dWRlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgcHVibGljIE1hcmtlckNsaWNrOiBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJiaXRhcnkgbWV0YWRhdGEgdG8gYXNzaWduIHRvIHRoZSBNYXJrZXIuIFRoaXMgaXMgdXNlZnVsIGZvciBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBNZXRhZGF0YTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZWRvd24gZXZlbnQgaXMgZmlyZWQgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZURvd246IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZW1vdmUgZXZlbnQgaXMgZmlyZWQgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZU1vdmU6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIG1hcmtlciBtb3VzZW91dC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZU91dDogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gbWFya2VyIG1vdXNlb3Zlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZU92ZXI6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZSB0aGUgRE9NIG1vdXNldXAgZXZlbnQgaXMgZmlyZWQgb24gdGhlIG1hcmtlclxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlVXA6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW4gaXMgZmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIHJpZ2h0LWNsaWNrZWQgb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgUmlnaHRDbGljazogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdGl0bGUgb2YgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBUaXRsZTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbWFya2VyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVmlzaWJsZTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEljb24gV2lkdGhcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBXaWR0aDogbnVtYmVyO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIERlbGVnYXRlc1xyXG4gICAgLy8vXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzd2hldGhlciB0aGUgbWFya2VyIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gdGhlIG1hcmtlciBzZXJ2aWNlIGFuZCBpcyByZWFkeSBmb3IgdXNlLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IEFkZGVkVG9NYW5hZ2VyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fbWFya2VyQWRkZWRUb01hbmdlcjsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaWQgb2YgdGhlIG1hcmtlciBhcyBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5faWQ7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgbWFya2VyIGlzIGluIGEgY2x1c3RlciBsYXllci4gU2VlIHtAbGluayBDbHVzdGVyTGF5ZXJ9LlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IEluQ2x1c3RlckxheWVyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faW5DbHVzdGVyTGF5ZXI7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgbWFya2VyIGlzIGluIGEgY3VzdG9tIGxheWVyLiBTZWUge0BsaW5rIE1hcExheWVyfS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJbkN1c3RvbUxheWVyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faW5DdXN0b21MYXllcjsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0cyB0aGUgaWQgb2YgdGhlIExheWVyIHRoZSBtYXJrZXIgYmVsb25ncyB0by5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBMYXllcklkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9sYXllcklkOyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBNYXBNYXJrZXJEaXJlY3RpdmUuXHJcbiAgICAgKiBAcGFyYW0gX21hcmtlclNlcnZpY2UgLSBDb25jcmVhdGUgaW1wbGVtZW50YXRpb24gb2YgYSB7QGxpbmsgTWFya2VyU2VydmljZX0uXHJcbiAgICAgKiBAcGFyYW0gX2NvbnRhaW5lclJlZiAtIFZpZXcgY29udGFpbmVyIGhvc3RpbmcgdGhlIG1hcmtlci5cclxuICAgICAqIFVzZWQgdG8gZGV0ZXJtaW5lIHBhcmVudCBsYXllciB0aHJvdWdoIG1hcmt1cC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcmtlclNlcnZpY2U6IE1hcmtlclNlcnZpY2UsIHByaXZhdGUgX2NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xyXG4gICAgICAgIHRoaXMuX2lkID0gKG1hcmtlcklkKyspLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlcyBhIG1hcmtlciBnZW8gbG9jYXRpb24gdG8gYSBwaXhlbCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgbWFwIHZpZXdwb3J0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBbbG9jXSAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzLiBJZiBudWxsLCB0aGUgbWFya2VyJ3MgY29vcmRpbmF0ZXMgYXJlIHVzZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyBhbiB7QGxpbmsgSVBvaW50fSByZXByZXNlbnRpbmcgdGhlIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIExvY2F0aW9uVG9QaXhlbChsb2M/OiBJTGF0TG9uZyk6IFByb21pc2U8SVBvaW50PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlclNlcnZpY2UuTG9jYXRpb25Ub1BvaW50KGxvYyA/IGxvYyA6IHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIENvbXBvbmVudCBjb250ZW50IGluaXRpYWxpemF0aW9uLiBQYXJ0IG9mIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5faW5mb0JveCAhPSBudWxsKSB7IHRoaXMuX2luZm9Cb3guSG9zdE1hcmtlciA9IHRoaXM7IH1cclxuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5hbWU6IHN0cmluZyA9IHRoaXMuX2NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudC50YWdOYW1lO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC1jbHVzdGVyLWxheWVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5DbHVzdGVyTGF5ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3gtbWFwLWxheWVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5DdXN0b21MYXllciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJJZCA9IE51bWJlcih0aGlzLl9jb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQuYXR0cmlidXRlc1snbGF5ZXJJZCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9tYXJrZXJBZGRlZFRvTWFuZ2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtlclNlcnZpY2UuQWRkTWFya2VyKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJBZGRlZFRvTWFuZ2VyID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5BZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWN0cyB0byBjaGFuZ2VzIGluIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50IGFuZCBhY3R1YXRlcyBwcm9wZXJ0eSBjaGFuZ2VzIGluIHRoZSB1bmRlcmxpbmcgbGF5ZXIgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYW5nZXMgLSBjb2xsZWN0aW9uIG9mIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5MYXRpdHVkZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMuTG9uZ2l0dWRlICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fbWFya2VyQWRkZWRUb01hbmdlcikgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snTGF0aXR1ZGUnXSB8fCBjaGFuZ2VzWydMb25naXR1ZGUnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZU1hcmtlclBvc2l0aW9uKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snVGl0bGUnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZVRpdGxlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snTGFiZWwnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZUxhYmVsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snRHJhZ2dhYmxlJ10pIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFya2VyU2VydmljZS5VcGRhdGVEcmFnZ2FibGUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydJY29uVXJsJ10gfHwgY2hhbmdlc1snSWNvbkluZm8nXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZUljb24odGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydBbmNob3InXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZUFuY2hvcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Zpc2libGUnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZVZpc2libGUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIG9uIGNvbXBvbmVudCBkZXN0cnVjdGlvbi4gRnJlZXMgdGhlIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLkRlbGV0ZU1hcmtlcih0aGlzKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgocykgPT4gcy51bnN1YnNjcmliZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE1hcmtlciBJZC5cclxuICAgICAqIEByZXR1cm5zIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgaWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcgeyByZXR1cm4gJ01hcE1hcmtlci0nICsgdGhpcy5faWQudG9TdHJpbmcoKTsgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHZhcmlvdXMgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBBZGRFdmVudExpc3RlbmVycygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBfZ2V0RXZlbnRBcmc6IChlOiBNb3VzZUV2ZW50KSA9PiBJTWFya2VyRXZlbnQgPSBlID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIE1hcmtlcjogdGhpcyxcclxuICAgICAgICAgICAgICAgIENsaWNrOiBlLFxyXG4gICAgICAgICAgICAgICAgTG9jYXRpb246IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZSksXHJcbiAgICAgICAgICAgICAgICBQaXhlbHM6IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0UGl4ZWxzRnJvbUNsaWNrKGUpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2godGhpcy5fbWFya2VyU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUoJ2NsaWNrJywgdGhpcykuc3Vic2NyaWJlKChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIC8vL1xyXG4gICAgICAgICAgICAvLy8gdGhpcyBpcyBuZWNlc3Nhcnkgc2luY2UgbWFwIHdpbGwgdHJlYXQgYSBkb3VibGVjbGljayBmaXJzdCBhcyB0d28gY2xpY2tzLi4uJ1xyXG4gICAgICAgICAgICAvLy9cclxuICAgICAgICAgICAgdGhpcy5fY2xpY2tUaW1lb3V0ID0gdGltZXIoMzAwKS5zdWJzY3JpYmUobiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5mb0JveCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5mb0JveC5PcGVuKHRoaXMuX21hcmtlclNlcnZpY2UuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5NYXJrZXJDbGljay5lbWl0KF9nZXRFdmVudEFyZyhlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2godGhpcy5fbWFya2VyU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUoJ2RibGNsaWNrJywgdGhpcykuc3Vic2NyaWJlKChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbGlja1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NsaWNrVGltZW91dC51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpY2tUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLkRibENsaWNrLmVtaXQoX2dldEV2ZW50QXJnKGUpKTtcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWcuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnZW5kJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWdFbmQuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZ1N0YXJ0LmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vkb3duJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlRG93bi5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU1vdmUuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU91dC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlb3ZlcicsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU92ZXIuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZXVwJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlVXAuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlJpZ2h0Q2xpY2suZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgob2JqKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9zID0gdGhpcy5fbWFya2VyU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUob2JqLm5hbWUsIHRoaXMpLnN1YnNjcmliZShvYmouaGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKG9zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICAgIENvbXBvbmVudCxcclxuICAgIEV2ZW50RW1pdHRlcixcclxuICAgIE9uQ2hhbmdlcyxcclxuICAgIE9uSW5pdCxcclxuICAgIE9uRGVzdHJveSxcclxuICAgIFNpbXBsZUNoYW5nZSxcclxuICAgIFZpZXdDaGlsZCxcclxuICAgIENvbnRlbnRDaGlsZHJlbixcclxuICAgIElucHV0LFxyXG4gICAgT3V0cHV0LFxyXG4gICAgRWxlbWVudFJlZixcclxuICAgIEhvc3RCaW5kaW5nLFxyXG4gICAgVmlld0VuY2Fwc3VsYXRpb24sXHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICAgIE5nWm9uZVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlRmFjdG9yeSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcHNlcnZpY2VmYWN0b3J5JztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUG9seWdvblNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wb2x5bGluZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQ2x1c3RlclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9jbHVzdGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJQm94IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pYm94JztcclxuaW1wb3J0IHsgSU1hcE9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXAtb3B0aW9ucyc7XHJcbmltcG9ydCB7IE1hcFR5cGVJZCB9IGZyb20gJy4uL21vZGVscy9tYXAtdHlwZS1pZCc7XHJcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4vbWFwLW1hcmtlcic7XHJcblxyXG4vKipcclxuICogUmVuZGVycyBhIG1hcCBiYXNlZCBvbiBhIGdpdmVuIHByb3ZpZGVyLlxyXG4gKiAqKkltcG9ydGFudCBub3RlKio6IFRvIGJlIGFibGUgc2VlIGEgbWFwIGluIHRoZSBicm93c2VyLCB5b3UgaGF2ZSB0byBkZWZpbmUgYSBoZWlnaHQgZm9yIHRoZSBDU1NcclxuICogY2xhc3MgYG1hcC1jb250YWluZXJgLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuICogaW1wb3J0IHtNYXBDb21wb25lbnR9IGZyb20gJy4uLic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgc2VsZWN0b3I6ICdteS1tYXAnLFxyXG4gKiAgc3R5bGVzOiBbYFxyXG4gKiAgICAubWFwLWNvbnRhaW5lciB7IGhlaWdodDogMzAwcHg7IH1cclxuICogYF0sXHJcbiAqICB0ZW1wbGF0ZTogYFxyXG4gKiAgICA8eC1tYXAgW0xhdGl0dWRlXT1cImxhdFwiIFtMb25naXR1ZGVdPVwibG5nXCIgW1pvb21dPVwiem9vbVwiPjwveC1tYXA+XHJcbiAqICBgXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAneC1tYXAnLFxyXG4gICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgeyBwcm92aWRlOiBNYXBTZXJ2aWNlLCBkZXBzOiBbTWFwU2VydmljZUZhY3RvcnldLCB1c2VGYWN0b3J5OiBNYXBTZXJ2aWNlQ3JlYXRvciB9LFxyXG4gICAgICAgIHsgcHJvdmlkZTogTWFya2VyU2VydmljZSwgZGVwczogW01hcFNlcnZpY2VGYWN0b3J5LCBNYXBTZXJ2aWNlLCBMYXllclNlcnZpY2UsIENsdXN0ZXJTZXJ2aWNlXSwgdXNlRmFjdG9yeTogTWFya2VyU2VydmljZUZhY3RvcnkgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHByb3ZpZGU6IEluZm9Cb3hTZXJ2aWNlLCBkZXBzOiBbTWFwU2VydmljZUZhY3RvcnksIE1hcFNlcnZpY2UsXHJcbiAgICAgICAgICAgICAgICBNYXJrZXJTZXJ2aWNlXSwgdXNlRmFjdG9yeTogSW5mb0JveFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IHByb3ZpZGU6IExheWVyU2VydmljZSwgZGVwczogW01hcFNlcnZpY2VGYWN0b3J5LCBNYXBTZXJ2aWNlXSwgdXNlRmFjdG9yeTogTGF5ZXJTZXJ2aWNlRmFjdG9yeSB9LFxyXG4gICAgICAgIHsgcHJvdmlkZTogQ2x1c3RlclNlcnZpY2UsIGRlcHM6IFtNYXBTZXJ2aWNlRmFjdG9yeSwgTWFwU2VydmljZV0sIHVzZUZhY3Rvcnk6IENsdXN0ZXJTZXJ2aWNlRmFjdG9yeSB9LFxyXG4gICAgICAgIHsgcHJvdmlkZTogUG9seWdvblNlcnZpY2UsIGRlcHM6IFtNYXBTZXJ2aWNlRmFjdG9yeSwgTWFwU2VydmljZSwgTGF5ZXJTZXJ2aWNlXSwgdXNlRmFjdG9yeTogUG9seWdvblNlcnZpY2VGYWN0b3J5IH0sXHJcbiAgICAgICAgeyBwcm92aWRlOiBQb2x5bGluZVNlcnZpY2UsIGRlcHM6IFtNYXBTZXJ2aWNlRmFjdG9yeSwgTWFwU2VydmljZSwgTGF5ZXJTZXJ2aWNlXSwgdXNlRmFjdG9yeTogUG9seWxpbmVTZXJ2aWNlRmFjdG9yeSB9XHJcbiAgICBdLFxyXG4gICAgdGVtcGxhdGU6IGBcclxuICAgICAgICA8ZGl2ICNjb250YWluZXIgY2xhc3M9J21hcC1jb250YWluZXItaW5uZXInPjwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9J21hcC1jb250ZW50Jz5cclxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYCxcclxuICAgIHN0eWxlczogW2BcclxuICAgICAgICAubWFwLWNvbnRhaW5lci1pbm5lciB7IHdpZHRoOiBpbmhlcml0OyBoZWlnaHQ6IGluaGVyaXQ7IH1cclxuICAgICAgICAubWFwLWNvbnRhaW5lci1pbm5lciBkaXYgeyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyB9XHJcbiAgICAgICAgLm1hcC1jb250ZW50IHsgZGlzcGxheTpub25lOyB9XHJcbiAgICBgXSxcclxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWFwQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkluaXQsIE9uRGVzdHJveSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2xvbmdpdHVkZSA9IDA7XHJcbiAgICBwcml2YXRlIF9sYXRpdHVkZSA9IDA7XHJcbiAgICBwcml2YXRlIF96b29tID0gMDtcclxuICAgIHByaXZhdGUgX2NsaWNrVGltZW91dDogbnVtYmVyIHwgTm9kZUpTLlRpbWVyO1xyXG4gICAgcHJpdmF0ZSBfb3B0aW9uczogSU1hcE9wdGlvbnMgPSB7fTtcclxuICAgIHByaXZhdGUgX2JveDogSUJveCA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9tYXBQcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5tYXAtY29udGFpbmVyJykgcHVibGljIF9jb250YWluZXJDbGFzczogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBAVmlld0NoaWxkKCdjb250YWluZXInKSBwcml2YXRlIF9jb250YWluZXI6IEVsZW1lbnRSZWY7XHJcbiAgICBAQ29udGVudENoaWxkcmVuKE1hcE1hcmtlckRpcmVjdGl2ZSkgcHJpdmF0ZSBfbWFya2VyczogQXJyYXk8TWFwTWFya2VyRGlyZWN0aXZlPjtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldHMgdGhlIG1heGltdW0gYW5kIG1pbmltdW0gYm91bmRpbmcgYm94IGZvciBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgcHVibGljIGdldCBCb3goKTogSUJveCB7IHJldHVybiB0aGlzLl9ib3g7IH1cclxuICAgIHB1YmxpYyBzZXQgQm94KHZhbDogSUJveCkgeyB0aGlzLl9ib3ggPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGF0aXR1ZGUgdGhhdCBzZXRzIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZ2V0IExhdGl0dWRlKCk6IG51bWJlciB8IHN0cmluZyB7IHJldHVybiB0aGlzLl9sb25naXR1ZGU7IH1cclxuICAgIHB1YmxpYyBzZXQgTGF0aXR1ZGUodmFsdWU6IG51bWJlciB8IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2xhdGl0dWRlID0gdGhpcy5Db252ZXJ0VG9EZWNpbWFsKHZhbHVlKTtcclxuICAgICAgICB0aGlzLlVwZGF0ZUNlbnRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBsb25naXR1ZGUgdGhhdCBzZXRzIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZ2V0IExvbmdpdHVkZSgpOiBudW1iZXIgfCBzdHJpbmcgeyByZXR1cm4gdGhpcy5fbG9uZ2l0dWRlOyB9XHJcbiAgICBwdWJsaWMgc2V0IExvbmdpdHVkZSh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fbG9uZ2l0dWRlID0gdGhpcy5Db252ZXJ0VG9EZWNpbWFsKHZhbHVlKTtcclxuICAgICAgICB0aGlzLlVwZGF0ZUNlbnRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIGdlbmVyYWwgbWFwIE9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZ2V0IE9wdGlvbnMoKTogSU1hcE9wdGlvbnMgeyByZXR1cm4gdGhpcy5fb3B0aW9uczsgfVxyXG4gICAgcHVibGljIHNldCBPcHRpb25zKHZhbDogSU1hcE9wdGlvbnMpIHsgdGhpcy5fb3B0aW9ucyA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGA4YC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZ2V0IFpvb20oKTogbnVtYmVyIHwgc3RyaW5nIHsgcmV0dXJuIHRoaXMuX3pvb207IH1cclxuICAgIHB1YmxpYyBzZXQgWm9vbSh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fem9vbSA9IHRoaXMuQ29udmVydFRvRGVjaW1hbCh2YWx1ZSwgOCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl96b29tID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlNldFpvb20odGhpcy5fem9vbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGlzIGZpcmVkIHdoZW4gdGhlIG1hcCBib3VuZGluZyBib3ggY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgQm91bmRzQ2hhbmdlOiBFdmVudEVtaXR0ZXI8SUJveD4gPSBuZXcgRXZlbnRFbWl0dGVyPElCb3g+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIGNlbnRlciBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpXHJcbiAgICBDZW50ZXJDaGFuZ2U6IEV2ZW50RW1pdHRlcjxJTGF0TG9uZz4gPSBuZXcgRXZlbnRFbWl0dGVyPElMYXRMb25nPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwIChidXQgbm90IHdoZW4gdGhleSBjbGljayBvbiBhXHJcbiAgICAgKiBtYXJrZXIgb3IgaW5mb1dpbmRvdykuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KClcclxuICAgIE1hcENsaWNrOiBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyBvbiB0aGUgbWFwIChidXQgbm90IHdoZW4gdGhleSBjbGlja1xyXG4gICAgICogb24gYSBtYXJrZXIgb3IgaW5mb1dpbmRvdykuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KClcclxuICAgIE1hcERibENsaWNrOiBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgcmlnaHQtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXHJcbiAgICAgKiBvbiBhIG1hcmtlciBvciBpbmZvV2luZG93KS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgTWFwUmlnaHRDbGljazogRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3Mgb24gdGhlIG1hcCAoYnV0IG5vdCB3aGVuIHRoZXkgY2xpY2tcclxuICAgICAqIG9uIGEgbWFya2VyIG9yIGluZm9XaW5kb3cpLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpXHJcbiAgICBNYXBNb3VzZU92ZXI6IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXHJcbiAgICAgKiBvbiBhIG1hcmtlciBvciBpbmZvV2luZG93KS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgTWFwTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXHJcbiAgICAgKiBvbiBhIG1hcmtlciBvciBpbmZvV2luZG93KS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgTWFwTW91c2VNb3ZlOiBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZXZlbnQgZW1pdHRlciBpcyBmaXJlZCB3aGVuIHRoZSBtYXAgc2VydmljZSBpcyBhdmFpbGFibGUgYW5kIHRoZSBtYXBzIGhhcyBiZWVuXHJcbiAgICAgKiBJbml0aWFsaXplZCAoYnV0IG5vdCBuZWNlc3NhcmlseSBjcmVhdGVkKS4gSXQgY29udGFpbnMgYSBQcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIHJldHVybnNcclxuICAgICAqIHRoZSBtYWluIG1hcCBvYmplY3Qgb2YgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KClcclxuICAgIE1hcFByb21pc2U6IEV2ZW50RW1pdHRlcjxQcm9taXNlPGFueT4+ID0gbmV3IEV2ZW50RW1pdHRlcjxQcm9taXNlPGFueT4+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaWl0ZXIgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gY2hhbmdlc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpXHJcbiAgICBab29tQ2hhbmdlOiBFdmVudEVtaXR0ZXI8TnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8TnVtYmVyPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGlzIGZpcmVkIHdoZW4gdGhlIG1hcCBzZXJ2aWNlIGlzIGF2YWlsYWJsZSBhbmQgdGhlIG1hcHMgaGFzIGJlZW5cclxuICAgICAqIEluaXRpYWxpemVkXHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgTWFwU2VydmljZTogRXZlbnRFbWl0dGVyPE1hcFNlcnZpY2U+ID0gbmV3IEV2ZW50RW1pdHRlcjxNYXBTZXJ2aWNlPigpO1xyXG5cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1hcENvbXBvbmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSBDb25jcmV0ZWQgaW1wbGVtZW50YXRpb24gb2YgYSBtYXAgc2VydmljZSBmb3IgdGhlIHVuZGVybHlpbmcgbWFwcyBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR2VuZXJhbGx5IHByb3ZpZGVkIHZpYSBpbmplY3Rpb25zLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHsgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBvbiBDb21wb25lbnQgaW5pdGlhbGl6YXRpb24uIFBhcnQgb2YgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5Jbml0TWFwSW5zdGFuY2UodGhpcy5fY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuTWFwUHJvbWlzZS5lbWl0KHRoaXMuX21hcFNlcnZpY2UuTWFwUHJvbWlzZSk7XHJcbiAgICAgICAgdGhpcy5NYXBTZXJ2aWNlLmVtaXQodGhpcy5fbWFwU2VydmljZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiBjaGFuZ2VzIHRvIHRoZSBkYXRhYm91ZCBwcm9wZXJ0aWVzIG9jY3VyLiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIENoYW5nZXMgdGhhdCBoYXZlIG9jY3VyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBbcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21hcFByb21pc2UpIHtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZXNbJ0JveCddKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm94ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlNldFZpZXdPcHRpb25zKDxJTWFwT3B0aW9ucz57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kczogdGhpcy5fYm94XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoYW5nZXNbJ09wdGlvbnMnXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TZXRNYXBPcHRpb25zKHRoaXMuX29wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIG9uIGNvbXBvbmVudCBkZXN0cnVjdGlvbi4gRnJlZXMgdGhlIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX21hcFNlcnZpY2UuRGlzcG9zZU1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcnMgYSByZXNpemUgZXZlbnQgb24gdGhlIG1hcCBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGdldHMgcmVzb2x2ZWQgYWZ0ZXIgdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVHJpZ2dlclJlc2l6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAvLyBOb3RlOiBXaGVuIHdlIHdvdWxkIHRyaWdnZXIgdGhlIHJlc2l6ZSBldmVudCBhbmQgc2hvdyB0aGUgbWFwIGluIHRoZSBzYW1lIHR1cm4gKHdoaWNoIGlzIGFcclxuICAgICAgICAvLyBjb21tb24gY2FzZSBmb3IgdHJpZ2dlcmluZyBhIHJlc2l6ZSBldmVudCksIHRoZW4gdGhlIHJlc2l6ZSBldmVudCB3b3VsZCBub3RcclxuICAgICAgICAvLyB3b3JrICh0byBzaG93IHRoZSBtYXApLCBzbyB3ZSB0cmlnZ2VyIHRoZSBldmVudCBpbiBhIHRpbWVvdXQuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoXHJcbiAgICAgICAgICAgICAgICAoKSA9PiB7IHJldHVybiB0aGlzLl9tYXBTZXJ2aWNlLlRyaWdnZXJNYXBFdmVudCgncmVzaXplJykudGhlbigoKSA9PiByZXNvbHZlKCkpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHMuXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgbnVtYmVyLWlzaCB2YWx1ZSB0byBhIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydC5cclxuICAgICAqIEBwYXJhbSBbZGVmYXVsdFZhbHVlPW51bGxdIC0gRGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgdGhlIGNvbnZlcnNpb24gY2Fubm90IGJlIHBlcmZvcm1lZC5cclxuICAgICAqIEByZXR1cm5zIC0gQ29udmVydGVkIG51bWJlciBvZiB0aGUgZGVmYXVsdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQ29udmVydFRvRGVjaW1hbCh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBkZWZhdWx0VmFsdWU6IG51bWJlciA9IG51bGwpOiBudW1iZXIge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDxudW1iZXI+dmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyB0aGUgbWFwIGNsaWNrIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgSGFuZGxlTWFwQ2xpY2tFdmVudHMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TdWJzY3JpYmVUb01hcEV2ZW50PGFueT4oJ2NsaWNrJykuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBzaW5jZSBiaW5nIHdpbGwgdHJlYXQgYSBkb3VibGVjbGljayBmaXJzdCBhcyB0d28gY2xpY2tzLi4uJ1xyXG4gICAgICAgICAgICAvLy9cclxuICAgICAgICAgICAgdGhpcy5fY2xpY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLk1hcENsaWNrLmVtaXQoPE1vdXNlRXZlbnQ+ZSk7XHJcbiAgICAgICAgICAgIH0sIDMwMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TdWJzY3JpYmVUb01hcEV2ZW50PGFueT4oJ2RibGNsaWNrJykuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2xpY2tUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoPE5vZGVKUy5UaW1lcj50aGlzLl9jbGlja1RpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuTWFwRGJsQ2xpY2suZW1pdCg8TW91c2VFdmVudD5lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlN1YnNjcmliZVRvTWFwRXZlbnQ8YW55PigncmlnaHRjbGljaycpLnN1YnNjcmliZShlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5NYXBSaWdodENsaWNrLmVtaXQoPE1vdXNlRXZlbnQ+ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TdWJzY3JpYmVUb01hcEV2ZW50PGFueT4oJ21vdXNlb3ZlcicpLnN1YnNjcmliZShlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5NYXBNb3VzZU92ZXIuZW1pdCg8TW91c2VFdmVudD5lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlN1YnNjcmliZVRvTWFwRXZlbnQ8YW55PignbW91c2VvdXQnKS5zdWJzY3JpYmUoZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuTWFwTW91c2VPdXQuZW1pdCg8TW91c2VFdmVudD5lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlN1YnNjcmliZVRvTWFwRXZlbnQ8YW55PignbW91c2Vtb3ZlJykuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLk1hcE1vdXNlTW92ZS5lbWl0KDxNb3VzZUV2ZW50PmUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZWdhdGUgaGFuZGxpbmcgbWFwIGNlbnRlciBjaGFuZ2UgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBIYW5kbGVNYXBCb3VuZHNDaGFuZ2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TdWJzY3JpYmVUb01hcEV2ZW50PHZvaWQ+KCdib3VuZHNjaGFuZ2VkJykuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5HZXRCb3VuZHMoKS50aGVuKChib3VuZHM6IElCb3gpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuQm91bmRzQ2hhbmdlLmVtaXQoYm91bmRzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyBtYXAgY2VudGVyIGNoYW5nZSBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIEhhbmRsZU1hcENlbnRlckNoYW5nZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlN1YnNjcmliZVRvTWFwRXZlbnQ8dm9pZD4oJ2NlbnRlcmNoYW5nZWQnKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkdldENlbnRlcigpLnRoZW4oKGNlbnRlcjogSUxhdExvbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXRpdHVkZSAhPT0gY2VudGVyLmxhdGl0dWRlIHx8IHRoaXMuX2xvbmdpdHVkZSAhPT0gY2VudGVyLmxvbmdpdHVkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGl0dWRlID0gY2VudGVyLmxhdGl0dWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdpdHVkZSA9IGNlbnRlci5sb25naXR1ZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5DZW50ZXJDaGFuZ2UuZW1pdCg8SUxhdExvbmc+eyBsYXRpdHVkZTogdGhpcy5fbGF0aXR1ZGUsIGxvbmdpdHVkZTogdGhpcy5fbG9uZ2l0dWRlIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGVnYXRlIGhhbmRsaW5nIG1hcCB6b29tIGNoYW5nZSBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIEhhbmRsZU1hcFpvb21DaGFuZ2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TdWJzY3JpYmVUb01hcEV2ZW50PHZvaWQ+KCd6b29tY2hhbmdlZCcpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuR2V0Wm9vbSgpLnRoZW4oKHo6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pvb20gIT09IHopIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b29tID0gejtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLlpvb21DaGFuZ2UuZW1pdCh6KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbCAtIEh0bWwgZWxlbWVudHMgd2hpY2ggd2lsbCBob3N0IHRoZSBtYXAgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBJbml0TWFwSW5zdGFuY2UoZWw6IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmNlbnRlciA9PSBudWxsKSB7IHRoaXMuX29wdGlvbnMuY2VudGVyID0geyBsYXRpdHVkZTogdGhpcy5fbGF0aXR1ZGUsIGxvbmdpdHVkZTogdGhpcy5fbG9uZ2l0dWRlIH07IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuem9vbSA9PSBudWxsKSB7IHRoaXMuX29wdGlvbnMuem9vbSA9IHRoaXMuX3pvb207IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubWFwVHlwZUlkID09IG51bGwpIHsgdGhpcy5fb3B0aW9ucy5tYXBUeXBlSWQgPSBNYXBUeXBlSWQuaHlicmlkOyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib3ggIT0gbnVsbCkgeyB0aGlzLl9vcHRpb25zLmJvdW5kcyA9IHRoaXMuX2JveDsgfVxyXG4gICAgICAgICAgICB0aGlzLl9tYXBQcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVNYXAoZWwsIHRoaXMuX29wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLkhhbmRsZU1hcENlbnRlckNoYW5nZSgpO1xyXG4gICAgICAgICAgICB0aGlzLkhhbmRsZU1hcEJvdW5kc0NoYW5nZSgpO1xyXG4gICAgICAgICAgICB0aGlzLkhhbmRsZU1hcFpvb21DaGFuZ2UoKTtcclxuICAgICAgICAgICAgdGhpcy5IYW5kbGVNYXBDbGlja0V2ZW50cygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgbWFwIGNlbnRlciBiYXNlZCBvbiB0aGUgZ2VvIHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgVXBkYXRlQ2VudGVyKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fbGF0aXR1ZGUgIT09ICdudW1iZXInIHx8IHR5cGVvZiB0aGlzLl9sb25naXR1ZGUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TZXRDZW50ZXIoe1xyXG4gICAgICAgICAgICBsYXRpdHVkZTogdGhpcy5fbGF0aXR1ZGUsXHJcbiAgICAgICAgICAgIGxvbmdpdHVkZTogdGhpcy5fbG9uZ2l0dWRlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIGNsdXN0ZXIgc2VydmljZSBpbnN0YW5jZS4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBvZiBjb25zdHJhaW50cyB3aXRoIEFPVCB0aGF0IGRvIG5vIGFsbG93XHJcbiAqIHVzIHRvIHVzZSBsYW1kYSBmdW5jdGlvbnMgaW5saW5lLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSBmIC0gVGhlIHtAbGluayBNYXBTZXJ2aWNlRmFjdG9yeX0gaW1wbGVtZW50YXRpb24uXHJcbiAqIEBwYXJhbSBtIC0gQSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuXHJcbiAqIEByZXR1cm5zIC0gQSBjb25jcmV0ZSBpbnN0YW5jZSBvZiBhIENsdXN0ZXIgU2VydmljZSBiYXNlZCBvbiB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQ2x1c3RlclNlcnZpY2VGYWN0b3J5KGY6IE1hcFNlcnZpY2VGYWN0b3J5LCBtOiBNYXBTZXJ2aWNlKTogQ2x1c3RlclNlcnZpY2UgeyByZXR1cm4gZi5DcmVhdGVDbHVzdGVyU2VydmljZShtKTsgfVxyXG5cclxuLyoqXHJcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBpbmZvYm94IHNlcnZpY2UgaW5zdGFuY2UuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgY29uc3RyYWludHMgd2l0aCBBT1QgdGhhdCBkbyBubyBhbGxvd1xyXG4gKiB1cyB0byB1c2UgbGFtZGEgZnVuY3Rpb25zIGlubGluZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0gZiAtIFRoZSB7QGxpbmsgTWFwU2VydmljZUZhY3Rvcnl9IGltcGxlbWVudGF0aW9uLlxyXG4gKiBAcGFyYW0gbSAtIEEge0BsaW5rIE1hcFNlcnZpY2V9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gbSAtIEEge0BsaW5rIE1hcmtlclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gKiBAcmV0dXJucyAtIEEgY29uY3JldGUgaW5zdGFuY2Ugb2YgYSBJbmZvQm94IFNlcnZpY2UgYmFzZWQgb24gdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBJbmZvQm94U2VydmljZUZhY3RvcnkoZjogTWFwU2VydmljZUZhY3RvcnksIG06IE1hcFNlcnZpY2UsXHJcbiAgICBtYTogTWFya2VyU2VydmljZSk6IEluZm9Cb3hTZXJ2aWNlIHsgcmV0dXJuIGYuQ3JlYXRlSW5mb0JveFNlcnZpY2UobSwgbWEpOyB9XHJcblxyXG4vKipcclxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIGxheWVyIHNlcnZpY2UgaW5zdGFuY2UuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgY29uc3RyYWludHMgd2l0aCBBT1QgdGhhdCBkbyBubyBhbGxvd1xyXG4gKiB1cyB0byB1c2UgbGFtZGEgZnVuY3Rpb25zIGlubGluZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0gZiAtIFRoZSB7QGxpbmsgTWFwU2VydmljZUZhY3Rvcnl9IGltcGxlbWVudGF0aW9uLlxyXG4gKiBAcGFyYW0gbSAtIEEge0BsaW5rIE1hcFNlcnZpY2V9IGluc3RhbmNlLlxyXG4gKiBAcmV0dXJucyAtIEEgY29uY3JldGUgaW5zdGFuY2Ugb2YgYSBMYXllciBTZXJ2aWNlIGJhc2VkIG9uIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTGF5ZXJTZXJ2aWNlRmFjdG9yeShmOiBNYXBTZXJ2aWNlRmFjdG9yeSwgbTogTWFwU2VydmljZSk6IExheWVyU2VydmljZSB7IHJldHVybiBmLkNyZWF0ZUxheWVyU2VydmljZShtKTsgfVxyXG5cclxuLyoqXHJcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBtYXAgc2VydmljZSBpbnN0YW5jZS4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBvZiBjb25zdHJhaW50cyB3aXRoIEFPVCB0aGF0IGRvIG5vIGFsbG93XHJcbiAqIHVzIHRvIHVzZSBsYW1kYSBmdW5jdGlvbnMgaW5saW5lLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSBmIC0gVGhlIHtAbGluayBNYXBTZXJ2aWNlRmFjdG9yeX0gaW1wbGVtZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIC0gQSBjb25jcmV0ZSBpbnN0YW5jZSBvZiBhIE1hcFNlcnZpY2UgYmFzZWQgb24gdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBNYXBTZXJ2aWNlQ3JlYXRvcihmOiBNYXBTZXJ2aWNlRmFjdG9yeSk6IE1hcFNlcnZpY2UgeyByZXR1cm4gZi5DcmVhdGUoKTsgfVxyXG5cclxuLyoqXHJcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBtYXJrZXIgc2VydmljZSBpbnN0YW5jZS4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBvZiBjb25zdHJhaW50cyB3aXRoIEFPVCB0aGF0IGRvIG5vIGFsbG93XHJcbiAqIHVzIHRvIHVzZSBsYW1kYSBmdW5jdGlvbnMgaW5saW5lLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSBmIC0gVGhlIHtAbGluayBNYXBTZXJ2aWNlRmFjdG9yeX0gaW1wbGVtZW50YXRpb24uXHJcbiAqIEBwYXJhbSBtIC0gQSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBsIC0gQSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGMgLSBBIHtAbGluayBDbHVzdGVyU2VydmljZX0gaW5zdGFuY2UuXHJcbiAqIEByZXR1cm5zIC0gQSBjb25jcmV0ZSBpbnN0YW5jZSBvZiBhIE1hcmtlciBTZXJ2aWNlIGJhc2VkIG9uIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTWFya2VyU2VydmljZUZhY3RvcnkoZjogTWFwU2VydmljZUZhY3RvcnksIG06IE1hcFNlcnZpY2UsIGw6IExheWVyU2VydmljZSwgYzogQ2x1c3RlclNlcnZpY2UpOiBNYXJrZXJTZXJ2aWNlIHtcclxuICAgIHJldHVybiBmLkNyZWF0ZU1hcmtlclNlcnZpY2UobSwgbCwgYyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgcG9seWdvbiBzZXJ2aWNlIGluc3RhbmNlLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIG9mIGNvbnN0cmFpbnRzIHdpdGggQU9UIHRoYXQgZG8gbm8gYWxsb3dcclxuICogdXMgdG8gdXNlIGxhbWRhIGZ1bmN0aW9ucyBpbmxpbmUuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIGYgLSBUaGUge0BsaW5rIE1hcFNlcnZpY2VGYWN0b3J5fSBpbXBsZW1lbnRhdGlvbi5cclxuICogQHBhcmFtIG0gLSBBIHtAbGluayBNYXBTZXJ2aWNlfSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGwgLSBBIHtAbGluayBMYXllclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gKiBAcmV0dXJucyAtIEEgY29uY3JldGUgaW5zdGFuY2Ugb2YgYSBQb2x5Z29uIFNlcnZpY2UgYmFzZWQgb24gdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBQb2x5Z29uU2VydmljZUZhY3RvcnkoZjogTWFwU2VydmljZUZhY3RvcnksIG06IE1hcFNlcnZpY2UsIGw6IExheWVyU2VydmljZSk6IFBvbHlnb25TZXJ2aWNlIHtcclxuICAgIHJldHVybiBmLkNyZWF0ZVBvbHlnb25TZXJ2aWNlKG0sIGwpO1xyXG59XHJcblxyXG4vKipcclxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHBvbHlsaW5lIHNlcnZpY2UgaW5zdGFuY2UuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgY29uc3RyYWludHMgd2l0aCBBT1QgdGhhdCBkbyBubyBhbGxvd1xyXG4gKiB1cyB0byB1c2UgbGFtZGEgZnVuY3Rpb25zIGlubGluZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0gZiAtIFRoZSB7QGxpbmsgTWFwU2VydmljZUZhY3Rvcnl9IGltcGxlbWVudGF0aW9uLlxyXG4gKiBAcGFyYW0gbSAtIEEge0BsaW5rIE1hcFNlcnZpY2V9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gbCAtIEEge0BsaW5rIExheWVyU2VydmljZX0gaW5zdGFuY2UuXHJcbiAqIEByZXR1cm5zIC0gQSBjb25jcmV0ZSBpbnN0YW5jZSBvZiBhIFBvbHlsaW5lIFNlcnZpY2UgYmFzZWQgb24gdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBQb2x5bGluZVNlcnZpY2VGYWN0b3J5KGY6IE1hcFNlcnZpY2VGYWN0b3J5LCBtOiBNYXBTZXJ2aWNlLCBsOiBMYXllclNlcnZpY2UpOiBQb2x5bGluZVNlcnZpY2Uge1xyXG4gICAgcmV0dXJuIGYuQ3JlYXRlUG9seWxpbmVTZXJ2aWNlKG0sIGwpO1xyXG59XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBBZnRlckNvbnRlbnRJbml0LCBTaW1wbGVDaGFuZ2UsXHJcbiAgICBDb250ZW50Q2hpbGRyZW4sIElucHV0LCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2xheWVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBNYXJrZXJEaXJlY3RpdmUgfSBmcm9tICcuL21hcC1tYXJrZXInO1xyXG5cclxuLyoqXHJcbiAqIGludGVybmFsIGNvdW50ZXIgdG8gdXNlIGFzIGlkcyBmb3IgbXVsdGlwbGUgbGF5ZXJzLlxyXG4gKi9cclxubGV0IGxheWVySWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIE1hcExheWVyRGlyZWN0aXZlIGNyZWF0ZXMgYSBsYXllciBvbiBhIHtAbGluayBNYXBDb21wb25lbnR9LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuICogaW1wb3J0IHtNYXBDb21wb25lbnQsIE1hcE1hcmtlckRpcmVjdGl2ZX0gZnJvbSAnLi4uJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxyXG4gKiAgc3R5bGVzOiBbYFxyXG4gKiAgIC5tYXAtY29udGFpbmVyIHtcclxuICogICAgIGhlaWdodDogMzAwcHg7XHJcbiAqICAgfVxyXG4gKiBgXSxcclxuICogdGVtcGxhdGU6IGBcclxuICogICA8eC1tYXAgW0xhdGl0dWRlXT0nbGF0JyBbTG9uZ2l0dWRlXT0nbG5nJyBbWm9vbV09J3pvb20nPlxyXG4gKiAgICAgPHgtbWFwLWxheWVyIFtWaXNpYmxlXT0ndmlzaWJsZSc+XHJcbiAqICAgICAgICAgPHgtbWFwLW1hcmtlciBbTGF0aXR1ZGVdPSdsYXQnIFtMb25naXR1ZGVdPSdsbmcnIFtMYWJlbF09JydNJyc+PC94LW1hcC1tYXJrZXI+XHJcbiAqICAgICA8L3gtbWFwLWxheWVyPlxyXG4gKiAgIDwveC1tYXA+XHJcbiAqIGBcclxuICogfSlcclxuICogYGBgXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICd4LW1hcC1sYXllcidcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hcExheWVyRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByb3RlY3RlZCBfdmlzaWJsZSA9IHRydWU7XHJcbiAgICBwcm90ZWN0ZWQgX2FkZGVkVG9NYW5hZ2VyID0gZmFsc2U7XHJcbiAgICBwcm90ZWN0ZWQgX2lkOiBudW1iZXI7XHJcblxyXG4gICAgQENvbnRlbnRDaGlsZHJlbihNYXBNYXJrZXJEaXJlY3RpdmUpIHByb3RlY3RlZCBfbWFya2VyczogQXJyYXk8TWFwTWFya2VyRGlyZWN0aXZlPjtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBsYXllciB2aXNpYmlsaXR5LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgVmlzaWJsZSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3Zpc2libGU7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IFZpc2libGUodmFsOiBib29sZWFuKSB7IHRoaXMuX3Zpc2libGUgPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxheWVyIGlkLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcExheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2lkOyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBNYXBMYXllckRpcmVjdGl2ZS5cclxuICAgICAqIEBwYXJhbSBfbGF5ZXJTZXJ2aWNlIC0gQ29uY3JldGVkIGltcGxlbWVudGF0aW9uIG9mIGEgbGF5ZXIgc2VydmljZSBmb3IgdGhlIHVuZGVybHlpbmcgbWFwcyBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICAgKiBHZW5lcmFsbHkgcHJvdmlkZWQgdmlhIGluamVjdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0gX2NvbnRhaW5lclJlZiAtIFJlZmVyZW5jZSB0byB0aGUgY29udGFpbmVyIGhvc3RpbmcgdGhlIG1hcCBjYW52YXMuIEdlbmVyYWxseSBwcm92aWRlZCB2aWEgaW5qZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLCBwcm90ZWN0ZWQgX2NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xyXG4gICAgICAgIHRoaXMuX2lkID0gbGF5ZXJJZCsrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBvbiBDb21wb25lbnQgaW5pdGlhbGl6YXRpb24uIFBhcnQgb2YgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcExheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9jb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LmF0dHJpYnV0ZXNbJ2xheWVySWQnXSA9IHRoaXMuX2lkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJTZXJ2aWNlLkFkZExheWVyKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2FkZGVkVG9NYW5hZ2VyID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5nZXMgdG8gdGhlIGRhdGFib3VkIHByb3BlcnRpZXMgb2NjdXIuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gQ2hhbmdlcyB0aGF0IGhhdmUgb2NjdXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHsgW3Byb3BOYW1lOiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSk6IHZvaWQge1xyXG4gICAgICAgIGlmICghdGhpcy5fYWRkZWRUb01hbmFnZXIpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Zpc2libGUnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllclNlcnZpY2UuR2V0TmF0aXZlTGF5ZXIodGhpcykudGhlbihsID0+IHtcclxuICAgICAgICAgICAgICAgIGwuU2V0VmlzaWJsZSghbC5HZXRWaXNpYmxlKCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgb24gY29tcG9uZW50IGRlc3RydWN0aW9uLiBGcmVlcyB0aGUgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGNvbXBvbmVudC4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJTZXJ2aWNlLkRlbGV0ZUxheWVyKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IElDbHVzdGVySWNvbkluZm8gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ljbHVzdGVyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2UsXHJcbiAgICBDb250ZW50Q2hpbGRyZW4sIElucHV0LCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IENsdXN0ZXJQbGFjZW1lbnRNb2RlIH0gZnJvbSAnLi4vbW9kZWxzL2NsdXN0ZXItcGxhY2VtZW50LW1vZGUnO1xyXG5pbXBvcnQgeyBDbHVzdGVyQ2xpY2tBY3Rpb24gfSBmcm9tICcuLi9tb2RlbHMvY2x1c3Rlci1jbGljay1hY3Rpb24nO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElDbHVzdGVyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWNsdXN0ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mb30gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSVNwaWRlckNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pc3BpZGVyLWNsdXN0ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4vbWFwLW1hcmtlcic7XHJcbmltcG9ydCB7IE1hcExheWVyRGlyZWN0aXZlIH0gZnJvbSAnLi9tYXAtbGF5ZXInO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIENyZWF0ZXMgYSBjbHVzdGVyIGxheWVyIG9uIGEge0BsaW5rIE1hcENvbXBvbmVudH0uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG4gKiBpbXBvcnQge01hcENvbXBvbmVudCwgTWFwTWFya2VyRGlyZWN0aXZlfSBmcm9tICcuLi4nO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXHJcbiAqICBzdHlsZXM6IFtgXHJcbiAqICAgLm1hcC1jb250YWluZXIge1xyXG4gKiAgICAgaGVpZ2h0OiAzMDBweDtcclxuICogICB9XHJcbiAqIGBdLFxyXG4gKiB0ZW1wbGF0ZTogYFxyXG4gKiAgIDx4LW1hcCBbTGF0aXR1ZGVdPSdsYXQnIFtMb25naXR1ZGVdPSdsbmcnIFtab29tXT0nem9vbSc+XHJcbiAqICAgICA8eC1jbHVzdGVyLWxheWVyIFtWaXNpYmxlXT0ndmlzaWJsZSc+XHJcbiAqICAgICAgICAgPHgtbWFwLW1hcmtlciBbTGF0aXR1ZGVdPSdsYXQnIFtMb25naXR1ZGVdPSdsbmcnIFtMYWJlbF09JydNJyc+PC94LW1hcC1tYXJrZXI+XHJcbiAqICAgICA8L3gtY2x1c3Rlci1sYXllcj5cclxuICogICA8L3gtbWFwPlxyXG4gKiBgXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAneC1jbHVzdGVyLWxheWVyJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgQ2x1c3RlckxheWVyRGlyZWN0aXZlIGV4dGVuZHMgTWFwTGF5ZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfY2x1c3RlcmluZ0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgcHJpdmF0ZSBfY2x1c3RlclBsYWNlbWVudE1vZGU6IENsdXN0ZXJQbGFjZW1lbnRNb2RlID0gQ2x1c3RlclBsYWNlbWVudE1vZGUuTWVhblZhbHVlO1xyXG4gICAgcHJpdmF0ZSBfY2x1c3RlckNsaWNrQWN0aW9uOiBDbHVzdGVyQ2xpY2tBY3Rpb24gPSBDbHVzdGVyQ2xpY2tBY3Rpb24uWm9vbUludG9DbHVzdGVyO1xyXG4gICAgcHJpdmF0ZSBfc3BpZGVyQ2x1c3Rlck9wdGlvbnM6IElTcGlkZXJDbHVzdGVyT3B0aW9ucztcclxuICAgIHByaXZhdGUgX3pJbmRleDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfZ3JpZFNpemU6IG51bWJlcjtcclxuICAgIHByaXZhdGUgX2xheWVyT2Zmc2V0OiBJUG9pbnQ7XHJcbiAgICBwcml2YXRlIF9pY29uSW5mbzogSU1hcmtlckljb25JbmZvO1xyXG4gICAgcHJpdmF0ZSBfbWluaW11bUNsdXN0ZXJTaXplOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9zdHlsZXM6IEFycmF5PElDbHVzdGVySWNvbkluZm8+O1xyXG4gICAgcHJpdmF0ZSBfdXNlRHluYW1pY1NpemVNYXJrZXIgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2R5bmFtaWNNYXJrZXJCYXNlU2l6ZSA9IDE4O1xyXG4gICAgcHJpdmF0ZSBfZHluYW1pY01hcmtlclJhbmdlczogTWFwPG51bWJlciwgc3RyaW5nPiA9IG5ldyBNYXA8bnVtYmVyLCBzdHJpbmc+KFtcclxuICAgICAgICBbMTAsICdyZ2JhKDIwLCAxODAsIDIwLCAwLjUpJ10sXHJcbiAgICAgICAgWzEwMCwgJ3JnYmEoMjU1LCAyMTAsIDQwLCAwLjUpJ10sXHJcbiAgICAgICAgW051bWJlci5NQVhfU0FGRV9JTlRFR0VSICwgJ3JnYmEoMjU1LCA0MCwgNDAsIDAuNSknXVxyXG4gICAgXSk7XHJcbiAgICBwcml2YXRlIF96b29tT25DbGljayA9IHRydWU7XHJcbiAgICBwcml2YXRlIF9pY29uQ3JlYXRpb25DYWxsYmFjazogKG06IEFycmF5PE1hcmtlcj4sIGk6IElNYXJrZXJJY29uSW5mbykgPT4gc3RyaW5nO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlZmludGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB0aGUgQ2x1c3RlciBDbGljayBBY3Rpb24ge0BsaW5rIENsdXN0ZXJDbGlja0FjdGlvbn0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgQ2x1c3RlckNsaWNrQWN0aW9uKCk6IENsdXN0ZXJDbGlja0FjdGlvbiAgeyByZXR1cm4gdGhpcy5fY2x1c3RlckNsaWNrQWN0aW9uOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBDbHVzdGVyQ2xpY2tBY3Rpb24odmFsOiBDbHVzdGVyQ2xpY2tBY3Rpb24pIHsgdGhpcy5fY2x1c3RlckNsaWNrQWN0aW9uID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0aGUgY2x1c3RlcmluZyBsYXllciBlbmFibGVzIGNsdXN0ZXJpbmcuIFdoZW4gc2V0IHRvIGZhbHNlLCB0aGUgbGF5ZXJcclxuICAgICAqIGJlaGF2ZXMgbGlrZSBhIGdlbmVyaWMgbGF5ZXIuIFRoaXMgaXMgaGFuZHkgaWYgeW91IHdhbnQgdG8gcHJldmVudCBjbHVzdGVyaW5nIGF0IGNlcnRhaW4gem9vbSBsZXZlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgQ2x1c3RlcmluZ0VuYWJsZWQoKTogYm9vbGVhbiAgeyByZXR1cm4gdGhpcy5fY2x1c3RlcmluZ0VuYWJsZWQ7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IENsdXN0ZXJpbmdFbmFibGVkKHZhbDogYm9vbGVhbikgeyB0aGlzLl9jbHVzdGVyaW5nRW5hYmxlZCA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBjbHVzdGVyIHBsYWNlbWVudCBtb2RlLiB7QGxpbmsgQ2x1c3RlclBsYWNlbWVudE1vZGV9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgQ2x1c3RlclBsYWNlbWVudE1vZGUoKTogQ2x1c3RlclBsYWNlbWVudE1vZGUgIHsgcmV0dXJuIHRoaXMuX2NsdXN0ZXJQbGFjZW1lbnRNb2RlOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBDbHVzdGVyUGxhY2VtZW50TW9kZSh2YWw6IENsdXN0ZXJQbGFjZW1lbnRNb2RlKSB7IHRoaXMuX2NsdXN0ZXJQbGFjZW1lbnRNb2RlID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGNhbGxiYWNrIGludm9rZWQgdG8gY3JlYXRlIGEgY3VzdG9tIGNsdXN0ZXIgbWFya2VyLiBOb3RlIHRoYXQgd2hlbiB7QGxpbmsgVXNlRHluYW1pY1NpemVNYXJrZXJzfSBpcyBlbmFibGVkLFxyXG4gICAgICogeW91IGNhbm5vdCBzZXQgYSBjdXN0b20gbWFya2VyIGNhbGxiYWNrLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IEN1c3RvbU1hcmtlckNhbGxiYWNrKCk6IChtOiBBcnJheTxNYXJrZXI+LCBpOiBJTWFya2VySWNvbkluZm8pID0+IHN0cmluZyAgeyByZXR1cm4gdGhpcy5faWNvbkNyZWF0aW9uQ2FsbGJhY2s7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IEN1c3RvbU1hcmtlckNhbGxiYWNrKHZhbDogKG06IEFycmF5PE1hcmtlcj4sIGk6IElNYXJrZXJJY29uSW5mbykgPT4gc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl91c2VEeW5hbWljU2l6ZU1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3coXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKGBZb3UgY2Fubm90IHNldCBhIGN1c3RvbSBtYXJrZXIgY2FsbGJhY2sgd2hlbiBVc2VEeW5hbWljU2l6ZU1hcmtlcnMgaXMgc2V0IHRvIHRydWUuXHJcbiAgICAgICAgICAgICAgICAgICAgU2V0IFVzZUR5bmFtaWNTaXplTWFrZXJzIHRvIGZhbHNlLmApXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2ljb25DcmVhdGlvbkNhbGxiYWNrID0gdmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFzZSBzaXplIG9mIGR5bmFtaWMgbWFya2VycyBpbiBwaXhlbHMuIFRoZSBhY3R1YWx5IHNpemUgb2YgdGhlIGR5bmFtaWMgbWFya2VyIGlzIGJhc2VkIG9uIHRoaXMuXHJcbiAgICAgKiBTZWUge0BsaW5rIFVzZUR5bmFtaWNTaXplTWFya2Vyc30uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgRHluYW1pY01hcmtlckJhc2VTaXplKCk6IG51bWJlciAgeyByZXR1cm4gdGhpcy5fZHluYW1pY01hcmtlckJhc2VTaXplOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBEeW5hbWljTWFya2VyQmFzZVNpemUodmFsOiBudW1iZXIpIHsgdGhpcy5fZHluYW1pY01hcmtlckJhc2VTaXplID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHJhbmdlcyB0byB1c2UgdG8gY2FsY3VsYXRlIGJyZWFrcG9pbnRzIGFuZCBjb2xvcnMgZm9yIGR5bmFtaWMgbWFya2Vycy5cclxuICAgICAqIFRoZSBtYXAgY29udGFpbnMga2V5L3ZhbHVlIHBhaXJzLCB3aXRoIHRoZSBrZXlzIGJlaW5nXHJcbiAgICAgKiB0aGUgYnJlYWtwb2ludCBzaXplcyBhbmQgdGhlIHZhbHVlcyB0aGUgY29sb3JzIHRvIGJlIHVzZWQgZm9yIHRoZSBkeW5hbWljIG1hcmtlciBpbiB0aGF0IHJhbmdlLiBTZWUge0BsaW5rIFVzZUR5bmFtaWNTaXplTWFya2Vyc30uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgRHluYW1pY01hcmtlclJhbmdlcygpOiBNYXA8bnVtYmVyLCBzdHJpbmc+ICB7IHJldHVybiB0aGlzLl9keW5hbWljTWFya2VyUmFuZ2VzOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBEeW5hbWljTWFya2VyUmFuZ2VzKHZhbDogTWFwPG51bWJlciwgc3RyaW5nPikgeyB0aGlzLl9keW5hbWljTWFya2VyUmFuZ2VzID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGdyaWQgc2l6ZSB0byBiZSB1c2VkIGZvciBjbHVzdGVyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IEdyaWRTaXplKCk6IG51bWJlciAgeyByZXR1cm4gdGhpcy5fZ3JpZFNpemU7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IEdyaWRTaXplKHZhbDogbnVtYmVyKSB7IHRoaXMuX2dyaWRTaXplID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIEljb25JbmZvIHRvIGJlIHVzZWQgdG8gY3JlYXRlIGEgY3VzdG9tIGNsdXN0ZXIgbWFya2VyLiBTdXBwb3J0cyBmb250LWJhc2VkLCBTVkcsIGdyYXBoaWNzIGFuZCBtb3JlLlxyXG4gICAgICogU2VlIHtAbGluayBJTWFya2VySWNvbkluZm99LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IEljb25JbmZvKCk6IElNYXJrZXJJY29uSW5mbyAgeyByZXR1cm4gdGhpcy5faWNvbkluZm87IH1cclxuICAgICAgICBwdWJsaWMgc2V0IEljb25JbmZvKHZhbDogSU1hcmtlckljb25JbmZvKSB7IHRoaXMuX2ljb25JbmZvID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgQW4gb2Zmc2V0IGFwcGxpZWQgdG8gdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBMYXllck9mZnNldCgpOiBJUG9pbnQgIHsgcmV0dXJuIHRoaXMuX2xheWVyT2Zmc2V0OyB9XHJcbiAgICAgICAgcHVibGljIHNldCBMYXllck9mZnNldCh2YWw6IElQb2ludCkgeyB0aGlzLl9sYXllck9mZnNldCA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHBpbnMgcmVxdWlyZWQgdG8gZm9ybSBhIGNsdXN0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IE1pbmltdW1DbHVzdGVyU2l6ZSgpOiBudW1iZXIgIHsgcmV0dXJuIHRoaXMuX21pbmltdW1DbHVzdGVyU2l6ZTsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgTWluaW11bUNsdXN0ZXJTaXplKHZhbDogbnVtYmVyKSB7IHRoaXMuX21pbmltdW1DbHVzdGVyU2l6ZSA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25zIGZvciBzcGlkZXIgY2x1c3RlcmluZyBiZWhhdmlvci4gU2VlIHtAbGluayBJU3BpZGVyQ2x1c3Rlck9wdGlvbnN9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgU3BpZGVyQ2x1c3Rlck9wdGlvbnMoKTogSVNwaWRlckNsdXN0ZXJPcHRpb25zIHsgcmV0dXJuIHRoaXMuX3NwaWRlckNsdXN0ZXJPcHRpb25zOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBTcGlkZXJDbHVzdGVyT3B0aW9ucyh2YWw6IElTcGlkZXJDbHVzdGVyT3B0aW9ucykgeyB0aGlzLl9zcGlkZXJDbHVzdGVyT3B0aW9ucyA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBjbHVzdGVyIHN0eWxlc1xyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgU3R5bGVzKCk6IEFycmF5PElDbHVzdGVySWNvbkluZm8+IHsgcmV0dXJuIHRoaXMuX3N0eWxlczsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgU3R5bGVzKHZhbDogQXJyYXk8SUNsdXN0ZXJJY29uSW5mbz4pIHsgdGhpcy5fc3R5bGVzID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0byB1c2UgZHluYW1pYyBtYXJrZXJzLiBEeW5hbWljIG1hcmtlcnMgY2hhbmdlIGluIHNpemUgYW5kIGNvbG9yIGRlcGVuZGluZyBvbiB0aGUgbnVtYmVyIG9mXHJcbiAgICAgKiBwaW5zIGluIHRoZSBjbHVzdGVyLiBJZiBzZXQgdG8gdHJ1ZSwgdGhpcyB3aWxsIHRha2UgcHJlY2VuZGVuY2Ugb3ZlciBhbnkgY3VzdG9tIG1hcmtlciBjcmVhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBVc2VEeW5hbWljU2l6ZU1hcmtlcnMoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl91c2VEeW5hbWljU2l6ZU1hcmtlcjsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgVXNlRHluYW1pY1NpemVNYXJrZXJzKHZhbDogYm9vbGVhbikge1xyXG4gICAgICAgICAgICB0aGlzLl91c2VEeW5hbWljU2l6ZU1hcmtlciA9IHZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbkNyZWF0aW9uQ2FsbGJhY2sgPSAobTogQXJyYXk8TWFya2VyPiwgaW5mbzogSU1hcmtlckljb25JbmZvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENsdXN0ZXJMYXllckRpcmVjdGl2ZS5DcmVhdGVEeW5hbWljU2l6ZU1hcmtlcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5sZW5ndGgsIGluZm8sIHRoaXMuX2R5bmFtaWNNYXJrZXJCYXNlU2l6ZSwgdGhpcy5fZHluYW1pY01hcmtlclJhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB6LWluZGV4IG9mIHRoZSBsYXllci4gSWYgbm90IHVzZWQsIGxheWVycyBnZXQgc3RhY2tlZCBpbiB0aGUgb3JkZXIgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBaSW5kZXgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3pJbmRleDsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgWkluZGV4KHZhbDogbnVtYmVyKSB7IHRoaXMuX3pJbmRleCA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdGhlIGNsdXN0ZXIgc2hvdWxkIHpvb20gaW4gb24gY2xpY2tcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IFpvb21PbkNsaWNrKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fem9vbU9uQ2xpY2s7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IFpvb21PbkNsaWNrKHZhbDogYm9vbGVhbikgeyB0aGlzLl96b29tT25DbGljayA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgZHluYW1pYyBzaXplIG1hcmtlciB0byBiZSB1c2VkIGZvciBjbHVzdGVyIG1hcmtlcnMgaWYgVXNlRHluYW1pY1NpemVNYXJrZXJzIGlzIHNldCB0byB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzaXplIC0gVGhlIG51bWJlciBvZiBtYXJrZXJzIGluIHRoZSBjbHVzdGVyLlxyXG4gICAgICogQHBhcmFtIGluZm8gIC0gVGhlIGljb24gaW5mbyB0byBiZSB1c2VkLiBUaGlzIHdpbGwgYmUgaHlkcmF0ZWQgd2l0aFxyXG4gICAgICogdGhlIGFjdHVhbHkgZGltZW5zaW9ucyBvZiB0aGUgY3JlYXRlZCBtYXJrZXJzIGFuZCBpcyB1c2VkIGJ5IHRoZSB1bmRlcmx5aW5nIG1vZGVsL3NlcnZpY2VzXHJcbiAgICAgKiB0byBjb3JyZWN0bHkgb2Zmc2V0IHRoZSBtYXJrZXIgZm9yIGNvcnJlY3QgcG9zaXRpb25pbmcuXHJcbiAgICAgKiBAcGFyYW0gYmFzZU1hcmtlclNpemUgLSBUaGUgYmFzZSBzaXplIGZvciBkeW5taWMgbWFya2Vycy5cclxuICAgICAqIEBwYXJhbSByYW5nZXMgLSBUaGUgcmFuZ2VzIHRvIHVzZSB0byBjYWxjdWxhdGUgYnJlYWtwb2ludHMgYW5kIGNvbG9ycyBmb3IgZHluYW1pYyBtYXJrZXJzLlxyXG4gICAgICogVGhlIG1hcCBjb250YWlucyBrZXkvdmFsdWUgcGFpcnMsIHdpdGggdGhlIGtleXMgYmVpbmdcclxuICAgICAqIHRoZSBicmVha3BvaW50IHNpemVzIGFuZCB0aGUgdmFsdWVzIHRoZSBjb2xvcnMgdG8gYmUgdXNlZCBmb3IgdGhlIGR5bmFtaWMgbWFya2VyIGluIHRoYXQgcmFuZ2UuXHJcbiAgICAgKiBAcmV0dXJucyAtIEFuIHN0cmluZyBjb250YWluaW5nIHRoZSBTVkcgZm9yIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENyZWF0ZUR5bmFtaWNTaXplTWFya2VyKHNpemU6IG51bWJlciwgaW5mbzogSU1hcmtlckljb25JbmZvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlTWFya2VyU2l6ZTogbnVtYmVyLCByYW5nZXM6IE1hcDxudW1iZXIsIHN0cmluZz4pOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG1yOiBudW1iZXIgPSBiYXNlTWFya2VyU2l6ZTtcclxuICAgICAgICBjb25zdCBvdXRsaW5lOiBudW1iZXIgPSBtciAqIDAuMzU7XHJcbiAgICAgICAgY29uc3QgdG90YWw6IG51bWJlciA9IHNpemU7XHJcbiAgICAgICAgY29uc3QgcjogbnVtYmVyID0gTWF0aC5sb2codG90YWwpIC8gTWF0aC5sb2coMTApICogNSArIG1yO1xyXG4gICAgICAgIGNvbnN0IGQ6IG51bWJlciA9IHIgKiAyO1xyXG4gICAgICAgIGxldCBmaWxsQ29sb3I6IHN0cmluZztcclxuICAgICAgICByYW5nZXMuZm9yRWFjaCgodiwgaykgPT4ge1xyXG4gICAgICAgICAgICBpZiAodG90YWwgPD0gayAmJiAhZmlsbENvbG9yKSB7IGZpbGxDb2xvciA9IHY7IH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWZpbGxDb2xvcikgeyBmaWxsQ29sb3IgPSAncmdiYSgyMCwgMTgwLCAyMCwgMC41KSc7IH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuIFNWRyBzdHJpbmcgb2YgdHdvIGNpcmNsZXMsIG9uZSBvbiB0b3Agb2YgdGhlIG90aGVyLCB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzIGFuZCBjb2xvci5cclxuICAgICAgICBjb25zdCBzdmc6IEFycmF5PGFueT4gPSBbYDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB3aWR0aD0nJHtkfScgaGVpZ2h0PScke2R9Jz5gLFxyXG4gICAgICAgICAgICBgPGNpcmNsZSBjeD0nJHtyfScgY3k9JyR7cn0nIHI9JyR7cn0nIGZpbGw9JyR7ZmlsbENvbG9yfScvPmAsXHJcbiAgICAgICAgICAgIGA8Y2lyY2xlIGN4PScke3J9JyBjeT0nJHtyfScgcj0nJHtyIC0gb3V0bGluZX0nIGZpbGw9JyR7ZmlsbENvbG9yfScvPmAsXHJcbiAgICAgICAgICAgIGA8L3N2Zz5gXTtcclxuICAgICAgICBpbmZvLnNpemUgPSB7IHdpZHRoOiBkLCBoZWlnaHQ6IGQgfTtcclxuICAgICAgICBpbmZvLm1hcmtlck9mZnNldFJhdGlvID0geyB4OiAwLjUsIHk6IDAuNSB9O1xyXG4gICAgICAgIGluZm8udGV4dE9mZnNldCA9IHsgeDogMCwgeTogciAtIDggfTtcclxuICAgICAgICByZXR1cm4gc3ZnLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBfbGF5ZXJTZXJ2aWNlIC0gQ29uY3JldGVkIGltcGxlbWVudGF0aW9uIG9mIGEgY2x1c3RlciBsYXllciBzZXJ2aWNlIGZvciB0aGUgdW5kZXJseWluZyBtYXBzXHJcbiAgICAgKiBpbXBsZW1lbnRhdGlvbnMuIEdlbmVyYWxseSBwcm92aWRlZCB2aWEgaW5qZWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSBfY29udGFpbmVyUmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIHZpZXcgY29udGFpbmVyIG9mIHRoZSBsYXllci4gR2VuZXJhbGx5IHByb3ZpZGVkIHZpYSBpbmplY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfbGF5ZXJTZXJ2aWNlOiBDbHVzdGVyU2VydmljZSwgX2NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xyXG4gICAgICAgIHN1cGVyKF9sYXllclNlcnZpY2UsIF9jb250YWluZXJSZWYpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWN0cyB0byBjaGFuZ2VzIGluIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50IGFuZCBhY3R1YXRlcyBwcm9wZXJ0eSBjaGFuZ2VzIGluIHRoZSB1bmRlcmxpbmcgbGF5ZXIgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYW5nZXMgLSBjb2xsZWN0aW9uIG9mIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBbcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZFRvTWFuYWdlcikgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snQ2x1c3RlckNsaWNrQWN0aW9uJ10pIHtcclxuICAgICAgICAgICAgdGhyb3cgKFxyXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKCdZb3UgY2Fubm90IGNoYW5nZSB0aGUgQ2x1c3RlckNsaWNrQWN0aW9uIGFmdGVyIHRoZSBsYXllciBoYXMgYmVlbiBhZGRlZCB0byB0aGUgbGF5ZXJzZXJ2aWNlLicpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBvcHRpb25zOiBJQ2x1c3Rlck9wdGlvbnMgPSB7IGlkOiB0aGlzLl9pZCB9O1xyXG4gICAgICAgIGlmIChjaGFuZ2VzWydDbHVzdGVyaW5nRW5hYmxlZCddKSB7IG9wdGlvbnMuY2x1c3RlcmluZ0VuYWJsZWQgPSB0aGlzLl9jbHVzdGVyaW5nRW5hYmxlZDsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydHcmlkU2l6ZSddKSB7IG9wdGlvbnMuZ3JpZFNpemUgPSB0aGlzLl9ncmlkU2l6ZTsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydMYXllck9mZnNldCddKSB7IG9wdGlvbnMubGF5ZXJPZmZzZXQgPSB0aGlzLl9sYXllck9mZnNldDsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydTcGlkZXJDbHVzdGVyT3B0aW9ucyddKSB7IG9wdGlvbnMuc3BpZGVyQ2x1c3Rlck9wdGlvbnMgPSB0aGlzLl9zcGlkZXJDbHVzdGVyT3B0aW9uczsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydaSW5kZXgnXSkgeyBvcHRpb25zLnpJbmRleCA9IHRoaXMuX3pJbmRleDsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydWaXNpYmxlJ10pIHsgb3B0aW9ucy52aXNpYmxlID0gdGhpcy5fdmlzaWJsZTsgfVxyXG5cclxuICAgICAgICB0aGlzLl9sYXllclNlcnZpY2UuR2V0TmF0aXZlTGF5ZXIodGhpcykudGhlbigobDogTGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgbC5TZXRPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gICAgRGlyZWN0aXZlLCBJbnB1dCwgT3V0cHV0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgVmlld0NvbnRhaW5lclJlZixcclxuICAgIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBBZnRlckNvbnRlbnRJbml0LCBTaW1wbGVDaGFuZ2VzXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElQb2x5Z29uRXZlbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5Z29uLWV2ZW50JztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgUG9seWdvblNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJbmZvQm94Q29tcG9uZW50IH0gZnJvbSAnLi9pbmZvYm94JztcclxuXHJcbmxldCBwb2x5Z29uSWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIE1hcFBvbHlnb25EaXJlY3RpdmUgcmVuZGVycyBhIHBvbHlnb24gaW5zaWRlIGEge0BsaW5rIE1hcENvbXBvbmVudH0uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG4gKiBpbXBvcnQge01hcENvbXBvbmVudCwgTWFwUG9seWdvbkRpcmVjdGl2ZX0gZnJvbSAnLi4uJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICBzZWxlY3RvcjogJ215LW1hcCxcclxuICogIHN0eWxlczogW2BcclxuICogICAubWFwLWNvbnRhaW5lciB7IGhlaWdodDogMzAwcHg7IH1cclxuICogYF0sXHJcbiAqIHRlbXBsYXRlOiBgXHJcbiAqICAgPHgtbWFwIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtab29tXT1cInpvb21cIj5cclxuICogICAgICA8eC1tYXAtcG9seWdvbiBbUGF0aHNdPVwicGF0aFwiPjwveC1tYXAtcG9seWdvbj5cclxuICogICA8L3gtbWFwPlxyXG4gKiBgXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAneC1tYXAtcG9seWdvbidcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hcFBvbHlnb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2luQ3VzdG9tTGF5ZXIgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2lkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9sYXllcklkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9hZGRlZFRvU2VydmljZSA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfZXZlbnRzOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEFueSBJbmZvQm94IHRoYXQgaXMgYSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhlIHBvbHlnb25cclxuICAgIC8vL1xyXG4gICAgQENvbnRlbnRDaGlsZChJbmZvQm94Q29tcG9uZW50KSBwcm90ZWN0ZWQgX2luZm9Cb3g6IEluZm9Cb3hDb21wb25lbnQ7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdGhpcyBQb2x5Z29uIGhhbmRsZXMgbW91c2UgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBDbGlja2FibGUgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIGNhbiBkcmFnIHRoaXMgc2hhcGUgb3ZlciB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBEcmFnZ2FibGUgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciBjYW4gZWRpdCB0aGlzIHNoYXBlIGJ5IGRyYWdnaW5nIHRoZSBjb250cm9sXHJcbiAgICAgKiBwb2ludHMgc2hvd24gYXQgdGhlIHZlcnRpY2VzIGFuZCBvbiBlYWNoIHNlZ21lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIEVkaXRhYmxlID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmlsbCBjb2xvciBvZiB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgRmlsbENvbG9yOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmlsbCBvcGFjaXR5IGJldHdlZW4gMC4wIGFuZCAxLjBcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgRmlsbE9wYWNpdHk6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gdHJ1ZSwgZWRnZXMgb2YgdGhlIHBvbHlnb24gYXJlIGludGVycHJldGVkIGFzIGdlb2Rlc2ljIGFuZCB3aWxsXHJcbiAgICAgKiBmb2xsb3cgdGhlIGN1cnZhdHVyZSBvZiB0aGUgRWFydGguIFdoZW4gZmFsc2UsIGVkZ2VzIG9mIHRoZSBwb2x5Z29uIGFyZVxyXG4gICAgICogcmVuZGVyZWQgYXMgc3RyYWlnaHQgbGluZXMgaW4gc2NyZWVuIHNwYWNlLiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIGFcclxuICAgICAqIGdlb2Rlc2ljIHBvbHlnb24gbWF5IGFwcGVhciB0byBjaGFuZ2Ugd2hlbiBkcmFnZ2VkLCBhcyB0aGUgZGltZW5zaW9uc1xyXG4gICAgICogYXJlIG1haW50YWluZWQgcmVsYXRpdmUgdG8gdGhlIHN1cmZhY2Ugb2YgdGhlIGVhcnRoLiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgR2VvZGVzaWMgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWF4aW11bSB6b29tIGF0IHdoaWNoIHRoZSBwb2x5Z29uIGxhYmxlIGlzIHZpc2libGUuIElnbm9yZWQgaWYgU2hvd0xhYmVsIGlzIGZhbHNlLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIExhYmVsTWF4Wm9vbTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtaW5pbXVtIHpvb20gYXQgd2hpY2ggdGhlIHBvbHlnb24gbGFibGUgaXMgdmlzaWJsZS4gSWdub3JlZCBpZiBTaG93TGFiZWwgaXMgZmFsc2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWxNaW5ab29tOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcmJpdGFyeSBtZXRhZGF0YSB0byBhc3NpZ24gdG8gdGhlIFBvbHlnb24uIFRoaXMgaXMgdXNlZnVsIGZvciBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTWV0YWRhdGE6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yZGVyZWQgc2VxdWVuY2Ugb2YgY29vcmRpbmF0ZXMgdGhhdCBkZXNpZ25hdGVzIGEgY2xvc2VkIGxvb3AuXHJcbiAgICAgKiBVbmxpa2UgcG9seWxpbmVzLCBhIHBvbHlnb24gbWF5IGNvbnNpc3Qgb2Ygb25lIG9yIG1vcmUgcGF0aHMuXHJcbiAgICAgKiBBcyBhIHJlc3VsdCwgdGhlIHBhdGhzIHByb3BlcnR5IG1heSBzcGVjaWZ5IG9uZSBvciBtb3JlIGFycmF5cyBvZlxyXG4gICAgICogTGF0TG5nIGNvb3JkaW5hdGVzLiBQYXRocyBhcmUgY2xvc2VkIGF1dG9tYXRpY2FsbHk7IGRvIG5vdCByZXBlYXQgdGhlXHJcbiAgICAgKiBmaXJzdCB2ZXJ0ZXggb2YgdGhlIHBhdGggYXMgdGhlIGxhc3QgdmVydGV4LiBTaW1wbGUgcG9seWdvbnMgbWF5IGJlXHJcbiAgICAgKiBkZWZpbmVkIHVzaW5nIGEgc2luZ2xlIGFycmF5IG9mIExhdExuZ3MuIE1vcmUgY29tcGxleCBwb2x5Z29ucyBtYXlcclxuICAgICAqIHNwZWNpZnkgYW4gYXJyYXkgb2YgYXJyYXlzIChmb3IgaW5uZXIgbG9vcHMgKS4gQW55IHNpbXBsZSBhcnJheXMgYXJlIGNvbnZlcnRlZCBpbnRvIEFycmF5cy5cclxuICAgICAqIEluc2VydGluZyBvciByZW1vdmluZyBMYXRMbmdzIGZyb20gdGhlIEFycmF5IHdpbGwgYXV0b21hdGljYWxseSB1cGRhdGVcclxuICAgICAqIHRoZSBwb2x5Z29uIG9uIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFBhdGhzOiBBcnJheTxJTGF0TG9uZz4gfCBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgdGhlIHRpdGxlIGFzIHRoZSBsYWJlbCBvbiB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd0xhYmVsOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBzaG93IHRoZSB0aXRsZSBvZiB0aGUgcG9seWdvbiBhcyB0aGUgdG9vbHRpcCBvbiB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd1Rvb2x0aXA6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0cm9rZSBjb2xvci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU3Ryb2tlQ29sb3I6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdHJva2Ugb3BhY2l0eSBiZXR3ZWVuIDAuMCBhbmQgMS4wXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFN0cm9rZU9wYWNpdHk6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdHJva2Ugd2lkdGggaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBTdHJva2VXZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0aXRsZSBvZiB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVGl0bGU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBwb2x5Z29uIGlzIHZpc2libGUgb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVmlzaWJsZTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB6SW5kZXggY29tcGFyZWQgdG8gb3RoZXIgcG9seXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIHpJbmRleDogbnVtYmVyO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIERlbGVnYXRlIGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIGNsaWNrIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBDbGljazogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gZGJsY2xpY2sgZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERibENsaWNrOiBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIHJlcGVhdGVkbHkgZmlyZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIHBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERyYWc6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgRHJhZ0VuZDogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgRHJhZ1N0YXJ0OiBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZWRvd24gZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlRG93bjogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vtb3ZlIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZU1vdmU6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWdvbiBtb3VzZW91dC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWdvbiBtb3VzZW92ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlT3ZlcjogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGUgdGhlIERPTSBtb3VzZXVwIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlVXA6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIFBvbHlnb24gaXMgcmlnaHQtY2xpY2tlZCBvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgUmlnaHRDbGljazogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGVkaXRpbmcgaGFzIGNvbXBsZXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgUGF0aENoYW5nZWQ6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGhhcyBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB0aGUgc2VydmljZS5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBBZGRlZFRvU2VydmljZSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2FkZGVkVG9TZXJ2aWNlOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGlkIG9mIHRoZSBwb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5faWQ7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGlkIG9mIHRoZSBwb2x5Z29uIGFzIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZEFzU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9pZC50b1N0cmluZygpOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgaW4gYSBjdXN0b20gbGF5ZXIuIFNlZSB7QGxpbmsgTWFwTGF5ZXJ9LlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJbkN1c3RvbUxheWVyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faW5DdXN0b21MYXllcjsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0cyB0aGUgaWQgb2YgdGhlIExheWVyIHRoZSBwb2x5Z29uIGJlbG9uZ3MgdG8uXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IExheWVySWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2xheWVySWQ7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1hcFBvbHlnb25EaXJlY3RpdmUuXHJcbiAgICAgKiBAcGFyYW0gX3BvbHlnb25NYW5hZ2VyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcG9seWdvblNlcnZpY2U6IFBvbHlnb25TZXJ2aWNlLCBwcml2YXRlIF9jb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpIHtcclxuICAgICAgICB0aGlzLl9pZCA9IHBvbHlnb25JZCsrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhZnRlciB0aGUgY29udGVudCBpbnRpYWxpemF0aW9uIG9mIHRoZSBkaXJlY3RpdmUgaXMgY29tcGxldGUuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5hbWU6IHN0cmluZyA9IHRoaXMuX2NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudC50YWdOYW1lO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC1tYXAtbGF5ZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbkN1c3RvbUxheWVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVySWQgPSBOdW1iZXIodGhpcy5fY29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LmF0dHJpYnV0ZXNbJ2xheWVySWQnXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZFRvU2VydmljZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29uU2VydmljZS5BZGRQb2x5Z29uKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRlZFRvU2VydmljZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuQWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gY2hhbmdlcyB0byB0aGUgZGF0YWJvdWQgcHJvcGVydGllcyBvY2N1ci4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYW5nZXMgLSBDaGFuZ2VzIHRoYXQgaGF2ZSBvY2N1cmVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiBhbnkge1xyXG4gICAgICAgIGlmICghdGhpcy5fYWRkZWRUb1NlcnZpY2UpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGNvbnN0IG86IElQb2x5Z29uT3B0aW9ucyA9IHRoaXMuR2VuZXJhdGVQb2x5Z29uQ2hhbmdlU2V0KGNoYW5nZXMpO1xyXG4gICAgICAgIGlmIChvICE9IG51bGwpIHsgdGhpcy5fcG9seWdvblNlcnZpY2UuU2V0T3B0aW9ucyh0aGlzLCBvKTsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydQYXRocyddICYmICFjaGFuZ2VzWydQYXRocyddLmlzRmlyc3RDaGFuZ2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29uU2VydmljZS5VcGRhdGVQb2x5Z29uKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcG95Z29uIGlzIGJlaW5nIGRlc3Ryb3llZC4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuIFJlbGVhc2UgcmVzb3VyY2VzLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9wb2x5Z29uU2VydmljZS5EZWxldGVQb2x5Z29uKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKChzKSA9PiBzLnVuc3Vic2NyaWJlKCkpO1xyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIC8vLyByZW1vdmUgZXZlbnQgc3Vic2NyaXB0aW9uc1xyXG4gICAgICAgIC8vL1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaXJlcyB1cCB0aGUgZXZlbnQgcmVjZWl2ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgY29uc3QgX2dldEV2ZW50QXJnOiAoZTogTW91c2VFdmVudCkgPT4gSVBvbHlnb25FdmVudCA9IGUgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgUG9seWdvbjogdGhpcyxcclxuICAgICAgICAgICAgICAgIENsaWNrOiBlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaCh0aGlzLl9wb2x5Z29uU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUoJ2NsaWNrJywgdGhpcykuc3Vic2NyaWJlKChldjogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0OiBNYXBQb2x5Z29uRGlyZWN0aXZlID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luZm9Cb3ggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5mb0JveC5PcGVuKHRoaXMuX3BvbHlnb25TZXJ2aWNlLkdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGV2KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5DbGljay5lbWl0KF9nZXRFdmVudEFyZyhldikpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBjb25zdCBoYW5kbGVycyA9IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnZGJsY2xpY2snLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRGJsQ2xpY2suZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWcuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnZW5kJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWdFbmQuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZ1N0YXJ0LmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vkb3duJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlRG93bi5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU1vdmUuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU91dC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlb3ZlcicsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU92ZXIuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZXVwJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlVXAuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlJpZ2h0Q2xpY2suZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdwYXRoY2hhbmdlZCcsIGhhbmRsZXI6IChldjogSVBvbHlnb25FdmVudCkgPT4gdGhpcy5QYXRoQ2hhbmdlZC5lbWl0KGV2KSB9XHJcbiAgICAgICAgXTtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChvYmopID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3MgPSB0aGlzLl9wb2x5Z29uU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUob2JqLm5hbWUsIHRoaXMpLnN1YnNjcmliZShvYmouaGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKG9zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgSVBvbHlnb24gb3B0aW9uIGNoYW5nZXNldCBmcm9tIGRpcmVjdGl2ZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIHtAbGluayBTaW1wbGVDaGFuZ2VzfSBpZGVudGlmeWluZyB0aGUgY2hhbmdlcyB0aGF0IG9jY3VyZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJUG9seWdvbk9wdGlvbnN9IGNvbnRhaW5pbmcgdGhlIHBvbHlnb24gb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIEdlbmVyYXRlUG9seWdvbkNoYW5nZVNldChjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogSVBvbHlnb25PcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMgPSB7IGlkOiB0aGlzLl9pZCB9O1xyXG4gICAgICAgIGxldCBoYXNPcHRpb25zOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0NsaWNrYWJsZSddKSB7IG9wdGlvbnMuY2xpY2thYmxlID0gdGhpcy5DbGlja2FibGU7IGhhc09wdGlvbnMgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0RyYWdnYWJsZSddKSB7IG9wdGlvbnMuZHJhZ2dhYmxlID0gdGhpcy5EcmFnZ2FibGU7IGhhc09wdGlvbnMgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0VkaXRhYmxlJ10pIHsgb3B0aW9ucy5lZGl0YWJsZSA9IHRoaXMuRWRpdGFibGU7IGhhc09wdGlvbnMgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0ZpbGxDb2xvciddIHx8IGNoYW5nZXNbJ0ZpbGxPcGFjaXR5J10pIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5maWxsQ29sb3IgPSB0aGlzLkZpbGxDb2xvcjtcclxuICAgICAgICAgICAgb3B0aW9ucy5maWxsT3BhY2l0eSA9IHRoaXMuRmlsbE9wYWNpdHk7XHJcbiAgICAgICAgICAgIGhhc09wdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snR2VvZGVzaWMnXSkgeyBvcHRpb25zLmdlb2Rlc2ljID0gdGhpcy5HZW9kZXNpYzsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snTGFiZWxNYXhab29tJ10pIHsgb3B0aW9ucy5sYWJlbE1heFpvb20gPSB0aGlzLkxhYmVsTWF4Wm9vbTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snTGFiZWxNaW5ab29tJ10pIHsgb3B0aW9ucy5sYWJlbE1pblpvb20gPSB0aGlzLkxhYmVsTWluWm9vbTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU2hvd1Rvb2x0aXAnXSkgeyBvcHRpb25zLnNob3dUb29sdGlwID0gdGhpcy5TaG93VG9vbHRpcDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU2hvd0xhYmVsJ10pIHsgb3B0aW9ucy5zaG93TGFiZWwgPSB0aGlzLlNob3dMYWJlbDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU3Ryb2tlQ29sb3InXSB8fCBjaGFuZ2VzWydTdHJva2VPcGFjaXR5J10pIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5zdHJva2VDb2xvciA9IHRoaXMuU3Ryb2tlQ29sb3I7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc3Ryb2tlT3BhY2l0eSA9IHRoaXMuU3Ryb2tlT3BhY2l0eTtcclxuICAgICAgICAgICAgaGFzT3B0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydTdHJva2VXZWlnaHQnXSkgeyBvcHRpb25zLnN0cm9rZVdlaWdodCA9IHRoaXMuU3Ryb2tlV2VpZ2h0OyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydUaXRsZSddKSB7IG9wdGlvbnMudGl0bGUgPSB0aGlzLlRpdGxlOyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydWaXNpYmxlJ10pIHsgb3B0aW9ucy52aXNpYmxlID0gdGhpcy5WaXNpYmxlOyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWyd6SW5kZXgnXSkgeyBvcHRpb25zLnpJbmRleCA9IHRoaXMuekluZGV4OyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIHJldHVybiBoYXNPcHRpb25zID8gb3B0aW9ucyA6IG51bGw7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgICBEaXJlY3RpdmUsIElucHV0LCBPdXRwdXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBWaWV3Q29udGFpbmVyUmVmLFxyXG4gICAgRXZlbnRFbWl0dGVyLCBDb250ZW50Q2hpbGQsIEFmdGVyQ29udGVudEluaXQsIFNpbXBsZUNoYW5nZXNcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvaW50JztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wb2x5bGluZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lRXZlbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1ldmVudCc7XHJcbmltcG9ydCB7IEluZm9Cb3hDb21wb25lbnQgfSBmcm9tICcuL2luZm9ib3gnO1xyXG5cclxubGV0IHBvbHlsaW5lSWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIE1hcFBvbHlsaW5lRGlyZWN0aXZlIHJlbmRlcnMgYSBwb2x5bGluZSBpbnNpZGUgYSB7QGxpbmsgTWFwQ29tcG9uZW50fS5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50LCBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZnJvbSAnLi4uJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICBzZWxlY3RvcjogJ215LW1hcCxcclxuICogIHN0eWxlczogW2BcclxuICogICAubWFwLWNvbnRhaW5lciB7IGhlaWdodDogMzAwcHg7IH1cclxuICogYF0sXHJcbiAqIHRlbXBsYXRlOiBgXHJcbiAqICAgPHgtbWFwIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtab29tXT1cInpvb21cIj5cclxuICogICAgICA8eC1tYXAtcG9seWxpbmUgW1BhdGhzXT1cInBhdGhcIj48L3gtbWFwLXBvbHlsaW5lPlxyXG4gKiAgIDwveC1tYXA+XHJcbiAqIGBcclxuICogfSlcclxuICogYGBgXHJcbiAqXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICd4LW1hcC1wb2x5bGluZSdcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hcFBvbHlsaW5lRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9pbkN1c3RvbUxheWVyID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9pZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfbGF5ZXJJZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfYWRkZWRUb1NlcnZpY2UgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2V2ZW50czogU3Vic2NyaXB0aW9uW10gPSBbXTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBBbnkgSW5mb0JveCB0aGF0IGlzIGEgZGlyZWN0IGNoaWxkcmVuIG9mIHRoZSBwb2x5bGluZVxyXG4gICAgLy8vXHJcbiAgICBAQ29udGVudENoaWxkKEluZm9Cb3hDb21wb25lbnQpIHByb3RlY3RlZCBfaW5mb0JveDogSW5mb0JveENvbXBvbmVudDtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0aGlzIFBvbHlsaW5lIGhhbmRsZXMgbW91c2UgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgQ2xpY2thYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciBjYW4gZHJhZyB0aGlzIHNoYXBlIG92ZXIgdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIERyYWdnYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIGNhbiBlZGl0IHRoaXMgc2hhcGUgYnkgZHJhZ2dpbmcgdGhlIGNvbnRyb2xcclxuICAgICAqIHBvaW50cyBzaG93biBhdCB0aGUgdmVydGljZXMgYW5kIG9uIGVhY2ggc2VnbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIEVkaXRhYmxlID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIHRydWUsIGVkZ2VzIG9mIHRoZSBwb2x5bGluZSBhcmUgaW50ZXJwcmV0ZWQgYXMgZ2VvZGVzaWMgYW5kIHdpbGxcclxuICAgICAqIGZvbGxvdyB0aGUgY3VydmF0dXJlIG9mIHRoZSBFYXJ0aC4gV2hlbiBmYWxzZSwgZWRnZXMgb2YgdGhlIHBvbHlsaW5lIGFyZVxyXG4gICAgICogcmVuZGVyZWQgYXMgc3RyYWlnaHQgbGluZXMgaW4gc2NyZWVuIHNwYWNlLiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIGFcclxuICAgICAqIGdlb2Rlc2ljIHBvbHlsaW5lIG1heSBhcHBlYXIgdG8gY2hhbmdlIHdoZW4gZHJhZ2dlZCwgYXMgdGhlIGRpbWVuc2lvbnNcclxuICAgICAqIGFyZSBtYWludGFpbmVkIHJlbGF0aXZlIHRvIHRoZSBzdXJmYWNlIG9mIHRoZSBlYXJ0aC4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBHZW9kZXNpYyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJiaXRhcnkgbWV0YWRhdGEgdG8gYXNzaWduIHRvIHRoZSBQb2x5bGluZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGV2ZW50c1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTWV0YWRhdGE6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yZGVyZWQgc2VxdWVuY2Ugb2YgY29vcmRpbmF0ZXMgdGhhdCBkZXNpZ25hdGVzIGEgcG9seWxpbmUuXHJcbiAgICAgKiBTaW1wbGUgcG9seWxpbmVzIG1heSBiZSBkZWZpbmVkIHVzaW5nIGEgc2luZ2xlIGFycmF5IG9mIExhdExuZ3MuIE1vcmVcclxuICAgICAqIGNvbXBsZXggcG9seWxpbmVzIG1heSBzcGVjaWZ5IGFuIGFycmF5IG9mIGFycmF5cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFBhdGg6IEFycmF5PElMYXRMb25nPiB8IEFycmF5PEFycmF5PElMYXRMb25nPj4gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyB0aGUgdGl0bGUgb2YgdGhlIHBvbHlsaW5lIGFzIHRoZSB0b29sdGlwIG9uIHRoZSBwb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd1Rvb2x0aXA6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0cm9rZSBjb2xvci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFN0cm9rZUNvbG9yOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3Ryb2tlIG9wYWNpdHkgYmV0d2VlbiAwLjAgYW5kIDEuMFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU3Ryb2tlT3BhY2l0eTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0cm9rZSB3aWR0aCBpbiBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBTdHJva2VXZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0aXRsZSBvZiB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFRpdGxlOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgcG9seWxpbmUgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVmlzaWJsZTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB6SW5kZXggY29tcGFyZWQgdG8gb3RoZXIgcG9seXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyB6SW5kZXg6IG51bWJlcjtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBEZWxlZ2F0ZSBkZWZpbml0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBDbGljazogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBEYmxDbGljazogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIHJlcGVhdGVkbHkgZmlyZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIHBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgRHJhZzogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgRHJhZ0VuZDogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBwb2x5bGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERyYWdTdGFydDogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZWRvd24gZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgTW91c2VEb3duOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZU1vdmU6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBQb2x5bGluZSBtb3VzZW91dC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlT3V0OiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWxpbmUgbW91c2VvdmVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgTW91c2VPdmVyOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlVXA6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVuIGlzIGZpcmVkIHdoZW4gdGhlIFBvbHlsaW5lIGlzIHJpZ2h0LWNsaWNrZWQgb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBSaWdodENsaWNrOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBoYXMgYmVlbiByZWdpc3RlcmVkIHdpdGggdGhlIHNlcnZpY2UuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IEFkZGVkVG9TZXJ2aWNlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fYWRkZWRUb1NlcnZpY2U7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaWQgb2YgdGhlIHBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2lkOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBpZCBvZiB0aGUgcG9seWxpbmUgYXMgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZEFzU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9pZC50b1N0cmluZygpOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIGluIGEgY3VzdG9tIGxheWVyLiBTZWUge0BsaW5rIE1hcExheWVyfS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IEluQ3VzdG9tTGF5ZXIoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9pbkN1c3RvbUxheWVyOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXRzIHRoZSBpZCBvZiB0aGUgTGF5ZXIgdGhlIHBvbHlsaW5lIGJlbG9uZ3MgdG8uXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBMYXllcklkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9sYXllcklkOyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBNYXBQb2x5bGluZURpcmVjdGl2ZS5cclxuICAgICAqIEBwYXJhbSBfcG9seWxpbmVNYW5hZ2VyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BvbHlsaW5lU2VydmljZTogUG9seWxpbmVTZXJ2aWNlLCBwcml2YXRlIF9jb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpIHtcclxuICAgICAgICB0aGlzLl9pZCA9IHBvbHlsaW5lSWQrKztcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGNvbnRlbnQgaW50aWFsaXphdGlvbiBvZiB0aGUgZGlyZWN0aXZlIGlzIGNvbXBsZXRlLiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50TmFtZTogc3RyaW5nID0gdGhpcy5fY29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LnRhZ05hbWU7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd4LW1hcC1sYXllcicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luQ3VzdG9tTGF5ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJJZCA9IE51bWJlcih0aGlzLl9jb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQuYXR0cmlidXRlc1snbGF5ZXJJZCddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2FkZGVkVG9TZXJ2aWNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lU2VydmljZS5BZGRQb2x5bGluZSh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fYWRkZWRUb1NlcnZpY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkFkZEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5nZXMgdG8gdGhlIGRhdGFib3VkIHByb3BlcnRpZXMgb2NjdXIuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gQ2hhbmdlcyB0aGF0IGhhdmUgb2NjdXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IGFueSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZFRvU2VydmljZSkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgY29uc3QgbzogSVBvbHlsaW5lT3B0aW9ucyA9IHRoaXMuR2VuZXJhdGVQb2x5bGluZUNoYW5nZVNldChjaGFuZ2VzKTtcclxuICAgICAgICBpZiAobyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lU2VydmljZS5TZXRPcHRpb25zKHRoaXMsIG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snUGF0aCddICYmICFjaGFuZ2VzWydQYXRoJ10uaXNGaXJzdENoYW5nZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lU2VydmljZS5VcGRhdGVQb2x5bGluZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcG9seWxpbmUgaXMgYmVpbmcgZGVzdHJveWVkLiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS4gUmVsZWFzZSByZXNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZVNlcnZpY2UuRGVsZXRlUG9seWxpbmUodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmZvckVhY2goKHMpID0+IHMudW5zdWJzY3JpYmUoKSk7XHJcbiAgICAgICAgICAgIC8vL1xyXG4gICAgICAgICAgICAvLy8gcmVtb3ZlIGV2ZW50IHN1YnNjcmlwdGlvbnNcclxuICAgICAgICAgICAgLy8vXHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdpcmVzIHVwIHRoZSBldmVudCByZWNlaXZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgY29uc3QgX2dldEV2ZW50QXJnOiAoZTogTW91c2VFdmVudCkgPT4gSVBvbHlsaW5lRXZlbnQgPSBlID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIFBvbHlsaW5lOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgQ2xpY2s6IGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUoJ2NsaWNrJywgdGhpcykuc3Vic2NyaWJlKChldjogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5mb0JveCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmZvQm94Lk9wZW4odGhpcy5fcG9seWxpbmVTZXJ2aWNlLkdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGV2KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5DbGljay5lbWl0KF9nZXRFdmVudEFyZyhldikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdkYmxjbGljaycsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5EYmxDbGljay5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWcnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZy5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdlbmQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZ0VuZC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdzdGFydCcsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5EcmFnU3RhcnQuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZWRvd24nLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuTW91c2VEb3duLmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vtb3ZlJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlTW92ZS5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlb3V0JywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlT3V0LmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdmVyJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlT3Zlci5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNldXAnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuTW91c2VVcC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ3JpZ2h0Y2xpY2snLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuUmlnaHRDbGljay5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChvYmopID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3MgPSB0aGlzLl9wb2x5bGluZVNlcnZpY2UuQ3JlYXRlRXZlbnRPYnNlcnZhYmxlKG9iai5uYW1lLCB0aGlzKS5zdWJzY3JpYmUob2JqLmhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMucHVzaChvcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIElQb2x5bGluZSBvcHRpb24gY2hhbmdlc2V0IGZyb20gZGlyZWN0aXZlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0ge0BsaW5rIFNpbXBsZUNoYW5nZXN9IGlkZW50aWZ5aW5nIHRoZSBjaGFuZ2VzIHRoYXQgb2NjdXJlZC5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElQb2x5bGluZU9wdGlvbnN9IGNvbnRhaW5pbmcgdGhlIHBvbHlsaW5lIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgR2VuZXJhdGVQb2x5bGluZUNoYW5nZVNldChjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogSVBvbHlsaW5lT3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyA9IHsgaWQ6IHRoaXMuX2lkIH07XHJcbiAgICAgICAgbGV0IGhhc09wdGlvbnM6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICBpZiAoY2hhbmdlc1snQ2xpY2thYmxlJ10pIHsgb3B0aW9ucy5jbGlja2FibGUgPSB0aGlzLkNsaWNrYWJsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snRHJhZ2dhYmxlJ10pIHsgb3B0aW9ucy5kcmFnZ2FibGUgPSB0aGlzLkRyYWdnYWJsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snRWRpdGFibGUnXSkgeyBvcHRpb25zLmVkaXRhYmxlID0gdGhpcy5FZGl0YWJsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snR2VvZGVzaWMnXSkgeyBvcHRpb25zLmdlb2Rlc2ljID0gdGhpcy5HZW9kZXNpYzsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU2hvd1Rvb2x0aXAnXSkgeyBvcHRpb25zLnNob3dUb29sdGlwID0gdGhpcy5TaG93VG9vbHRpcDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU3Ryb2tlQ29sb3InXSkgeyBvcHRpb25zLnN0cm9rZUNvbG9yID0gdGhpcy5TdHJva2VDb2xvcjsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU3Ryb2tlT3BhY2l0eSddKSB7IG9wdGlvbnMuc3Ryb2tlT3BhY2l0eSA9IHRoaXMuU3Ryb2tlT3BhY2l0eTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU3Ryb2tlV2VpZ2h0J10pIHsgb3B0aW9ucy5zdHJva2VXZWlnaHQgPSB0aGlzLlN0cm9rZVdlaWdodDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snVGl0bGUnXSkgeyBvcHRpb25zLnRpdGxlID0gdGhpcy5UaXRsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snVmlzaWJsZSddKSB7IG9wdGlvbnMudmlzaWJsZSA9IHRoaXMuVmlzaWJsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snekluZGV4J10pIHsgb3B0aW9ucy56SW5kZXggPSB0aGlzLnpJbmRleDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICByZXR1cm4gaGFzT3B0aW9ucyA/IG9wdGlvbnMgOiBudWxsO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gICAgRGlyZWN0aXZlLCBTaW1wbGVDaGFuZ2UsIElucHV0LCBPdXRwdXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLFxyXG4gICAgRXZlbnRFbWl0dGVyLCBDb250ZW50Q2hpbGQsIEFmdGVyQ29udGVudEluaXQsIFZpZXdDb250YWluZXJSZWYsIE5nWm9uZVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElNYXJrZXJFdmVudCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1ldmVudCc7XHJcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF5ZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF5ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJQ2x1c3Rlckljb25JbmZvIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbWFya2VyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQ2x1c3RlclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9jbHVzdGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBDbHVzdGVyQ2xpY2tBY3Rpb24gfSBmcm9tICcuLi9tb2RlbHMvY2x1c3Rlci1jbGljay1hY3Rpb24nO1xyXG5pbXBvcnQgeyBDbHVzdGVyUGxhY2VtZW50TW9kZSB9IGZyb20gJy4uL21vZGVscy9jbHVzdGVyLXBsYWNlbWVudC1tb2RlJztcclxuaW1wb3J0IHsgQ2x1c3RlckxheWVyRGlyZWN0aXZlIH0gZnJvbSAnLi9jbHVzdGVyLWxheWVyJztcclxuXHJcbi8qKlxyXG4gKiBpbnRlcm5hbCBjb3VudGVyIHRvIHVzZSBhcyBpZHMgZm9yIG1hcmtlci5cclxuICovXHJcbmxldCBsYXllcklkID0gMTAwMDAwMDtcclxuXHJcbi8qKlxyXG4gKiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZSBwZXJmb3JtYW50bHkgcmVuZGVycyBhIGxhcmdlIHNldCBvZiBtYXAgbWFya2VyIGluc2lkZSBhIHtAbGluayBNYXBDb21wb25lbnR9LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuICogaW1wb3J0IHtNYXBDb21wb25lbnQsIE1hcE1hcmtlckRpcmVjdGl2ZX0gZnJvbSAnLi4uJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxyXG4gKiAgc3R5bGVzOiBbYFxyXG4gKiAgIC5tYXAtY29udGFpbmVyIHtcclxuICogICAgIGhlaWdodDogMzAwcHg7XHJcbiAqICAgfVxyXG4gKiBgXSxcclxuICogdGVtcGxhdGU6IGBcclxuICogICA8eC1tYXAgW0xhdGl0dWRlXT1cImxhdFwiIFtMb25naXR1ZGVdPVwibG5nXCIgW1pvb21dPVwiem9vbVwiPlxyXG4gKiAgICAgIDx4LW1hcC1tYXJrZXItbGF5ZXIgW01hcmtlck9wdGlvbnNdPVwiX21hcmtlcnNcIj48L3gtbWFwLW1hcmtlci1sYXllcj5cclxuICogICA8L3gtbWFwPlxyXG4gKiBgXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAneC1tYXAtbWFya2VyLWxheWVyJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2lkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9sYXllclByb21pc2U6IFByb21pc2U8TGF5ZXI+O1xyXG4gICAgcHJpdmF0ZSBfc2VydmljZTogTGF5ZXJTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBfc3R5bGVzOiBBcnJheTxJQ2x1c3Rlckljb25JbmZvPjtcclxuICAgIHByaXZhdGUgX3VzZUR5bmFtaWNTaXplTWFya2VyID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9keW5hbWljTWFya2VyQmFzZVNpemUgPSAxODtcclxuICAgIHByaXZhdGUgX2R5bmFtaWNNYXJrZXJSYW5nZXM6IE1hcDxudW1iZXIsIHN0cmluZz4gPSBuZXcgTWFwPG51bWJlciwgc3RyaW5nPihbXHJcbiAgICAgICAgWzEwLCAncmdiYSgyMCwgMTgwLCAyMCwgMC41KSddLFxyXG4gICAgICAgIFsxMDAsICdyZ2JhKDI1NSwgMjEwLCA0MCwgMC41KSddLFxyXG4gICAgICAgIFtOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAsICdyZ2JhKDI1NSwgNDAsIDQwLCAwLjUpJ11cclxuICAgIF0pO1xyXG4gICAgcHJpdmF0ZSBfaWNvbkNyZWF0aW9uQ2FsbGJhY2s6IChtOiBBcnJheTxNYXJrZXI+LCBpOiBJTWFya2VySWNvbkluZm8pID0+IHN0cmluZztcclxuICAgIHByaXZhdGUgX3N0cmVhbWluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfbWFya2VyczogQXJyYXk8SU1hcmtlck9wdGlvbnM+ID0gbmV3IEFycmF5PElNYXJrZXJPcHRpb25zPigpO1xyXG4gICAgcHJpdmF0ZSBfbWFya2Vyc0xhc3Q6IEFycmF5PElNYXJrZXJPcHRpb25zPiA9IG5ldyBBcnJheTxJTWFya2VyT3B0aW9ucz4oKTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHRoZSBDbHVzdGVyIENsaWNrIEFjdGlvbiB7QGxpbmsgQ2x1c3RlckNsaWNrQWN0aW9ufS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIENsdXN0ZXJDbGlja0FjdGlvbjogQ2x1c3RlckNsaWNrQWN0aW9uID0gIENsdXN0ZXJDbGlja0FjdGlvbi5ab29tSW50b0NsdXN0ZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIEljb25JbmZvIHRvIGJlIHVzZWQgdG8gY3JlYXRlIGEgY3VzdG9tIGNsdXN0ZXIgbWFya2VyLiBTdXBwb3J0cyBmb250LWJhc2VkLCBTVkcsIGdyYXBoaWNzIGFuZCBtb3JlLlxyXG4gICAgICogU2VlIHtAbGluayBJTWFya2VySWNvbkluZm99LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgQ2x1c3Rlckljb25JbmZvOiBJTWFya2VySWNvbkluZm87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGNsdXN0ZXIgcGxhY2VtZW50IG1vZGUuIHtAbGluayBDbHVzdGVyUGxhY2VtZW50TW9kZX1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgIHB1YmxpYyBDbHVzdGVyUGxhY2VtZW50TW9kZTogQ2x1c3RlclBsYWNlbWVudE1vZGUgPSBDbHVzdGVyUGxhY2VtZW50TW9kZS5NZWFuVmFsdWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGNhbGxiYWNrIGludm9rZWQgdG8gY3JlYXRlIGEgY3VzdG9tIGNsdXN0ZXIgbWFya2VyLiBOb3RlIHRoYXQgd2hlbiB7QGxpbmsgVXNlRHluYW1pY1NpemVNYXJrZXJzfSBpcyBlbmFibGVkLFxyXG4gICAgICogeW91IGNhbm5vdCBzZXQgYSBjdXN0b20gbWFya2VyIGNhbGxiYWNrLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgQ3VzdG9tTWFya2VyQ2FsbGJhY2soKTogKG06IEFycmF5PE1hcmtlcj4sIGk6IElNYXJrZXJJY29uSW5mbykgPT4gc3RyaW5nICB7IHJldHVybiB0aGlzLl9pY29uQ3JlYXRpb25DYWxsYmFjazsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgQ3VzdG9tTWFya2VyQ2FsbGJhY2sodmFsOiAobTogQXJyYXk8TWFya2VyPiwgaTogSU1hcmtlckljb25JbmZvKSA9PiBzdHJpbmcpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZUR5bmFtaWNTaXplTWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyhcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoYFlvdSBjYW5ub3Qgc2V0IGEgY3VzdG9tIG1hcmtlciBjYWxsYmFjayB3aGVuIFVzZUR5bmFtaWNTaXplTWFya2VycyBpcyBzZXQgdG8gdHJ1ZS5cclxuICAgICAgICAgICAgICAgICAgICBTZXQgVXNlRHluYW1pY1NpemVNYWtlcnMgdG8gZmFsc2UuYClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faWNvbkNyZWF0aW9uQ2FsbGJhY2sgPSB2YWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBiYXNlIHNpemUgb2YgZHluYW1pYyBtYXJrZXJzIGluIHBpeGVscy4gVGhlIGFjdHVhbHkgc2l6ZSBvZiB0aGUgZHluYW1pYyBtYXJrZXIgaXMgYmFzZWQgb24gdGhpcy5cclxuICAgICAqIFNlZSB7QGxpbmsgVXNlRHluYW1pY1NpemVNYXJrZXJzfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBEeW5hbWljTWFya2VyQmFzZVNpemUoKTogbnVtYmVyICB7IHJldHVybiB0aGlzLl9keW5hbWljTWFya2VyQmFzZVNpemU7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IER5bmFtaWNNYXJrZXJCYXNlU2l6ZSh2YWw6IG51bWJlcikgeyB0aGlzLl9keW5hbWljTWFya2VyQmFzZVNpemUgPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcmFuZ2VzIHRvIHVzZSB0byBjYWxjdWxhdGUgYnJlYWtwb2ludHMgYW5kIGNvbG9ycyBmb3IgZHluYW1pYyBtYXJrZXJzLlxyXG4gICAgICogVGhlIG1hcCBjb250YWlucyBrZXkvdmFsdWUgcGFpcnMsIHdpdGggdGhlIGtleXMgYmVpbmdcclxuICAgICAqIHRoZSBicmVha3BvaW50IHNpemVzIGFuZCB0aGUgdmFsdWVzIHRoZSBjb2xvcnMgdG8gYmUgdXNlZCBmb3IgdGhlIGR5bmFtaWMgbWFya2VyIGluIHRoYXQgcmFuZ2UuIFNlZSB7QGxpbmsgVXNlRHluYW1pY1NpemVNYXJrZXJzfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBEeW5hbWljTWFya2VyUmFuZ2VzKCk6IE1hcDxudW1iZXIsIHN0cmluZz4gIHsgcmV0dXJuIHRoaXMuX2R5bmFtaWNNYXJrZXJSYW5nZXM7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IER5bmFtaWNNYXJrZXJSYW5nZXModmFsOiBNYXA8bnVtYmVyLCBzdHJpbmc+KSB7IHRoaXMuX2R5bmFtaWNNYXJrZXJSYW5nZXMgPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgbGF5ZXIgY2x1c3RlcnMuIFRoaXMgcHJvcGVydHkgY2FuIG9ubHkgYmUgc2V0IG9uIGNyZWF0aW9uIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIEVuYWJsZUNsdXN0ZXJpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZ3JpZCBzaXplIHRvIGJlIHVzZWQgZm9yIGNsdXN0ZXJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBHcmlkU2l6ZTogbnVtYmVyID0gMTUwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBJY29uSW5mbyB0byBiZSB1c2VkIHRvIGNyZWF0ZSBhIGN1c3RvbSBtYXJrZXIgaW1hZ2VzLiBTdXBwb3J0cyBmb250LWJhc2VkLCBTVkcsIGdyYXBoaWNzIGFuZCBtb3JlLlxyXG4gICAgICogU2VlIHtAbGluayBJTWFya2VySWNvbkluZm99LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgSWNvbkluZm86IElNYXJrZXJJY29uSW5mbztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyBBbiBvZmZzZXQgYXBwbGllZCB0byB0aGUgcG9zaXRpb25pbmcgb2YgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGF5ZXJPZmZzZXQ6IElQb2ludCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgSU1hcmtlck9wdGlvbnMgYXJyYXkgaG9sZGluZyB0aGUgbWFya2VyIGluZm8uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBNYXJrZXJPcHRpb25zKCk6IEFycmF5PElNYXJrZXJPcHRpb25zPiB7IHJldHVybiB0aGlzLl9tYXJrZXJzOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBNYXJrZXJPcHRpb25zKHZhbDogQXJyYXk8SU1hcmtlck9wdGlvbnM+KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHJlYW1pbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnNMYXN0LnB1c2goLi4udmFsLnNsaWNlKDApKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaCguLi52YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2VycyA9IHZhbC5zbGljZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY2x1c3RlciBzdHlsZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IFN0eWxlcygpOiBBcnJheTxJQ2x1c3Rlckljb25JbmZvPiB7IHJldHVybiB0aGlzLl9zdHlsZXM7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IFN0eWxlcyh2YWw6IEFycmF5PElDbHVzdGVySWNvbkluZm8+KSB7IHRoaXMuX3N0eWxlcyA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRvIHRyZWF0IGNoYW5nZXMgaW4gdGhlIE1hcmtlck9wdGlvbnMgYXMgc3RyZWFtcyBvZiBuZXcgbWFya2Vycy4gSW4gdGhzaSBtb2RlLCBjaGFuZ2luZyB0aGVcclxuICAgICAqIEFycmF5IHN1cHBsaWVkIGluIE1hcmtlck9wdGlvbnMgd2lsbCBiZSBpbmNyZW1lbnRhbGx5IGRyYXduIG9uIHRoZSBtYXAgYXMgb3Bwb3NlZCB0byByZXBsYWNlIHRoZSBtYXJrZXJzIG9uIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBUcmVhdE5ld01hcmtlck9wdGlvbnNBc1N0cmVhbSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3N0cmVhbWluZzsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgVHJlYXROZXdNYXJrZXJPcHRpb25zQXNTdHJlYW0odmFsOiBib29sZWFuKSB7IHRoaXMuX3N0cmVhbWluZyA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gdXNlIGR5bmFtaWMgbWFya2Vycy4gRHluYW1pYyBtYXJrZXJzIGNoYW5nZSBpbiBzaXplIGFuZCBjb2xvciBkZXBlbmRpbmcgb24gdGhlIG51bWJlciBvZlxyXG4gICAgICogcGlucyBpbiB0aGUgY2x1c3Rlci4gSWYgc2V0IHRvIHRydWUsIHRoaXMgd2lsbCB0YWtlIHByZWNlbmRlbmNlIG92ZXIgYW55IGN1c3RvbSBtYXJrZXIgY3JlYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBVc2VEeW5hbWljU2l6ZU1hcmtlcnMoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl91c2VEeW5hbWljU2l6ZU1hcmtlcjsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgVXNlRHluYW1pY1NpemVNYXJrZXJzKHZhbDogYm9vbGVhbikge1xyXG4gICAgICAgICAgICB0aGlzLl91c2VEeW5hbWljU2l6ZU1hcmtlciA9IHZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbkNyZWF0aW9uQ2FsbGJhY2sgPSAobTogQXJyYXk8TWFya2VyPiwgaW5mbzogSU1hcmtlckljb25JbmZvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENsdXN0ZXJMYXllckRpcmVjdGl2ZS5DcmVhdGVEeW5hbWljU2l6ZU1hcmtlcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5sZW5ndGgsIGluZm8sIHRoaXMuX2R5bmFtaWNNYXJrZXJCYXNlU2l6ZSwgdGhpcy5fZHluYW1pY01hcmtlclJhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbWFya2VyIGxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBWaXNpYmxlOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB6LWluZGV4IG9mIHRoZSBsYXllci4gSWYgbm90IHVzZWQsIGxheWVycyBnZXQgc3RhY2tlZCBpbiB0aGUgb3JkZXIgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFpJbmRleDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRoZSBjbHVzdGVyIHNob3VsZCB6b29tIGluIG9uIGNsaWNrXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFpvb21PbkNsaWNrOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRGVsZWdhdGVzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgZHluYW1pYyBpY29uIGZvciBhIG1hcmtlciBpcyBiZWluZyBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgcHVibGljIER5bmFtaWNNYXJrZXJDcmVhdGVkOiBFdmVudEVtaXR0ZXI8SU1hcmtlckljb25JbmZvPiA9IG5ldyBFdmVudEVtaXR0ZXI8SU1hcmtlckljb25JbmZvPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhIG1hcmtlciBpbiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBwdWJsaWMgTWFya2VyQ2xpY2s6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgYSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBwdWJsaWMgRHJhZ0VuZDogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcclxuXHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGlkIG9mIHRoZSBtYXJrZXIgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5faWQ7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlLlxyXG4gICAgICogQHBhcmFtIF9tYXJrZXJTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE1hcmtlclNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSBDb25jcmVhdGUgaW1wbGVtZW50YXRpb24gb2YgYSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfS5cclxuICAgICAqIEBwYXJhbSBfY2x1c3RlclNlcnZpY2UgLSBDb25jcmVhdGUgaW1wbGVtZW50YXRpb24gb2YgYSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE1hcFNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE5nWm9uZX0gc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBfbWFya2VyU2VydmljZTogTWFya2VyU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF9sYXllclNlcnZpY2U6IExheWVyU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF9jbHVzdGVyU2VydmljZTogQ2x1c3RlclNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcclxuICAgICAgICB0aGlzLl9pZCA9IGxheWVySWQrKztcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGVzIGEgZ2VvIGxvY2F0aW9uIHRvIGEgcGl4ZWwgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIG1hcCB2aWV3cG9ydC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW2xvY10gLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIGFuIHtAbGluayBJUG9pbnR9IHJlcHJlc2VudGluZyB0aGUgcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBMb2NhdGlvblRvUGl4ZWwobG9jOiBJTGF0TG9uZyk6IFByb21pc2U8SVBvaW50PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlclNlcnZpY2UuTG9jYXRpb25Ub1BvaW50KGxvYyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgQ29tcG9uZW50IGNvbnRlbnQgaW5pdGlhbGl6YXRpb24uIFBhcnQgb2YgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXJPcHRpb25zOiBJTGF5ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogdGhpcy5faWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmYWtlTGF5ZXJEaXJlY3RpdmU6IGFueSA9IHtcclxuICAgICAgICAgICAgICAgIElkIDogdGhpcy5faWQsXHJcbiAgICAgICAgICAgICAgICBWaXNpYmxlOiB0aGlzLlZpc2libGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLkVuYWJsZUNsdXN0ZXJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyU2VydmljZS5BZGRMYXllcihmYWtlTGF5ZXJEaXJlY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkdldE5hdGl2ZUxheWVyKGZha2VMYXllckRpcmVjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2aWNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmFrZUxheWVyRGlyZWN0aXZlLkxheWVyT2Zmc2V0ID0gdGhpcy5MYXllck9mZnNldDtcclxuICAgICAgICAgICAgICAgIGZha2VMYXllckRpcmVjdGl2ZS5aSW5kZXggPSB0aGlzLlpJbmRleDtcclxuICAgICAgICAgICAgICAgIGZha2VMYXllckRpcmVjdGl2ZS5DbHVzdGVyaW5nRW5hYmxlZCA9IHRoaXMuRW5hYmxlQ2x1c3RlcmluZztcclxuICAgICAgICAgICAgICAgIGZha2VMYXllckRpcmVjdGl2ZS5DbHVzdGVyUGxhY2VtZW50TW9kZSA9IHRoaXMuQ2x1c3RlclBsYWNlbWVudE1vZGU7XHJcbiAgICAgICAgICAgICAgICBmYWtlTGF5ZXJEaXJlY3RpdmUuR3JpZFNpemUgPSB0aGlzLkdyaWRTaXplO1xyXG4gICAgICAgICAgICAgICAgZmFrZUxheWVyRGlyZWN0aXZlLkNsdXN0ZXJDbGlja0FjdGlvbiA9IHRoaXMuQ2x1c3RlckNsaWNrQWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgZmFrZUxheWVyRGlyZWN0aXZlLkljb25JbmZvID0gdGhpcy5DbHVzdGVySWNvbkluZm87XHJcbiAgICAgICAgICAgICAgICBmYWtlTGF5ZXJEaXJlY3RpdmUuQ3VzdG9tTWFya2VyQ2FsbGJhY2sgPSB0aGlzLkN1c3RvbU1hcmtlckNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgZmFrZUxheWVyRGlyZWN0aXZlLlVzZUR5bmFtaWNTaXplTWFya2VycyA9IHRoaXMuVXNlRHluYW1pY1NpemVNYXJrZXJzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2x1c3RlclNlcnZpY2UuQWRkTGF5ZXIoZmFrZUxheWVyRGlyZWN0aXZlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZSA9IHRoaXMuX2NsdXN0ZXJTZXJ2aWNlLkdldE5hdGl2ZUxheWVyKGZha2VMYXllckRpcmVjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2aWNlID0gdGhpcy5fY2x1c3RlclNlcnZpY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLnRoZW4obCA9PiB7XHJcbiAgICAgICAgICAgICAgICBsLlNldFZpc2libGUodGhpcy5WaXNpYmxlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLk1hcmtlck9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuVXBkYXRlTWFya2VycygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgb24gY29tcG9uZW50IGRlc3RydWN0aW9uLiBGcmVlcyB0aGUgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGNvbXBvbmVudC4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLnRoZW4obCA9PiB7XHJcbiAgICAgICAgICAgIGwuRGVsZXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFjdHMgdG8gY2hhbmdlcyBpbiBkYXRhLWJvdW5kIHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvbmVudCBhbmQgYWN0dWF0ZXMgcHJvcGVydHkgY2hhbmdlcyBpbiB0aGUgdW5kZXJsaW5nIGxheWVyIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gY29sbGVjdGlvbiBvZiBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xyXG4gICAgICAgIGxldCBzaG91bGRTZXRPcHRpb25zOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgbzogSUNsdXN0ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogdGhpcy5faWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChjaGFuZ2VzWydNYXJrZXJPcHRpb25zJ10pIHtcclxuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlVwZGF0ZU1hcmtlcnMoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydWaXNpYmxlJ10gJiYgIWNoYW5nZXNbJ1Zpc2libGUnXS5maXJzdENoYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4gbC5TZXRWaXNpYmxlKHRoaXMuVmlzaWJsZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0VuYWJsZUNsdXN0ZXJpbmcnXSAmJiAhY2hhbmdlc1snRW5hYmxlQ2x1c3RlcmluZyddLmZpcnN0Q2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmICgnU3RvcENsdXN0ZXJpbmcnIGluIHRoaXMuX3NlcnZpY2UpIHtcclxuICAgICAgICAgICAgICAgIG8uY2x1c3RlcmluZ0VuYWJsZWQgPSB0aGlzLkVuYWJsZUNsdXN0ZXJpbmc7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRPcHRpb25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgY2hhbmdlIEVuYWJsZUNsdXN0ZXJpbmcgYWZ0ZXIgdGhlIGxheWVyIGhhcyBiZWVuIGNyZWF0ZWQuJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydDbHVzdGVyUGxhY2VtZW50TW9kZSddICYmICFjaGFuZ2VzWydDbHVzdGVyUGxhY2VtZW50TW9kZSddLmZpcnN0Q2hhbmdlICYmICdTdG9wQ2x1c3RlcmluZycgaW4gdGhpcy5fc2VydmljZSkge1xyXG4gICAgICAgICAgICBvLnBsYWNlbWVudE1vZGUgPSB0aGlzLkNsdXN0ZXJQbGFjZW1lbnRNb2RlO1xyXG4gICAgICAgICAgICBzaG91bGRTZXRPcHRpb25zID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0dyaWRTaXplJ10gJiYgIWNoYW5nZXNbJ0dyaWRTaXplJ10uZmlyc3RDaGFuZ2UgJiYgJ1N0b3BDbHVzdGVyaW5nJyBpbiB0aGlzLl9zZXJ2aWNlKSB7XHJcbiAgICAgICAgICAgIG8uZ3JpZFNpemUgPSB0aGlzLkdyaWRTaXplO1xyXG4gICAgICAgICAgICBzaG91bGRTZXRPcHRpb25zID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0NsdXN0ZXJDbGlja0FjdGlvbiddICYmICFjaGFuZ2VzWydDbHVzdGVyQ2xpY2tBY3Rpb24nXS5maXJzdENoYW5nZSAmJiAnU3RvcENsdXN0ZXJpbmcnIGluIHRoaXMuX3NlcnZpY2UpIHtcclxuICAgICAgICAgICAgby56b29tT25DbGljayA9IHRoaXMuQ2x1c3RlckNsaWNrQWN0aW9uID09PSBDbHVzdGVyQ2xpY2tBY3Rpb24uWm9vbUludG9DbHVzdGVyO1xyXG4gICAgICAgICAgICBzaG91bGRTZXRPcHRpb25zID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChjaGFuZ2VzWydaSW5kZXgnXSAmJiAhY2hhbmdlc1snWkluZGV4J10uZmlyc3RDaGFuZ2UpIHx8XHJcbiAgICAgICAgICAgIChjaGFuZ2VzWydMYXllck9mZnNldCddICYmICFjaGFuZ2VzWydMYXllck9mZnNldCddLmZpcnN0Q2hhbmdlKSB8fFxyXG4gICAgICAgICAgICAoY2hhbmdlc1snSWNvbkluZm8nXSAmJiAhY2hhbmdlc1snSWNvbkluZm8nXS5maXJzdENoYW5nZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignWW91IGNhbm5vdCBjaGFuZ2UgWkluZGV4IG9yIExheWVyT2Zmc2V0IGFmdGVyIHRoZSBsYXllciBoYXMgYmVlbiBjcmVhdGVkLicpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaG91bGRTZXRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmFrZUxheWVyRGlyZWN0aXZlOiBhbnkgPSB7SWQgOiB0aGlzLl9pZH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllclByb21pc2UudGhlbihsID0+IGwuU2V0T3B0aW9ucyhvKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE1hcmtlciBJZC5cclxuICAgICAqIEByZXR1cm5zIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgaWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiAnTWFwTWFya2VyTGF5ZXItJyArIHRoaXMuX2lkLnRvU3RyaW5nKCk7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB2YXJpb3VzIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbSAtIHRoZSBtYXJrZXIgZm9yIHdoaWNoIHRvIGFkZCB0aGUgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQWRkRXZlbnRMaXN0ZW5lcnMobTogTWFya2VyKTogdm9pZCB7XHJcbiAgICAgICAgbS5BZGRMaXN0ZW5lcignY2xpY2snLCAoZTogTW91c2VFdmVudCkgPT4gdGhpcy5NYXJrZXJDbGljay5lbWl0KHtcclxuICAgICAgICAgICAgICAgIE1hcmtlcjogbSxcclxuICAgICAgICAgICAgICAgIENsaWNrOiBlLFxyXG4gICAgICAgICAgICAgICAgTG9jYXRpb246IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZSksXHJcbiAgICAgICAgICAgICAgICBQaXhlbHM6IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0UGl4ZWxzRnJvbUNsaWNrKGUpXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICBtLkFkZExpc3RlbmVyKCdkcmFnZW5kJywgKGU6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZ0VuZC5lbWl0KHtcclxuICAgICAgICAgICAgICAgIE1hcmtlcjogbSxcclxuICAgICAgICAgICAgICAgIENsaWNrOiBlLFxyXG4gICAgICAgICAgICAgICAgTG9jYXRpb246IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZSksXHJcbiAgICAgICAgICAgICAgICBQaXhlbHM6IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0UGl4ZWxzRnJvbUNsaWNrKGUpXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgb3IgdXBkYXRlcyB0aGUgbWFya2VycyBiYXNlZCBvbiB0aGUgbWFya2VyIG9wdGlvbnMuIFRoaXMgd2lsbCBwbGFjZSB0aGUgbWFya2VycyBvbiB0aGUgbWFwXHJcbiAgICAgKiBhbmQgcmVnaXN0ZXIgdGhlIGFzc29jaWF0ZWQgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIFVwZGF0ZU1hcmtlcnMoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xheWVyUHJvbWlzZSA9PSBudWxsKSB7IHJldHVybjsgfVxyXG4gICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXJzOiBBcnJheTxJTWFya2VyT3B0aW9ucz4gPSB0aGlzLl9zdHJlYW1pbmcgPyB0aGlzLl9tYXJrZXJzTGFzdC5zcGxpY2UoMCkgOiB0aGlzLl9tYXJrZXJzO1xyXG5cclxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIHByb21pc2UgZm9yIHRoZSBtYXJrZXJzXHJcbiAgICAgICAgICAgIGNvbnN0IG1wOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+ID0gdGhpcy5fc2VydmljZS5DcmVhdGVNYXJrZXJzKG1hcmtlcnMsIHRoaXMuSWNvbkluZm8pO1xyXG5cclxuICAgICAgICAgICAgLy8gc2V0IG1hcmtlcnMgb25jZSBwcm9taXNlcyBhcmUgZnVsbGZpbGxlZC5cclxuICAgICAgICAgICAgbXAudGhlbihtID0+IHtcclxuICAgICAgICAgICAgICAgIG0uZm9yRWFjaChtYXJrZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEV2ZW50TGlzdGVuZXJzKG1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0cmVhbWluZyA/IGwuQWRkRW50aXRpZXMobSkgOiBsLlNldEVudGl0aWVzKG0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICAgIERpcmVjdGl2ZSwgU2ltcGxlQ2hhbmdlLCBJbnB1dCwgT3V0cHV0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyxcclxuICAgIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBBZnRlckNvbnRlbnRJbml0LCBWaWV3Q29udGFpbmVyUmVmLCBOZ1pvbmUsXHJcbiAgICBTaW1wbGVDaGFuZ2VzXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pc2l6ZSc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2x5Z29uRXZlbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5Z29uLWV2ZW50JztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGFiZWxPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGFiZWwtb3B0aW9ucyc7XHJcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2xheWVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi9tb2RlbHMvcG9seWdvbic7XHJcbmltcG9ydCB7IE1hcExhYmVsIH0gZnJvbSAnLi4vbW9kZWxzL21hcC1sYWJlbCc7XHJcbmltcG9ydCB7IENhbnZhc092ZXJsYXkgfSBmcm9tICcuLi9tb2RlbHMvY2FudmFzLW92ZXJsYXknO1xyXG5cclxuLyoqXHJcbiAqIGludGVybmFsIGNvdW50ZXIgdG8gdXNlIGFzIGlkcyBmb3IgcG9seWdvbnMuXHJcbiAqL1xyXG5sZXQgbGF5ZXJJZCA9IDEwMDAwMDA7XHJcblxyXG4vKipcclxuICogTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlIHBlcmZvcm1hbnRseSByZW5kZXJzIGEgbGFyZ2Ugc2V0IG9mIHBvbHlnb25zIG9uIGEge0BsaW5rIE1hcENvbXBvbmVudH0uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG4gKiBpbXBvcnQge01hcENvbXBvbmVudH0gZnJvbSAnLi4uJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxyXG4gKiAgc3R5bGVzOiBbYFxyXG4gKiAgIC5tYXAtY29udGFpbmVyIHtcclxuICogICAgIGhlaWdodDogMzAwcHg7XHJcbiAqICAgfVxyXG4gKiBgXSxcclxuICogdGVtcGxhdGU6IGBcclxuICogICA8eC1tYXAgW0xhdGl0dWRlXT1cImxhdFwiIFtMb25naXR1ZGVdPVwibG5nXCIgW1pvb21dPVwiem9vbVwiPlxyXG4gKiAgICAgIDx4LW1hcC1wb2x5Z29uLWxheWVyIFtQb2x5Z29uT3B0aW9uc109XCJfcG9seWdvbnNcIj48L3gtbWFwLXBvbHlnb24tbGF5ZXI+XHJcbiAqICAgPC94LW1hcD5cclxuICogYFxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ3gtbWFwLXBvbHlnb24tbGF5ZXInXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2lkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9sYXllclByb21pc2U6IFByb21pc2U8TGF5ZXI+O1xyXG4gICAgcHJpdmF0ZSBfc2VydmljZTogTGF5ZXJTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBfY2FudmFzOiBDYW52YXNPdmVybGF5O1xyXG4gICAgcHJpdmF0ZSBfbGFiZWxzOiBBcnJheTx7bG9jOiBJTGF0TG9uZywgdGl0bGU6IHN0cmluZ30+ID0gbmV3IEFycmF5PHtsb2M6IElMYXRMb25nLCB0aXRsZTogc3RyaW5nfT4oKTtcclxuICAgIHByaXZhdGUgX3Rvb2x0aXA6IE1hcExhYmVsO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFN1YnNjcmlwdGlvbnM6IEFycmF5PFN1YnNjcmlwdGlvbj4gPSBuZXcgQXJyYXk8U3Vic2NyaXB0aW9uPigpO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2RlZmF1bHRPcHRpb25zOiBJTGFiZWxPcHRpb25zID0ge1xyXG4gICAgICAgIGZvbnRTaXplOiAxMSxcclxuICAgICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXHJcbiAgICAgICAgc3Ryb2tlV2VpZ2h0OiAyLFxyXG4gICAgICAgIHN0cm9rZUNvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgZm9udENvbG9yOiAnI2ZmZmZmZidcclxuICAgIH07XHJcbiAgICBwcml2YXRlIF9zdHJlYW1pbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3BvbHlnb25zOiBBcnJheTxJUG9seWdvbk9wdGlvbnM+ID0gbmV3IEFycmF5PElQb2x5Z29uT3B0aW9ucz4oKTtcclxuICAgIHByaXZhdGUgX3BvbHlnb25zTGFzdDogQXJyYXk8SVBvbHlnb25PcHRpb25zPiA9IG5ldyBBcnJheTxJUG9seWdvbk9wdGlvbnM+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG1heGltdW0gem9vbSBhdCB3aGljaCB0aGUgcG9seWdvbiBsYWJlbHMgYXJlIHZpc2libGUuIElnbm9yZWQgaWYgU2hvd0xhYmVsIGlzIGZhbHNlLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWxNYXhab29tOiBudW1iZXIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWluaW11bSB6b29tIGF0IHdoaWNoIHRoZSBwb2x5Z29uIGxhYmVscyBhcmUgdmlzaWJsZS4gSWdub3JlZCBpZiBTaG93TGFiZWwgaXMgZmFsc2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYWJlbE1pblpvb206IG51bWJlciA9IC0xO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VwY2lmaWVzIHN0eWxlaW5nIG9wdGlvbnMgZm9yIG9uLW1hcCBwb2x5Z29uIGxhYmVscy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYWJlbE9wdGlvbnM6IElMYWJlbE9wdGlvbnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgQW4gb2Zmc2V0IGFwcGxpZWQgdG8gdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYXllck9mZnNldDogSVBvaW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHBvbHlnb24gb3B0aW9ucyByZXByZXNlbnRpbmcgdGhlIHBvbHlnb25zIGluIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBQb2x5Z29uT3B0aW9ucygpOiBBcnJheTxJUG9seWdvbk9wdGlvbnM+IHsgcmV0dXJuIHRoaXMuX3BvbHlnb25zOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBQb2x5Z29uT3B0aW9ucyh2YWw6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmVhbWluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWdvbnNMYXN0LnB1c2goLi4udmFsLnNsaWNlKDApKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlnb25zLnB1c2goLi4udmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlnb25zID0gdmFsLnNsaWNlKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBzaG93IHRoZSBwb2x5Z29uIHRpdGxlcyBhcyB0aGUgbGFiZWxzIG9uIHRoZSBwb2x5Z29ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBTaG93TGFiZWxzOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgdGhlIHRpdGxlcyBvZiB0aGUgcG9seWdvc24gYXMgdGhlIHRvb2x0aXBzIG9uIHRoZSBwb2x5Z29ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBTaG93VG9vbHRpcHM6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRvIHRyZWF0IGNoYW5nZXMgaW4gdGhlIFBvbHlnb25PcHRpb25zIGFzIHN0cmVhbXMgb2YgbmV3IG1hcmtlcnMuIEluIHRoaXMgbW9kZSwgY2hhbmdpbmcgdGhlXHJcbiAgICAgKiBBcnJheSBzdXBwbGllZCBpbiBQb2x5Z29uT3B0aW9ucyB3aWxsIGJlIGluY3JlbWVudGFsbHkgZHJhd24gb24gdGhlIG1hcCBhcyBvcHBvc2VkIHRvIHJlcGxhY2UgdGhlIHBvbHlnb25zIG9uIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgVHJlYXROZXdQb2x5Z29uT3B0aW9uc0FzU3RyZWFtKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc3RyZWFtaW5nOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBUcmVhdE5ld1BvbHlnb25PcHRpb25zQXNTdHJlYW0odmFsOiBib29sZWFuKSB7IHRoaXMuX3N0cmVhbWluZyA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbWFya2VyIGxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVmlzaWJsZTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgei1pbmRleCBvZiB0aGUgbGF5ZXIuIElmIG5vdCB1c2VkLCBsYXllcnMgZ2V0IHN0YWNrZWQgaW4gdGhlIG9yZGVyIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgWkluZGV4OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIERlbGVnYXRlc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgcG9seWdvbiBpbiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgcHVibGljIFBvbHlnb25DbGljazogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gZGJsY2xpY2sgZXZlbnQgaXMgZmlyZWQgb24gYSBwb2x5Z29uIGluIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBQb2x5Z29uRGJsQ2xpY2s6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiBhIHBvbHlnb24gaW4gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIFBvbHlnb25Nb3VzZU1vdmU6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gbW91c2VvdXQgb24gYSBwb2x5Z29uIGluIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBQb2x5Z29uTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gbW91c2VvdmVyIG9uIGEgcG9seWdvbiBpbiBhIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIFBvbHlnb25Nb3VzZU92ZXI6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcblxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBpZCBvZiB0aGUgbWFya2VyIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IElkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9pZDsgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlLlxyXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSBDb25jcmVhdGUgaW1wbGVtZW50YXRpb24gb2YgYSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfS5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIENvbmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHtAbGluayBNYXBTZXJ2aWNlfS5cclxuICAgICAqIEBwYXJhbSBfem9uZSAtIENvbmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHtAbGluayBOZ1pvbmV9IHNlcnZpY2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICAgICAgdGhpcy5faWQgPSBsYXllcklkKys7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIENvbXBvbmVudCBjb250ZW50IGluaXRpYWxpemF0aW9uLiBQYXJ0IG9mIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcclxuICAgICAgICBjb25zdCBsYXllck9wdGlvbnM6IElMYXllck9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGlkOiB0aGlzLl9pZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZha2VMYXllckRpcmVjdGl2ZTogYW55ID0ge1xyXG4gICAgICAgICAgICAgICAgSWQgOiB0aGlzLl9pZCxcclxuICAgICAgICAgICAgICAgIFZpc2libGU6IHRoaXMuVmlzaWJsZSxcclxuICAgICAgICAgICAgICAgIExheWVyT2Zmc2V0OiB0aGlzLkxheWVyT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgWkluZGV4OiB0aGlzLlpJbmRleFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllclNlcnZpY2UuQWRkTGF5ZXIoZmFrZUxheWVyRGlyZWN0aXZlKTtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkdldE5hdGl2ZUxheWVyKGZha2VMYXllckRpcmVjdGl2ZSk7XHJcblxyXG4gICAgICAgICAgICBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllclByb21pc2UsXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUNhbnZhc092ZXJsYXkoZWwgPT4gdGhpcy5EcmF3TGFiZWxzKGVsKSlcclxuICAgICAgICAgICAgXSkudGhlbih2YWx1ZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzBdLlNldFZpc2libGUodGhpcy5WaXNpYmxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IHZhbHVlc1sxXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5fY2FudmFzUmVhZHkudGhlbihiID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwID0gdGhpcy5fY2FudmFzLkdldFRvb2xUaXBPdmVybGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKHRoaXMuU2hvd1Rvb2x0aXBzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuUG9seWdvbk9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuVXBkYXRlUG9seWdvbnMoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIG9uIGNvbXBvbmVudCBkZXN0cnVjdGlvbi4gRnJlZXMgdGhlIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLmZvckVhY2gocyA9PiBzLnVuc3Vic2NyaWJlKCkpO1xyXG4gICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4ge1xyXG4gICAgICAgICAgICBsLkRlbGV0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLl9jYW52YXMpIHsgdGhpcy5fY2FudmFzLkRlbGV0ZSgpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFjdHMgdG8gY2hhbmdlcyBpbiBkYXRhLWJvdW5kIHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvbmVudCBhbmQgYWN0dWF0ZXMgcHJvcGVydHkgY2hhbmdlcyBpbiB0aGUgdW5kZXJsaW5nIGxheWVyIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gY29sbGVjdGlvbiBvZiBjaGFuZ2VzLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xyXG4gICAgICAgIGlmIChjaGFuZ2VzWydQb2x5Z29uT3B0aW9ucyddKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5VcGRhdGVQb2x5Z29ucygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Zpc2libGUnXSAmJiAhY2hhbmdlc1snVmlzaWJsZSddLmZpcnN0Q2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4gbC5TZXRWaXNpYmxlKHRoaXMuVmlzaWJsZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKGNoYW5nZXNbJ1pJbmRleCddICYmICFjaGFuZ2VzWydaSW5kZXgnXS5maXJzdENoYW5nZSkgfHxcclxuICAgICAgICAgICAgKGNoYW5nZXNbJ0xheWVyT2Zmc2V0J10gJiYgIWNoYW5nZXNbJ0xheWVyT2Zmc2V0J10uZmlyc3RDaGFuZ2UpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgY2hhbmdlIFpJbmRleCBvciBMYXllck9mZnNldCBhZnRlciB0aGUgbGF5ZXIgaGFzIGJlZW4gY3JlYXRlZC4nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoY2hhbmdlc1snU2hvd0xhYmVscyddICYmICFjaGFuZ2VzWydTaG93TGFiZWxzJ10uZmlyc3RDaGFuZ2UpIHx8XHJcbiAgICAgICAgICAgIChjaGFuZ2VzWydMYWJlbE1pblpvb20nXSAmJiAhY2hhbmdlc1snTGFiZWxNaW5ab29tJ10uZmlyc3RDaGFuZ2UpIHx8XHJcbiAgICAgICAgICAgIChjaGFuZ2VzWydMYWJlbE1heFpvb20nXSAmJiAhY2hhbmdlc1snTGFiZWxNYXhab29tJ10uZmlyc3RDaGFuZ2UpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW52YXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5SZWRyYXcodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Nob3dUb29sdGlwcyddICYmIHRoaXMuX3Rvb2x0aXApIHtcclxuICAgICAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKGNoYW5nZXNbJ1Nob3dUb29sdGlwcyddLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgTWFya2VyIElkLlxyXG4gICAgICogQHJldHVybnMgLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciBpZC5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiAnTWFwUG9seWdvbkxheWVyLScgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdmFyaW91cyBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHAgLSB0aGUgcG9seWdvbiBmb3Igd2hpY2ggdG8gYWRkIHRoZSBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQWRkRXZlbnRMaXN0ZW5lcnMocDogUG9seWdvbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdjbGljaycsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Qb2x5Z29uQ2xpY2suZW1pdCh7UG9seWdvbjogcCwgQ2xpY2s6IGV2fSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnZGJsY2xpY2snLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuUG9seWdvbkRibENsaWNrLmVtaXQoe1BvbHlnb246IHAsIENsaWNrOiBldn0pIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Qb2x5Z29uTW91c2VNb3ZlLmVtaXQoe1BvbHlnb246IHAsIENsaWNrOiBldn0pIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlb3V0JywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlnb25Nb3VzZU91dC5lbWl0KHtQb2x5Z29uOiBwLCBDbGljazogZXZ9KSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW92ZXInLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuUG9seWdvbk1vdXNlT3Zlci5lbWl0KHtQb2x5Z29uOiBwLCBDbGljazogZXZ9KSB9XHJcbiAgICAgICAgXTtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChvYmopID0+IHAuQWRkTGlzdGVuZXIob2JqLm5hbWUsIG9iai5oYW5kbGVyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgcG9seWdvbiBsYWJlbHMuIENhbGxlZCBieSB0aGUgQ2FudmFzIG92ZXJsYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVsIC0gVGhlIGNhbnZhcyBvbiB3aGljaCB0byBkcmF3IHRoZSBsYWJlbHMuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgRHJhd0xhYmVscyhlbDogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5TaG93TGFiZWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuR2V0Wm9vbSgpLnRoZW4oeiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5MYWJlbE1pblpvb20gPD0geiAmJiB0aGlzLkxhYmVsTWF4Wm9vbSA+PSB6KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBlbC5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuX2xhYmVscy5tYXAoeCA9PiB4LnRpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkxvY2F0aW9uc1RvUG9pbnRzKHRoaXMuX2xhYmVscy5tYXAoeCA9PiB4LmxvYykpLnRoZW4obG9jcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemU6IElTaXplID0gdGhpcy5fbWFwU2VydmljZS5NYXBTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbG9jcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZHJhdyB0aGUgcG9pbnQgaWYgaXQgaXMgbm90IGluIHZpZXcuIFRoaXMgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZSB3aGVuIHpvb21lZCBpbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NzW2ldLnggPj0gMCAmJiBsb2NzW2ldLnkgPj0gMCAmJiBsb2NzW2ldLnggPD0gc2l6ZS53aWR0aCAmJiBsb2NzW2ldLnkgPD0gc2l6ZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkRyYXdUZXh0KGN0eCwgbG9jc1tpXSwgbGFiZWxzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgbGFiZWwgdGV4dCBhdCB0aGUgYXBwcm9wcmlhdGUgcGxhY2Ugb24gdGhlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSBjdHggLSBDYW52YXMgZHJhd2luZyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGxvYyAtIFBpeGVsIGxvY2F0aW9uIG9uIHRoZSBjYW52YXMgd2hlcmUgdG8gY2VudGVyIHRoZSB0ZXh0LlxyXG4gICAgICogQHBhcmFtIHRleHQgLSBUZXh0IHRvIGRyYXcuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgRHJhd1RleHQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGxvYzogSVBvaW50LCB0ZXh0OiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgbG86IElMYWJlbE9wdGlvbnMgPSB0aGlzLkxhYmVsT3B0aW9ucztcclxuICAgICAgICBpZiAobG8gPT0gbnVsbCAmJiB0aGlzLl90b29sdGlwKSB7IGxvID0gdGhpcy5fdG9vbHRpcC5EZWZhdWx0TGFiZWxTdHlsZTsgfVxyXG4gICAgICAgIGlmIChsbyA9PSBudWxsKSB7IGxvID0gdGhpcy5fZGVmYXVsdE9wdGlvbnM7IH1cclxuXHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbG8uc3Ryb2tlQ29sb3I7XHJcbiAgICAgICAgY3R4LmZvbnQgPSBgJHtsby5mb250U2l6ZX1weCAke2xvLmZvbnRGYW1pbHl9YDtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlV2VpZ2h0OiBudW1iZXIgPSBsby5zdHJva2VXZWlnaHQ7XHJcbiAgICAgICAgaWYgKHRleHQgJiYgc3Ryb2tlV2VpZ2h0ICYmIHN0cm9rZVdlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlVGV4dCh0ZXh0LCBsb2MueCwgbG9jLnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbG8uZm9udENvbG9yO1xyXG4gICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBsb2MueCwgbG9jLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFuYWdlcyB0aGUgdG9vbHRpcCBhbmQgdGhlIGF0dGFjaG1lbnQgb2YgdGhlIGFzc29jaWF0ZWQgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzaG93IC0gVHJ1ZSB0byBlbmFibGUgdGhlIHRvb2x0aXAsIGZhbHNlIHRvIGRpc2FibGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgTWFuYWdlVG9vbHRpcChzaG93OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHNob3cgJiYgdGhpcy5fY2FudmFzKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZCB0b29sdGlwIHN1YnNjcmlwdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuUG9seWdvbk1vdXNlTW92ZS5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2M6IElMYXRMb25nID0gdGhpcy5fY2FudmFzLkdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGUuQ2xpY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGxvYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLlBvbHlnb25Nb3VzZU92ZXIuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuUG9seWdvbi5UaXRsZSAmJiBlLlBvbHlnb24uVGl0bGUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYzogSUxhdExvbmcgPSB0aGlzLl9jYW52YXMuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZS5DbGljayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ3RleHQnLCBlLlBvbHlnb24uVGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGxvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90b29sdGlwVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLnB1c2godGhpcy5Qb2x5Z29uTW91c2VPdXQuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0b29sdGlwIHN1YnNjcmlwdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMuZm9yRWFjaChzID0+IHMudW5zdWJzY3JpYmUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLnNwbGljZSgwKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgb3IgdXBkYXRlcyB0aGUgcG9seWdvbnMgYmFzZWQgb24gdGhlIHBvbHlnb24gb3B0aW9ucy4gVGhpcyB3aWxsIHBsYWNlIHRoZSBwb2x5Z29ucyBvbiB0aGUgbWFwXHJcbiAgICAgKiBhbmQgcmVnaXN0ZXIgdGhlIGFzc29jaWF0ZWQgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBVcGRhdGVQb2x5Z29ucygpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fbGF5ZXJQcm9taXNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sYXllclByb21pc2UudGhlbihsID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9seWdvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4gPSB0aGlzLl9zdHJlYW1pbmcgPyB0aGlzLl9wb2x5Z29uc0xhc3Quc3BsaWNlKDApIDogdGhpcy5fcG9seWdvbnM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKSB7IHRoaXMuX2xhYmVscy5zcGxpY2UoMCk7IH1cclxuXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBwcm9taXNlIGZvciB0aGUgbWFya2Vyc1xyXG4gICAgICAgICAgICBjb25zdCBscDogUHJvbWlzZTxBcnJheTxQb2x5Z29uPj4gPSB0aGlzLl9zZXJ2aWNlLkNyZWF0ZVBvbHlnb25zKGwuR2V0T3B0aW9ucygpLmlkLCBwb2x5Z29ucyk7XHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgbWFya2VycyBvbmNlIHByb21pc2VzIGFyZSBmdWxsZmlsbGVkLlxyXG4gICAgICAgICAgICBscC50aGVuKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgcC5mb3JFYWNoKHBvbHkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5LlRpdGxlICE9IG51bGwgJiYgcG9seS5UaXRsZS5sZW5ndGggPiAwKSB7IHRoaXMuX2xhYmVscy5wdXNoKHtsb2M6IHBvbHkuQ2VudHJvaWQsIHRpdGxlOiBwb2x5LlRpdGxlfSk7IH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEV2ZW50TGlzdGVuZXJzKHBvbHkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJlYW1pbmcgPyBsLkFkZEVudGl0aWVzKHApIDogbC5TZXRFbnRpdGllcyhwKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYW52YXMpIHsgdGhpcy5fY2FudmFzLlJlZHJhdyghdGhpcy5fc3RyZWFtaW5nKTsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICAgIERpcmVjdGl2ZSwgU2ltcGxlQ2hhbmdlLCBJbnB1dCwgT3V0cHV0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyxcclxuICAgIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBBZnRlckNvbnRlbnRJbml0LCBWaWV3Q29udGFpbmVyUmVmLCBOZ1pvbmUsXHJcbiAgICBTaW1wbGVDaGFuZ2VzXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pc2l6ZSc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2x5bGluZUV2ZW50IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtZXZlbnQnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElMYXllck9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXllci1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxhYmVsT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhYmVsLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9tb2RlbHMvbGF5ZXInO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IE1hcExhYmVsIH0gZnJvbSAnLi4vbW9kZWxzL21hcC1sYWJlbCc7XHJcbmltcG9ydCB7IENhbnZhc092ZXJsYXkgfSBmcm9tICcuLi9tb2RlbHMvY2FudmFzLW92ZXJsYXknO1xyXG5cclxuLyoqXHJcbiAqIGludGVybmFsIGNvdW50ZXIgdG8gdXNlIGFzIGlkcyBmb3IgcG9seWxpbmVzLlxyXG4gKi9cclxubGV0IGxheWVySWQgPSAxMDAwMDAwO1xyXG5cclxuLyoqXHJcbiAqIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmUgcGVyZm9ybWFudGx5IHJlbmRlcnMgYSBsYXJnZSBzZXQgb2YgcG9seWxpbmUgb24gYSB7QGxpbmsgTWFwQ29tcG9uZW50fS5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50fSBmcm9tICcuLi4nO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXHJcbiAqICBzdHlsZXM6IFtgXHJcbiAqICAgLm1hcC1jb250YWluZXIge1xyXG4gKiAgICAgaGVpZ2h0OiAzMDBweDtcclxuICogICB9XHJcbiAqIGBdLFxyXG4gKiB0ZW1wbGF0ZTogYFxyXG4gKiAgIDx4LW1hcCBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbWm9vbV09XCJ6b29tXCI+XHJcbiAqICAgICAgPHgtbWFwLXBvbHlsaW5lLWxheWVyIFtQb2x5Z29uT3B0aW9uc109XCJfcG9seWxpbmVcIj48L3gtbWFwLXBvbHlsaW5lLWxheWVyPlxyXG4gKiAgIDwveC1tYXA+XHJcbiAqIGBcclxuICogfSlcclxuICogYGBgXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICd4LW1hcC1wb2x5bGluZS1sYXllcidcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2lkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9sYXllclByb21pc2U6IFByb21pc2U8TGF5ZXI+O1xyXG4gICAgcHJpdmF0ZSBfc2VydmljZTogTGF5ZXJTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBfY2FudmFzOiBDYW52YXNPdmVybGF5O1xyXG4gICAgcHJpdmF0ZSBfbGFiZWxzOiBBcnJheTx7bG9jOiBJTGF0TG9uZywgdGl0bGU6IHN0cmluZ30+ID0gbmV3IEFycmF5PHtsb2M6IElMYXRMb25nLCB0aXRsZTogc3RyaW5nfT4oKTtcclxuICAgIHByaXZhdGUgX3Rvb2x0aXA6IE1hcExhYmVsO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFN1YnNjcmlwdGlvbnM6IEFycmF5PFN1YnNjcmlwdGlvbj4gPSBuZXcgQXJyYXk8U3Vic2NyaXB0aW9uPigpO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2RlZmF1bHRPcHRpb25zOiBJTGFiZWxPcHRpb25zID0ge1xyXG4gICAgICAgIGZvbnRTaXplOiAxMSxcclxuICAgICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXHJcbiAgICAgICAgc3Ryb2tlV2VpZ2h0OiAyLFxyXG4gICAgICAgIHN0cm9rZUNvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgZm9udENvbG9yOiAnI2ZmZmZmZidcclxuICAgIH07XHJcbiAgICBwcml2YXRlIF9zdHJlYW1pbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3BvbHlsaW5lczogQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4gPSBuZXcgQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4oKTtcclxuICAgIHByaXZhdGUgX3BvbHlsaW5lc0xhc3Q6IEFycmF5PElQb2x5bGluZU9wdGlvbnM+ID0gbmV3IEFycmF5PElQb2x5bGluZU9wdGlvbnM+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG1heGltdW0gem9vbSBhdCB3aGljaCB0aGUgcG9seWxpbmUgbGFiZWxzIGFyZSB2aXNpYmxlLiBJZ25vcmVkIGlmIFNob3dMYWJlbCBpcyBmYWxzZS5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYWJlbE1heFpvb206IG51bWJlciA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtaW5pbXVtIHpvb20gYXQgd2hpY2ggdGhlIHBvbHlsaW5lIGxhYmVscyBhcmUgdmlzaWJsZS4gSWdub3JlZCBpZiBTaG93TGFiZWwgaXMgZmFsc2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWxNaW5ab29tOiBudW1iZXIgPSAtMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlcGNpZmllcyBzdHlsZWluZyBvcHRpb25zIGZvciBvbi1tYXAgcG9seWxpbmUgbGFiZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYWJlbE9wdGlvbnM6IElMYWJlbE9wdGlvbnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgQW4gb2Zmc2V0IGFwcGxpZWQgdG8gdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGF5ZXJPZmZzZXQ6IElQb2ludCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBwb2x5bGluZSBvcHRpb25zIHJlcHJlc2VudGluZyB0aGUgcG9seWxpbmVzIGluIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgUG9seWxpbmVPcHRpb25zKCk6IEFycmF5PElQb2x5bGluZU9wdGlvbnM+IHsgcmV0dXJuIHRoaXMuX3BvbHlsaW5lczsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgUG9seWxpbmVPcHRpb25zKHZhbDogQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmVhbWluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWxpbmVzTGFzdC5wdXNoKC4uLnZhbC5zbGljZSgwKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2x5bGluZXMucHVzaCguLi52YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWxpbmVzID0gdmFsLnNsaWNlKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBzaG93IHRoZSBwb2x5bGluZXMgdGl0bGVzIGFzIHRoZSBsYWJlbHMgb24gdGhlIHBvbHlsaW5lcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd0xhYmVsczogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBzaG93IHRoZSB0aXRsZXMgb2YgdGhlIHBvbHlsaW5lcyBhcyB0aGUgdG9vbHRpcHMgb24gdGhlIHBvbHlsaW5lcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd1Rvb2x0aXBzOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0byB0cmVhdCBjaGFuZ2VzIGluIHRoZSBQb2x5bGluZU9wdGlvbnMgYXMgc3RyZWFtcyBvZiBuZXcgbWFya2Vycy4gSW4gdGhpcyBtb2RlLCBjaGFuZ2luZyB0aGVcclxuICAgICAqIEFycmF5IHN1cHBsaWVkIGluIFBvbHlsaW5lT3B0aW9ucyB3aWxsIGJlIGluY3JlbWVudGFsbHkgZHJhd24gb24gdGhlIG1hcCBhcyBvcHBvc2VkIHRvIHJlcGxhY2UgdGhlIHBvbHlsaW5lcyBvbiB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBUcmVhdE5ld1BvbHlsaW5lT3B0aW9uc0FzU3RyZWFtKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc3RyZWFtaW5nOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBUcmVhdE5ld1BvbHlsaW5lT3B0aW9uc0FzU3RyZWFtKHZhbDogYm9vbGVhbikgeyB0aGlzLl9zdHJlYW1pbmcgPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIG1hcmtlciBsYXllclxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBWaXNpYmxlOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB6LWluZGV4IG9mIHRoZSBsYXllci4gSWYgbm90IHVzZWQsIGxheWVycyBnZXQgc3RhY2tlZCBpbiB0aGUgb3JkZXIgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgWkluZGV4OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIERlbGVnYXRlc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgcG9seWxpbmUgaW4gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBwdWJsaWMgUG9seWxpbmVDbGljazogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiBhIHBvbHlsaW5lIGluIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgUG9seWxpbmVEYmxDbGljazogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZW1vdmUgZXZlbnQgaXMgZmlyZWQgb24gYSBwb2x5bGluZSBpbiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIFBvbHlsaW5lTW91c2VNb3ZlOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gbW91c2VvdXQgb24gYSBwb2x5bGluZSBpbiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIFBvbHlsaW5lTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBtb3VzZW92ZXIgb24gYSBwb2x5bGluZSBpbiBhIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBQb2x5bGluZU1vdXNlT3ZlcjogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG5cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaWQgb2YgdGhlIHBvbHlsaW5lIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5faWQ7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmUuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyU2VydmljZSAtIENvbmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHtAbGluayBMYXllclNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE1hcFNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE5nWm9uZX0gc2VydmljZS5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICAgICAgdGhpcy5faWQgPSBsYXllcklkKys7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIENvbXBvbmVudCBjb250ZW50IGluaXRpYWxpemF0aW9uLiBQYXJ0IG9mIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXJPcHRpb25zOiBJTGF5ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogdGhpcy5faWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmYWtlTGF5ZXJEaXJlY3RpdmU6IGFueSA9IHtcclxuICAgICAgICAgICAgICAgIElkIDogdGhpcy5faWQsXHJcbiAgICAgICAgICAgICAgICBWaXNpYmxlOiB0aGlzLlZpc2libGUsXHJcbiAgICAgICAgICAgICAgICBMYXllck9mZnNldDogdGhpcy5MYXllck9mZnNldCxcclxuICAgICAgICAgICAgICAgIFpJbmRleDogdGhpcy5aSW5kZXhcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJTZXJ2aWNlLkFkZExheWVyKGZha2VMYXllckRpcmVjdGl2ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZSA9IHRoaXMuX2xheWVyU2VydmljZS5HZXROYXRpdmVMYXllcihmYWtlTGF5ZXJEaXJlY3RpdmUpO1xyXG5cclxuICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUNhbnZhc092ZXJsYXkoZWwgPT4gdGhpcy5EcmF3TGFiZWxzKGVsKSlcclxuICAgICAgICAgICAgICAgIF0pLnRoZW4odmFsdWVzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbMF0uU2V0VmlzaWJsZSh0aGlzLlZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IHZhbHVlc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuX2NhbnZhc1JlYWR5LnRoZW4oYiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAgPSB0aGlzLl9jYW52YXMuR2V0VG9vbFRpcE92ZXJsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKHRoaXMuU2hvd1Rvb2x0aXBzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5Qb2x5bGluZU9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLlVwZGF0ZVBvbHlsaW5lcygpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fc2VydmljZSA9IHRoaXMuX2xheWVyU2VydmljZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBvbiBjb21wb25lbnQgZGVzdHJ1Y3Rpb24uIEZyZWVzIHRoZSByZXNvdXJjZXMgdXNlZCBieSB0aGUgY29tcG9uZW50LiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMuZm9yRWFjaChzID0+IHMudW5zdWJzY3JpYmUoKSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLnRoZW4obCA9PiB7XHJcbiAgICAgICAgICAgIGwuRGVsZXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhcykgeyB0aGlzLl9jYW52YXMuRGVsZXRlKCk7IH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWN0cyB0byBjaGFuZ2VzIGluIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50IGFuZCBhY3R1YXRlcyBwcm9wZXJ0eSBjaGFuZ2VzIGluIHRoZSB1bmRlcmxpbmcgbGF5ZXIgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYW5nZXMgLSBjb2xsZWN0aW9uIG9mIGNoYW5nZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xyXG4gICAgICAgIGlmIChjaGFuZ2VzWydQb2x5bGluZU9wdGlvbnMnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuVXBkYXRlUG9seWxpbmVzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snVmlzaWJsZSddICYmICFjaGFuZ2VzWydWaXNpYmxlJ10uZmlyc3RDaGFuZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLnRoZW4obCA9PiBsLlNldFZpc2libGUodGhpcy5WaXNpYmxlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoY2hhbmdlc1snWkluZGV4J10gJiYgIWNoYW5nZXNbJ1pJbmRleCddLmZpcnN0Q2hhbmdlKSB8fFxyXG4gICAgICAgICAgICAoY2hhbmdlc1snTGF5ZXJPZmZzZXQnXSAmJiAhY2hhbmdlc1snTGF5ZXJPZmZzZXQnXS5maXJzdENoYW5nZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignWW91IGNhbm5vdCBjaGFuZ2UgWkluZGV4IG9yIExheWVyT2Zmc2V0IGFmdGVyIHRoZSBsYXllciBoYXMgYmVlbiBjcmVhdGVkLicpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChjaGFuZ2VzWydTaG93TGFiZWxzJ10gJiYgIWNoYW5nZXNbJ1Nob3dMYWJlbHMnXS5maXJzdENoYW5nZSkgfHxcclxuICAgICAgICAgICAgKGNoYW5nZXNbJ0xhYmVsTWluWm9vbSddICYmICFjaGFuZ2VzWydMYWJlbE1pblpvb20nXS5maXJzdENoYW5nZSkgfHxcclxuICAgICAgICAgICAgKGNoYW5nZXNbJ0xhYmVsTWF4Wm9vbSddICYmICFjaGFuZ2VzWydMYWJlbE1heFpvb20nXS5maXJzdENoYW5nZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbnZhcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLlJlZHJhdyh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU2hvd1Rvb2x0aXBzJ10gJiYgdGhpcy5fdG9vbHRpcCkge1xyXG4gICAgICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoY2hhbmdlc1snU2hvd1Rvb2x0aXBzJ10uY3VycmVudFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMYXllciBJZC5cclxuICAgICAqIEByZXR1cm5zIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBpZC5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcgeyByZXR1cm4gJ01hcFBvbHlsaW5lTGF5ZXItJyArIHRoaXMuX2lkLnRvU3RyaW5nKCk7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB2YXJpb3VzIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIHBvbHlsaW5lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcCAtIHRoZSBwb2x5bGluZSBmb3Igd2hpY2ggdG8gYWRkIHRoZSBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIEFkZEV2ZW50TGlzdGVuZXJzKHA6IFBvbHlsaW5lKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBbXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlsaW5lQ2xpY2suZW1pdCh7UG9seWxpbmU6IHAsIENsaWNrOiBldn0pIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2RibGNsaWNrJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlsaW5lRGJsQ2xpY2suZW1pdCh7UG9seWxpbmU6IHAsIENsaWNrOiBldn0pIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Qb2x5bGluZU1vdXNlTW92ZS5lbWl0KHtQb2x5bGluZTogcCwgQ2xpY2s6IGV2fSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdXQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuUG9seWxpbmVNb3VzZU91dC5lbWl0KHtQb2x5bGluZTogcCwgQ2xpY2s6IGV2fSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdmVyJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlsaW5lTW91c2VPdmVyLmVtaXQoe1BvbHlsaW5lOiBwLCBDbGljazogZXZ9KSB9XHJcbiAgICAgICAgXTtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChvYmopID0+IHAuQWRkTGlzdGVuZXIob2JqLm5hbWUsIG9iai5oYW5kbGVyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgcG9seWxpbmUgbGFiZWxzLiBDYWxsZWQgYnkgdGhlIENhbnZhcyBvdmVybGF5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbCAtIFRoZSBjYW52YXMgb24gd2hpY2ggdG8gZHJhdyB0aGUgbGFiZWxzLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBEcmF3TGFiZWxzKGVsOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLlNob3dMYWJlbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5HZXRab29tKCkudGhlbih6ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLkxhYmVsTWluWm9vbSA8PSB6ICYmIHRoaXMuTGFiZWxNYXhab29tID49IHopIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGVsLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5fbGFiZWxzLm1hcCh4ID0+IHgudGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuTG9jYXRpb25zVG9Qb2ludHModGhpcy5fbGFiZWxzLm1hcCh4ID0+IHgubG9jKSkudGhlbihsb2NzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZTogSVNpemUgPSB0aGlzLl9tYXBTZXJ2aWNlLk1hcFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsb2NzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkcmF3IHRoZSBwb2ludCBpZiBpdCBpcyBub3QgaW4gdmlldy4gVGhpcyBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlIHdoZW4gem9vbWVkIGluLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY3NbaV0ueCA+PSAwICYmIGxvY3NbaV0ueSA+PSAwICYmIGxvY3NbaV0ueCA8PSBzaXplLndpZHRoICYmIGxvY3NbaV0ueSA8PSBzaXplLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRHJhd1RleHQoY3R4LCBsb2NzW2ldLCBsYWJlbHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBsYWJlbCB0ZXh0IGF0IHRoZSBhcHByb3ByaWF0ZSBwbGFjZSBvbiB0aGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIGN0eCAtIENhbnZhcyBkcmF3aW5nIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gbG9jIC0gUGl4ZWwgbG9jYXRpb24gb24gdGhlIGNhbnZhcyB3aGVyZSB0byBjZW50ZXIgdGhlIHRleHQuXHJcbiAgICAgKiBAcGFyYW0gdGV4dCAtIFRleHQgdG8gZHJhdy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBEcmF3VGV4dChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgbG9jOiBJUG9pbnQsIHRleHQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBsbzogSUxhYmVsT3B0aW9ucyA9IHRoaXMuTGFiZWxPcHRpb25zO1xyXG4gICAgICAgIGlmIChsbyA9PSBudWxsICYmIHRoaXMuX3Rvb2x0aXApIHsgbG8gPSB0aGlzLl90b29sdGlwLkRlZmF1bHRMYWJlbFN0eWxlOyB9XHJcbiAgICAgICAgaWYgKGxvID09IG51bGwpIHsgbG8gPSB0aGlzLl9kZWZhdWx0T3B0aW9uczsgfVxyXG5cclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsby5zdHJva2VDb2xvcjtcclxuICAgICAgICBjdHguZm9udCA9IGAke2xvLmZvbnRTaXplfXB4ICR7bG8uZm9udEZhbWlseX1gO1xyXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICBjb25zdCBzdHJva2VXZWlnaHQ6IG51bWJlciA9IGxvLnN0cm9rZVdlaWdodDtcclxuICAgICAgICBpZiAodGV4dCAmJiBzdHJva2VXZWlnaHQgJiYgc3Ryb2tlV2VpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdlaWdodDtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRleHQsIGxvYy54LCBsb2MueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsby5mb250Q29sb3I7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIGxvYy54LCBsb2MueSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYW5hZ2VzIHRoZSB0b29sdGlwIGFuZCB0aGUgYXR0YWNobWVudCBvZiB0aGUgYXNzb2NpYXRlZCBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNob3cgLSBUcnVlIHRvIGVuYWJsZSB0aGUgdG9vbHRpcCwgZmFsc2UgdG8gZGlzYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBNYW5hZ2VUb29sdGlwKHNob3c6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICBpZiAoc2hvdyAmJiB0aGlzLl9jYW52YXMpIHtcclxuICAgICAgICAgICAgLy8gYWRkIHRvb2x0aXAgc3Vic2NyaXB0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLnB1c2godGhpcy5Qb2x5bGluZU1vdXNlTW92ZS5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2M6IElMYXRMb25nID0gdGhpcy5fY2FudmFzLkdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGUuQ2xpY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGxvYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLlBvbHlsaW5lTW91c2VPdmVyLmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZShlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlLlBvbHlsaW5lLlRpdGxlICYmIGUuUG9seWxpbmUuVGl0bGUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYzogSUxhdExvbmcgPSB0aGlzLl9jYW52YXMuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZS5DbGljayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ3RleHQnLCBlLlBvbHlsaW5lLlRpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBsb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuUG9seWxpbmVNb3VzZU91dC5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRvb2x0aXAgc3Vic2NyaXB0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU3Vic2NyaXB0aW9ucy5mb3JFYWNoKHMgPT4gcy51bnN1YnNjcmliZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMuc3BsaWNlKDApO1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBvciB1cGRhdGVzIHRoZSBwb2x5bGluZXNzIGJhc2VkIG9uIHRoZSBwb2x5bGluZSBvcHRpb25zLiBUaGlzIHdpbGwgcGxhY2UgdGhlIHBvbHlsaW5lcyBvbiB0aGUgbWFwXHJcbiAgICAgKiBhbmQgcmVnaXN0ZXIgdGhlIGFzc29jaWF0ZWQgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgVXBkYXRlUG9seWxpbmVzKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXllclByb21pc2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5bGluZXM6IEFycmF5PElQb2x5bGluZU9wdGlvbnM+ID0gdGhpcy5fc3RyZWFtaW5nID8gdGhpcy5fcG9seWxpbmVzTGFzdC5zcGxpY2UoMCkgOiB0aGlzLl9wb2x5bGluZXM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKSB7IHRoaXMuX2xhYmVscy5zcGxpY2UoMCk7IH1cclxuXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBwcm9taXNlIGZvciB0aGUgcG9seWxpbmVzXHJcbiAgICAgICAgICAgIGNvbnN0IGxwOiBQcm9taXNlPEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+ID0gdGhpcy5fc2VydmljZS5DcmVhdGVQb2x5bGluZXMobC5HZXRPcHRpb25zKCkuaWQsIHBvbHlsaW5lcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgcG9seWxpbmVzIG9uY2UgcHJvbWlzZXMgYXJlIGZ1bGxmaWxsZWQuXHJcbiAgICAgICAgICAgIGxwLnRoZW4ocCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5OiBBcnJheTxQb2x5bGluZT4gPSBuZXcgQXJyYXk8UG9seWxpbmU+KCk7XHJcbiAgICAgICAgICAgICAgICBwLmZvckVhY2gocG9seSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9seSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpdGxlOiBzdHJpbmcgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudHJvaWRzOiBBcnJheTxJTGF0TG9uZz4gPSBuZXcgQXJyYXk8SUxhdExvbmc+KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHkuZm9yRWFjaCh4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkucHVzaCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXZlbnRMaXN0ZW5lcnMoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50cm9pZHMucHVzaCh4LkNlbnRyb2lkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LlRpdGxlICE9IG51bGwgJiYgeC5UaXRsZS5sZW5ndGggPiAwICYmIHRpdGxlLmxlbmd0aCA9PT0gMCkgeyB0aXRsZSA9IHguVGl0bGU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVscy5wdXNoKHtsb2M6IFBvbHlsaW5lLkdldFBvbHlsaW5lQ2VudHJvaWQoY2VudHJvaWRzKSwgdGl0bGU6IHRpdGxlfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5LnB1c2gocG9seSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2x5LlRpdGxlICE9IG51bGwgJiYgcG9seS5UaXRsZS5sZW5ndGggPiAwKSB7IHRoaXMuX2xhYmVscy5wdXNoKHtsb2M6IHBvbHkuQ2VudHJvaWQsIHRpdGxlOiBwb2x5LlRpdGxlfSk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFdmVudExpc3RlbmVycyhwb2x5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0cmVhbWluZyA/IGwuQWRkRW50aXRpZXMoeSkgOiBsLlNldEVudGl0aWVzKHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbnZhcykgeyB0aGlzLl9jYW52YXMuUmVkcmF3KCF0aGlzLl9zdHJlYW1pbmcpOyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgaW1wbGVtZW50YXRpb24uIFVTZWQgZm9yIGRlZmludGlvbiBvbmx5IGFuZCBhcyBhIGJhc2UgdG8gaW1wbGVtZW50IHlvdXJcclxuICogb3duIHByb3ZpZGVyLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTWFwQVBJTG9hZGVyIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHRoZSBuZWNlc3NhcnkgcmVzb3VyY2VzIGZvciBhIGdpdmVuIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgZnVsbGZpbGxlZCB3aGVuIHRoZSByZXNvdXJjZXMgaGF2ZSBiZWVuIGxvYWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IExvYWQoKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEb2N1bWVudCBSZWZlcmVuY2Ugc2VydmljZSB0byBhc3Npc3Qgd2l0aCBhYnN0cmFjdGluZyB0aGUgYXZhaWxhYmlsaXR5IG9mIGRvY3VtZW50LiBOZWVkZWQgZm9yIEFPVCBhbmRcclxuICogU2VydmVyIFNpZGUgcmVuZGVyaW5nXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIERvY3VtZW50UmVmIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciBhIGRvY3VtZW50IGltcGxlbWVudGF0aW9uIGlzIGF2YWlsYWJsZS4gR2VuZXJhbGx5IHdpbGwgYmUgdHJ1ZSBpbiB0aGUgYnJvd3NlciBhbmQgZmFsc2Ugb3RoZXJ3aXNlLCB1bmxlc3MgdGhlcmVcclxuICAgICAqIHRoZXJlIGlzIGEgYnJvd3Nlci1sZXNzIGltcGxlbWVudGF0aW9uIGluIHRoZSBjdXJyZW50IG5vbi1icm93c2VyIGVudmlyb25tZW50LlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIERvY3VtZW50UmVmXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICEodHlwZW9mIChkb2N1bWVudCkgPT09ICd1bmRlZmluZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRvY3VtZW50IG9iamVjdCBvZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBkb2N1bWVudCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIERvY3VtZW50UmVmXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXROYXRpdmVEb2N1bWVudCgpOiBhbnkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGRvY3VtZW50KSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFdpbmRvdyBSZWZlcmVuY2Ugc2VydmljZSB0byBhc3Npc3Qgd2l0aCBhYnN0cmFjdGluZyB0aGUgYXZhaWxhYmlsaXR5IG9mIHdpbmRvdy4gTmVlZGVkIGZvciBBT1QgYW5kXHJcbiAqIFNlcnZlciBTaWRlIHJlbmRlcmluZ1xyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBXaW5kb3dSZWYge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIGEgd2luZG93IGltcGxlbWVudGF0aW9uIGlzIGF2YWlsYWJsZS4gR2VuZXJhbGx5IHdpbGwgYmUgdHJ1ZSBpbiB0aGUgYnJvd3NlciBhbmQgZmFsc2Ugb3RoZXJ3aXNlLCB1bmxlc3MgdGhlcmVcclxuICAgICAqIHRoZXJlIGlzIGEgYnJvd3Nlci1sZXNzIGltcGxlbWVudGF0aW9uIGluIHRoZSBjdXJyZW50IG5vbi1icm93c2VyIGVudmlyb25tZW50LlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIFdpbmRvd1JlZlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IElzQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAhKHR5cGVvZiAod2luZG93KSA9PT0gJ3VuZGVmaW5lZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgd2luZG93IG9iamVjdCBvZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSB3aW5kb3cgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBXaW5kb3dSZWZcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldE5hdGl2ZVdpbmRvdygpOiBhbnkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKHdpbmRvdykgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBNYXBBUElMb2FkZXIsIFdpbmRvd1JlZiwgRG9jdW1lbnRSZWYgfSBmcm9tICcuLi9tYXBhcGlsb2FkZXInO1xyXG5cclxuLyoqXHJcbiAqIFByb3RvY29sIGVudW1lcmF0aW9uXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbmV4cG9ydCBlbnVtIFNjcmlwdFByb3RvY29sIHtcclxuICAgIEhUVFAsXHJcbiAgICBIVFRQUyxcclxuICAgIEFVVE9cclxufVxyXG5cclxuLyoqXHJcbiAqIEJpbmcgTWFwcyBWOCBzcGVjaWZpYyBsb2FkZXIgY29uZmlndXJhdGlvbiB0byBiZSB1c2VkIHdpdGggdGhlIHtAbGluayBCaW5nTWFwQVBJTG9hZGVyfVxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBCaW5nTWFwQVBJTG9hZGVyQ29uZmlnICB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQVBJIGtleSBmb3IgYmluZyBtYXBzXHJcbiAgICAvLy9cclxuICAgIGFwaUtleSA9ICcnO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEhvc3QgYW5kIFBhdGggdXNlZCBmb3IgdGhlIGA8c2NyaXB0PmAgdGFnLlxyXG4gICAgLy8vXHJcbiAgICBob3N0QW5kUGF0aCA9ICd3d3cuYmluZy5jb20vYXBpL21hcHMvbWFwY29udHJvbCc7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvdG9jb2wgdXNlZCBmb3IgdGhlIGA8c2NyaXB0PmAgdGFnLlxyXG4gICAgLy8vXHJcbiAgICBwcm90b2NvbDogU2NyaXB0UHJvdG9jb2wgPSBTY3JpcHRQcm90b2NvbC5IVFRQUztcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBUaGUgYnJhbmNoIHRvIGJlIHVzZWQuIExlYXZlIGVtcHR5IGZvciBwcm9kdWN0aW9uLiBVc2UgZXhwZXJpbWVudGFsXHJcbiAgICAvLy9cclxuICAgIGJyYW5jaCA9ICcnO1xyXG59XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBsb2FkZXIgY29uZmlndXJhdGlvbi5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfQ09ORklHVVJBVElPTiA9IG5ldyBCaW5nTWFwQVBJTG9hZGVyQ29uZmlnKCk7XHJcblxyXG4vKipcclxuICogQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uIGZvciB0aGUge0BsaW5rIE1hcEFQSUxvYWRlcn0gc2VydmljZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQmluZ01hcEFQSUxvYWRlciBleHRlbmRzIE1hcEFQSUxvYWRlciB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVmaW50aXRpb25zLlxyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9zY3JpcHRMb2FkaW5nUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnMuXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvYWRlciBjb25maWd1cmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBBUElMb2FkZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBDb25maWcoKTogQmluZ01hcEFQSUxvYWRlckNvbmZpZyB7IHJldHVybiB0aGlzLl9jb25maWc7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ01hcEFQSUxvYWRlci5cclxuICAgICAqIEBwYXJhbSBfY29uZmlnICAtIFRoZSBsb2FkZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSBfd2luZG93UmVmIC0gQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFdpbmRvd1JlZn0uIE5lY2Vzc2FyeSBiZWNhdXNlIEJpbmcgTWFwIFY4IGludGVyYWN0cyB3aXRoIHRoZSB3aW5kb3cgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIF9kb2N1bWVudFJlZiAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBEb2N1bWVudFJlZn0uXHJcbiAgICAgKiBOZWNlc3NhcnkgYmVjYXVzZSBCaW5nIE1hcCBWOCBpbnRlcmFjdHMgd2l0aCB0aGUgZG9jdW1lbnQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCBAT3B0aW9uYWwoKSBwcml2YXRlIF9jb25maWc6IEJpbmdNYXBBUElMb2FkZXJDb25maWcsIHByaXZhdGUgX3dpbmRvd1JlZjogV2luZG93UmVmLCBwcml2YXRlIF9kb2N1bWVudFJlZjogRG9jdW1lbnRSZWYpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcgPT09IG51bGwgfHwgdGhpcy5fY29uZmlnID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29uZmlnID0gREVGQVVMVF9DT05GSUdVUkFUSU9OO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kcyBhbmQgTWFwQVBJTG9hZGVyIGltcGxlbWVudGF0aW9uLlxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyB0aGUgbmVjZXNzYXJ5IHJlc291cmNlcyBmb3IgQmluZyBNYXBzIFY4LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBMb2FkKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzY3JpcHQgPSB0aGlzLl9kb2N1bWVudFJlZi5HZXROYXRpdmVEb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcclxuICAgICAgICBzY3JpcHQuZGVmZXIgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTmFtZSA9IGBhbmd1bGFyMmJpbmdtYXBzJHtuZXcgRGF0ZSgpLmdldE1pbGxpc2Vjb25kcygpfWA7XHJcbiAgICAgICAgc2NyaXB0LnNyYyA9IHRoaXMuR2V0U2NyaXB0U3JjKGNhbGxiYWNrTmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmU6IEZ1bmN0aW9uLCByZWplY3Q6IEZ1bmN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICg8YW55PnRoaXMuX3dpbmRvd1JlZi5HZXROYXRpdmVXaW5kb3coKSlbY2FsbGJhY2tOYW1lXSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSAoZXJyb3I6IEV2ZW50KSA9PiB7IHJlamVjdChlcnJvcik7IH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWYuR2V0TmF0aXZlRG9jdW1lbnQoKS5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBCaW5nIE1hcCBWOCBzY3JpcHRzIHVybCBmb3IgaW5qZWN0aW9ucyBpbnRvIHRoZSBoZWFkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrTmFtZSAtIE5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBCaW5nIE1hcHMgVjggc2NyaXB0cyBhcmUgbG9hZGVkLlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgdXJsIHRvIGJlIHVzZWQgdG8gbG9hZCB0aGUgQmluZyBNYXAgc2NyaXB0cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcEFQSUxvYWRlclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIEdldFNjcmlwdFNyYyhjYWxsYmFja05hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2xUeXBlOiBTY3JpcHRQcm90b2NvbCA9ICh0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLnByb3RvY29sKSB8fCBERUZBVUxUX0NPTkZJR1VSQVRJT04ucHJvdG9jb2w7XHJcbiAgICAgICAgbGV0IHByb3RvY29sOiBzdHJpbmc7XHJcblxyXG4gICAgICAgIHN3aXRjaCAocHJvdG9jb2xUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgU2NyaXB0UHJvdG9jb2wuQVVUTzpcclxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTY3JpcHRQcm90b2NvbC5IVFRQOlxyXG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnaHR0cDonO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU2NyaXB0UHJvdG9jb2wuSFRUUFM6XHJcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9ICdodHRwczonO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBob3N0QW5kUGF0aDogc3RyaW5nID0gdGhpcy5fY29uZmlnLmhvc3RBbmRQYXRoIHx8IERFRkFVTFRfQ09ORklHVVJBVElPTi5ob3N0QW5kUGF0aDtcclxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrTmFtZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5icmFuY2ggIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zWydicmFuY2gnXSA9IHRoaXMuX2NvbmZpZy5icmFuY2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmFtczogc3RyaW5nID0gT2JqZWN0LmtleXMocXVlcnlQYXJhbXMpXHJcbiAgICAgICAgICAgIC5tYXAoKGs6IHN0cmluZywgaTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW0gPSAoaSA9PT0gMCkgPyAnPycgOiAnJic7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0gKz0gYCR7a309JHtxdWVyeVBhcmFtc1trXX1gO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuam9pbignJyk7XHJcbiAgICAgICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0QW5kUGF0aH0ke3BhcmFtc31gO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgSUluZm9XaW5kb3dPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctb3B0aW9ucyc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IEluZm9Cb3hBY3Rpb25EaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2luZm9ib3gtYWN0aW9uJztcclxuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuLi9pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJbmZvQm94Q29tcG9uZW50IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9pbmZvYm94JztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuL2JpbmctbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nSW5mb1dpbmRvdyB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctaW5mby13aW5kb3cnO1xyXG5pbXBvcnQgeyBCaW5nTWFwRXZlbnRzTG9va3VwIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1ldmVudHMtbG9va3VwJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIEluZm9Cb3hTZXJ2aWNlfSBjb250cmFjdCBmb3IgdGhlIEJpbmcgTWFwcyBWOCBhcmNoaXRlY3R1cmUuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEJpbmdJbmZvQm94U2VydmljZSBpbXBsZW1lbnRzIEluZm9Cb3hTZXJ2aWNlIHtcclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9ib3hlczogTWFwPEluZm9Cb3hDb21wb25lbnQsIFByb21pc2U8SW5mb1dpbmRvdz4+ID0gbmV3IE1hcDxJbmZvQm94Q29tcG9uZW50LCBQcm9taXNlPEluZm9XaW5kb3c+PigpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ0luZm9Cb3hTZXJ2aWNlLlxyXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gQ29uY3JldGUge0BsaW5rIE1hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciBCaW5nIE1hcHMgVjguIEFuIGluc3RhbmNlIG9mIHtAbGluayBCaW5nTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBBbiBpbnN0YW5jZSBvZiBOZ1pvbmUgdG8gcHJvdmlkZSB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gaW5mbyB3aW5kb3cgdG8gdGhlIG1hcCBvciBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRJbmZvV2luZG93KGluZm86IEluZm9Cb3hDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMgPSB7fTtcclxuICAgICAgICBpZiAodHlwZW9mIGluZm8uTGF0aXR1ZGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBpbmZvLkxvbmdpdHVkZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiBpbmZvLkxhdGl0dWRlLFxyXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBpbmZvLkxvbmdpdHVkZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGluZm8uSW5mb1dpbmRvd0FjdGlvbnMgIT09ICd1bmRlZmluZWQnICYmIGluZm8uSW5mb1dpbmRvd0FjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmFjdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgaW5mby5JbmZvV2luZG93QWN0aW9ucy5mb3JFYWNoKChhY3Rpb246IEluZm9Cb3hBY3Rpb25EaXJlY3RpdmUpID0+IHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogYWN0aW9uLkxhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlcjogKCkgPT4geyBhY3Rpb24uQWN0aW9uQ2xpY2tlZC5lbWl0KG51bGwpOyB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmZvLkh0bWxDb250ZW50ICE9PSAnJykge1xyXG4gICAgICAgICAgICBvcHRpb25zLmh0bWxDb250ZW50ID0gaW5mby5IdG1sQ29udGVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMudGl0bGUgPSBpbmZvLlRpdGxlO1xyXG4gICAgICAgICAgICBvcHRpb25zLmRlc2NyaXB0aW9uID0gaW5mby5EZXNjcmlwdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluZm8ueE9mZnNldCB8fCBpbmZvLnlPZmZzZXQpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGl4ZWxPZmZzZXQgPT0gbnVsbCkgeyBvcHRpb25zLnBpeGVsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuICAgICAgICAgICAgaWYgKGluZm8ueE9mZnNldCkgeyBvcHRpb25zLnBpeGVsT2Zmc2V0LnggPSBpbmZvLnhPZmZzZXQ7IH1cclxuICAgICAgICAgICAgaWYgKGluZm8ueU9mZnNldCkgeyBvcHRpb25zLnBpeGVsT2Zmc2V0LnkgPSBpbmZvLnlPZmZzZXQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdGlvbnMudmlzaWJsZSA9IGluZm8uVmlzaWJsZTtcclxuICAgICAgICBjb25zdCBpbmZvUHJvbWlzZSA9IHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlSW5mb1dpbmRvdyhvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9ib3hlcy5zZXQoaW5mbywgaW5mb1Byb21pc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIGFuIEluZm9Cb3hDb21wb25lbnQgdGhhdCBpcyBvcGVuLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGluZm8gLSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gY29tcG9uZW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluZm9ib3guXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBoYXMgYmVlbiBjbG9zZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDbG9zZShpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKCh3KSA9PiB3LkNsb3NlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGRlbGVnYXRlIGZvciBhbiBpbmZvIHdpbmRvdy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIChlLmcuICdjbGljaycpXHJcbiAgICAgKiBAcGFyYW0gaW5mb0NvbXBvbmVudCAtIFRoZSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIGluZm9Db21wb25lbnQ6IEluZm9Cb3hDb21wb25lbnQpOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgICAgICBjb25zdCBldmVudE5hbWVUcmFuc2xhdGVkID0gQmluZ01hcEV2ZW50c0xvb2t1cFtldmVudE5hbWVdO1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JveGVzLmdldChpbmZvQ29tcG9uZW50KS50aGVuKChiOiBJbmZvV2luZG93KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBiLkFkZExpc3RlbmVyKGV2ZW50TmFtZVRyYW5zbGF0ZWQsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBhbiBpbmZvYm94LlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGluZm8gLSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gY29tcG9uZW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluZm9ib3guXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBoYXMgYmVlbiBkZWxldGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlSW5mb1dpbmRvdyhpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdyA9IHRoaXMuX2JveGVzLmdldChpbmZvKTtcclxuICAgICAgICBpZiAodyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHcudGhlbigoaTogSW5mb1dpbmRvdykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaS5DbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYm94ZXMuZGVsZXRlKGluZm8pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW5zIGFuIGluZm9ib3ggdGhhdCBpcyBjbG9zZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpbmZvYm94IGhhcyBiZWVuIG9wZW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIE9wZW4oaW5mbzogSW5mb0JveENvbXBvbmVudCwgbG9jPzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoaW5mby5DbG9zZUluZm9Cb3hlc09uT3BlbiB8fCBpbmZvLk1vZGFsKSB7XHJcbiAgICAgICAgICAgIC8vIGNsb3NlIGFsbCBvcGVuIGluZm8gYm94ZXMuXHJcbiAgICAgICAgICAgIHRoaXMuX2JveGVzLmZvckVhY2goKHY6IFByb21pc2U8SW5mb1dpbmRvdz4sIGk6IEluZm9Cb3hDb21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmZvLklkICE9PSBpLklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdi50aGVuKHcgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAody5Jc09wZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcuQ2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuQ2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKCh3KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnM6IElJbmZvV2luZG93T3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoaW5mby5IdG1sQ29udGVudCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHRtbENvbnRlbnQgPSBpbmZvLkh0bWxDb250ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50aXRsZSA9IGluZm8uVGl0bGU7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRlc2NyaXB0aW9uID0gaW5mby5EZXNjcmlwdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3LlNldE9wdGlvbnMob3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5mby5MYXRpdHVkZSAmJiBpbmZvLkxvbmdpdHVkZSkge1xyXG4gICAgICAgICAgICAgICAgdy5TZXRQb3NpdGlvbih7IGxhdGl0dWRlOiBpbmZvLkxhdGl0dWRlLCBsb25naXR1ZGU6IGluZm8uTG9uZ2l0dWRlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvYykge1xyXG4gICAgICAgICAgICAgICAgLy8vXHJcbiAgICAgICAgICAgICAgICAvLy8gdGhpcyBzaXR1YXRpb24gaXMgc3BlY2lmaWNhbGx5IHVzZWQgZm9yIGNsdXN0ZXIgbGF5ZXJzIHRoYXQgdXNlIHNwaWRlcmluZy5cclxuICAgICAgICAgICAgICAgIC8vL1xyXG4gICAgICAgICAgICAgICAgdy5TZXRQb3NpdGlvbihsb2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluZm8uSG9zdE1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgdy5TZXRQb3NpdGlvbih7IGxhdGl0dWRlOiBpbmZvLkhvc3RNYXJrZXIuTGF0aXR1ZGUsIGxvbmdpdHVkZTogaW5mby5Ib3N0TWFya2VyLkxvbmdpdHVkZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3Lk9wZW4oKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm9ib3ggb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSUluZm9XaW5kb3dPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucyB0byBzZXQuIE9wdGlvbnMgcHJvdmlkZWQgYXJlXHJcbiAgICAgKiBtZXJnZWQgd2l0aCB0aGUgZXhpc3Rpbmcgb3B0aW9ucyBvZiB0aGUgdW5kZXJseWluZyBpbmZvYm94LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGluZm9ib3ggb3B0aW9ucyBoYXZlIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMoaW5mbzogSW5mb0JveENvbXBvbmVudCwgb3B0aW9uczogSUluZm9XaW5kb3dPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKChpOiBJbmZvV2luZG93KSA9PiBpLlNldE9wdGlvbnMob3B0aW9ucykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaW5mb2JveCBiYXNlZCBvbiB0aGUgcHJvcGVydGllcyBzZXQgb24gdGhlIEluZm9Cb3ggY29tcG9uZW50LlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGluZm8gLSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gY29tcG9uZW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluZm9ib3guXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBwb3NpdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0UG9zaXRpb24oaW5mbzogSW5mb0JveENvbXBvbmVudCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3hlcy5nZXQoaW5mbykudGhlbigoaTogSW5mb1dpbmRvdykgPT4gaS5TZXRQb3NpdGlvbih7XHJcbiAgICAgICAgICAgIGxhdGl0dWRlOiBpbmZvLkxhdGl0dWRlLFxyXG4gICAgICAgICAgICBsb25naXR1ZGU6IGluZm8uTG9uZ2l0dWRlXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLW1hcmtlcic7XHJcbmltcG9ydCB7IE1hcmtlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9tYXJrZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2xheWVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDbHVzdGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NsdXN0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4vYmluZy1tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4vYmluZy1jb252ZXJzaW9ucyc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIE1hcmtlclNlcnZpY2UgYWJzdHJhY3QgY2xhc3MgZm9yIEJpbmcgTWFwcyBWOC5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQmluZ01hcmtlclNlcnZpY2UgaW1wbGVtZW50cyBNYXJrZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfbWFya2VyczogTWFwPE1hcE1hcmtlckRpcmVjdGl2ZSwgUHJvbWlzZTxNYXJrZXI+PiA9IG5ldyBNYXA8TWFwTWFya2VyRGlyZWN0aXZlLCBQcm9taXNlPE1hcmtlcj4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nTWFya2VyU2VydmljZS5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbnN0YW5jZS4gVGhlIGNvbmNyZXRlIHtAbGluayBCaW5nTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyU2VydmljZSAtIHtAbGluayBMYXllclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBCaW5nTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBpcyBleHBlY3RlZC5cclxuICAgICAqIEBwYXJhbSBfY2x1c3RlclNlcnZpY2UgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBCaW5nQ2x1c3RlclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHN1cHBvcnQgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcclxuICAgICAgICAgICAgICAgIHByaXZhdGUgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBfY2x1c3RlclNlcnZpY2U6IENsdXN0ZXJTZXJ2aWNlLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1lbWJlcnMgYW5kIE1hcmtlclNlcnZpY2UgaW1wbGVtZW50YXRpb25cclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG1hcmtlci4gRGVwZW5kaW5nIG9uIHRoZSBtYXJrZXIgY29udGV4dCwgdGhlIG1hcmtlciB3aWxsIGVpdGhlciBieSBhZGRlZCB0byB0aGUgbWFwIG9yIGEgY29ycmVjc3BvbmRpbmcgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcmtlciAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSB0byBiZSBhZGRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZE1hcmtlcihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IElNYXJrZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogeyBsYXRpdHVkZTogbWFya2VyLkxhdGl0dWRlLCBsb25naXR1ZGU6IG1hcmtlci5Mb25naXR1ZGUgfSxcclxuICAgICAgICAgICAgdGl0bGU6IG1hcmtlci5UaXRsZSxcclxuICAgICAgICAgICAgbGFiZWw6IG1hcmtlci5MYWJlbCxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBtYXJrZXIuRHJhZ2dhYmxlLFxyXG4gICAgICAgICAgICBpY29uOiBtYXJrZXIuSWNvblVybCxcclxuICAgICAgICAgICAgaWNvbkluZm86IG1hcmtlci5JY29uSW5mbyxcclxuICAgICAgICAgICAgaXNGaXJzdDogbWFya2VyLklzRmlyc3RJblNldCxcclxuICAgICAgICAgICAgaXNMYXN0OiBtYXJrZXIuSXNMYXN0SW5TZXRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChtYXJrZXIuV2lkdGgpIHsgby53aWR0aCA9IG1hcmtlci5XaWR0aDsgfVxyXG4gICAgICAgIGlmIChtYXJrZXIuSGVpZ2h0KSB7IG8uaGVpZ2h0ID0gbWFya2VyLkhlaWdodDsgfVxyXG4gICAgICAgIGlmIChtYXJrZXIuQW5jaG9yKSB7IG8uYW5jaG9yID0gbWFya2VyLkFuY2hvcjsgfVxyXG4gICAgICAgIGlmIChtYXJrZXIuTWV0YWRhdGEpIHsgby5tZXRhZGF0YSA9IG1hcmtlci5NZXRhZGF0YTsgfVxyXG5cclxuICAgICAgICAvLyBjcmVhdGUgbWFya2VyIHZpYSBwcm9taXNlLlxyXG4gICAgICAgIGxldCBtYXJrZXJQcm9taXNlOiBQcm9taXNlPE1hcmtlcj4gPSBudWxsO1xyXG4gICAgICAgIGlmIChtYXJrZXIuSW5DbHVzdGVyTGF5ZXIpIHtcclxuICAgICAgICAgICAgbWFya2VyUHJvbWlzZSA9IHRoaXMuX2NsdXN0ZXJTZXJ2aWNlLkNyZWF0ZU1hcmtlcihtYXJrZXIuTGF5ZXJJZCwgbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hcmtlci5JbkN1c3RvbUxheWVyKSB7XHJcbiAgICAgICAgICAgIG1hcmtlclByb21pc2UgPSB0aGlzLl9sYXllclNlcnZpY2UuQ3JlYXRlTWFya2VyKG1hcmtlci5MYXllcklkLCBvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1hcmtlclByb21pc2UgPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZU1hcmtlcihvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX21hcmtlcnMuc2V0KG1hcmtlciwgbWFya2VyUHJvbWlzZSk7XHJcbiAgICAgICAgaWYgKG1hcmtlci5JY29uSW5mbykge1xyXG4gICAgICAgICAgICBtYXJrZXJQcm9taXNlLnRoZW4oKG06IE1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGljb25JbmZvIHRvIHByb3ZpZGUgaG9vayB0byBkbyBwb3N0IGljb24gY3JlYXRpb24gYWN0aXZpdGllcyBhbmRcclxuICAgICAgICAgICAgICAgIC8vIGFsc28gcmUtYW5jaG9yIHRoZSBtYXJrZXJcclxuICAgICAgICAgICAgICAgIG1hcmtlci5EeW5hbWljTWFya2VyQ3JlYXRlZC5lbWl0KG8uaWNvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDogSVBvaW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IChvLmljb25JbmZvLnNpemUgJiYgby5pY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoby5pY29uSW5mby5zaXplLndpZHRoICogby5pY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpby54KSA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogKG8uaWNvbkluZm8uc2l6ZSAmJiBvLmljb25JbmZvLm1hcmtlck9mZnNldFJhdGlvKSA/IChvLmljb25JbmZvLnNpemUuaGVpZ2h0ICogby5pY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpby55KSA6IDAsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbS5TZXRBbmNob3IocCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxyXG4gICAgICogQHBhcmFtIG1hcmtlciAtIFRoZSB7QGxpbmsgTWFwTWFya2VyfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxyXG4gICAgICogQHJldHVybnMgLSBPYnNlcnZhYmxlIGVtaXRpbmcgYW4gaW5zdGFuY2Ugb2YgVCBlYWNoIHRpbWUgdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZUV2ZW50T2JzZXJ2YWJsZTxUPihldmVudE5hbWU6IHN0cmluZywgbWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgICAgICBjb25zdCBiOiBTdWJqZWN0PFQ+ID0gbmV3IFN1YmplY3Q8VD4oKTtcclxuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnbW91c2Vtb3ZlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5hc09ic2VydmFibGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3JpZ2h0Y2xpY2snKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiLmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gbW91c2Vtb3ZlIGFuZCByaWdodGNsaWNrIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGJpbmcgcG9seWdvbnMuXHJcbiAgICAgICAgLy8vXHJcblxyXG5cclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbS5BZGRMaXN0ZW5lcihldmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGEgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSB7QGxpbmsgTWFwTWFya2VyfSB0byBiZSBkZWxldGVkLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBtYXJrZXIgaGFzIGJlZW4gZGVsZXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZU1hcmtlcihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpO1xyXG4gICAgICAgIGxldCBwOiBQcm9taXNlPHZvaWQ+ID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgaWYgKG0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwID0gbS50aGVuKChtYTogTWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLkluQ2x1c3RlckxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2x1c3RlclNlcnZpY2UuR2V0TmF0aXZlTGF5ZXIobWFya2VyLkxheWVySWQpLnRoZW4obCA9PiB7IGwuUmVtb3ZlRW50aXR5KG1hKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLkluQ3VzdG9tTGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXllclNlcnZpY2UuR2V0TmF0aXZlTGF5ZXIobWFya2VyLkxheWVySWQpLnRoZW4obCA9PiB7IGwuUmVtb3ZlRW50aXR5KG1hKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hLkRlbGV0ZU1hcmtlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMuZGVsZXRlKG1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIgb24gdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnQgfCBhbnkpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgaWYgKCFlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWUucHJpbWl0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShlLnByaW1pdGl2ZSBpbnN0YW5jZW9mIE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluID0gZS5wcmltaXRpdmU7XHJcbiAgICAgICAgY29uc3QgbG9jOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IHAuZ2V0TG9jYXRpb24oKTtcclxuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogbG9jLmxhdGl0dWRlLCBsb25naXR1ZGU6IGxvYy5sb25naXR1ZGUgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIG1hcmtlciBtb2RlbCBmb3IgdGhlIG1hcmtlciBhbGxvd2luZyBhY2Nlc3MgdG8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uYXRpbGl5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSBUaGUge0BsaW5rIE1hcE1hcmtlcn0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgbWFya2VyIG1vZGVsLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBNYXJrZXJ9IGltcGxlbWVudGF0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIHBsYXRmb3JtLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TmF0aXZlTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTxNYXJrZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIG1hcmtlciBwaXhlbCBsb2NhdGlvbiBmb3IgdGhlIG1hcmtlciBvbiB0aGUgY2xpY2sgbG9jYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElMYXRMb25nfSBjb250YWluaW5nIHRoZSBwaXhlbHMgb2YgdGhlIG1hcmtlciBvbiB0aGUgbWFwIGNhbnZhcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFBpeGVsc0Zyb21DbGljayhlOiBNb3VzZUV2ZW50IHwgYW55KTogSVBvaW50IHtcclxuICAgICAgICBjb25zdCBsb2M6IElMYXRMb25nID0gdGhpcy5HZXRDb29yZGluYXRlc0Zyb21DbGljayhlKTtcclxuICAgICAgICBpZiAobG9jID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGw6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKGxvYyk7XHJcbiAgICAgICAgY29uc3QgcDogTWljcm9zb2Z0Lk1hcHMuUG9pbnQgPSA8TWljcm9zb2Z0Lk1hcHMuUG9pbnQ+KDxCaW5nTWFwU2VydmljZT5cclxuICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZSkuTWFwSW5zdGFuY2UudHJ5TG9jYXRpb25Ub1BpeGVsKGwsIE1pY3Jvc29mdC5NYXBzLlBpeGVsUmVmZXJlbmNlLmNvbnRyb2wpO1xyXG4gICAgICAgIGlmIChwID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICByZXR1cm4geyB4OiBwLngsIHk6IHAueSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBnZW8gbG9jYXRpb24gdG8gYSBwaXhlbCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgbWFwIGNhbnZhcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gRWl0aGVyIGEge0BsaW5rIE1hcE1hcmtlcn0gb3IgYSB7QGxpbmsgSUxhdExvbmd9IGZvciB0aGUgYmFzaXMgb2YgdHJhbnNsYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyBhIHtAbGluayBJUG9pbnR9XHJcbiAgICAgKiB3aXRoIHRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgTWFwTWFya2VyIG9yIElMYXRMb25nIHJlbGF0aXZlIHRvIHRoZSBtYXAgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgTG9jYXRpb25Ub1BvaW50KHRhcmdldDogTWFwTWFya2VyRGlyZWN0aXZlIHwgSUxhdExvbmcpOiBQcm9taXNlPElQb2ludD4ge1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwTWFya2VyRGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldCh0YXJnZXQpLnRoZW4oKG06IE1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbDogSUxhdExvbmcgPSBtLkxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDogUHJvbWlzZTxJUG9pbnQ+ID0gdGhpcy5fbWFwU2VydmljZS5Mb2NhdGlvblRvUG9pbnQobCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBTZXJ2aWNlLkxvY2F0aW9uVG9Qb2ludCh0YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYW5jaG9yIHBvc2l0aW9uIGZvciB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBhbmNob3IuXHJcbiAgICAgKiBBbmNob3IgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgYW5jaG9yIHBvc2l0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVBbmNob3IobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IHtcclxuICAgICAgICAgICAgbS5TZXRBbmNob3IobWFya2VyLkFuY2hvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJ9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgZHJhZ2FiaWxpdHkuXHJcbiAgICAgKiBEcmFnYWJpbGl0eSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBtYXJrZXIgaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFVwZGF0ZURyYWdnYWJsZShtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4gbS5TZXREcmFnZ2FibGUobWFya2VyLkRyYWdnYWJsZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgSWNvbiBvbiB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBpY29uLlxyXG4gICAgICogSWNvbiBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpY29uIGluZm9ybWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVJY29uKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChtOiBNYXJrZXIsIGljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mbykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaWNvbiAmJiBpY29uICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgbS5TZXRJY29uKGljb24pO1xyXG4gICAgICAgICAgICAgICAgbWFya2VyLkR5bmFtaWNNYXJrZXJDcmVhdGVkLmVtaXQoaWNvbkluZm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hcmtlci5JY29uSW5mbykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IE1hcmtlci5DcmVhdGVNYXJrZXIobWFya2VyLkljb25JbmZvKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocykgPT09ICdzdHJpbmcnKSB7IHJldHVybihwYXlsb2FkKG0sIHMsIG1hcmtlci5JY29uSW5mbykpOyB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy50aGVuKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ocGF5bG9hZChtLCB4Lmljb24sIHguaWNvbkluZm8pKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybihtLlNldEljb24obWFya2VyLkljb25VcmwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgbGFiZWwgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgbGFiZWwuXHJcbiAgICAgKiBMYWJlbCBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBsYWJlbCBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVXBkYXRlTGFiZWwobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IHsgbS5TZXRMYWJlbChtYXJrZXIuTGFiZWwpOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBDb29yZGluYXRlIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIHBvc2l0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVNYXJrZXJQb3NpdGlvbihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oXHJcbiAgICAgICAgICAgIChtOiBNYXJrZXIpID0+IG0uU2V0UG9zaXRpb24oe1xyXG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IG1hcmtlci5MYXRpdHVkZSxcclxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogbWFya2VyLkxvbmdpdHVkZVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB0aXRsZSBvbiB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSB0aXRsZS5cclxuICAgICAqIFRpdGxlIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIHRpdGxlIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVUaXRsZShtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4gbS5TZXRUaXRsZShtYXJrZXIuVGl0bGUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZpc2liaWxpdHkgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgdmlzaWJsaXR5LlxyXG4gICAgICogVmlzaWJpbGl0eSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVWaXNpYmxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiBtLlNldFZpc2libGUobWFya2VyLlZpc2libGUpKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2ZXIsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcEFQSUxvYWRlciB9IGZyb20gJy4uL21hcGFwaWxvYWRlcic7XHJcbmltcG9ydCB7IEJpbmdNYXBBUElMb2FkZXIsIEJpbmdNYXBBUElMb2FkZXJDb25maWcgfSBmcm9tICcuL2JpbmctbWFwLmFwaS1sb2FkZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4vYmluZy1jb252ZXJzaW9ucyc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XHJcbmltcG9ydCB7IEluZm9XaW5kb3cgfSBmcm9tICcuLi8uLi9tb2RlbHMvaW5mby13aW5kb3cnO1xyXG5pbXBvcnQgeyBCaW5nTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1tYXJrZXInO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IEJpbmdMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctbGF5ZXInO1xyXG5pbXBvcnQgeyBCaW5nQ2x1c3RlckxheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1jbHVzdGVyLWxheWVyJztcclxuaW1wb3J0IHsgQmluZ0luZm9XaW5kb3cgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWluZm8td2luZG93JztcclxuaW1wb3J0IHsgQmluZ1BvbHlnb24gfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLXBvbHlnb24nO1xyXG5pbXBvcnQgeyBCaW5nUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLXBvbHlsaW5lJztcclxuaW1wb3J0IHsgTWl4aW5NYXBMYWJlbFdpdGhPdmVybGF5VmlldyB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctbGFiZWwnO1xyXG5pbXBvcnQgeyBNaXhpbkNhbnZhc092ZXJsYXkgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWNhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgQmluZ0NhbnZhc092ZXJsYXkgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWNhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uLy4uL21vZGVscy9jYW52YXMtb3ZlcmxheSc7XHJcbmltcG9ydCB7IElMYXllck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXllci1vcHRpb25zJztcclxuaW1wb3J0IHsgSUNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSU1hcE9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXAtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvaW50JztcclxuaW1wb3J0IHsgSVNpemUgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lzaXplJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJQm94IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pYm94JztcclxuXHJcbmltcG9ydCB7IEJpbmdNYXBFdmVudHNMb29rdXAgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWV2ZW50cy1sb29rdXAnO1xyXG5cclxuLyoqXHJcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBNYXBTZXJ2aWNlIGFic3RyYWN0IGltcGxlbWVudGluZyBhIEJpbiBNYXAgVjggcHJvdmlkZXJcclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQmluZ01hcFNlcnZpY2UgaW1wbGVtZW50cyBNYXBTZXJ2aWNlIHtcclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIERlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgcHJpdmF0ZSBfbWFwOiBQcm9taXNlPE1pY3Jvc29mdC5NYXBzLk1hcD47XHJcbiAgICBwcml2YXRlIF9tYXBJbnN0YW5jZTogTWljcm9zb2Z0Lk1hcHMuTWFwO1xyXG4gICAgcHJpdmF0ZSBfbWFwUmVzb2x2ZXI6ICh2YWx1ZT86IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4gdm9pZDtcclxuICAgIHByaXZhdGUgX2NvbmZpZzogQmluZ01hcEFQSUxvYWRlckNvbmZpZztcclxuICAgIHByaXZhdGUgX21vZHVsZXM6IE1hcDxzdHJpbmcsIE9iamVjdD4gPSBuZXcgTWFwPHN0cmluZywgT2JqZWN0PigpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IERlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW4gYXJyYXkgb2YgbG9hZGVkIEJvbmcgbW9kdWxlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IExvYWRlZE1vZHVsZXMoKTogTWFwPHN0cmluZywgT2JqZWN0PiB7IHJldHVybiB0aGlzLl9tb2R1bGVzOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBCaW5nIE1hcCBjb250cm9sIGluc3RhbmNlIHVuZGVybHlpbmcgdGhlIGltcGxlbWVudGF0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBNYXBJbnN0YW5jZSgpOiBNaWNyb3NvZnQuTWFwcy5NYXAgeyByZXR1cm4gdGhpcy5fbWFwSW5zdGFuY2U7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBQcm9taXNlIGZvciBhIEJpbmcgTWFwIGNvbnRyb2wgaW5zdGFuY2UgdW5kZXJseWluZyB0aGUgaW1wbGVtZW50YXRpb24uIFVzZSB0aGlzIGluc3RlYWQgb2Yge0BsaW5rIE1hcEluc3RhbmNlfSBpZiB5b3VcclxuICAgICAqIGFyZSBub3Qgc3VyZSBpZiBhbmQgd2hlbiB0aGUgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBNYXBQcm9taXNlKCk6IFByb21pc2U8TWljcm9zb2Z0Lk1hcHMuTWFwPiB7IHJldHVybiB0aGlzLl9tYXA7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1hcHMgcGh5c2ljYWwgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTWFwU2l6ZSgpOiBJU2l6ZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuTWFwSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgY29uc3QgczogSVNpemUgPSB7IHdpZHRoOiB0aGlzLk1hcEluc3RhbmNlLmdldFdpZHRoKCksIGhlaWdodDogdGhpcy5NYXBJbnN0YW5jZS5nZXRIZWlnaHQoKSB9O1xyXG4gICAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nTWFwU2VydmljZS5cclxuICAgICAqIEBwYXJhbSBfbG9hZGVyIE1hcEFQSUxvYWRlciBpbnN0YW5jZSBpbXBsZW1lbnRlZCBmb3IgQmluZyBNYXBzLiBUaGlzIGluc3RhbmNlIHdpbGwgZ2VuZXJhbGx5IGJlIGluamVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIE5nWm9uZSBvYmplY3QgdG8gZW5hYmxlIHpvbmUgYXdhcmUgcHJvbWlzZXMuIFRoaXMgd2lsbCBnZW5lcmFsbHkgYmUgaW5qZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2xvYWRlcjogTWFwQVBJTG9hZGVyLCBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcclxuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgUHJvbWlzZTxNaWNyb3NvZnQuTWFwcy5NYXA+KChyZXNvbHZlOiAoKSA9PiB2b2lkKSA9PiB7IHRoaXMuX21hcFJlc29sdmVyID0gcmVzb2x2ZTsgfSk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gKDxCaW5nTWFwQVBJTG9hZGVyPnRoaXMuX2xvYWRlcikuQ29uZmlnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzIGFuZCBNYXBTZXJ2aWNlIGludGVyZmFjZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2FudmFzIG92ZXJsYXkgbGF5ZXIgdG8gcGVyZm9ybSBjdXN0b20gZHJhd2luZyBvdmVyIHRoZSBtYXAgd2l0aCBvdXRcclxuICAgICAqIHNvbWUgb2YgdGhlIG92ZXJoZWFkIGFzc29jaWF0ZWQgd2l0aCBnb2luZyB0aHJvdWdoIHRoZSBNYXAgb2JqZWN0cy5cclxuICAgICAqIEBwYXJhbSBkcmF3Q2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjYW52YXMgaXMgcmVhZHkgdG8gYmVcclxuICAgICAqIHJlbmRlcmVkIGZvciB0aGUgY3VycmVudCBtYXAgdmlldy5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBDYW52YXNPdmVybGF5fSBvYmplY3QuXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZUNhbnZhc092ZXJsYXkoZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZCk6IFByb21pc2U8Q2FudmFzT3ZlcmxheT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheTogQmluZ0NhbnZhc092ZXJsYXkgPSBuZXcgQmluZ0NhbnZhc092ZXJsYXkoZHJhd0NhbGxiYWNrKTtcclxuICAgICAgICAgICAgbWFwLmxheWVycy5pbnNlcnQob3ZlcmxheSk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdmVybGF5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEJpbmcgbWFwIGNsdXN0ZXIgbGF5ZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLiBTZWUge0BsaW5rIElDbHVzdGVyT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTGF5ZXJ9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJMYXllciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVDbHVzdGVyTGF5ZXIob3B0aW9uczogSUNsdXN0ZXJPcHRpb25zKTogUHJvbWlzZTxMYXllcj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSBuZXcgUHJvbWlzZTxMYXllcj4ocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkxvYWRNb2R1bGUoJ01pY3Jvc29mdC5NYXBzLkNsdXN0ZXJpbmcnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSUNsdXN0ZXJMYXllck9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlQ2x1c3Rlck9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF5ZXI6IE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJMYXllciA9IG5ldyBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyTGF5ZXIobmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+KCksIG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBibDogQmluZ0NsdXN0ZXJMYXllcjtcclxuICAgICAgICAgICAgICAgICAgICBtYXAubGF5ZXJzLmluc2VydChsYXllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYmwgPSBuZXcgQmluZ0NsdXN0ZXJMYXllcihsYXllciwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmwuU2V0T3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluZm9ybWF0aW9uIHdpbmRvdyBmb3IgYSBtYXAgcG9zaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIC0gSW5mb3dpbmRvdyBvcHRpb25zLiBTZWUge0BsaW5rIElJbmZvV2luZG93T3B0aW9uc31cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBJbmZvV2luZG93fSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBNaWNyb3NvZnQuTWFwcy5JbmZvYm94IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZUluZm9XaW5kb3cob3B0aW9ucz86IElJbmZvV2luZG93T3B0aW9ucyk6IFByb21pc2U8SW5mb1dpbmRvdz4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcclxuICAgICAgICAgICAgbGV0IGxvYzogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb247XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxvYyA9IG1hcC5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvYyA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbihvcHRpb25zLnBvc2l0aW9uLmxhdGl0dWRlLCBvcHRpb25zLnBvc2l0aW9uLmxvbmdpdHVkZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaW5mb0JveDogTWljcm9zb2Z0Lk1hcHMuSW5mb2JveCA9IG5ldyBNaWNyb3NvZnQuTWFwcy5JbmZvYm94KGxvYywgQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUluZm9Cb3hPcHRpb25zKG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgaW5mb0JveC5zZXRNYXAobWFwKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5nSW5mb1dpbmRvdyhpbmZvQm94KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXAgbGF5ZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLiBTZWUge0BsaW5rIElMYXllck9wdGlvbnN9XHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTGF5ZXJ9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIE1pY3Jvc29mdC5NYXBzLkxheWVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZUxheWVyKG9wdGlvbnM6IElMYXllck9wdGlvbnMpOiBQcm9taXNlPExheWVyPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsYXllcjogTWljcm9zb2Z0Lk1hcHMuTGF5ZXIgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuTGF5ZXIob3B0aW9ucy5pZC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgbWFwLmxheWVycy5pbnNlcnQobGF5ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmdMYXllcihsYXllciwgdGhpcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVsIC0gSFRNTCBlbGVtZW50IHRvIGhvc3QgdGhlIG1hcC5cclxuICAgICAqIEBwYXJhbSBtYXBPcHRpb25zIC0gTWFwIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIG1hcCBoYXMgYmVlbiBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlTWFwKGVsOiBIVE1MRWxlbWVudCwgbWFwT3B0aW9uczogSU1hcE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVyLkxvYWQoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gYXBwbHkgbWl4aW5zXHJcbiAgICAgICAgICAgIE1peGluTWFwTGFiZWxXaXRoT3ZlcmxheVZpZXcoKTtcclxuICAgICAgICAgICAgTWl4aW5DYW52YXNPdmVybGF5KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBtYXAgc3RhcnR1cC4uLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwSW5zdGFuY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5EaXNwb3NlTWFwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSU1hcExvYWRPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvYWRPcHRpb25zKG1hcE9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoIW8uY3JlZGVudGlhbHMpIHtcclxuICAgICAgICAgICAgICAgIG8uY3JlZGVudGlhbHMgPSB0aGlzLl9jb25maWcuYXBpS2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IG5ldyBNaWNyb3NvZnQuTWFwcy5NYXAoZWwsIG8pO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG1hcDtcclxuICAgICAgICAgICAgdGhpcy5fbWFwUmVzb2x2ZXIobWFwKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBCaW5nIG1hcCBtYXJrZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBbb3B0aW9ucz08SU1hcmtlck9wdGlvbnM+e31dIC0gT3B0aW9ucyBmb3IgdGhlIG1hcmtlci4gU2VlIHtAbGluayBJTWFya2VyT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTWFya2VyfSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBNaWNyb3NvZnQuTWFwcy5QdXNoUGluIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZU1hcmtlcihvcHRpb25zOiBJTWFya2VyT3B0aW9ucyA9IDxJTWFya2VyT3B0aW9ucz57fSk6IFByb21pc2U8TWFya2VyPiB7XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChpY29uOiBzdHJpbmcsIG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKTogQmluZ01hcmtlciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYzogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24ob3B0aW9ucy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVNYXJrZXJPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoaWNvbiAmJiBpY29uICE9PSAnJykgeyBvLmljb24gPSBpY29uOyB9XHJcbiAgICAgICAgICAgIGNvbnN0IHB1c2hwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbihsb2MsIG8pO1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXI6IEJpbmdNYXJrZXIgPSBuZXcgQmluZ01hcmtlcihwdXNocGluLCBtYXAsIG51bGwpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IG1hcmtlci5NZXRhZGF0YS5zZXQoaywgdikpOyB9XHJcbiAgICAgICAgICAgIG1hcC5lbnRpdGllcy5wdXNoKHB1c2hwaW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gbWFya2VyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pY29uSW5mbyAmJiBvcHRpb25zLmljb25JbmZvLm1hcmtlclR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXJrZXIuQ3JlYXRlTWFya2VyKG9wdGlvbnMuaWNvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocykgPT09ICdzdHJpbmcnKSB7IHJldHVybiAocGF5bG9hZChzLCBtYXApKTsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMudGhlbih4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwYXlsb2FkKHguaWNvbiwgbWFwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBheWxvYWQobnVsbCwgbWFwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBwb2x5Z29uIHdpdGhpbiB0aGUgQmluZyBNYXBzIFY4IG1hcCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBwb2x5Z29uLiBTZWUge0BsaW5rIElQb2x5Z29uT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgUG9seWdvbn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgbmF0aXZlIHBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24ob3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsb2NzOiBBcnJheTxBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4+ID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBhdGhzKG9wdGlvbnMucGF0aHMpO1xyXG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWdvbk9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWdvbk9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvbHk6IE1pY3Jvc29mdC5NYXBzLlBvbHlnb24gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9seWdvbihsb2NzLCBvKTtcclxuICAgICAgICAgICAgbWFwLmVudGl0aWVzLnB1c2gocG9seSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IEJpbmdQb2x5Z29uKHBvbHksIHRoaXMsIG51bGwpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHAuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykgeyBwLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93TGFiZWwgIT0gbnVsbCkgeyBwLlNob3dMYWJlbCA9IG9wdGlvbnMuc2hvd0xhYmVsOyB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dUb29sdGlwICE9IG51bGwpIHsgcC5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGFiZWxNYXhab29tICE9IG51bGwpIHsgcC5MYWJlbE1heFpvb20gPSBvcHRpb25zLmxhYmVsTWF4Wm9vbTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sYWJlbE1pblpvb20gIT0gbnVsbCkgeyBwLkxhYmVsTWluWm9vbSA9IG9wdGlvbnMubGFiZWxNaW5ab29tOyB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVkaXRhYmxlKSB7IHAuU2V0RWRpdGFibGUob3B0aW9ucy5lZGl0YWJsZSk7IH1cclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcG9seWxpbmUgd2l0aGluIHRoZSBCaW5nIE1hcHMgVjggbWFwIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHBvbHlsaW5lLiBTZWUge0BsaW5rIElQb2x5bGluZU9wdGlvbnN9LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIFBvbHlsaW5lfSBvYmplY3QgKG9yIGFuIGFycmF5IHRoZXJlb2YgZm9yIGNvbXBsZXggcGF0aHMpLFxyXG4gICAgICogd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBwb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVQb2x5bGluZShvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogUHJvbWlzZTxQb2x5bGluZSB8IEFycmF5PFBvbHlsaW5lPj4ge1xyXG4gICAgICAgIGxldCBwb2x5bGluZTogTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlsaW5lT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgbG9jczogQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQYXRocyhvcHRpb25zLnBhdGgpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXRoICYmIG9wdGlvbnMucGF0aC5sZW5ndGggPiAwICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMucGF0aFswXSkpIHtcclxuICAgICAgICAgICAgICAgIHBvbHlsaW5lID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lKGxvY3NbMF0sIG8pO1xyXG4gICAgICAgICAgICAgICAgbWFwLmVudGl0aWVzLnB1c2gocG9seWxpbmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsID0gbmV3IEJpbmdQb2x5bGluZShwb2x5bGluZSwgbWFwLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gcGwuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgJiYgb3B0aW9ucy50aXRsZSAhPT0gJycpIHsgcGwuVGl0bGUgPSBvcHRpb25zLnRpdGxlOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93VG9vbHRpcCAhPSBudWxsKSB7IHBsLlNob3dUb29sdGlwID0gb3B0aW9ucy5zaG93VG9vbHRpcDsgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXM6IEFycmF5PFBvbHlsaW5lPiA9IG5ldyBBcnJheTxQb2x5bGluZT4oKTtcclxuICAgICAgICAgICAgICAgIGxvY3MuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5bGluZSA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZShwLCBvKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXAuZW50aXRpZXMucHVzaChwb2x5bGluZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsID0gbmV3IEJpbmdQb2x5bGluZShwb2x5bGluZSwgbWFwLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBsLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykgeyBwbC5UaXRsZSA9IG9wdGlvbnMudGl0bGU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93VG9vbHRpcCAhPSBudWxsKSB7IHBsLlNob3dUb29sdGlwID0gb3B0aW9ucy5zaG93VG9vbHRpcDsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gocGwpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgYSBsYXllciBmcm9tIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gTGF5ZXIgdG8gZGVsZXRlLiBTZWUge0BsaW5rIExheWVyfS4gVGhpcyBtZXRob2QgZXhwZWN0cyB0aGUgQmluZyBzcGVjaWZpYyBMYXllciBtb2RlbCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBmdWxsZmlsbGVkIHdoZW4gdGhlIGxheWVyIGhhcyBiZWVuIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVMYXllcihsYXllcjogTGF5ZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIG1hcC5sYXllcnMucmVtb3ZlKGxheWVyLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3Bhb3NlIHRoZSBtYXAgYW5kIGFzc29jaWF0ZWQgcmVzb3VyZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEaXNwb3NlTWFwKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXAgPT0gbnVsbCAmJiB0aGlzLl9tYXBJbnN0YW5jZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX21hcEluc3RhbmNlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcCA9IG5ldyBQcm9taXNlPE1pY3Jvc29mdC5NYXBzLk1hcD4oKHJlc29sdmU6ICgpID0+IHZvaWQpID0+IHsgdGhpcy5fbWFwUmVzb2x2ZXIgPSByZXNvbHZlOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIG1hcCBjZW50ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgZ29lIGxvY2F0aW9uIG9mIHRoZSBjZW50ZXIuIFNlZSB7QGxpbmsgSUxhdExvbmd9LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q2VudGVyKCk6IFByb21pc2U8SUxhdExvbmc+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIDxJTGF0TG9uZz57XHJcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogY2VudGVyLmxhdGl0dWRlLFxyXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBjZW50ZXIubG9uZ2l0dWRlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIG1hcCBib3VuZGluZyBib3hcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgZ29lIGxvY2F0aW9uIG9mIHRoZSBib3VuZGluZyBib3guIFNlZSB7QGxpbmsgSUJveH0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRCb3VuZHMoKTogUHJvbWlzZTxJQm94PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBib3ggPSBtYXAuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiA8SUJveD57XHJcbiAgICAgICAgICAgICAgICBtYXhMYXRpdHVkZTogYm94LmdldE5vcnRoKCksXHJcbiAgICAgICAgICAgICAgICBtYXhMb25naXR1ZGU6IGJveC5jcm9zc2VzSW50ZXJuYXRpb25hbERhdGVMaW5lKCkgPyBib3guZ2V0V2VzdCgpIDogYm94LmdldEVhc3QoKSxcclxuICAgICAgICAgICAgICAgIG1pbkxhdGl0dWRlOiBib3guZ2V0U291dGgoKSxcclxuICAgICAgICAgICAgICAgIG1pbkxvbmdpdHVkZTogYm94LmNyb3NzZXNJbnRlcm5hdGlvbmFsRGF0ZUxpbmUoKSA/IGJveC5nZXRFYXN0KCkgOiBib3guZ2V0V2VzdCgpLFxyXG4gICAgICAgICAgICAgICAgY2VudGVyOiB7IGxhdGl0dWRlOiBib3guY2VudGVyLmxhdGl0dWRlLCBsb25naXR1ZGU6IGJveC5jZW50ZXIubG9uZ2l0dWRlIH0sXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgc2hhcmVkIG9yIHByaXZhdGUgaW5zdGFuY2Ugb2YgdGhlIG1hcCBkcmF3aW5nIHRvb2xzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBbdXNlU2hhcmVkSW5zdGFuY2U9dHJ1ZV0gLSBTZXQgdG8gZmFsc2UgdG8gY3JlYXRlIGEgcHJpdmF0ZSBpbnN0YW5jZS5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSB0aGF0IHdoZW4gcmVzb2x2ZWQgY29udGFpbnN0IGFuIGluc3RhbmNlIG9mIHRoZSBkcmF3aW5nIHRvb2xzLlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXREcmF3aW5nVG9vbHMgKHVzZVNoYXJlZEluc3RhbmNlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8TWljcm9zb2Z0Lk1hcHMuRHJhd2luZ1Rvb2xzPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPE1pY3Jvc29mdC5NYXBzLkRyYXdpbmdUb29scz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLkxvYWRNb2R1bGVJbnN0YW5jZSgnTWljcm9zb2Z0Lk1hcHMuRHJhd2luZ1Rvb2xzJywgdXNlU2hhcmVkSW5zdGFuY2UpLnRoZW4oKG86IE1pY3Jvc29mdC5NYXBzLkRyYXdpbmdUb29scykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShvKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgem9vbSBsZXZlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFpvb20oKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiBtYXAuZ2V0Wm9vbSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgbW9kdWxlIGludG8gdGhlIE1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbW9kdWxlTmFtZSAtIFRoZSBtb2R1bGUgdG8gbG9hZC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIGNhbGwgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBMb2FkTW9kdWxlKG1vZHVsZU5hbWU6IHN0cmluZywgY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcclxuICAgICAgICBpZiAodGhpcy5fbW9kdWxlcy5oYXMobW9kdWxlTmFtZSkpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLmxvYWRNb2R1bGUobW9kdWxlTmFtZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kdWxlcy5zZXQobW9kdWxlTmFtZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIG1vZHVsZSBpbnRvIHRoZSBNYXAgYW5kIGRlbGl2ZXJzIGFuZCBpbnN0YW5jZSBvZiB0aGUgbW9kdWxlIHBheWxvYWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1vZHVsZU5hbWUgLSBUaGUgbW9kdWxlIHRvIGxvYWQuXHJcbiAgICAgKiBAcGFyYW0gdXNlU2hhcmVkSW5zdGFuY2UtIFVzZSBhIHNoYXJlZCBpbnN0YW5jZSBpZiB0cnVlLCBjcmVhdGUgYSBuZXcgaW5zdGFuY2UgaWYgZmFsc2UuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIExvYWRNb2R1bGVJbnN0YW5jZShtb2R1bGVOYW1lOiBzdHJpbmcsIHVzZVNoYXJlZEluc3RhbmNlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8T2JqZWN0PiB7XHJcbiAgICAgICAgY29uc3Qgczogc3RyaW5nID0gbW9kdWxlTmFtZS5zdWJzdHIobW9kdWxlTmFtZS5sYXN0SW5kZXhPZignLicpICsgMSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX21vZHVsZXMuaGFzKG1vZHVsZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIGxldCBvOiBhbnkgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIXVzZVNoYXJlZEluc3RhbmNlKSAge1xyXG4gICAgICAgICAgICAgICAgbyA9IG5ldyAoPGFueT5NaWNyb3NvZnQuTWFwcylbc10odGhpcy5fbWFwSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX21vZHVsZXMuZ2V0KG1vZHVsZU5hbWUpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG8gPSB0aGlzLl9tb2R1bGVzLmdldChtb2R1bGVOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG8gPSBuZXcgKDxhbnk+TWljcm9zb2Z0Lk1hcHMpW3NdKHRoaXMuX21hcEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vZHVsZXMuc2V0KG1vZHVsZU5hbWUsIG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8T2JqZWN0PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMubG9hZE1vZHVsZShtb2R1bGVOYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbyA9IG5ldyAoPGFueT5NaWNyb3NvZnQuTWFwcylbc10odGhpcy5fbWFwSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VTaGFyZWRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb2R1bGVzLnNldChtb2R1bGVOYW1lLCBvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vZHVsZXMuc2V0KG1vZHVsZU5hbWUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCdDb3VsZCBub3QgbG9hZCBtb2R1bGUgb3IgY3JlYXRlIGluc3RhbmNlLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aWRlcyBhIGNvbnZlcnNpb24gb2YgZ2VvIGNvb3JkaW5hdGVzIHRvIHBpeGVscyBvbiB0aGUgbWFwIGNvbnRyb2wuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvYyAtIFRoZSBnZW8gY29vcmRpbmF0ZXMgdG8gdHJhbnNsYXRlLlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGFuIHtAbGluayBJUG9pbnR9IGludGVyZmFjZSByZXByZXNlbnRpbmcgdGhlIHBpeGVscy4gVGhpcyBwcm9taXNlIHJlc29sdmVzIHRvIG51bGxcclxuICAgICAqIGlmIHRoZSBnb2UgY29vcmRpbmF0ZXMgYXJlIG5vdCBpbiB0aGUgdmlldyBwb3J0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgTG9jYXRpb25Ub1BvaW50KGxvYzogSUxhdExvbmcpOiBQcm9taXNlPElQb2ludD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobTogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGw6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKGxvYyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHA6IE1pY3Jvc29mdC5NYXBzLlBvaW50ID0gPE1pY3Jvc29mdC5NYXBzLlBvaW50Pm0udHJ5TG9jYXRpb25Ub1BpeGVsKGwsIE1pY3Jvc29mdC5NYXBzLlBpeGVsUmVmZXJlbmNlLmNvbnRyb2wpO1xyXG4gICAgICAgICAgICBpZiAocCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBwLngsIHk6IHAueSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSBjb252ZXJzaW9uIG9mIGdlbyBjb29yZGluYXRlcyB0byBwaXhlbHMgb24gdGhlIG1hcCBjb250cm9sLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2MgLSBUaGUgZ2VvIGNvb3JkaW5hdGVzIHRvIHRyYW5zbGF0ZS5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhbiB7QGxpbmsgSVBvaW50fSBpbnRlcmZhY2UgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBMb2NhdGlvbnNUb1BvaW50cyhsb2NzOiBBcnJheTxJTGF0TG9uZz4pOiBQcm9taXNlPEFycmF5PElQb2ludD4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG06IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsID0gbG9jcy5tYXAobG9jID0+IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihsb2MpKTtcclxuICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUG9pbnQ+ID0gPEFycmF5PE1pY3Jvc29mdC5NYXBzLlBvaW50Pj5tLnRyeUxvY2F0aW9uVG9QaXhlbChsLFxyXG4gICAgICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuUGl4ZWxSZWZlcmVuY2UuY29udHJvbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwID8gcCA6IG5ldyBBcnJheTxJUG9pbnQ+KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDZW50ZXJzIHRoZSBtYXAgb24gYSBnZW8gbG9jYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhdExuZyAtIEdlb0Nvb3JkaW5hdGVzIGFyb3VuZCB3aGljaCB0byBjZW50ZXIgdGhlIG1hcC4gU2VlIHtAbGluayBJTGF0TG9uZ31cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgY2VudGVyIG9wZXJhdGlvbnMgaGFzIGJlZW4gY29tcGxldGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0Q2VudGVyKGxhdExuZzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiBtYXAuc2V0Vmlldyh7XHJcbiAgICAgICAgICAgIGNlbnRlcjogQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKGxhdExuZylcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBnZW5lcmljIG1hcCBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRNYXBPcHRpb25zKG9wdGlvbnM6IElNYXBPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwLnRoZW4oKG06IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JTWFwT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBtLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2aWV3IG9wdGlvbnMgb2YgdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0Vmlld09wdGlvbnMob3B0aW9uczogSU1hcE9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9tYXAudGhlbigobTogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklWaWV3T3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVWaWV3T3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgbS5zZXRWaWV3KG8pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB6b29tIC0gWm9vbSBsZXZlbCB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgb25jZSB0aGUgem9vbSBvcGVyYXRpb24gaXMgY29tcGxldGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRab29tKHpvb206IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IG1hcC5zZXRWaWV3KHtcclxuICAgICAgICAgICAgem9vbTogem9vbVxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXZlbnQgc3Vic2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoZS5nLiAnY2xpY2snKVxyXG4gICAgICogQHJldHVybnMgLSBBbiBvYnNlcnZhYmxlIG9mIHRweWUgRSB0aGF0IGZpcmVzIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFN1YnNjcmliZVRvTWFwRXZlbnQ8RT4oZXZlbnROYW1lOiBzdHJpbmcpOiBPYnNlcnZhYmxlPEU+IHtcclxuICAgICAgICBjb25zdCBldmVudE5hbWVUcmFuc2xhdGVkID0gQmluZ01hcEV2ZW50c0xvb2t1cFtldmVudE5hbWVdO1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPEU+KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcC50aGVuKChtOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcclxuICAgICAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKG0sIGV2ZW50TmFtZVRyYW5zbGF0ZWQsIChlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIHRoZSBnaXZlbiBldmVudCBuYW1lIG9uIHRoZSBtYXAgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIEV2ZW50IHRvIHRyaWdnZXIuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgb25jZSB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVHJpZ2dlck1hcEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtKSA9PiBNaWNyb3NvZnQuTWFwcy5FdmVudHMuaW52b2tlKG0sIGV2ZW50TmFtZSwgbnVsbCkpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcclxuaW1wb3J0IHsgQmluZ01hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctbWFya2VyJztcclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbGF5ZXInO1xyXG5pbXBvcnQgeyBNYXJrZXJUeXBlSWQgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyLXR5cGUtaWQnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLWxheWVyJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLW1hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0NvbnZlcnNpb25zIH0gZnJvbSAnLi9iaW5nLWNvbnZlcnNpb25zJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGFic3RyYWN0IHBhcnRpYWxseSBpbXBsZW1lbnRzIHRoZSBjb250cmFjdCBmb3IgdGhlIHtAbGluayBMYXllclNlcnZpY2V9XHJcbiAqIGFuZCB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9IGZvciB0aGUgQmluZyBNYXBzIFY4IGFyY2h0aWVjdHVyZS4gSXQgc2VydmVzXHJcbiAqIGFzIHRoZSBiYXNlIGNsYXNzIGZvciBiYXNpYyBsYXllciAoe0BsaW5rIEJpbmdMYXllclNlcnZpY2V9KSBhbmQgY2x1c3RlciBsYXllciAoe0BsaW5rIEJpbmdDbHVzdGVyTGF5ZXJ9KS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCaW5nTGF5ZXJCYXNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIHByb3RlY3RlZCBfbGF5ZXJzOiBNYXA8bnVtYmVyLCBQcm9taXNlPExheWVyPj4gPSBuZXcgTWFwPG51bWJlciwgUHJvbWlzZTxMYXllcj4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nTGF5ZXJCYXNlLlxyXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gQ29uY3JldGUge0BsaW5rIE1hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciBCaW5nIE1hcHMgVjguIEFuIGluc3RhbmNlIG9mIHtAbGluayBCaW5nTWFwU2VydmljZX0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllckJhc2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBwcm90ZWN0ZWQgX3pvbmU6IE5nWm9uZSkgeyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGxheWVyIHRvIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAgICogR2VuZXJhbGx5LCBNYXBMYXllckRpcmVjdGl2ZSB3aWxsIGJlIGluamVjdGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAgKiBMYXllclNlcnZpY2UgYW5kIHRoZW4gc2VsZiByZWdpc3RlciBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyQmFzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXJrZXIgaW4gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBJZCBvZiB0aGUgbGF5ZXIgaW4gd2hpY2ggdG8gY3JlYXRlIHRoZSBtYXJrZXIuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTWFya2VyT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcmtlciBwcm9wZXJ0aWVzLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBNYXJrZXJ9IG1vZGVsIGZvciB0aGUgY3JlYXRlZCBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllckJhc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZU1hcmtlcihsYXllcjogbnVtYmVyLCBvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IFByb21pc2U8TWFya2VyPiB7XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChpY29uOiBzdHJpbmcsIGw6IExheWVyKTogQmluZ01hcmtlciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYzogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24ob3B0aW9ucy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVNYXJrZXJPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoaWNvbiAmJiBpY29uICE9PSAnJykgeyBvLmljb24gPSBpY29uOyB9XHJcbiAgICAgICAgICAgIGNvbnN0IHB1c2hwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbihsb2MsIG8pO1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXI6IEJpbmdNYXJrZXIgPSBuZXcgQmluZ01hcmtlcihwdXNocGluLCBudWxsLCBsLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgbWFya2VyLklzRmlyc3QgPSBvcHRpb25zLmlzRmlyc3Q7XHJcbiAgICAgICAgICAgIG1hcmtlci5Jc0xhc3QgPSBvcHRpb25zLmlzTGFzdDtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2LCBrKSA9PiBtYXJrZXIuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICBsLkFkZEVudGl0eShtYXJrZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWFya2VyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLkdldExheWVyQnlJZChsYXllcik7XHJcbiAgICAgICAgaWYgKHAgPT0gbnVsbCkgeyB0aHJvdyAobmV3IEVycm9yKGBMYXllciB3aXRoIGlkICR7bGF5ZXJ9IG5vdCBmb3VuZCBpbiBMYXllciBNYXBgKSk7IH1cclxuICAgICAgICByZXR1cm4gcC50aGVuKChsOiBMYXllcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pY29uSW5mbyAmJiBvcHRpb25zLmljb25JbmZvLm1hcmtlclR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXJrZXIuQ3JlYXRlTWFya2VyKG9wdGlvbnMuaWNvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzKSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuKHBheWxvYWQocywgbCkpOyB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy50aGVuKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ocGF5bG9hZCh4Lmljb24sIGwpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAocGF5bG9hZChudWxsLCBsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBtYXJrZXJzLiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFycmF5cyBvZiBtYXJrZXJzIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE1hcmtlciBvcHRpb25zIGRlZmluaW5nIHRoZSBtYXJrZXJzLlxyXG4gICAgICogQHBhcmFtIG1hcmtlckljb24gLSBPcHRpb25hbCBpbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSBjdXN0b20gbWFya2Vycy4gVGhpcyB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIG1hcmtlcnMuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBNYXJrZXIgbW9kZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJCYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVNYXJrZXJzKG9wdGlvbnM6IEFycmF5PElNYXJrZXJPcHRpb25zPiwgbWFya2VySWNvbj86IElNYXJrZXJJY29uSW5mbyk6IFByb21pc2U8QXJyYXk8TWFya2VyPj4ge1xyXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSAoaWNvbjogc3RyaW5nLCBvcDogQXJyYXk8SU1hcmtlck9wdGlvbnM+KTogQXJyYXk8QmluZ01hcmtlcj4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXJzOiBBcnJheTxCaW5nTWFya2VyPiA9IG9wLm1hcChtbyA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgczogc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZU1hcmtlck9wdGlvbnMobW8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGljb24gJiYgaWNvbiAhPT0gJycgKSB7IHMgPSBpY29uOyB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvLmljb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gby5pY29uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG8uaWNvbikgeyBkZWxldGUgby5pY29uOyB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2M6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKG1vLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB1c2hwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbihsb2MsIG8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1nID0gTWFya2VyLkdldEltYWdlRm9yTWFya2VyKHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGltZyAhPSBudWxsKSB7ICg8YW55PnB1c2hwaW4pLmltYWdlID0gaW1nOyB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWFya2VyOiBCaW5nTWFya2VyID0gbmV3IEJpbmdNYXJrZXIocHVzaHBpbiwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuSXNGaXJzdCA9IG1vLmlzRmlyc3Q7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuSXNMYXN0ID0gbW8uaXNMYXN0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vLm1ldGFkYXRhKSB7IG1vLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IG1hcmtlci5NZXRhZGF0YS5zZXQoaywgdikpOyB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+ID0gbmV3IFByb21pc2U8QXJyYXk8TWFya2VyPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWFya2VySWNvbiAmJiBtYXJrZXJJY29uLm1hcmtlclR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXJrZXIuQ3JlYXRlTWFya2VyKG1hcmtlckljb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzKSA9PT0gJ3N0cmluZycpIHsgcmVzb2x2ZShwYXlsb2FkKHMsIG9wdGlvbnMpKTsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMudGhlbih4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKHguaWNvbiwgb3B0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKG51bGwsIG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgbGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbGF5ZXIgaGFzIGJlZW4gcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyQmFzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuX2xheWVycy5nZXQobGF5ZXIuSWQpO1xyXG4gICAgICAgIGlmIChsID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbC50aGVuKChsMTogTGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGwxLkRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLmRlbGV0ZShsYXllci5JZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgTGF5ZXIgbW9kZWwgcmVwcmVzZW50ZWQgYnkgdGhpcyBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IG9yIExheWVyIElkIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIgbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gcmVzb2x2ZWQgY29udGFpbnMgdGhlIExheWVyIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJCYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXROYXRpdmVMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmV8bnVtYmVyKTogUHJvbWlzZTxMYXllcj4ge1xyXG4gICAgICAgIGxldCBwOiBQcm9taXNlPExheWVyPiA9IG51bGw7XHJcbiAgICAgICAgaWYgKHR5cGVvZihsYXllcikgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHAgPSB0aGlzLl9sYXllcnMuZ2V0KGxheWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHAgPSB0aGlzLl9sYXllcnMuZ2V0KCg8TWFwTGF5ZXJEaXJlY3RpdmU+bGF5ZXIpLklkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvdGVjdGVkIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbGF5ZXIgYmFzZWQgb24gaXRzIGlkLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBpZCAtIExheWVyIElkLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBMYXllcn0gbW9kZWwgZm9yIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyQmFzZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgR2V0TGF5ZXJCeUlkKGlkOiBudW1iZXIpOiBQcm9taXNlPExheWVyPiB7XHJcbiAgICAgICAgbGV0IHA6IFByb21pc2U8TGF5ZXI+O1xyXG4gICAgICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKChsOiBQcm9taXNlPExheWVyPiwgazogbnVtYmVyKSA9PiB7IGlmIChrID09PSBpZCkgeyBwID0gbDsgfSB9KTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBCaW5nTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1tYXJrZXInO1xyXG5pbXBvcnQgeyBCaW5nUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctcG9seWdvbic7XHJcbmltcG9ydCB7IEJpbmdQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcExheWVyRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9tYXAtbGF5ZXInO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuL2JpbmctbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nTGF5ZXJCYXNlIH0gZnJvbSAnLi9iaW5nLWxheWVyLWJhc2UnO1xyXG5pbXBvcnQgeyBCaW5nQ29udmVyc2lvbnMgfSBmcm9tICcuL2JpbmctY29udmVyc2lvbnMnO1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBMYXllclNlcnZpY2V9IGNvbnRyYWN0IGZvciBhICBCaW5nIE1hcHMgVjggc3BlY2lmaWMgaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEJpbmdMYXllclNlcnZpY2UgZXh0ZW5kcyBCaW5nTGF5ZXJCYXNlIGltcGxlbWVudHMgTGF5ZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdMYXllclNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSBJbnN0YW5jZSBvZiB0aGUgQmluZyBNYXBzIFNlcnZpY2UuIFdpbGwgZ2VuZXJhbGx5IGJlIGluamVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHByb3ZpZGUgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfbWFwU2VydmljZTogTWFwU2VydmljZSwgX3pvbmU6IE5nWm9uZSkge1xyXG4gICAgICAgIHN1cGVyKF9tYXBTZXJ2aWNlLCBfem9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbGF5ZXIgdG8gdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIE1hcExheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICAgKiBHZW5lcmFsbHksIE1hcExheWVyRGlyZWN0aXZlIHdpbGwgYmUgaW5qZWN0ZWQgd2l0aCBhbiBpbnN0YW5jZSBvZiB0aGVcclxuICAgICAqIExheWVyU2VydmljZSBhbmQgdGhlbiBzZWxmIHJlZ2lzdGVyIG9uIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBsYXllclByb21pc2UgPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUxheWVyKHsgaWQ6IGxheWVyLklkIH0pO1xyXG4gICAgICAgIHRoaXMuX2xheWVycy5zZXQobGF5ZXIuSWQsIGxheWVyUHJvbWlzZSk7XHJcbiAgICAgICAgbGF5ZXJQcm9taXNlLnRoZW4obCA9PiBsLlNldFZpc2libGUobGF5ZXIuVmlzaWJsZSkpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBwb2x5Z29uIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5Z29uIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlnb24uXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlnb24gbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24obGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XHJcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLkdldExheWVyQnlJZChsYXllcik7XHJcbiAgICAgICAgaWYgKHAgPT0gbnVsbCkgeyB0aHJvdyAobmV3IEVycm9yKGBMYXllciB3aXRoIGlkICR7bGF5ZXJ9IG5vdCBmb3VuZCBpbiBMYXllciBNYXBgKSk7IH1cclxuICAgICAgICByZXR1cm4gcC50aGVuKChsOiBMYXllcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsb2NzOiBBcnJheTxBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4+ID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBhdGhzKG9wdGlvbnMucGF0aHMpO1xyXG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlnb25PcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5OiBNaWNyb3NvZnQuTWFwcy5Qb2x5Z29uID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlnb24obG9jcywgbyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvbHlnb246IFBvbHlnb24gPSBuZXcgQmluZ1BvbHlnb24ocG9seSwgPEJpbmdNYXBTZXJ2aWNlPnRoaXMuX21hcFNlcnZpY2UsIGwuTmF0aXZlUHJpbWl0dmUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2LCBrKSA9PiBwb2x5Z29uLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgJiYgb3B0aW9ucy50aXRsZSAhPT0gJycpIHtwb2x5Z29uLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93TGFiZWwgIT0gbnVsbCkgeyBwb2x5Z29uLlNob3dMYWJlbCA9IG9wdGlvbnMuc2hvd0xhYmVsOyB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dUb29sdGlwICE9IG51bGwpIHsgcG9seWdvbi5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGFiZWxNYXhab29tICE9IG51bGwpIHsgcG9seWdvbi5MYWJlbE1heFpvb20gPSBvcHRpb25zLmxhYmVsTWF4Wm9vbTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sYWJlbE1pblpvb20gIT0gbnVsbCkgeyBwb2x5Z29uLkxhYmVsTWluWm9vbSA9IG9wdGlvbnMubGFiZWxNaW5ab29tOyB9XHJcbiAgICAgICAgICAgIGwuQWRkRW50aXR5KHBvbHlnb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5Z29ucy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWdvbnMgdG8gYmUgdXNlZCBpbiBidWxrXHJcbiAgICAgKiBvcGVyYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5Z29uIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlnb25zLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgUG9seWdvbiBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb25zKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PiB7XHJcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLkdldExheWVyQnlJZChsYXllcik7XHJcbiAgICAgICAgaWYgKHAgPT0gbnVsbCkgeyB0aHJvdyAobmV3IEVycm9yKGBMYXllciB3aXRoIGlkICR7bGF5ZXJ9IG5vdCBmb3VuZCBpbiBMYXllciBNYXBgKSk7IH1cclxuICAgICAgICByZXR1cm4gcC50aGVuKChsOiBMYXllcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5Z29uczogUHJvbWlzZTxBcnJheTxQb2x5Z29uPj4gPSBuZXcgUHJvbWlzZTxBcnJheTxQb2x5Z29uPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9seXM6IEFycmF5PEJpbmdQb2x5Z29uPiA9IG9wdGlvbnMubWFwKG8gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY3M6IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMoby5wYXRocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3A6IE1pY3Jvc29mdC5NYXBzLklQb2x5bGluZU9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWdvbk9wdGlvbnMobyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seTogTWljcm9zb2Z0Lk1hcHMuUG9seWdvbiA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2x5Z29uKGxvY3MsIG9wKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5Z29uOiBCaW5nUG9seWdvbiA9IG5ldyBCaW5nUG9seWdvbihwb2x5LCA8QmluZ01hcFNlcnZpY2U+dGhpcy5fbWFwU2VydmljZSwgbC5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8udGl0bGUgJiYgby50aXRsZSAhPT0gJycpIHsgcG9seWdvbi5UaXRsZSA9IG8udGl0bGU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoby5tZXRhZGF0YSkgeyBvLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBvbHlnb24uTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHBvbHlzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29ucztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBwb2x5bGluZSB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgbGluZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgbGluZS5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgUG9seWxpbmUgKG9yIGFuIGFycmF5XHJcbiAgICAgKiBvZiBwb2x5Z29ucyBmb3IgY29tcGxleCBwYXRocykgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xyXG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5HZXRMYXllckJ5SWQobGF5ZXIpO1xyXG4gICAgICAgIGxldCBwb2x5bGluZTogTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmU7XHJcbiAgICAgICAgbGV0IGxpbmU6IFBvbHlsaW5lO1xyXG4gICAgICAgIGlmIChwID09IG51bGwpIHsgdGhyb3cgKG5ldyBFcnJvcihgTGF5ZXIgd2l0aCBpZCAke2xheWVyfSBub3QgZm91bmQgaW4gTGF5ZXIgTWFwYCkpOyB9XHJcbiAgICAgICAgcmV0dXJuIHAudGhlbigobDogTGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbG9jczogQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQYXRocyhvcHRpb25zLnBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlsaW5lT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGF0aCAmJiBvcHRpb25zLnBhdGgubGVuZ3RoID4gMCAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGhbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICBwb2x5bGluZSA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZShsb2NzWzBdLCBvKTtcclxuICAgICAgICAgICAgICAgIGxpbmUgPSBuZXcgQmluZ1BvbHlsaW5lKHBvbHlsaW5lLCB0aGlzLl9tYXBTZXJ2aWNlLk1hcEluc3RhbmNlLCBsLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgICAgIGwuQWRkRW50aXR5KGxpbmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gbGluZS5NZXRhZGF0YS5zZXQoaywgdikpOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykge2xpbmUuVGl0bGUgPSBvcHRpb25zLnRpdGxlOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93VG9vbHRpcCAhPSBudWxsKSB7IGxpbmUuU2hvd1Rvb2x0aXAgPSBvcHRpb25zLnNob3dUb29sdGlwOyB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzOiBBcnJheTxQb2x5bGluZT4gPSBuZXcgQXJyYXk8UG9seWxpbmU+KCk7XHJcbiAgICAgICAgICAgICAgICBsb2NzLmZvckVhY2goeCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWxpbmUgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmUoeCwgbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IG5ldyBCaW5nUG9seWxpbmUocG9seWxpbmUsIHRoaXMuX21hcFNlcnZpY2UuTWFwSW5zdGFuY2UsIGwuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGwuQWRkRW50aXR5KGxpbmUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IGxpbmUuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlICYmIG9wdGlvbnMudGl0bGUgIT09ICcnKSB7bGluZS5UaXRsZSA9IG9wdGlvbnMudGl0bGU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93VG9vbHRpcCAhPSBudWxsKSB7IGxpbmUuU2hvd1Rvb2x0aXAgPSBvcHRpb25zLnNob3dUb29sdGlwOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuYm91bmQgcG9seWxpbmVzLiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFycmF5cyBvZiBwb2x5bGluZXMgdG8gYmUgdXNlZCBpbiBidWxrXHJcbiAgICAgKiBvcGVyYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5bGluZXMuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlsaW5lIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlsaW5lcy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIFBvbHlsaW5lIG1vZGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWxpbmVzKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5bGluZU9wdGlvbnM+KTogUHJvbWlzZTxBcnJheTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+PiB7XHJcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLkdldExheWVyQnlJZChsYXllcik7XHJcbiAgICAgICAgaWYgKHAgPT0gbnVsbCkgeyB0aHJvdyAobmV3IEVycm9yKGBMYXllciB3aXRoIGlkICR7bGF5ZXJ9IG5vdCBmb3VuZCBpbiBMYXllciBNYXBgKSk7IH1cclxuICAgICAgICByZXR1cm4gcC50aGVuKChsOiBMYXllcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5bGluZXM6IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4gPSBuZXcgUHJvbWlzZTxBcnJheTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2x5czogQXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiA9IG9wdGlvbnMubWFwKG8gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY3M6IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMoby5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcDogTWljcm9zb2Z0Lk1hcHMuSVBvbHlsaW5lT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5bGluZU9wdGlvbnMobyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY3MgJiYgbG9jcy5sZW5ndGggPiAwICYmICFBcnJheS5pc0FycmF5KGxvY3NbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvbHk6IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lKGxvY3NbMF0sIG9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seWxpbmU6IEJpbmdQb2x5bGluZSA9IG5ldyBCaW5nUG9seWxpbmUocG9seSwgdGhpcy5fbWFwU2VydmljZS5NYXBJbnN0YW5jZSwgbC5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnRpdGxlICYmIG8udGl0bGUgIT09ICcnKSB7IHBvbHlsaW5lLlRpdGxlID0gby50aXRsZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5tZXRhZGF0YSkgeyBvLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBvbHlsaW5lLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXM6IEFycmF5PFBvbHlsaW5lPiA9IG5ldyBBcnJheTxQb2x5bGluZT4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jcy5mb3JFYWNoKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seSA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZSh4LCBvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5bGluZTogQmluZ1BvbHlsaW5lID0gbmV3IEJpbmdQb2x5bGluZShwb2x5LCB0aGlzLl9tYXBTZXJ2aWNlLk1hcEluc3RhbmNlLCBsLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLm1ldGFkYXRhKSB7IG8ubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gcG9seWxpbmUuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8udGl0bGUgJiYgby50aXRsZSAhPT0gJycpIHtwb2x5bGluZS5UaXRsZSA9IG8udGl0bGU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gocG9seWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShwb2x5cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9seWxpbmVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcclxuaW1wb3J0IHsgSUNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSU1hcmtlckljb25JbmZvIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IEJpbmdNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLW1hcmtlcic7XHJcbmltcG9ydCB7IEJpbmdDbHVzdGVyTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWNsdXN0ZXItbGF5ZXInO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XHJcbmltcG9ydCB7IENsdXN0ZXJDbGlja0FjdGlvbiB9IGZyb20gJy4uLy4uL21vZGVscy9jbHVzdGVyLWNsaWNrLWFjdGlvbic7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IENsdXN0ZXJMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvY2x1c3Rlci1sYXllcic7XHJcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0xheWVyQmFzZSB9IGZyb20gJy4vYmluZy1sYXllci1iYXNlJztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuL2JpbmctbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nQ29udmVyc2lvbnMgfSBmcm9tICcuL2JpbmctY29udmVyc2lvbnMnO1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBDbHVzdGVyU2VydmljZX0gY29udHJhY3QgZm9yIGEgIEJpbmcgTWFwcyBWOCBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbi5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQmluZ0NsdXN0ZXJTZXJ2aWNlIGV4dGVuZHMgQmluZ0xheWVyQmFzZSBpbXBsZW1lbnRzIENsdXN0ZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdDbHVzdGVyU2VydmljZS5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIENvbmNyZXRlIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgQmluZyBNYXBzIFY4LiBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgQmluZ01hcFNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHByb3ZpZGUgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBfem9uZTogTmdab25lKSB7XHJcbiAgICAgICAgc3VwZXIoX21hcFNlcnZpY2UsIF96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbGF5ZXIgdG8gdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIENsdXN0ZXJMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAgICogR2VuZXJhbGx5LCBNYXBMYXllciB3aWxsIGJlIGluamVjdGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAgKiBMYXllclNlcnZpY2UgYW5kIHRoZW4gc2VsZiByZWdpc3RlciBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMYXllcihsYXllcjogQ2x1c3RlckxheWVyRGlyZWN0aXZlKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uczogSUNsdXN0ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogbGF5ZXIuSWQsXHJcbiAgICAgICAgICAgIHZpc2libGU6IGxheWVyLlZpc2libGUsXHJcbiAgICAgICAgICAgIGNsdXN0ZXJpbmdFbmFibGVkOiBsYXllci5DbHVzdGVyaW5nRW5hYmxlZCxcclxuICAgICAgICAgICAgcGxhY2VtZW50TW9kZTogbGF5ZXIuQ2x1c3RlclBsYWNlbWVudE1vZGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChsYXllci5HcmlkU2l6ZSkgeyBvcHRpb25zLmdyaWRTaXplID0gbGF5ZXIuR3JpZFNpemU7IH1cclxuICAgICAgICBpZiAobGF5ZXIuTGF5ZXJPZmZzZXQpIHsgb3B0aW9ucy5sYXllck9mZnNldCA9IGxheWVyLkxheWVyT2Zmc2V0OyB9XHJcbiAgICAgICAgaWYgKGxheWVyLlpJbmRleCkgeyBvcHRpb25zLnpJbmRleCA9IGxheWVyLlpJbmRleDsgfVxyXG4gICAgICAgIGlmIChsYXllci5JY29uSW5mbykge1xyXG4gICAgICAgICAgICBvcHRpb25zLmNsdXN0ZXJlZFBpbkNhbGxiYWNrID0gKHBpbjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4pID0+IHsgdGhpcy5DcmVhdGVDbHVzdGVyUHVzaFBpbihwaW4sIGxheWVyKTsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxheWVyLkN1c3RvbU1hcmtlckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY2x1c3RlcmVkUGluQ2FsbGJhY2sgPSAocGluOiBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbikgPT4geyB0aGlzLkNyZWF0ZUN1c3RvbUNsdXN0ZXJQdXNoUGluKHBpbiwgbGF5ZXIpOyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGF5ZXIuU3BpZGVyQ2x1c3Rlck9wdGlvbnMpIHsgb3B0aW9ucy5zcGlkZXJDbHVzdGVyT3B0aW9ucyA9IGxheWVyLlNwaWRlckNsdXN0ZXJPcHRpb25zOyB9XHJcblxyXG4gICAgICAgIGNvbnN0IGxheWVyUHJvbWlzZTogUHJvbWlzZTxMYXllcj4gPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUNsdXN0ZXJMYXllcihvcHRpb25zKTtcclxuICAgICAgICAoPEJpbmdNYXBTZXJ2aWNlPnRoaXMuX21hcFNlcnZpY2UpLk1hcFByb21pc2UudGhlbihtID0+IHtcclxuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIobSwgJ3ZpZXdjaGFuZ2VlbmQnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLkNsdXN0ZXJpbmdFbmFibGVkICYmIG0uZ2V0Wm9vbSgpID09PSAxOSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyUHJvbWlzZS50aGVuKChsOiBCaW5nQ2x1c3RlckxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwuU2V0T3B0aW9ucyh7IGlkOiBsYXllci5JZCwgY2x1c3RlcmluZ0VuYWJsZWQ6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLkNsdXN0ZXJpbmdFbmFibGVkICYmIG0uZ2V0Wm9vbSgpIDwgMTkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXllclByb21pc2UudGhlbigobDogQmluZ0NsdXN0ZXJMYXllcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWwuR2V0T3B0aW9ucygpLmNsdXN0ZXJpbmdFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLlNldE9wdGlvbnMoeyBpZDogbGF5ZXIuSWQsIGNsdXN0ZXJpbmdFbmFibGVkOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2xheWVycy5zZXQobGF5ZXIuSWQsIGxheWVyUHJvbWlzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWdvbiB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGluc3RhbmNlIG9mIHRoZSBQb2x5Z29uIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24obGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XHJcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignUG9seWdvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY2x1c3RlcmluZyBsYXllcnMuIFlvdSBjYW4gb25seSB1c2UgbWFya2Vycy4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuYm91bmQgcG9seWdvbnMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIHBvbHlnb25zIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29ucy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIFBvbHlnb24gbW9kZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb25zKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PiB7XHJcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignUG9seWdvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY2x1c3RlcmluZyBsYXllcnMuIFlvdSBjYW4gb25seSB1c2UgbWFya2Vycy4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIGxpbmUuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlsaW5lIG9wdGlvbnMgZGVmaW5pbmcgdGhlIGxpbmUuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlsaW5lIChvciBhbiBhcnJheVxyXG4gICAgICogb2YgcG9seWdvbnMgZm9yIGNvbXBsZXggcGF0aHMpIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xyXG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1BvbHlsaW5lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBjbHVzdGVyaW5nIGxheWVycy4gWW91IGNhbiBvbmx5IHVzZSBtYXJrZXJzLicpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5bGluZXMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIHBvbHlsaW5lcyB0byBiZSB1c2VkIGluIGJ1bGtcclxuICAgICAqIG9wZXJhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIHBvbHlsaW5lcy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWxpbmVzLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgUG9seWxpbmUgbW9kZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lcyhsYXllcjogbnVtYmVyLCBvcHRpb25zOiBBcnJheTxJUG9seWxpbmVPcHRpb25zPik6IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4ge1xyXG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1BvbHlsaW5lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBjbHVzdGVyaW5nIGxheWVycy4gWW91IGNhbiBvbmx5IHVzZSBtYXJrZXJzLicpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgaW5pdGlhbCBzZXQgb2YgZW50aXRpZXNcclxuICAgICAqIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgY2x1c3Rlci4gVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBhcyBhZGRpbmcgYW4gZW50aXRpeSB3aWxsIHJlY2FsY3VsYXRlIGFsbCBjbHVzdGVycy5cclxuICAgICAqIEFzIHN1Y2gsIFN0b3BDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGFkZGluZyBtYW55IGVudGl0aWVzIGFuZCBTdGFydENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIGFkZGluZyBpc1xyXG4gICAgICogY29tcGxldGUgdG8gcmVjYWxjdWxhdGUgdGhlIGNsdXN0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIENsdXN0ZXJMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU3RhcnRDbHVzdGVyaW5nKGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBsID0gdGhpcy5fbGF5ZXJzLmdldChsYXllci5JZCk7XHJcbiAgICAgICAgaWYgKGwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsLnRoZW4oKGwxOiBCaW5nQ2x1c3RlckxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsMS5TdGFydENsdXN0ZXJpbmcoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgYXMgYWRkaW5nIGFuIGVudGl0aXkgd2lsbCByZWNhbGN1bGF0ZSBhbGwgY2x1c3RlcnMuXHJcbiAgICAgKiBBcyBzdWNoLCBTdG9wQ2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgbWFueSBlbnRpdGllcyBhbmQgU3RhcnRDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgb25jZSBhZGRpbmcgaXNcclxuICAgICAqIGNvbXBsZXRlIHRvIHJlY2FsY3VsYXRlIHRoZSBjbHVzdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgY29tcG9uZW50IG9iamVjdCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFN0b3BDbHVzdGVyaW5nKGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBsID0gdGhpcy5fbGF5ZXJzLmdldChsYXllci5JZCk7XHJcbiAgICAgICAgaWYgKGwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsLnRoZW4oKGwxOiBCaW5nQ2x1c3RlckxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsMS5TdG9wQ2x1c3RlcmluZygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgZGVmYXVsdCBjbHVzdGVyIHB1c2hwaW4gYXMgYSBjYWxsYmFjayBmcm9tIEJpbmdNYXBzIHdoZW4gY2x1c3RlcmluZyBvY2N1cnMuIFRoZSB7QGxpbmsgQ2x1c3RlckxheWVyRGlyZWN0aXZlfSBtb2RlbFxyXG4gICAgICogY2FuIHByb3ZpZGUgYW4gSWNvbkluZm8gcHJvcGVydHkgdGhhdCB3b3VsZCBnb3Zlcm4gdGhlIGFwcGFyZW5hY2Ugb2YgdGhlIHBpbi4gVGhpcyBtZXRob2Qgd2lsbCBhc3NpZ24gdGhlIHNhbWUgcGluIHRvIGFsbFxyXG4gICAgICogY2x1c3RlcnMgaW4gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjbHVzdGVyIC0gVGhlIGNsdXN0ZXIgZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgcHVzaHBpbi5cclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSB7QGxpbmsgQ2x1c3RlckxheWVyRGlyZWN0aXZlfSBjb21wb25lbnQgcmVwcmVzZW50aW5nIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQ3JlYXRlQ2x1c3RlclB1c2hQaW4oY2x1c3RlcjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4sIGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9sYXllcnMuZ2V0KGxheWVyLklkKS50aGVuKChsOiBCaW5nQ2x1c3RlckxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChsYXllci5JY29uSW5mbykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkOiAoaWNvOiBzdHJpbmcsIGluZm86IElNYXJrZXJJY29uSW5mbykgPT4gdm9pZCA9IChpY28sIGluZm8pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5pY29uID0gaWNvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvLmFuY2hvciA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2ludChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbmZvLnNpemUgJiYgaW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoaW5mby5zaXplLndpZHRoICogaW5mby5tYXJrZXJPZmZzZXRSYXRpby54KSA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5mby5zaXplICYmIGluZm8ubWFya2VyT2Zmc2V0UmF0aW8pID8gKGluZm8uc2l6ZS5oZWlnaHQgKiBpbmZvLm1hcmtlck9mZnNldFJhdGlvLnkpIDogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbjogc3RyaW5nfFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+ID0gTWFya2VyLkNyZWF0ZU1hcmtlcihsYXllci5JY29uSW5mbyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGljb24pID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQoaWNvbiwgbGF5ZXIuSWNvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbi50aGVuKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkKHguaWNvbiwgeC5pY29uSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxheWVyLkNsdXN0ZXJDbGlja0FjdGlvbiA9PT0gQ2x1c3RlckNsaWNrQWN0aW9uLlpvb21JbnRvQ2x1c3Rlcikge1xyXG4gICAgICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIoY2x1c3RlciwgJ2NsaWNrJywgKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncykgPT4gdGhpcy5ab29tSW50b0NsdXN0ZXIoZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXllci5DbHVzdGVyQ2xpY2tBY3Rpb24gPT09IENsdXN0ZXJDbGlja0FjdGlvbi5TcGlkZXIpIHtcclxuICAgICAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKGNsdXN0ZXIsICdkYmxjbGljaycsIChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpID0+IHRoaXMuWm9vbUludG9DbHVzdGVyKGUpKTtcclxuICAgICAgICAgICAgICAgIGwuSW5pdGlhbGl6ZVNwaWRlckNsdXN0ZXJTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIGEgaG9vayBmb3IgY29uc3VtZXJzIHRvIHByb3ZpZGUgYSBjdXN0b20gZnVuY3Rpb24gdG8gY3JlYXRlIGNsdXN0ZXIgYmlucyBmb3IgYSBjbHVzdGVyLiBUaGlzIGlzIHBhcnRpY3VhcmlseSB1c2VmdWxcclxuICAgICAqIGluIHNpdHVhdGlvbiB3aGVyZSB0aGUgcGluIHNob3VsZCBkaWZmZXIgdG8gcmVwcmVzZW50IGluZm9ybWF0aW9uIGFib3V0IHRoZSBwaW5zIGluIHRoZSBjbHVzdGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjbHVzdGVyIC0gVGhlIGNsdXN0ZXIgZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgcHVzaHBpbi5cclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSB7QGxpbmsgQ2x1c3RlckxheWVyRGlyZWN0aXZlfSBjb21wb25lbnRcclxuICAgICAqIHJlcHJlc2VudGluZyB0aGUgbGF5ZXIuIFNldCB0aGUge0BsaW5rIENsdXN0ZXJMYXllckRpcmVjdGl2ZS5DdXN0b21NYXJrZXJDYWxsYmFja31cclxuICAgICAqIHByb3BlcnR5IHRvIGRlZmluZSB0aGUgY2FsbGJhY2sgZ2VuZXJhdGluZyB0aGUgcGluLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBDcmVhdGVDdXN0b21DbHVzdGVyUHVzaFBpbihjbHVzdGVyOiBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbiwgbGF5ZXI6IENsdXN0ZXJMYXllckRpcmVjdGl2ZSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2xheWVycy5nZXQobGF5ZXIuSWQpLnRoZW4oKGw6IEJpbmdDbHVzdGVyTGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgLy8gYXNzZW1ibGUgbWFya2VycyBmb3IgY2FsbGJhY2tcclxuICAgICAgICAgICAgY29uc3QgbTogQXJyYXk8TWFya2VyPiA9IG5ldyBBcnJheTxNYXJrZXI+KCk7XHJcbiAgICAgICAgICAgIGNsdXN0ZXIuY29udGFpbmVkUHVzaHBpbnMuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcjogTWFya2VyID0gbC5HZXRNYXJrZXJGcm9tQmluZ01hcmtlcihwKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIpIHsgbS5wdXNoKG1hcmtlcik7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGljb25JbmZvOiBJTWFya2VySWNvbkluZm8gPSB7IG1hcmtlclR5cGU6IE1hcmtlclR5cGVJZC5Ob25lIH07XHJcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBvLmljb24gPSBsYXllci5DdXN0b21NYXJrZXJDYWxsYmFjayhtLCBpY29uSW5mbyk7XHJcbiAgICAgICAgICAgIGlmIChvLmljb24gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBvLmFuY2hvciA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2ludChcclxuICAgICAgICAgICAgICAgICAgICAoaWNvbkluZm8uc2l6ZSAmJiBpY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoaWNvbkluZm8uc2l6ZS53aWR0aCAqIGljb25JbmZvLm1hcmtlck9mZnNldFJhdGlvLngpIDogMCxcclxuICAgICAgICAgICAgICAgICAgICAoaWNvbkluZm8uc2l6ZSAmJiBpY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoaWNvbkluZm8uc2l6ZS5oZWlnaHQgKiBpY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpby55KSA6IDBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWNvbkluZm8udGV4dE9mZnNldCkgeyBvLnRleHRPZmZzZXQgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9pbnQoaWNvbkluZm8udGV4dE9mZnNldC54LCBpY29uSW5mby50ZXh0T2Zmc2V0LnkpOyB9XHJcbiAgICAgICAgICAgICAgICBjbHVzdGVyLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxheWVyLkNsdXN0ZXJDbGlja0FjdGlvbiA9PT0gQ2x1c3RlckNsaWNrQWN0aW9uLlpvb21JbnRvQ2x1c3Rlcikge1xyXG4gICAgICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIoY2x1c3RlciwgJ2NsaWNrJywgKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncykgPT4gdGhpcy5ab29tSW50b0NsdXN0ZXIoZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXllci5DbHVzdGVyQ2xpY2tBY3Rpb24gPT09IENsdXN0ZXJDbGlja0FjdGlvbi5TcGlkZXIpIHtcclxuICAgICAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKGNsdXN0ZXIsICdkYmxjbGljaycsIChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpID0+IHRoaXMuWm9vbUludG9DbHVzdGVyKGUpKTtcclxuICAgICAgICAgICAgICAgIGwuSW5pdGlhbGl6ZVNwaWRlckNsdXN0ZXJTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFpvb21zIGludG8gdGhlIGNsdXN0ZXIgb24gY2xpY2sgc28gdGhhdCB0aGUgbWVtYmVycyBvZiB0aGUgY2x1c3RlciBjb21mb3J0YWJsZSBmaXQgaW50byB0aGUgem9tbWVkIGFyZWEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGUgLSBNb3VzZSBFdmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgWm9vbUludG9DbHVzdGVyKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHBpbjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4gPSA8TWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4+ZS50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHBpbiAmJiBwaW4uY29udGFpbmVkUHVzaHBpbnMpIHtcclxuICAgICAgICAgICAgbGV0IGJvdW5kczogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb25SZWN0O1xyXG4gICAgICAgICAgICBjb25zdCBsb2NzOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4gPSBuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+KCk7XHJcbiAgICAgICAgICAgIHBpbi5jb250YWluZWRQdXNocGlucy5mb3JFYWNoKHAgPT4gbG9jcy5wdXNoKHAuZ2V0TG9jYXRpb24oKSkpO1xyXG4gICAgICAgICAgICBib3VuZHMgPSBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvblJlY3QuZnJvbUxvY2F0aW9ucyhsb2NzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFpvb20gaW50byB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBjbHVzdGVyLlxyXG4gICAgICAgICAgICAvLyBBZGQgYSBwYWRkaW5nIHRvIGNvbXBlbnNhdGUgZm9yIHRoZSBwaXhlbCBhcmVhIG9mIHRoZSBwdXNocGlucy5cclxuICAgICAgICAgICAgKDxCaW5nTWFwU2VydmljZT50aGlzLl9tYXBTZXJ2aWNlKS5NYXBQcm9taXNlLnRoZW4oKG06IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbS5zZXRWaWV3KHsgYm91bmRzOiBib3VuZHMsIHBhZGRpbmc6IDc1IH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBNYXBQb2x5Z29uRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9tYXAtcG9seWdvbic7XHJcbmltcG9ydCB7IFBvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi4vcG9seWdvbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIFBvbHlnb24gU2VydmljZSBhYnN0cmFjdCBjbGFzcyBmb3IgQmluZyBNYXBzIFY4LlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBCaW5nUG9seWdvblNlcnZpY2UgaW1wbGVtZW50cyBQb2x5Z29uU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX3BvbHlnb25zOiBNYXA8TWFwUG9seWdvbkRpcmVjdGl2ZSwgUHJvbWlzZTxQb2x5Z29uPj4gPSBuZXcgTWFwPE1hcFBvbHlnb25EaXJlY3RpdmUsIFByb21pc2U8UG9seWdvbj4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nUG9seWdvblNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuIFRoZSBjb25jcmV0ZSB7QGxpbmsgQmluZ01hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSB7QGxpbmsgQmluZ0xheWVyU2VydmljZX0gaW5zdGFuY2UuXHJcbiAgICAgKiBUaGUgY29uY3JldGUge0BsaW5rIEJpbmdMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHN1cHBvcnQgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25TZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfbGF5ZXJTZXJ2aWNlOiBMYXllclNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWdvbiB0byBhIG1hcC4gRGVwZW5kaW5nIG9uIHRoZSBwb2x5Z29uIGNvbnRleHQsIHRoZSBwb2x5Z29uIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxyXG4gICAgICogY29ycmVjc3BvbmRpbmcgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZFBvbHlnb24ocG9seWdvbjogTWFwUG9seWdvbkRpcmVjdGl2ZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IElQb2x5Z29uT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgaWQ6IHBvbHlnb24uSWQsXHJcbiAgICAgICAgICAgIGNsaWNrYWJsZTogcG9seWdvbi5DbGlja2FibGUsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogcG9seWdvbi5EcmFnZ2FibGUsXHJcbiAgICAgICAgICAgIGVkaXRhYmxlOiBwb2x5Z29uLkVkaXRhYmxlLFxyXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHBvbHlnb24uRmlsbENvbG9yLFxyXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogcG9seWdvbi5GaWxsT3BhY2l0eSxcclxuICAgICAgICAgICAgZ2VvZGVzaWM6IHBvbHlnb24uR2VvZGVzaWMsXHJcbiAgICAgICAgICAgIGxhYmVsTWF4Wm9vbTogcG9seWdvbi5MYWJlbE1heFpvb20sXHJcbiAgICAgICAgICAgIGxhYmVsTWluWm9vbTogcG9seWdvbi5MYWJlbE1pblpvb20sXHJcbiAgICAgICAgICAgIHBhdGhzOiBwb2x5Z29uLlBhdGhzLFxyXG4gICAgICAgICAgICBzaG93TGFiZWw6IHBvbHlnb24uU2hvd0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93VG9vbHRpcDogcG9seWdvbi5TaG93VG9vbHRpcCxcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHBvbHlnb24uU3Ryb2tlQ29sb3IsXHJcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHBvbHlnb24uU3Ryb2tlT3BhY2l0eSxcclxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiBwb2x5Z29uLlN0cm9rZVdlaWdodCxcclxuICAgICAgICAgICAgdGl0bGU6IHBvbHlnb24uVGl0bGUsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHBvbHlnb24uVmlzaWJsZSxcclxuICAgICAgICAgICAgekluZGV4OiBwb2x5Z29uLnpJbmRleCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBwb2x5Z29uUHJvbWlzZTogUHJvbWlzZTxQb2x5Z29uPjtcclxuICAgICAgICBpZiAocG9seWdvbi5JbkN1c3RvbUxheWVyKSB7XHJcbiAgICAgICAgICAgIHBvbHlnb25Qcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkNyZWF0ZVBvbHlnb24ocG9seWdvbi5MYXllcklkLCBvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBvbHlnb25Qcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVQb2x5Z29uKG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wb2x5Z29ucy5zZXQocG9seWdvbiwgcG9seWdvblByb21pc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYSBwb2x5Z29uLlxyXG4gICAgICAqXHJcbiAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxyXG4gICAgICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxyXG4gICAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgICpcclxuICAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25TZXJ2aWNlXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgICAgICAgY29uc3QgYjogU3ViamVjdDxUPiA9IG5ldyBTdWJqZWN0PFQ+KCk7XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ21vdXNlbW92ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIuYXNPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdyaWdodGNsaWNrJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5hc09ic2VydmFibGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgLy8vIG1vdXNlbW92ZSBhbmQgcmlnaHRjbGljayBhcmUgbm90IHN1cHBvcnRlZCBieSBiaW5nIHBvbHlnb25zLlxyXG4gICAgICAgIC8vL1xyXG5cclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29ucy5nZXQocG9seWdvbikudGhlbigocDogUG9seWdvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcC5BZGRMaXN0ZW5lcihldmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIERlbGV0ZXMgYSBwb2x5Z29uLlxyXG4gICAgICAqXHJcbiAgICAgICogQHBhcmFtIHBvbHlnb24gLSB7QGxpbmsgTWFwUG9seWdvbkRpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cclxuICAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlnb24gaGFzIGJlZW4gZGVsZXRlZC5cclxuICAgICAgKlxyXG4gICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblNlcnZpY2VcclxuICAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pO1xyXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbS50aGVuKChsOiBQb2x5Z29uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsLkRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWdvbnMuZGVsZXRlKHBvbHlnb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIHBvbHlnb24gb24gdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC4gRXhwZWN0ZWQgdG8gaW1wbGVtZW50IHtAbGluayBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3N9LlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZTogTW91c2VFdmVudCB8IGFueSk6IElMYXRMb25nIHtcclxuICAgICAgICBjb25zdCB4OiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MgPSA8TWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzPmU7XHJcbiAgICAgICAgcmV0dXJuIHsgbGF0aXR1ZGU6IHgubG9jYXRpb24ubGF0aXR1ZGUsIGxvbmdpdHVkZTogeC5sb2NhdGlvbi5sb25naXR1ZGUgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIHBvbHlnb24gbW9kZWwgZm9yIHRoZSBwb2x5Z29uIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IGZvciB3aGljaCB0byBvYnRhaW4gdGhlIHBvbHlnb24gbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIFBvbHlnb259IGltcGxlbWVudGF0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIHBsYXRmb3JtLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldE5hdGl2ZVBvbHlnb24ocG9seWdvbjogTWFwUG9seWdvbkRpcmVjdGl2ZSk6IFByb21pc2U8UG9seWdvbj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29ucy5nZXQocG9seWdvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBvbHlnb24gb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9seWdvbiAtIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSVBvbHlnb25PcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxyXG4gICAgICogb3B0aW9ucyBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWdvbiBvcHRpb25zIGhhdmUgYmVlbiBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlLCBvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pLnRoZW4oKGw6IFBvbHlnb24pID0+IHsgbC5TZXRPcHRpb25zKG9wdGlvbnMpOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIFBvbHlnb24gcGF0aFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2x5Z29uIC0ge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlnb24gaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25TZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pO1xyXG4gICAgICAgIGlmIChtID09IG51bGwgfHwgcG9seWdvbi5QYXRocyA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHBvbHlnb24uUGF0aHMpIHx8IHBvbHlnb24uUGF0aHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG0udGhlbigobDogUG9seWdvbikgPT4gIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9seWdvbi5QYXRoc1swXSkpIHtcclxuICAgICAgICAgICAgICAgIGwuU2V0UGF0aHMocG9seWdvbi5QYXRocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsLlNldFBhdGgoPEFycmF5PElMYXRMb25nPj5wb2x5Z29uLlBhdGhzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IE1hcFBvbHlsaW5lRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9tYXAtcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuLi9wb2x5bGluZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIFBvbHlsaW5lIFNlcnZpY2UgYWJzdHJhY3QgY2xhc3MgZm9yIEJpbmcgTWFwcyBWOC5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQmluZ1BvbHlsaW5lU2VydmljZSBpbXBsZW1lbnRzIFBvbHlsaW5lU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX3BvbHlsaW5lczogTWFwPE1hcFBvbHlsaW5lRGlyZWN0aXZlLCBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+ID1cclxuICAgIG5ldyBNYXA8TWFwUG9seWxpbmVEaXJlY3RpdmUsIFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4oKTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdQb2x5bGluZVNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuIFRoZSBjb25jcmV0ZSB7QGxpbmsgQmluZ01hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbnN0YW5jZS5cclxuICAgICAqIFRoZSBjb25jcmV0ZSB7QGxpbmsgQmluZ0xheWVyU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgaW5zdGFuY2UgdG8gc3VwcG9ydCB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfbGF5ZXJTZXJ2aWNlOiBMYXllclNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1lbWJlcnMgYW5kIE1hcmtlclNlcnZpY2UgaW1wbGVtZW50YXRpb25cclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHBvbHlsaW5lIHRvIGEgbWFwLiBEZXBlbmRpbmcgb24gdGhlIHBvbHlsaW5lIGNvbnRleHQsIHRoZSBwb2x5bGluZSB3aWxsIGVpdGhlciBieSBhZGRlZCB0byB0aGUgbWFwIG9yIGFcclxuICAgICAqIGNvcnJlc3BvbmRpbmcgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZFBvbHlsaW5lKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IElQb2x5bGluZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGlkOiBwb2x5bGluZS5JZCxcclxuICAgICAgICAgICAgY2xpY2thYmxlOiBwb2x5bGluZS5DbGlja2FibGUsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogcG9seWxpbmUuRHJhZ2dhYmxlLFxyXG4gICAgICAgICAgICBlZGl0YWJsZTogcG9seWxpbmUuRWRpdGFibGUsXHJcbiAgICAgICAgICAgIGdlb2Rlc2ljOiBwb2x5bGluZS5HZW9kZXNpYyxcclxuICAgICAgICAgICAgcGF0aDogcG9seWxpbmUuUGF0aCxcclxuICAgICAgICAgICAgc2hvd1Rvb2x0aXA6IHBvbHlsaW5lLlNob3dUb29sdGlwLFxyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogcG9seWxpbmUuU3Ryb2tlQ29sb3IsXHJcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHBvbHlsaW5lLlN0cm9rZU9wYWNpdHksXHJcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogcG9seWxpbmUuU3Ryb2tlV2VpZ2h0LFxyXG4gICAgICAgICAgICB0aXRsZTogcG9seWxpbmUuVGl0bGUsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHBvbHlsaW5lLlZpc2libGUsXHJcbiAgICAgICAgICAgIHpJbmRleDogcG9seWxpbmUuekluZGV4LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHBvbHlsaW5lUHJvbWlzZTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+O1xyXG4gICAgICAgIGlmIChwb2x5bGluZS5JbkN1c3RvbUxheWVyKSB7XHJcbiAgICAgICAgICAgIHBvbHlsaW5lUHJvbWlzZSA9IHRoaXMuX2xheWVyU2VydmljZS5DcmVhdGVQb2x5bGluZShwb2x5bGluZS5MYXllcklkLCBvKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb2x5bGluZVByb21pc2UgPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZVBvbHlsaW5lKG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wb2x5bGluZXMuc2V0KHBvbHlsaW5lLCBwb2x5bGluZVByb21pc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYSBsaW5lLlxyXG4gICAgICAqXHJcbiAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxyXG4gICAgICAqIEBwYXJhbSBwb2x5bGluZSAtIFRoZSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgZXZlbnQuXHJcbiAgICAgICogQHJldHVybnMgLSBPYnNlcnZhYmxlIGVtaXRpbmcgYW4gaW5zdGFuY2Ugb2YgVCBlYWNoIHRpbWUgdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAgKlxyXG4gICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgICAgICBjb25zdCBiOiBTdWJqZWN0PFQ+ID0gbmV3IFN1YmplY3Q8VD4oKTtcclxuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnbW91c2Vtb3ZlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5hc09ic2VydmFibGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3JpZ2h0Y2xpY2snKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiLmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gbW91c2Vtb3ZlIGFuZCByaWdodGNsaWNrIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGJpbmcgcG9seWdvbnMuXHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSkudGhlbihwID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHg6IEFycmF5PFBvbHlsaW5lPiA9IEFycmF5LmlzQXJyYXkocCkgPyBwIDogW3BdO1xyXG4gICAgICAgICAgICAgICAgeC5mb3JFYWNoKGxpbmUgPT4gbGluZS5BZGRMaXN0ZW5lcihldmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBEZWxldGVzIGEgcG9seWxpbmUuXHJcbiAgICAgICpcclxuICAgICAgKiBAcGFyYW0gcG9seWxpbmUgLSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5bGluZSBoYXMgYmVlbiBkZWxldGVkLlxyXG4gICAgICAqXHJcbiAgICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVNlcnZpY2VcclxuICAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVQb2x5bGluZShwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSk7XHJcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtLnRoZW4oKGw6IFBvbHlsaW5lKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4OiBBcnJheTxQb2x5bGluZT4gPSBBcnJheS5pc0FycmF5KGwpID8gbCA6IFtsXTtcclxuICAgICAgICAgICAgICAgIHguZm9yRWFjaChsaW5lID0+ICBsaW5lLkRlbGV0ZSgpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lcy5kZWxldGUocG9seWxpbmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlciBvbiB0aGUgY2xpY2sgbG9jYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyk6IElMYXRMb25nIHtcclxuICAgICAgICBpZiAoIWUpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICBpZiAoIWUubG9jYXRpb24pIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogZS5sb2NhdGlvbi5sYXRpdHVkZSwgbG9uZ2l0dWRlOiBlLmxvY2F0aW9uLmxvbmdpdHVkZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgbWFya2VyIG1vZGVsIGZvciB0aGUgbWFya2VyIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgcG9seWxpbmUgbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIFBvbHlsaW5lfVxyXG4gICAgICogaW1wbGVtZW50YXRpb24gb2YgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm0uIEZvciBjb21wbGV4IHBhdGhzLCByZXR1cm5zIGFuIGFycmF5IG9mIHBvbHlsaW5lcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TmF0aXZlUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBvbHlsaW5lIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0ge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSVBvbHlsaW5lT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcclxuICAgICAqIG9wdGlvbnMgYWxyZWFkeSBvbiB0aGUgdW5kZXJseWluZyBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlsaW5lIG9wdGlvbnMgaGF2ZSBiZWVuIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSkudGhlbihsID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeDogQXJyYXk8UG9seWxpbmU+ID0gQXJyYXkuaXNBcnJheShsKSA/IGwgOiBbbF07XHJcbiAgICAgICAgICAgIHguZm9yRWFjaChsaW5lID0+IGxpbmUuU2V0T3B0aW9ucyhvcHRpb25zKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBQb2x5bGluZSBwYXRoXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0ge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5bGluZSBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVQb2x5bGluZShwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSk7XHJcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtLnRoZW4obCA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHg6IEFycmF5PFBvbHlsaW5lPiA9IEFycmF5LmlzQXJyYXkobCkgPyBsIDogW2xdO1xyXG4gICAgICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID1cclxuICAgICAgICAgICAgICAgIHBvbHlsaW5lLlBhdGgubGVuZ3RoID4gMCAmJiBBcnJheS5pc0FycmF5KHBvbHlsaW5lLlBhdGhbMF0pID8gPEFycmF5PEFycmF5PElMYXRMb25nPj4+cG9seWxpbmUuUGF0aCA6XHJcbiAgICAgICAgICAgICAgICA8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5bcG9seWxpbmUuUGF0aF07XHJcbiAgICAgICAgICAgICB4LmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHAubGVuZ3RoID4gaW5kZXgpIHsgbGluZS5TZXRQYXRoKHBbaW5kZXhdKTsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobCkgJiYgbC5sZW5ndGggPiBwLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbC5zcGxpY2UocC5sZW5ndGggLSAxKS5mb3JFYWNoKGxpbmUgPT4gbGluZS5EZWxldGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2VGYWN0b3J5IH0gZnJvbSAnLi4vbWFwc2VydmljZWZhY3RvcnknO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBBUElMb2FkZXIsIFdpbmRvd1JlZiwgRG9jdW1lbnRSZWYgfSBmcm9tICcuLi9tYXBhcGlsb2FkZXInO1xyXG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbWFya2VyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJbmZvQm94U2VydmljZSB9IGZyb20gJy4uL2luZm9ib3guc2VydmljZSc7XHJcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL2xheWVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDbHVzdGVyU2VydmljZSB9IGZyb20gJy4uL2NsdXN0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IFBvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi4vcG9seWdvbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUG9seWxpbmVTZXJ2aWNlIH0gZnJvbSAnLi4vcG9seWxpbmUuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdNYXBBUElMb2FkZXIsIEJpbmdNYXBBUElMb2FkZXJDb25maWcgfSBmcm9tICcuL2JpbmctbWFwLmFwaS1sb2FkZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdJbmZvQm94U2VydmljZSB9IGZyb20gJy4vYmluZy1pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nTWFya2VyU2VydmljZSB9IGZyb20gJy4vYmluZy1tYXJrZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLW1hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0xheWVyU2VydmljZSB9IGZyb20gJy4vYmluZy1sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0NsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLWNsdXN0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdQb2x5Z29uU2VydmljZSB9IGZyb20gJy4vYmluZy1wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nUG9seWxpbmVTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLXBvbHlsaW5lLnNlcnZpY2UnO1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgYSBmYWN0b3J5IHRvIGNyZWF0ZSB0aHJlIG5lY2Vzc2FyeSBCaW5nIE1hcHMgVjggc3BlY2lmaWMgc2VydmljZSBpbnN0YW5jZXMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeSBpbXBsZW1lbnRzIE1hcFNlcnZpY2VGYWN0b3J5IHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeS5cclxuICAgICAqIEBwYXJhbSBfbG9hZGVyIC0ge0BsaW5rIE1hcEFQSUxvYWRlcn0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBCaW5nIE1hcCBWOCBwcm92aWRlci5cclxuICAgICAqIEBwYXJhbSBfem9uZSAtIE5nWm9uZSBvYmplY3QgdG8gaW1wbGVtZW50IHpvbmUgYXdhcmUgcHJvbWlzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sb2FkZXI6IE1hcEFQSUxvYWRlciwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kcyBhbmQgTWFwU2VydmljZUZhY3RvcnkgaW1wbGVtZW50YXRpb24uXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIG1hcCBzZXJ2aWNlIGZvciB0aGUgQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIE1hcFNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdNYXBTZXJ2aWNlfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGUoKTogTWFwU2VydmljZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5nTWFwU2VydmljZSh0aGlzLl9sb2FkZXIsIHRoaXMuX3pvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgY2x1c3RlciBzZXJ2aWNlIGZvciB0aGUgQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ01hcFNlcnZpY2V9LlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdDbHVzdGVyU2VydmljZX0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlQ2x1c3RlclNlcnZpY2UoX21hcFNlcnZpY2U6IEJpbmdNYXBTZXJ2aWNlKTogQ2x1c3RlclNlcnZpY2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZ0NsdXN0ZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhoIGluZm8gYm94IHNlcnZpY2UgZm9yIHRoZSBCaW5nIE1hcHMgVjggaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBCaW5nTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJbmZvQm94U2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ0luZm9Cb3hTZXJ2aWNlfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVJbmZvQm94U2VydmljZShfbWFwU2VydmljZTogQmluZ01hcFNlcnZpY2UpOiBJbmZvQm94U2VydmljZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5nSW5mb0JveFNlcnZpY2UoX21hcFNlcnZpY2UsIHRoaXMuX3pvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgbGF5ZXIgc2VydmljZSBmb3IgdGhlIEJpbmcgTWFwcyBWOCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwIC0ge0BsaW5rIE1hcFNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdNYXBTZXJ2aWNlfS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIExheWVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ0xheWVyU2VydmljZX0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlTGF5ZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlOiBCaW5nTWFwU2VydmljZSk6IExheWVyU2VydmljZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5nTGF5ZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIG1hcmtlciBzZXJ2aWNlIGZvciB0aGUgQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ01hcFNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIGxheWVycyAtIHtAbGluayBMYXllclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdMYXllclNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIGNsdXN0ZXJzICAtIHtAbGluayBDbHVzdGVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ0NsdXN0ZXJTZXJ2aWNlfS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIE1hcmtlclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdNYXJrZXJTZXJ2aWNlfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVNYXJrZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlOiBCaW5nTWFwU2VydmljZSxcclxuICAgICAgICBfbGF5ZXJTZXJ2aWNlOiBCaW5nTGF5ZXJTZXJ2aWNlLCBfY2x1c3RlclNlcnZpY2U6IEJpbmdDbHVzdGVyU2VydmljZSk6IE1hcmtlclNlcnZpY2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZ01hcmtlclNlcnZpY2UoX21hcFNlcnZpY2UsIF9sYXllclNlcnZpY2UsIF9jbHVzdGVyU2VydmljZSwgdGhpcy5fem9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBwb2x5Z29uIHNlcnZpY2UgZm9yIHRoZSBCaW5nIE1hcHMgVjggaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFwIGFyY2h0aWN0dXJlLlxyXG4gICAgICogQHBhcmFtIGxheWVycyAtIHtAbGluayBMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgUG9seWdvblNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWdvblNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSk6IFBvbHlnb25TZXJ2aWNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmdQb2x5Z29uU2VydmljZShtYXAsIGxheWVycywgdGhpcy5fem9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBwb2x5bGluZSBzZXJ2aWNlIGZvciB0aGUgQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIFBvbHlsaW5lU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVQb2x5bGluZVNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSk6IFBvbHlsaW5lU2VydmljZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5nUG9seWxpbmVTZXJ2aWNlKG1hcCwgbGF5ZXJzLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgcGxhZm9ybSBzcGVjaWZpYyBNYXBTZXJ2aWNlRmFjdG9yeS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0gYXBpTG9hZGVyIC0gQW4ge0BsaW5rIE1hcEFQSUxvYWRlcn0gaW5zdGFuY2UuIFRoaXMgaXMgZXhwZWN0ZWQgdG8gdGhlIGEge0BsaW5rIEJpbmdNYXBBUElMb2FkZXJ9LlxyXG4gKiBAcGFyYW0gem9uZSAtIEFuIE5nWm9uZSBpbnN0YW5jZSB0byBwcm92aWRlIHpvbmUgYXdhcmUgcHJvbWlzZXMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIC0gIEEge0BsaW5rIE1hcFNlcnZpY2VGYWN0b3J5fSBpbnN0YW5jZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBCaW5nTWFwU2VydmljZUZhY3RvcnlGYWN0b3J5KGFwaUxvYWRlcjogTWFwQVBJTG9hZGVyLCB6b25lOiBOZ1pvbmUpOiBNYXBTZXJ2aWNlRmFjdG9yeSB7XHJcbiAgICByZXR1cm4gbmV3IEJpbmdNYXBTZXJ2aWNlRmFjdG9yeShhcGlMb2FkZXIsIHpvbmUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHBsYWZvcm0gc3BlY2lmaWMgTWFwTG9hZGVyRmFjdG9yeS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcmV0dXJucyAtIEEge0BsaW5rIE1hcEFQSUxvYWRlcn0gaW5zdGFuY2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQmluZ01hcExvYWRlckZhY3RvcnkoKTogTWFwQVBJTG9hZGVyIHtcclxuICAgIHJldHVybiBuZXcgQmluZ01hcEFQSUxvYWRlcihuZXcgQmluZ01hcEFQSUxvYWRlckNvbmZpZygpLCBuZXcgV2luZG93UmVmKCksIG5ldyBEb2N1bWVudFJlZigpKTtcclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbGF5ZXInO1xyXG5pbXBvcnQgeyBNYXJrZXJUeXBlSWQgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyLXR5cGUtaWQnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLWxheWVyJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZU1hcFNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUNvbnZlcnNpb25zIH0gZnJvbSAnLi9nb29nbGUtY29udmVyc2lvbnMnO1xyXG5pbXBvcnQgeyBHb29nbGVNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1tYXJrZXInO1xyXG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5cclxuZGVjbGFyZSB2YXIgZ29vZ2xlOiBhbnk7XHJcblxyXG4vKipcclxuICogVGhpcyBhYnN0cmFjdCBwYXJ0aWFsbHkgaW1wbGVtZW50cyB0aGUgY29udHJhY3QgZm9yIHRoZSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfVxyXG4gKiBhbmQge0BsaW5rIENsdXN0ZXJTZXJ2aWNlfSBmb3IgdGhlIEdvb2dsZSBNYXBzIGFyY2h0aWVjdHVyZS4gSXQgc2VydmVzXHJcbiAqIGFzIHRoZSBiYXNlIGNsYXNzIGZvciBiYXNpYyBsYXllciAoe0BsaW5rIEdvb2dsZUxheWVyU2VydmljZX0pIGFuZCBjbHVzdGVyIGxheWVyICh7QGxpbmsgR29vZ2xlQ2x1c3RlckxheWVyfSkuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR29vZ2xlTGF5ZXJCYXNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IF9sYXllcnM6IE1hcDxudW1iZXIsIFByb21pc2U8TGF5ZXI+PjtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZUxheWVyQmFzZS5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIENvbmNyZXRlIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgR29vZ2xlIE1hcHMuXHJcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgaW5zdGFuY2UgdG8gcHJvdmlkZSB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllckJhc2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBwcm90ZWN0ZWQgX3pvbmU6IE5nWm9uZSkgeyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGxheWVyIHRvIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAgICogR2VuZXJhbGx5LCBNYXBMYXllckRpcmVjdGl2ZSB3aWxsIGJlIGluamVjdGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAgKiBMYXllclNlcnZpY2UgYW5kIHRoZW4gc2VsZiByZWdpc3RlciBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJCYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBBZGRMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgbGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbGF5ZXIgaGFzIGJlZW4gcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJCYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBsID0gdGhpcy5fbGF5ZXJzLmdldChsYXllci5JZCk7XHJcbiAgICAgICAgaWYgKGwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsLnRoZW4oKGwxOiBMYXllcikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbDEuRGVsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnMuZGVsZXRlKGxheWVyLklkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBMYXllciBtb2RlbCByZXByZXNlbnRlZCBieSB0aGlzIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIE1hcExheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3Qgb3IgbGF5ZXIgaWQgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBsYXllciBtb2RlbC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiByZXNvbHZlZCBjb250YWlucyB0aGUgTGF5ZXIgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyQmFzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TmF0aXZlTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlfG51bWJlcik6IFByb21pc2U8TGF5ZXI+IHtcclxuICAgICAgICBsZXQgcDogUHJvbWlzZTxMYXllcj4gPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2YobGF5ZXIpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBwID0gdGhpcy5fbGF5ZXJzLmdldChsYXllcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwID0gdGhpcy5fbGF5ZXJzLmdldCgoPE1hcExheWVyRGlyZWN0aXZlPmxheWVyKS5JZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG1hcmtlciBpbiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIElkIG9mIHRoZSBsYXllciBpbiB3aGljaCB0byBjcmVhdGUgdGhlIG1hcmtlci5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElNYXJrZXJPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgbWFya2VyIHByb3BlcnRpZXMuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIE1hcmtlcn0gbW9kZWwgZm9yIHRoZSBjcmVhdGVkIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJCYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVNYXJrZXIobGF5ZXI6IG51bWJlciwgb3B0aW9uczogSU1hcmtlck9wdGlvbnMpOiBQcm9taXNlPE1hcmtlcj4ge1xyXG4gICAgICAgIGNvbnN0IG1wOiBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4gPSB0aGlzLl9tYXBTZXJ2aWNlLk1hcFByb21pc2U7XHJcbiAgICAgICAgY29uc3QgbHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5fbGF5ZXJzLmdldChsYXllcik7XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbXAsIGxwXSkudGhlbigoW21hcCwgbF0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICh4OiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zKTogR29vZ2xlTWFya2VyID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoeCk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHZhbDogYW55LCBrZXk6IHN0cmluZykgPT4gbWFya2VyLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0TWFwKG1hcCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gbmV3IEdvb2dsZU1hcmtlcihtYXJrZXIpO1xyXG4gICAgICAgICAgICAgICAgbS5Jc0ZpcnN0ID0gb3B0aW9ucy5pc0ZpcnN0O1xyXG4gICAgICAgICAgICAgICAgbS5Jc0xhc3QgPSBvcHRpb25zLmlzTGFzdDtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodmFsOiBhbnksIGtleTogc3RyaW5nKSA9PiBtLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XHJcbiAgICAgICAgICAgICAgICBsLkFkZEVudGl0eShtKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaWNvbkluZm8gJiYgb3B0aW9ucy5pY29uSW5mby5tYXJrZXJUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gTWFya2VyLkNyZWF0ZU1hcmtlcihvcHRpb25zLmljb25JbmZvKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocykgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5pY29uID0gcztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZChvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnRoZW4oeCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uaWNvbiA9IHguaWNvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQobyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZChvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIG1hcmtlcnMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIG1hcmtlcnMgdG8gYmUgdXNlZCBpbiBidWxrXHJcbiAgICAgKiBvcGVyYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTWFya2VyIG9wdGlvbnMgZGVmaW5pbmcgdGhlIG1hcmtlcnMuXHJcbiAgICAgKiBAcGFyYW0gbWFya2VySWNvbiAtIE9wdGlvbmFsIGluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGN1c3RvbSBtYXJrZXJzLiBUaGlzIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgbWFya2Vycy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIE1hcmtlciBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyQmFzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlTWFya2VycyhvcHRpb25zOiBBcnJheTxJTWFya2VyT3B0aW9ucz4sIG1hcmtlckljb24/OiBJTWFya2VySWNvbkluZm8pOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+IHtcclxuICAgICAgICBjb25zdCBwYXlsb2FkID0gKGljb246IHN0cmluZyk6IEFycmF5PEdvb2dsZU1hcmtlcj4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXJzOiBBcnJheTxHb29nbGVNYXJrZXI+ID0gb3B0aW9ucy5tYXAobW8gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFya2VyT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU1hcmtlck9wdGlvbnMobW8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGljb24gJiYgaWNvbiAhPT0gJycpIHsgby5pY29uID0gaWNvbjsgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHVzaHBpbiA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIobyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXI6IEdvb2dsZU1hcmtlciA9IG5ldyBHb29nbGVNYXJrZXIocHVzaHBpbik7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuSXNGaXJzdCA9IG1vLmlzRmlyc3Q7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuSXNMYXN0ID0gbW8uaXNMYXN0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vLm1ldGFkYXRhKSB7IG1vLm1ldGFkYXRhLmZvckVhY2goKHZhbDogYW55LCBrZXk6IHN0cmluZykgPT4gbWFya2VyLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+ID0gbmV3IFByb21pc2U8QXJyYXk8TWFya2VyPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWFya2VySWNvbiAmJiBtYXJrZXJJY29uLm1hcmtlclR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXJrZXIuQ3JlYXRlTWFya2VyKG1hcmtlckljb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzKSA9PT0gJ3N0cmluZycpIHsgcmVzb2x2ZShwYXlsb2FkKHMpKTsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMudGhlbih4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKHguaWNvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSAocGF5bG9hZChudWxsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm90ZWN0ZWQgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsYXllciBiYXNlZCBvbiBpdHMgaWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIGlkIC0gTGF5ZXIgSWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIExheWVyfSBtb2RlbCBmb3IgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllckJhc2VcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIEdldExheWVyQnlJZChpZDogbnVtYmVyKTogUHJvbWlzZTxMYXllcj4ge1xyXG4gICAgICAgIGxldCBwOiBQcm9taXNlPExheWVyPjtcclxuICAgICAgICB0aGlzLl9sYXllcnMuZm9yRWFjaCgobDogUHJvbWlzZTxMYXllcj4sIGs6IG51bWJlcikgPT4geyBpZiAoayA9PT0gaWQpIHsgcCA9IGw7IH0gfSk7XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsIsOvwrvCv2ltcG9ydCB7IElDbHVzdGVySWNvbkluZm8gfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbWFya2VyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XHJcbmltcG9ydCB7IENsdXN0ZXJDbGlja0FjdGlvbiB9IGZyb20gJy4uLy4uL21vZGVscy9jbHVzdGVyLWNsaWNrLWFjdGlvbic7XHJcbmltcG9ydCB7IENsdXN0ZXJMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvY2x1c3Rlci1sYXllcic7XHJcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlTGF5ZXJCYXNlIH0gZnJvbSAnLi9nb29nbGUtbGF5ZXItYmFzZSc7XHJcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgR29vZ2xlQ2x1c3RlclNlcnZpY2UgZXh0ZW5kcyBHb29nbGVMYXllckJhc2UgaW1wbGVtZW50cyBDbHVzdGVyU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByb3RlY3RlZCBfbGF5ZXJzOiBNYXA8bnVtYmVyLCBQcm9taXNlPExheWVyPj4gPSBuZXcgTWFwPG51bWJlciwgUHJvbWlzZTxMYXllcj4+KCk7XHJcbiAgICBwcm90ZWN0ZWQgX2xheWVyU3R5bGVzOiBNYXA8bnVtYmVyLCBBcnJheTxHb29nbGVNYXBUeXBlcy5DbHVzdGVyU3R5bGU+PiA9IG5ldyBNYXA8bnVtYmVyLCBBcnJheTxHb29nbGVNYXBUeXBlcy5DbHVzdGVyU3R5bGU+PigpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFN0YXRpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIGNsdXN0ZXIgaWNvbiBmcm9tIHRoZSBzdHlsZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVzXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgdGhhdCB3aGVuIHJlc29sdmVkIGNvbnRhaW5zIGFuIEFycmF5IG9mIElDbHVzdGVySWNvbkluZm8gb2JqZWN0c1xyXG4gICAgICogY29udGFpbmluZyB0aGUgaHlkcmF0ZWQgY2x1c3RlciBpY29ucy5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDbHVzdGVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENyZWF0ZUNsdXN0ZXJJY29ucyhzdHlsZXM6IEFycmF5PElDbHVzdGVySWNvbkluZm8+KTogUHJvbWlzZTxBcnJheTxJQ2x1c3Rlckljb25JbmZvPj4ge1xyXG4gICAgICAgIGNvbnN0IGk6IFByb21pc2U8QXJyYXk8SUNsdXN0ZXJJY29uSW5mbz4+ID0gbmV3IFByb21pc2U8QXJyYXk8SUNsdXN0ZXJJY29uSW5mbz4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGEgPSBuZXcgQXJyYXk8UHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4+KCk7XHJcbiAgICAgICAgICAgIHN0eWxlcy5mb3JFYWNoKChzdHlsZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5pY29uSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHM6IHN0cmluZ3xQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PiA9IE1hcmtlci5DcmVhdGVNYXJrZXIoc3R5bGUuaWNvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocykgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnVybCA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS53aWR0aCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHN0eWxlLmljb25JbmZvLnNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5pY29uSW5mby5zaXplLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8gJiYgc3R5bGUuaWNvbkluZm8uc2l6ZSAmJiBzdHlsZS5hbmNob3IgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbzogSU1hcmtlckljb25JbmZvID0gc3R5bGUuaWNvbkluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5hbmNob3IgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5zaXplLndpZHRoICogby5tYXJrZXJPZmZzZXRSYXRpby54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uc2l6ZS5oZWlnaHQgKiBvLm1hcmtlck9mZnNldFJhdGlvLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlLmljb25JbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcy50aGVuKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUudXJsID0geC5pY29uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLndpZHRoID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHguaWNvbkluZm8uc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSB4Lmljb25JbmZvLnNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHguaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8gJiYgeC5pY29uSW5mby5zaXplICYmIHN0eWxlLmFuY2hvciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbzogSU1hcmtlckljb25JbmZvID0geC5pY29uSW5mbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5hbmNob3IgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uc2l6ZS53aWR0aCAqIG8ubWFya2VyT2Zmc2V0UmF0aW8ueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5zaXplLmhlaWdodCAqIG8ubWFya2VyT2Zmc2V0UmF0aW8ueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3R5bGUuaWNvbkluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYS5wdXNoKHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChwYS5sZW5ndGggPT09IDApIHsgcmVzb2x2ZShzdHlsZXMpOyB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocGEpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3R5bGVzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlQ2x1c3RlclNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2VcclxuICAgICAqIEBwYXJhbSBfem9uZVxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBfem9uZTogTmdab25lKSB7XHJcbiAgICAgICAgc3VwZXIoX21hcFNlcnZpY2UsIF96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGNsdXN0ZXIgbGF5ZXIgdG8gdGhlIG1hcFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllclxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMYXllcihsYXllcjogQ2x1c3RlckxheWVyRGlyZWN0aXZlKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uczogSUNsdXN0ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogbGF5ZXIuSWQsXHJcbiAgICAgICAgICAgIHZpc2libGU6IGxheWVyLlZpc2libGUsXHJcbiAgICAgICAgICAgIGNsdXN0ZXJpbmdFbmFibGVkOiBsYXllci5DbHVzdGVyaW5nRW5hYmxlZCxcclxuICAgICAgICAgICAgem9vbU9uQ2xpY2s6IGxheWVyLkNsdXN0ZXJDbGlja0FjdGlvbiA9PT0gQ2x1c3RlckNsaWNrQWN0aW9uLlpvb21JbnRvQ2x1c3RlclxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGxheWVyLkdyaWRTaXplKSB7IG9wdGlvbnMuZ3JpZFNpemUgPSBsYXllci5HcmlkU2l6ZTsgfVxyXG4gICAgICAgIGlmIChsYXllci5NaW5pbXVtQ2x1c3RlclNpemUpIHsgb3B0aW9ucy5taW5pbXVtQ2x1c3RlclNpemUgPSBsYXllci5NaW5pbXVtQ2x1c3RlclNpemU7IH1cclxuICAgICAgICBpZiAobGF5ZXIuU3R5bGVzKSB7IG9wdGlvbnMuc3R5bGVzID0gbGF5ZXIuU3R5bGVzOyB9XHJcbiAgICAgICAgaWYgKGxheWVyLlVzZUR5bmFtaWNTaXplTWFya2Vycykge1xyXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCB0byBhdHRlbXB0IHRvIHNldHVwIHN0eWxlcyBoZXJlIGFzIHRoZSBkeW5hbWljIGNhbGwgYmFjayB3aWxsIGdlbmVyYXRlIHRoZW0uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlcyA9IFt7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDMwLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDM1LFxyXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgdGV4dFNpemU6IDExLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgIGljb25JbmZvOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyVHlwZTogTWFya2VyVHlwZUlkLkZvbnRNYXJrZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9udE5hbWU6ICdGb250QXdlc29tZScsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDMwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnZ3JlZW4nLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdcXHVGMTExJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZHluYW1pY0NsdXN0ZXJDYWxsYmFjayA9IChtYXJrZXJzOiBBcnJheTxHb29nbGVNYXBUeXBlcy5NYXJrZXI+LCBudW1TdHlsZXM6IG51bWJlcixcclxuICAgICAgICAgICAgY2x1c3RlcmVyOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJDbHVzdGVyZXIpID0+IHtcclxuICAgICAgICAgICAgLy8gZHluYW1pY2FsbHkgZW5zdXJlIHRoYXQgdGhlIG5lY2Vzc2FyeSBzdHlsZSBmb3IgdGhpcyBjbHVzdGVyIGljb24gZXhpc3RzIGFuZFxyXG4gICAgICAgICAgICAvLyB0aGUgY2x1c3RlcmVyIGlzIGFscmVhZHkgaG9va2VkIHVwIHRvIHRoZSBzdHlsZXMgYXJyYXkgdmlhIHBvaW50ZXIsIHNvIHdlIG9ubHlcclxuICAgICAgICAgICAgLy8gbmVlZCB0byB1cGRhdGUgdGhlIHN0eWxlLiBTaW5jZSB0aGUgY2x1c3RlcmVyIHJlLXJlbmRlcnMgYSBjbHVzdGVyIGljb24gaXMgdGhlXHJcbiAgICAgICAgICAgIC8vIHRoZSBtYXJrZXIgY291bnQgY2hhbmdlcywgd2Ugd2lsbCBvbmx5IG5lZWQgdG8gcmV0YWluIHRoZSBjdXJyZW50IGljb24gYXMgb3Bwb3NlZFxyXG4gICAgICAgICAgICAvLyB0byBhbGwgY2x1c3RlciBpY29uLlxyXG4gICAgICAgICAgICBjb25zdCBzdHlsZXM6IEFycmF5PEdvb2dsZU1hcFR5cGVzLkNsdXN0ZXJTdHlsZT4gPSB0aGlzLl9sYXllclN0eWxlcy5nZXQobGF5ZXIuSWQpO1xyXG4gICAgICAgICAgICBjb25zdCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgbWFya2VyVHlwZTogTWFya2VyVHlwZUlkLk5vbmVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgaWNvbjogc3RyaW5nID0gbGF5ZXIuQ3VzdG9tTWFya2VyQ2FsbGJhY2soPGFueT5tYXJrZXJzLCBpY29uSW5mbyk7XHJcbiAgICAgICAgICAgIHN0eWxlc1swXSA9IHtcclxuICAgICAgICAgICAgICAgIHVybDogYFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCwke2ljb259XFxcImAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGljb25JbmZvLnNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGljb25JbmZvLnNpemUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0U2l6ZTogMTEsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogbWFya2Vycy5sZW5ndGgudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIGluZGV4OiAxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXNldFN0eWxlcyA9IChjbHVzdGVyZXI6IEdvb2dsZU1hcFR5cGVzLk1hcmtlckNsdXN0ZXJlcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJTdHlsZXMuaGFzKGxheWVyLklkKSkgeyB0aGlzLl9sYXllclN0eWxlcy5nZXQobGF5ZXIuSWQpLnNwbGljZSgwKTsgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlczogQXJyYXk8R29vZ2xlTWFwVHlwZXMuQ2x1c3RlclN0eWxlPiA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5DbHVzdGVyU3R5bGU+KCk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCh7fSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllclN0eWxlcy5zZXQobGF5ZXIuSWQsIHN0eWxlcyk7XHJcbiAgICAgICAgICAgICAgICBjbHVzdGVyZXIuc2V0U3R5bGVzKHN0eWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgc3R5bGVzIGFzIHRoZSBwb2ludGVyIHRvIHRoaXMgYXJyYXkgZ2V0cyBwYXNzZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcm91bmQga2V5IG9iamVjdHMgaW4gdGhlIGNsdXN0ZXJlci4gVGhlcmVmb3JlLCBpdCBtdXN0IGJlIGluaXRpYWxpemVkIGhlcmUgaW4gb3JkZXIgZm9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0byB0aGUgc3R5bGVzIHRvIGJlIHZpc2libGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbywgd2UgbmVlZCB0byBhZGQgYXQgbGVhc3Qgb25lIHN0eWxlIHRvIHByZXZlbnQgdGhlIGRlZmF1bHQgc3R5bGVzIGZyb20gYmVpbmcgcGlja2VkIHVwLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgbGF5ZXJQcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVDbHVzdGVyTGF5ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJzLnNldChsYXllci5JZCwgbGF5ZXJQcm9taXNlKTtcclxuICAgICAgICBsYXllclByb21pc2UudGhlbihsID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2x1c3RlcmVyOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJDbHVzdGVyZXIgPSA8R29vZ2xlTWFwVHlwZXMuTWFya2VyQ2x1c3RlcmVyPmwuTmF0aXZlUHJpbWl0dmU7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0eWxlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyAgPSBHb29nbGVDbHVzdGVyU2VydmljZS5DcmVhdGVDbHVzdGVySWNvbnMob3B0aW9ucy5zdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgcy50aGVuKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJlci5zZXRTdHlsZXMoPEFycmF5PEdvb2dsZU1hcFR5cGVzLkNsdXN0ZXJTdHlsZT4+eCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc2V0U3R5bGVzKGNsdXN0ZXJlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLk1hcFByb21pc2UudGhlbigobTogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbS5hZGRMaXN0ZW5lcignem9vbV9jaGFuZ2VkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0eWxlcyhjbHVzdGVyZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjbHVzdGVyZXIuc2V0Q2FsY3VsYXRvcigobSwgbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkeW5hbWljQ2x1c3RlckNhbGxiYWNrKG0sIG4sIGNsdXN0ZXJlcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbWFya2VyIGluIHRoZSBjbHVzdGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVNYXJrZXIobGF5ZXI6IG51bWJlciwgb3B0aW9uczogSU1hcmtlck9wdGlvbnMpOiBQcm9taXNlPE1hcmtlcj4ge1xyXG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5HZXRMYXllckJ5SWQobGF5ZXIpO1xyXG4gICAgICAgIGlmIChwID09IG51bGwpIHsgdGhyb3cgKG5ldyBFcnJvcihgTGF5ZXIgd2l0aCBpZCAke2xheWVyfSBub3QgZm91bmQgaW4gTGF5ZXIgTWFwYCkpOyB9XHJcblxyXG4gICAgICAgIHJldHVybiBwLnRoZW4oKGw6IExheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZU1hcmtlcihvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKG1hcmtlcjogTWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLklzRmlyc3QgPSBvcHRpb25zLmlzRmlyc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLklzTGFzdCA9IG9wdGlvbnMuaXNMYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGwuQWRkRW50aXR5KG1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSBjbHVzdGVyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFN0YXJ0Q2x1c3RlcmluZyhsYXllcjogQ2x1c3RlckxheWVyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIGNsdXN0ZXJpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXJcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDbHVzdGVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU3RvcENsdXN0ZXJpbmcobGF5ZXI6IENsdXN0ZXJMYXllckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBwb2x5Z29uIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5Z29uIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlnb24uXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlnb24gbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVQb2x5Z29uKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8UG9seWdvbj4ge1xyXG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1BvbHlnb25zIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNsdXN0ZXJpbmcgbGF5ZXJzLiBZb3UgY2FuIG9ubHkgdXNlIG1hcmtlcnMuJykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIHBvbHlnb25zLiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFycmF5cyBvZiBwb2x5Z29ucyB0byBiZSB1c2VkIGluIGJ1bGtcclxuICAgICAqIG9wZXJhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIHBvbHlnb24uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlnb24gb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWdvbnMuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBQb2x5Z29uIG1vZGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb25zKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PiB7XHJcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignUG9seWdvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY2x1c3RlcmluZyBsYXllcnMuIFlvdSBjYW4gb25seSB1c2UgbWFya2Vycy4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIGxpbmUuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlsaW5lIG9wdGlvbnMgZGVmaW5pbmcgdGhlIGxpbmUuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlsaW5lIChvciBhblxyXG4gICAgICogYXJyYXkgb2YgcG9seWdvbnMgZm9yIGNvbXBsZXggcGF0aHMpIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDbHVzdGVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWxpbmUobGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiB7XHJcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignUG9seWxpbmVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNsdXN0ZXJpbmcgbGF5ZXJzLiBZb3UgY2FuIG9ubHkgdXNlIG1hcmtlcnMuJykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIHBvbHlsaW5lcy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWxpbmVzIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWxpbmVzLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5bGluZSBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5bGluZXMuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBQb2x5bGluZSBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVQb2x5bGluZXMobGF5ZXI6IG51bWJlciwgb3B0aW9uczogQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+IHtcclxuICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdQb2x5bGluZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY2x1c3RlcmluZyBsYXllcnMuIFlvdSBjYW4gb25seSB1c2UgbWFya2Vycy4nKSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IEluZm9Cb3hDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2luZm9ib3gnO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuLi9pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbWFya2VyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgR29vZ2xlSW5mb1dpbmRvdyB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWluZm8td2luZG93JztcclxuaW1wb3J0IHsgR29vZ2xlTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtbWFya2VyJztcclxuaW1wb3J0IHsgR29vZ2xlTWFwRXZlbnRzTG9va3VwIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtZXZlbnRzLWxvb2t1cCc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVJbmZvQm94U2VydmljZSBleHRlbmRzIEluZm9Cb3hTZXJ2aWNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIHByaXZhdGUgX2JveGVzOiBNYXA8SW5mb0JveENvbXBvbmVudCwgUHJvbWlzZTxJbmZvV2luZG93Pj4gPSBuZXcgTWFwPEluZm9Cb3hDb21wb25lbnQsIFByb21pc2U8R29vZ2xlSW5mb1dpbmRvdz4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlSW5mb0JveFNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2VcclxuICAgICAqIEBwYXJhbSBfbWFya2VyU2VydmljZVxyXG4gICAgICogQHBhcmFtIF96b25lXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfbWFya2VyU2VydmljZTogTWFya2VyU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBpbmZvIHdpbmRvd1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmZvXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRJbmZvV2luZG93KGluZm86IEluZm9Cb3hDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMgPSB7fTtcclxuICAgICAgICBpZiAoaW5mby5IdG1sQ29udGVudCAhPT0gJycpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5odG1sQ29udGVudCA9IGluZm8uSHRtbENvbnRlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zLnRpdGxlID0gaW5mby5UaXRsZTtcclxuICAgICAgICAgICAgb3B0aW9ucy5kZXNjcmlwdGlvbiA9IGluZm8uRGVzY3JpcHRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmZvLnhPZmZzZXQgfHwgaW5mby55T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBpeGVsT2Zmc2V0ID09IG51bGwpIHsgb3B0aW9ucy5waXhlbE9mZnNldCA9IHsgeDogMCwgeTogMCB9OyB9XHJcbiAgICAgICAgICAgIGlmIChpbmZvLnhPZmZzZXQpIHsgb3B0aW9ucy5waXhlbE9mZnNldC54ID0gaW5mby54T2Zmc2V0OyB9XHJcbiAgICAgICAgICAgIGlmIChpbmZvLnlPZmZzZXQpIHsgb3B0aW9ucy5waXhlbE9mZnNldC55ID0gaW5mby55T2Zmc2V0OyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbnMuZGlzYWJsZUF1dG9QYW4gPSBpbmZvLkRpc2FibGVBdXRvUGFuO1xyXG4gICAgICAgIG9wdGlvbnMudmlzaWJsZSA9IGluZm8uVmlzaWJsZTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbmZvLkxhdGl0dWRlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgaW5mby5Mb25naXR1ZGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24gPSB7IGxhdGl0dWRlOiBpbmZvLkxhdGl0dWRlLCBsb25naXR1ZGU6IGluZm8uTG9uZ2l0dWRlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZm9XaW5kb3dQcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVJbmZvV2luZG93KG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2JveGVzLnNldChpbmZvLCBpbmZvV2luZG93UHJvbWlzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIGluZm8gd2luZG93XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZm9cclxuICAgICAqIEByZXR1cm5zIC0gIEEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIGluZm8gYm94IGlzIGNsb3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENsb3NlKGluZm86IEluZm9Cb3hDb21wb25lbnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYm94ZXMuZ2V0KGluZm8pLnRoZW4odyA9PiB7XHJcbiAgICAgICAgICAgIHcuQ2xvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYW4gaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxyXG4gICAgICogQHBhcmFtIGluZm9Db21wb25lbnQgLSBUaGUge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBpbmZvQ29tcG9uZW50OiBJbmZvQm94Q29tcG9uZW50KTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgICAgICAgY29uc3QgZ29vZ2xlRXZlbnROYW1lOiBzdHJpbmcgPSBHb29nbGVNYXBFdmVudHNMb29rdXBbZXZlbnROYW1lXTtcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9ib3hlcy5nZXQoaW5mb0NvbXBvbmVudCkudGhlbigoYjogSW5mb1dpbmRvdykgPT4ge1xyXG4gICAgICAgICAgICAgICAgYi5BZGRMaXN0ZW5lcihnb29nbGVFdmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgaW5mbyB3aW5kb3dcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5mb1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlSW5mb1dpbmRvdyhpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgdGhlIGluZm8gd2luZG93LiBXaW5kb3cgb3BlbnMgb24gYSBtYXJrZXIsIGlmIHN1cHBsaWVkLCBvciBhIHNwZWNpZmljIGxvY2F0aW9uIGlmIGdpdmVuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZm9cclxuICAgICAqIEBwYXJhbSBbbG9jXVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgT3BlbihpbmZvOiBJbmZvQm94Q29tcG9uZW50LCBsb2M/OiBJTGF0TG9uZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmIChpbmZvLkNsb3NlSW5mb0JveGVzT25PcGVuIHx8IGluZm8uTW9kYWwpIHtcclxuICAgICAgICAgICAgLy8gY2xvc2UgYWxsIG9wZW4gaW5mbyBib3hlc1xyXG4gICAgICAgICAgICB0aGlzLl9ib3hlcy5mb3JFYWNoKChib3g6IFByb21pc2U8SW5mb1dpbmRvdz4sIGk6IEluZm9Cb3hDb21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmZvLklkICE9PSBpLklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm94LnRoZW4oKHcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcuSXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3LkNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLkNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3hlcy5nZXQoaW5mbykudGhlbigodzogR29vZ2xlSW5mb1dpbmRvdykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKGluZm8uSHRtbENvbnRlbnQgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmh0bWxDb250ZW50ID0gaW5mby5IdG1sQ29udGVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMudGl0bGUgPSBpbmZvLlRpdGxlO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kZXNjcmlwdGlvbiA9IGluZm8uRGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdy5TZXRPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoaW5mby5Ib3N0TWFya2VyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJTZXJ2aWNlLkdldE5hdGl2ZU1hcmtlcihpbmZvLkhvc3RNYXJrZXIpLnRoZW4oKG1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXBTZXJ2aWNlLk1hcFByb21pc2UudGhlbigobWFwKSA9PiAoPEdvb2dsZUluZm9XaW5kb3c+dykuT3BlbigoPEdvb2dsZU1hcmtlcj5tYXJrZXIpLk5hdGl2ZVByaW1pdHZlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwU2VydmljZS5NYXBQcm9taXNlLnRoZW4oKG1hcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvYykgeyB3LlNldFBvc2l0aW9uKGxvYyk7IH1cclxuICAgICAgICAgICAgICAgIHcuT3BlbigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5mb1xyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMoaW5mbzogSW5mb0JveENvbXBvbmVudCwgb3B0aW9uczogSUluZm9XaW5kb3dPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKCh3OiBHb29nbGVJbmZvV2luZG93KSA9PiB7XHJcbiAgICAgICAgICAgIHcuU2V0T3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IHBvc2l0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZm9cclxuICAgICAqIEBwYXJhbSBsYXRsbmdcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFBvc2l0aW9uKGluZm86IEluZm9Cb3hDb21wb25lbnQsIGxhdGxuZzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0aGlzLl9ib3hlcy5nZXQoaW5mbykudGhlbigodykgPT4ge1xyXG4gICAgICAgICAgICB3LlNldFBvc2l0aW9uKGxhdGxuZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBlYWNoU2VyaWVzLCBuZXh0VGljayB9IGZyb20gJ2FzeW5jJztcclxuaW1wb3J0IHsgR29vZ2xlTWFya2VyIH0gZnJvbSAnLi9nb29nbGUtbWFya2VyJztcclxuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2xheWVyJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbWFya2VyJztcclxuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uL3BvbHlsaW5lJztcclxuaW1wb3J0IHsgQ2x1c3RlclBsYWNlbWVudE1vZGUgfSBmcm9tICcuLi9jbHVzdGVyLXBsYWNlbWVudC1tb2RlJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIGEgbGF5ZXIgZm9yIHRoZSBHb29nbGUgTWFwIFByb3ZpZGVyLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR29vZ2xlTGF5ZXIgaW1wbGVtZW50cyBMYXllciB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2VudGl0aWVzOiBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPiA9IG5ldyBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPigpO1xyXG4gICAgcHJpdmF0ZSBfdmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVmaW5pdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBuYXRpdmUgcHJpbWl0aXZlIHVuZGVybmVhdGggdGhlIGFic3RyYWN0aW9uIGxheWVyLiBHb29nbGUgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiBhIGN1c3RvbSBsYXllcixcclxuICAgICAqIHNvIHdlIGFyZSByZXR1cm5pbmcgdGhlIE1hcCBhcyB0aGUgbmF0aXZlIG9iamVjdCBiZWNhdXNlIGl0IGhvc3RzIGFsbCB0aGUgbWFya2Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTmF0aXZlUHJpbWl0dmUoKTogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgR29vZ2xlTWFya2VyQ2x1c3RlcmVyIGNsYXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBfbGF5ZXIgR29vZ2xlTWFwVHlwZXMuTWFya2VyQ2x1c3RlcmVyLiBOYXRpdmUgR29vZ2xlIE1hcHMgTWFya2VyIENsdXN0ZXJlciBzdXBwb3J0aW5nIHRoZSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICogQHBhcmFtIF9tYXBzIE1hcFNlcnZpY2UuIE1hcFNlcnZpY2UgaW1wbGVtZW50YXRpb24gdG8gbGV2ZXJhZ2UgZm9yIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbGF5ZXI6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCwgcHJpdmF0ZSBfbWFwczogTWFwU2VydmljZSwgcHJpdmF0ZSBfaWQ6IG51bWJlcikgeyB9XHJcblxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzLCBMYXllciBpbnRlcmZhY2UgaW1wbGVtZW50YXRpb25cclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgc3RyaW5nLiBUeXBlIG9mIGV2ZW50IHRvIGFkZCAoY2xpY2ssIG1vdXNlb3ZlciwgZXRjKS4gWW91IGNhbiB1c2UgYW55IGV2ZW50IHRoYXQgdGhlIHVuZGVybHlpbmcgbmF0aXZlXHJcbiAgICAgKiBsYXllciBzdXBwb3J0cy5cclxuICAgICAqIEBwYXJhbSBmbiBmdW5jdGlvbi4gSGFuZGxlciB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdFdmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gR29vZ2xlIExheWVycy4gWW91IGNhbiBzdGlsbCBhZGQgZXZlbnRzIHRvIGluZGl2aWR1YWwgbWFya2Vycy4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGVudGl0eSB0byB0aGUgbGF5ZXIuIFVzZSB0aGlzIG1ldGhvZCB3aXRoIGNhdXRpb24gYXMgaXQgd2lsbFxyXG4gICAgICogdHJpZ2dlciBhIHJlY2FsdWF0aW9uIG9mIHRoZSBjbHVzdGVycyAoYW5kIGFzc29jaWF0ZWQgbWFya2VycyBpZiBhcHByb3ByaXRlKSBmb3JcclxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gSWYgeW91IHVzZSB0aGlzIG1ldGhvZCB0byBhZGQgbWFueSBtYXJrZXJzIHRvIHRoZSBjbHVzdGVyLCB1c2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmUuIEVudGl0eSB0byBhZGQgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMQXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkRW50aXR5KGVudGl0eTogTWFya2VyIHwgSW5mb1dpbmRvdyB8IFBvbHlnb24gfCBQb2x5bGluZSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChlbnRpdHkuTmF0aXZlUHJpbWl0dmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXMucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICBlbnRpdHkuTmF0aXZlUHJpbWl0dmUuc2V0VmlzaWJsZSh0aGlzLl92aXNpYmxlKTtcclxuICAgICAgICAgICAgZW50aXR5Lk5hdGl2ZVByaW1pdHZlLnNldE1hcCh0aGlzLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbnVtYmVyIG9mIGVudGl0aWVzIHRvIHRoZSBsYXllci4gRW50aXRpZXMgaW4gdGhpcyBjb250ZXh0IHNob3VsZCBiZSBtb2RlbCBhYnN0cmFjdGlvbnMgb2YgY29uY2VyZWQgbWFwIGZ1bmN0aW9uYWxpdHkgKHN1Y2hcclxuICAgICAqIGFzIG1hcmtlciwgaW5mb3dpbmRvdywgcG9seWxpbmUsIHBvbHlnb24sIGV0Yy4uKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdGllcyBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPi4gRW50aXRpZXMgdG8gYWRkIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTEF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPik6IHZvaWQge1xyXG4gICAgICAgIGlmIChlbnRpdGllcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoZW50aXRpZXMpICYmIGVudGl0aWVzLmxlbmd0aCAhPT0gMCApIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXMucHVzaCguLi5lbnRpdGllcyk7XHJcbiAgICAgICAgICAgIGVhY2hTZXJpZXMoWy4uLmVudGl0aWVzXSwgKGUsIG5leHQpID0+IHtcclxuICAgICAgICAgICAgICAgIGUuTmF0aXZlUHJpbWl0dmUuc2V0VmlzaWJsZSh0aGlzLl92aXNpYmxlKTtcclxuICAgICAgICAgICAgICAgIGUuTmF0aXZlUHJpbWl0dmUuc2V0TWFwKHRoaXMuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICAgICAgbmV4dFRpY2soKCkgPT4gbmV4dCgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgbGF5ZXIgYW5iZCB0aGUgbWFya2VycyBpbiBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcclxuICAgICAgICBlYWNoU2VyaWVzKHRoaXMuX2VudGl0aWVzLnNwbGljZSgwKSwgKGUsIG5leHQpID0+IHtcclxuICAgICAgICAgICAgZS5OYXRpdmVQcmltaXR2ZS5zZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IG5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIGdvdmVybmluZyB0aGUgYmVoYXZpb3Igb2YgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIElMYXllck9wdGlvbnMuIFRoZSBsYXllciBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0T3B0aW9ucygpOiBJTGF5ZXJPcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBJTGF5ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogdGhpcy5faWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQm9vbGVhbi4gVHJ1ZSBpcyB0aGUgbGF5ZXIgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0VmlzaWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gZW50aXR5IGZyb20gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZSBFbnRpdHkgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFJlbW92ZUVudGl0eShlbnRpdHk6IE1hcmtlciB8IEluZm9XaW5kb3cgfCBQb2x5Z29uIHwgUG9seWxpbmUpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZW50aXR5Lk5hdGl2ZVByaW1pdHZlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGo6IG51bWJlciA9IHRoaXMuX2VudGl0aWVzLmluZGV4T2YoZW50aXR5KTtcclxuICAgICAgICAgICAgaWYgKGogPiAtMSkgeyB0aGlzLl9lbnRpdGllcy5zcGxpY2UoaiwgMSk7IH1cclxuICAgICAgICAgICAgZW50aXR5Lk5hdGl2ZVByaW1pdHZlLnNldE1hcChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBlbnRpdGllcyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudGl0aWVzIEFycmF5PE1hcmtlcj58QXJyYXk8SW5mb1dpbmRvdz58QXJyYXk8UG9seWdvbj58QXJyYXk8UG9seWxpbmU+IGNvbnRhaW5pbmdcclxuICAgICAqIHRoZSBlbnRpdGllcyB0byBhZGQgdG8gdGhlIGNsdXN0ZXIuIFRoaXMgcmVwbGFjZXMgYW55IGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0RW50aXRpZXMoZW50aXRpZXM6IEFycmF5PE1hcmtlcj4gfCBBcnJheTxJbmZvV2luZG93PiB8IEFycmF5PFBvbHlnb24+IHwgQXJyYXk8UG9seWxpbmU+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5EZWxldGUoKTtcclxuICAgICAgICB0aGlzLkFkZEVudGl0aWVzKGVudGl0aWVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wdGlvbnMgZm9yIHRoZSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIElMYXllck9wdGlvbnMgY29udGFpbmluZyB0aGUgb3B0aW9ucyBlbnVtZXJhdGlvbiBjb250cm9sbGluZyB0aGUgbGF5ZXIgYmVoYXZpb3IuIFRoZSBzdXBwbGllZCBvcHRpb25zXHJcbiAgICAgKiBhcmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQvZXhpc3Rpbmcgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSUxheWVyT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2lkID0gb3B0aW9ucy5pZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZXMgdGhlIGNsdXN0ZXIgbGF5ZXIgdmlzaWJpbGl0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSBCb29sZWFuIHRydWUgdG8gbWFrZSB0aGUgbGF5ZXIgdmlzaWJsZSwgZmFsc2UgdG8gaGlkZSB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlckNsdXN0ZXJlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgZWFjaFNlcmllcyhbLi4udGhpcy5fZW50aXRpZXNdLCAoZSwgbmV4dCkgPT4ge1xyXG4gICAgICAgICAgICBlLk5hdGl2ZVByaW1pdHZlLnNldFZpc2libGUodmlzaWJsZSk7XHJcbiAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IG5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IEdvb2dsZUxheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtbGF5ZXInO1xyXG5pbXBvcnQgeyBHb29nbGVQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtcG9seWdvbic7XHJcbmltcG9ydCB7IEdvb2dsZVBvbHlsaW5lIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLWxheWVyJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUxheWVyQmFzZSB9IGZyb20gJy4vZ29vZ2xlLWxheWVyLWJhc2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHb29nbGVDb252ZXJzaW9ucyB9IGZyb20gJy4vZ29vZ2xlLWNvbnZlcnNpb25zJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi9nb29nbGUtbWFwLXR5cGVzJztcclxuXHJcbmRlY2xhcmUgdmFyIGdvb2dsZTogYW55O1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBMYXllclNlcnZpY2V9IGNvbnRyYWN0IGZvciBhIEdvb2dsZSBNYXBzIHNwZWNpZmljIGltcGxlbWVudGF0aW9uLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVMYXllclNlcnZpY2UgZXh0ZW5kcyBHb29nbGVMYXllckJhc2UgaW1wbGVtZW50cyBMYXllclNlcnZpY2UgIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBEZWNsYXJhdGlvbnMuXHJcbiAgICAvLy9cclxuICAgIHByb3RlY3RlZCBfbGF5ZXJzOiBNYXA8bnVtYmVyLCBQcm9taXNlPExheWVyPj4gPSBuZXcgTWFwPG51bWJlciwgUHJvbWlzZTxMYXllcj4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVMYXllclNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSBJbnN0YW5jZSBvZiB0aGUgR29vZ2xlIE1hcHMgU2VydmljZS4gV2lsbCBnZW5lcmFsbHkgYmUgaW5qZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgaW5zdGFuY2UgdG8gcHJvdmlkZSB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsIF96b25lOiBOZ1pvbmUpIHtcclxuICAgICAgICBzdXBlcihfbWFwU2VydmljZSwgX3pvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGxheWVyIHRvIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAgICogR2VuZXJhbGx5LCBNYXBMYXllckRpcmVjdGl2ZSB3aWxsIGJlIGluamVjdGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAgKiBMYXllclNlcnZpY2UgYW5kIHRoZW4gc2VsZiByZWdpc3RlciBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwOiBQcm9taXNlPExheWVyPiA9IG5ldyBQcm9taXNlPExheWVyPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuTWFwUHJvbWlzZS50aGVuKG0gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbDogR29vZ2xlTGF5ZXIgPSBuZXcgR29vZ2xlTGF5ZXIobSwgdGhpcy5fbWFwU2VydmljZSwgbGF5ZXIuSWQpO1xyXG4gICAgICAgICAgICAgICAgbC5TZXRWaXNpYmxlKGxheWVyLlZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJzLnNldChsYXllci5JZCwgcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWdvbiB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGluc3RhbmNlIG9mIHRoZSBQb2x5Z29uIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24obGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XHJcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxQb2x5Z29uPiA9IHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlUG9seWdvbihvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBsOiBQcm9taXNlPExheWVyPiA9IHRoaXMuX2xheWVycy5nZXQobGF5ZXIpO1xyXG4gICAgICAgIFByb21pc2UuYWxsKFtwLCBsXSkudGhlbih4ID0+IHhbMV0uQWRkRW50aXR5KHhbMF0pKTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5Z29ucy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWdvbnMgdG8gYmUgdXNlZCBpbiBidWxrXHJcbiAgICAgKiBvcGVyYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5Z29uIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlnb25zLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgUG9seWdvbiBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWdvbnMobGF5ZXI6IG51bWJlciwgb3B0aW9uczogQXJyYXk8SVBvbHlnb25PcHRpb25zPik6IFByb21pc2U8QXJyYXk8UG9seWdvbj4+IHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIE5vdGU6IHdlIGF0dGVtcHRlZCB1c2luZyBkYXRhLlBvbHlnb25zIGluIGFuIGF0dGVtcHQgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgYnV0IGVpdGhlciBkYXRhLlBvbHlnb25cclxuICAgICAgICAvLyBvciBkYXRhLk11bHRpUG9seWdvbiBhY3R1YWxseSBvcGVyYXRlIHNpZ25pZmljYW50bHkgc2xvd2VyIHRoYW4gZ2VuZXJhdGluZyB0aGUgcG9seWdvbnMgdGhpcyB3YXkuXHJcbiAgICAgICAgLy8gdGhlIHNsb3duZXNzIGluIGdvb2dsZSBhcyBvcHBvc2VkIHRvIGJpbmcgcHJvYmFibHkgY29tZXMgZnJvbSB0aGUgcG9pbnQgcmVkdWN0aW9uIGFsZ29yaXRobSB1c2VzLlxyXG4gICAgICAgIC8vIFNpZ25pZ2ljYW50IHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cyBtaWdodCBiZSBwb3NzaWJsZSBpbiBnb29nbGUgd2hlbiB1c2luZyBhIHBpeGVsIGJhc2VkIHJlZHVjdGlvbiBhbGdvcml0aG1cclxuICAgICAgICAvLyBwcmlvciB0byBzZXR0aW5nIHRoZSBwb2x5Z29uIHBhdGguIFRoaXMgd2lsbCBsb3dlciB0byBwcm9jZXNzaW5nIG92ZXJoZWFkIG9mIHRoZSBnb29nbGUgYWxnb3JpdGhtICh3aXRoIGlzIERvdWdsYXMtUGV1Y2tlclxyXG4gICAgICAgIC8vIGFuZCByYXRoZXIgY29tcHV0ZSBpbnRlbnNpdmUpXHJcbiAgICAgICAgLy9cclxuICAgICAgICBjb25zdCBwOiBQcm9taXNlPExheWVyPiA9IHRoaXMuR2V0TGF5ZXJCeUlkKGxheWVyKTtcclxuICAgICAgICBpZiAocCA9PSBudWxsKSB7IHRocm93IChuZXcgRXJyb3IoYExheWVyIHdpdGggaWQgJHtsYXllcn0gbm90IGZvdW5kIGluIExheWVyIE1hcGApKTsgfVxyXG4gICAgICAgIHJldHVybiBwLnRoZW4oKGw6IExheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvbHlnb25zOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PiA9IG5ldyBQcm9taXNlPEFycmF5PFBvbHlnb24+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2x5czogQXJyYXk8R29vZ2xlUG9seWdvbj4gPSBvcHRpb25zLm1hcChvID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcDogR29vZ2xlTWFwVHlwZXMuUG9seWdvbk9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5Z29uT3B0aW9ucyhvKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5OiBHb29nbGVNYXBUeXBlcy5Qb2x5Z29uID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlnb24ob3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvbHlnb246IEdvb2dsZVBvbHlnb24gPSBuZXcgR29vZ2xlUG9seWdvbihwb2x5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoby50aXRsZSAmJiBvLnRpdGxlICE9PSAnJykgeyBwb2x5Z29uLlRpdGxlID0gby50aXRsZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvLm1ldGFkYXRhKSB7IG8ubWV0YWRhdGEuZm9yRWFjaCgodmFsOiBhbnksIGtleTogc3RyaW5nKSA9PiBwb2x5Z29uLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocG9seXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25zO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHBvbHlsaW5lIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5bGluZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWxpbmUuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlsaW5lIChvciBhbiBhcnJheVxyXG4gICAgICogb2YgcG9seWdvbnMgZm9yIGNvbXBsZXggcGF0aHMpIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xyXG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiA9IHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlUG9seWxpbmUob3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgbDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLl9sYXllcnMuZ2V0KGxheWVyKTtcclxuICAgICAgICBQcm9taXNlLmFsbChbcCwgbF0pLnRoZW4oeCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHAxOiBBcnJheTxQb2x5bGluZT4gPSAgQXJyYXkuaXNBcnJheSh4WzBdKSA/IDxBcnJheTxQb2x5bGluZT4+eFswXSA6IFs8UG9seWxpbmU+eFswXV07XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcDIgb2YgcDEpIHt4WzFdLkFkZEVudGl0eShwMik7IH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5bGluZXMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIHBvbHlsaW5lcyB0byBiZSB1c2VkIGluIGJ1bGtcclxuICAgICAqIG9wZXJhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIHBvbHlsaW5lcy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWxpbmVzLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgUG9seWxpbmUgbW9kZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lcyhsYXllcjogbnVtYmVyLCBvcHRpb25zOiBBcnJheTxJUG9seWxpbmVPcHRpb25zPik6IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4ge1xyXG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5HZXRMYXllckJ5SWQobGF5ZXIpO1xyXG4gICAgICAgIGlmIChwID09IG51bGwpIHsgdGhyb3cgKG5ldyBFcnJvcihgTGF5ZXIgd2l0aCBpZCAke2xheWVyfSBub3QgZm91bmQgaW4gTGF5ZXIgTWFwYCkpOyB9XHJcbiAgICAgICAgcmV0dXJuIHAudGhlbigobDogTGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9seWxpbmVzOiBQcm9taXNlPEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+ID0gbmV3IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9seXM6IEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4gPSBvcHRpb25zLm1hcChvID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcDogR29vZ2xlTWFwVHlwZXMuUG9seWxpbmVPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWxpbmVPcHRpb25zKG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnBhdGggJiYgby5wYXRoLmxlbmd0aCA+IDAgJiYgIUFycmF5LmlzQXJyYXkoby5wYXRoWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5wYXRoID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMoby5wYXRoKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seTogR29vZ2xlTWFwVHlwZXMuUG9seWxpbmUgPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWxpbmUob3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5bGluZTogR29vZ2xlUG9seWxpbmUgPSBuZXcgR29vZ2xlUG9seWxpbmUocG9seSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnRpdGxlICYmIG8udGl0bGUgIT09ICcnKSB7IHBvbHlsaW5lLlRpdGxlID0gby50aXRsZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5tZXRhZGF0YSkgeyBvLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBvbHlsaW5lLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aHM6IEFycmF5PEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4+ID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMoby5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXM6IEFycmF5PFBvbHlsaW5lPiA9IG5ldyBBcnJheTxQb2x5bGluZT4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHMuZm9yRWFjaCh4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wLnBhdGggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seSA9IG5ldyBnb29nbGUubWFwcy5Qb2x5bGluZShvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5bGluZTogR29vZ2xlUG9seWxpbmUgPSBuZXcgR29vZ2xlUG9seWxpbmUocG9seSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5tZXRhZGF0YSkgeyBvLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBvbHlsaW5lLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnRpdGxlICYmIG8udGl0bGUgIT09ICcnKSB7cG9seWxpbmUuVGl0bGUgPSBvLnRpdGxlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHBvbHlsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocG9seXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lcztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTWFwQVBJTG9hZGVyLCBXaW5kb3dSZWYsIERvY3VtZW50UmVmIH0gZnJvbSAnLi4vbWFwYXBpbG9hZGVyJztcclxuXHJcbi8qKlxyXG4gKiBQcm90b2NvbCBlbnVtZXJhdGlvblxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqL1xyXG5leHBvcnQgZW51bSBTY3JpcHRQcm90b2NvbCB7XHJcbiAgICBIVFRQLFxyXG4gICAgSFRUUFMsXHJcbiAgICBBVVRPXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCaW5nIE1hcHMgVjggc3BlY2lmaWMgbG9hZGVyIGNvbmZpZ3VyYXRpb24gdG8gYmUgdXNlZCB3aXRoIHRoZSB7QGxpbmsgR29vZ2xlTWFwQVBJTG9hZGVyfVxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBBUElMb2FkZXJDb25maWcge1xyXG4gICAgLyoqXHJcbiAgICAgICAqIFRoZSBHb29nbGUgTWFwcyBBUEkgS2V5IChzZWU6XHJcbiAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L2dldC1hcGkta2V5KVxyXG4gICAgICAgKi9cclxuICAgIGFwaUtleT86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBHb29nbGUgTWFwcyBjbGllbnQgSUQgKGZvciBwcmVtaXVtIHBsYW5zKS5cclxuICAgICAqIFdoZW4geW91IGhhdmUgYSBHb29nbGUgTWFwcyBBUElzIFByZW1pdW0gUGxhbiBsaWNlbnNlLCB5b3UgbXVzdCBhdXRoZW50aWNhdGVcclxuICAgICAqIHlvdXIgYXBwbGljYXRpb24gd2l0aCBlaXRoZXIgYW4gQVBJIGtleSBvciBhIGNsaWVudCBJRC5cclxuICAgICAqIFRoZSBHb29nbGUgTWFwcyBBUEkgd2lsbCBmYWlsIHRvIGxvYWQgaWYgYm90aCBhIGNsaWVudCBJRCBhbmQgYW4gQVBJIGtleSBhcmUgaW5jbHVkZWQuXHJcbiAgICAgKi9cclxuICAgIGNsaWVudElkPzogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIEdvb2dsZSBNYXBzIGNoYW5uZWwgbmFtZSAoZm9yIHByZW1pdW0gcGxhbnMpLlxyXG4gICAgICogQSBjaGFubmVsIHBhcmFtZXRlciBpcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBhbGxvd3MgeW91IHRvIHRyYWNrIHVzYWdlIHVuZGVyIHlvdXIgY2xpZW50XHJcbiAgICAgKiBJRCBieSBhc3NpZ25pbmcgYSBkaXN0aW5jdCBjaGFubmVsIHRvIGVhY2ggb2YgeW91ciBhcHBsaWNhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGNoYW5uZWw/OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHb29nbGUgTWFwcyBBUEkgdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgYXBpVmVyc2lvbj86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvc3QgYW5kIFBhdGggdXNlZCBmb3IgdGhlIGA8c2NyaXB0PmAgdGFnLlxyXG4gICAgICovXHJcbiAgICBob3N0QW5kUGF0aD86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3RvY29sIHVzZWQgZm9yIHRoZSBgPHNjcmlwdD5gIHRhZy5cclxuICAgICAqL1xyXG4gICAgcHJvdG9jb2w/OiBTY3JpcHRQcm90b2NvbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgd2hpY2ggR29vZ2xlIE1hcHMgbGlicmFyaWVzIHNob3VsZCBnZXQgbG9hZGVkLlxyXG4gICAgICovXHJcbiAgICBsaWJyYXJpZXM/OiBzdHJpbmdbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IGJpYXMgZm9yIHRoZSBtYXAgYmVoYXZpb3IgaXMgVVMuXHJcbiAgICAgKiBJZiB5b3Ugd2lzaCB0byBhbHRlciB5b3VyIGFwcGxpY2F0aW9uIHRvIHNlcnZlIGRpZmZlcmVudCBtYXAgdGlsZXMgb3IgYmlhcyB0aGVcclxuICAgICAqIGFwcGxpY2F0aW9uLCB5b3UgY2FuIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBiZWhhdmlvciAoVVMpIGJ5IGRlZmluaW5nIGEgYHJlZ2lvbmAuXHJcbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvYmFzaWNzI1JlZ2lvblxyXG4gICAgICovXHJcbiAgICByZWdpb24/OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgR29vZ2xlIE1hcHMgQVBJIHVzZXMgdGhlIGJyb3dzZXIncyBwcmVmZXJyZWQgbGFuZ3VhZ2Ugd2hlbiBkaXNwbGF5aW5nXHJcbiAgICAgKiB0ZXh0dWFsIGluZm9ybWF0aW9uLiBJZiB5b3Ugd2lzaCB0byBvdmVyd3JpdGUgdGhpcyBiZWhhdmlvciBhbmQgZm9yY2UgdGhlIEFQSVxyXG4gICAgICogdG8gdXNlIGEgZ2l2ZW4gbGFuZ3VhZ2UsIHlvdSBjYW4gdXNlIHRoaXMgc2V0dGluZy5cclxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9iYXNpY3MjTGFuZ3VhZ2VcclxuICAgICAqL1xyXG4gICAgbGFuZ3VhZ2U/OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgR29vZ2xlIE1hcHMgQVBJIHJlcXVpcmVzIGEgc2VwYXJhdGUgbGlicmFyeSBmb3IgY2x1c3RlcmluZy4gU2V0IHRoZSBwcm9wZXJ0eVxyXG4gICAgICogdG8gdHJ1ZSBpbiBvcmRlciB0byBsb2FkIHRoaXMgbGlicmFyeS5cclxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9tYXJrZXItY2x1c3RlcmluZ1xyXG4gICAgICovXHJcbiAgICBlbmFibGVDbHVzdGVyaW5nPzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvc3QgYW5kIFBhdGggdXNlZCBmb3IgdGhlIGNsdXN0ZXIgbGlicmFyeSBgPHNjcmlwdD5gIHRhZy5cclxuICAgICAqL1xyXG4gICAgY2x1c3Rlckhvc3RBbmRQYXRoPzogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBsb2FkZXIgY29uZmlndXJhdGlvbi5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfQ09ORklHVVJBVElPTiA9IG5ldyBHb29nbGVNYXBBUElMb2FkZXJDb25maWcoKTtcclxuXHJcbi8qKlxyXG4gKiBCaW5nIE1hcHMgVjggaW1wbGVtZW50YXRpb24gZm9yIHRoZSB7QGxpbmsgTWFwQVBJTG9hZGVyfSBzZXJ2aWNlLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBBUElMb2FkZXIgZXh0ZW5kcyBNYXBBUElMb2FkZXIge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlZmludGl0aW9ucy5cclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfc2NyaXB0TG9hZGluZ1Byb21pc2U6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVjbGFyYXRpb25zLlxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsb2FkZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBBUElMb2FkZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBDb25maWcoKTogR29vZ2xlTWFwQVBJTG9hZGVyQ29uZmlnIHsgcmV0dXJuIHRoaXMuX2NvbmZpZzsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVNYXBBUElMb2FkZXIuXHJcbiAgICAgKiBAcGFyYW0gX2NvbmZpZyAtIFRoZSBsb2FkZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSBfd2luZG93UmVmIC0gQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFdpbmRvd1JlZn0uIE5lY2Vzc2FyeSBiZWNhdXNlIEJpbmcgTWFwIFY4IGludGVyYWN0cyB3aXRoIHRoZSB3aW5kb3cgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIF9kb2N1bWVudFJlZiAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBEb2N1bWVudFJlZn0uXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZWNlc3NhcnkgYmVjYXVzZSBCaW5nIE1hcCBWOCBpbnRlcmFjdHMgd2l0aCB0aGUgZG9jdW1lbnQgb2JqZWN0LlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcEFQSUxvYWRlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciggQE9wdGlvbmFsKCkgcHJpdmF0ZSBfY29uZmlnOiBHb29nbGVNYXBBUElMb2FkZXJDb25maWcsIHByaXZhdGUgX3dpbmRvd1JlZjogV2luZG93UmVmLCBwcml2YXRlIF9kb2N1bWVudFJlZjogRG9jdW1lbnRSZWYpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcgPT09IG51bGwgfHwgdGhpcy5fY29uZmlnID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29uZmlnID0gREVGQVVMVF9DT05GSUdVUkFUSU9OO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kcyBhbmQgTWFwQVBJTG9hZGVyIGltcGxlbWVudGF0aW9uLlxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyB0aGUgbmVjZXNzYXJ5IHJlc291cmNlcyBmb3IgQmluZyBNYXBzIFY4LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBBUElMb2FkZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIExvYWQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IHRoaXMuX2RvY3VtZW50UmVmLkdldE5hdGl2ZURvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcclxuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xyXG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tOYW1lID0gYENyZWF0ZWA7XHJcbiAgICAgICAgc2NyaXB0LnNyYyA9IHRoaXMuR2V0TWFwc1NjcmlwdFNyYyhjYWxsYmFja05hbWUpO1xyXG5cclxuICAgICAgICB0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlOiBGdW5jdGlvbiwgcmVqZWN0OiBGdW5jdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAoPGFueT50aGlzLl93aW5kb3dSZWYuR2V0TmF0aXZlV2luZG93KCkpW2NhbGxiYWNrTmFtZV0gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29uZmlnLmVuYWJsZUNsdXN0ZXJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQgdGhlbiBkZWxheSB0aGUgbG9hZGluZyB1bnRpbCBhZnRlciB0aGUgY2x1c3RlciBsaWJyYXJ5IGlzIGxvYWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXJTY3JpcHQgPSB0aGlzLl9kb2N1bWVudFJlZi5HZXROYXRpdmVEb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJTY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJTY3JpcHQuc3JjID0gdGhpcy5HZXRDbHVzdGVyU2NyaXB0U3JjKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlclNjcmlwdC5vbmxvYWQgPSBjbHVzdGVyU2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWYuR2V0TmF0aXZlRG9jdW1lbnQoKS5oZWFkLmFwcGVuZENoaWxkKGNsdXN0ZXJTY3JpcHQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gKGVycm9yOiBFdmVudCkgPT4geyByZWplY3QoZXJyb3IpOyB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2RvY3VtZW50UmVmLkdldE5hdGl2ZURvY3VtZW50KCkuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIEdvb2dsZSBNYXBzIHNjcmlwdHMgdXJsIGZvciBpbmplY3Rpb25zIGludG8gdGhlIGhlYWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tOYW1lIC0gTmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIEdvb2dsZSBNYXBzIHNjcmlwdHMgYXJlIGxvYWRlZC5cclxuICAgICAqIEByZXR1cm5zIC0gVGhlIHVybCB0byBiZSB1c2VkIHRvIGxvYWQgdGhlIEdvb2dsZSBNYXAgc2NyaXB0cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgR2V0TWFwc1NjcmlwdFNyYyhjYWxsYmFja05hbWU6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IGhvc3RBbmRQYXRoOiBzdHJpbmcgPSB0aGlzLl9jb25maWcuaG9zdEFuZFBhdGggfHwgJ21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanMnO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfSA9IHtcclxuICAgICAgICAgICAgdjogdGhpcy5fY29uZmlnLmFwaVZlcnNpb24sXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja05hbWUsXHJcbiAgICAgICAgICAgIGtleTogdGhpcy5fY29uZmlnLmFwaUtleSxcclxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLl9jb25maWcuY2xpZW50SWQsXHJcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMuX2NvbmZpZy5jaGFubmVsLFxyXG4gICAgICAgICAgICBsaWJyYXJpZXM6IHRoaXMuX2NvbmZpZy5saWJyYXJpZXMsXHJcbiAgICAgICAgICAgIHJlZ2lvbjogdGhpcy5fY29uZmlnLnJlZ2lvbixcclxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHRoaXMuX2NvbmZpZy5sYW5ndWFnZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuR2V0U2NyaXB0U3JjKGhvc3RBbmRQYXRoLCBxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBHb29nbGUgTWFwcyBDbHVzdGVyIGxpYnJhcnkgdXJsIGZvciBpbmplY3Rpb25zIGludG8gdGhlIGhlYWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSB1cmwgdG8gYmUgdXNlZCB0byBsb2FkIHRoZSBHb29nbGUgTWFwIENsdXN0ZXIgbGlicmFyeS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgR2V0Q2x1c3RlclNjcmlwdFNyYygpIHtcclxuICAgICAgICBjb25zdCBob3N0QW5kUGF0aDogc3RyaW5nID0gdGhpcy5fY29uZmlnLmNsdXN0ZXJIb3N0QW5kUGF0aCB8fFxyXG4gICAgICAgICAgICAnZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L2V4YW1wbGVzL21hcmtlcmNsdXN0ZXJlci9tYXJrZXJjbHVzdGVyZXIuanMnO1xyXG4gICAgICAgIHJldHVybiB0aGlzLkdldFNjcmlwdFNyYyhob3N0QW5kUGF0aCwge30pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHNjcmlwdHMgdXJsIGZvciBpbmplY3Rpb25zIGludG8gdGhlIGhlYWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaG9zdEFuZFBhdGggLSBIb3N0IGFuZCBwYXRoIG5hbWUgb2YgdGhlIHNjcmlwdCB0byBsb2FkLlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5UGFyYW1zIC0gVXJsIHF1ZXJ5IHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSB1cmwgd2l0aCBjb3JyZWN0IHByb3RvY29sLCBwYXRoLCBhbmQgcXVlcnkgcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgR2V0U2NyaXB0U3JjKGhvc3RBbmRQYXRoOiBzdHJpbmcsIHF1ZXJ5UGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfSk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2xUeXBlOiBTY3JpcHRQcm90b2NvbCA9XHJcbiAgICAgICAgICAgIDxTY3JpcHRQcm90b2NvbD4oKHRoaXMuX2NvbmZpZyAmJiB0aGlzLl9jb25maWcucHJvdG9jb2wpIHx8IFNjcmlwdFByb3RvY29sLkhUVFBTKTtcclxuICAgICAgICBsZXQgcHJvdG9jb2w6IHN0cmluZztcclxuXHJcbiAgICAgICAgc3dpdGNoIChwcm90b2NvbFR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBTY3JpcHRQcm90b2NvbC5BVVRPOlxyXG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFNjcmlwdFByb3RvY29sLkhUVFA6XHJcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9ICdodHRwOic7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTY3JpcHRQcm90b2NvbC5IVFRQUzpcclxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJ2h0dHBzOic7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBhcmFtczogc3RyaW5nID1cclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocXVlcnlQYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChrOiBzdHJpbmcpID0+IHF1ZXJ5UGFyYW1zW2tdICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChrOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHF1ZXJ5UGFyYW1zW2tdKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShxdWVyeVBhcmFtc1trXSkgJiYgcXVlcnlQYXJhbXNba10ubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoazogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gam9pbiBhcnJheXMgYXMgY29tbWEgc2VwZXJhdGVkIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpID0gcXVlcnlQYXJhbXNba107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrLCB2YWx1ZTogaS5qb2luKCcsJykgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrLCB2YWx1ZTogcXVlcnlQYXJhbXNba10gfTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAubWFwKChlbnRyeTogeyBrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB9KSA9PiB7IHJldHVybiBgJHtlbnRyeS5rZXl9PSR7ZW50cnkudmFsdWV9YDsgfSlcclxuICAgICAgICAgICAgICAgIC5qb2luKCcmJyk7XHJcbiAgICAgICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0QW5kUGF0aH0/JHtwYXJhbXN9YDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcclxuaW1wb3J0IHsgTWFwTWFya2VyRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9tYXAtbWFya2VyJztcclxuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4uL21hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5pbXBvcnQgeyBHb29nbGVDb252ZXJzaW9ucyB9IGZyb20gJy4vZ29vZ2xlLWNvbnZlcnNpb25zJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTWFya2VyU2VydmljZSBhYnN0cmFjdCBjbGFzcyBmb3IgR29vZ2xlLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXJrZXJTZXJ2aWNlIGltcGxlbWVudHMgTWFya2VyU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX21hcmtlcnM6IE1hcDxNYXBNYXJrZXJEaXJlY3RpdmUsIFByb21pc2U8TWFya2VyPj4gPSBuZXcgTWFwPE1hcE1hcmtlckRpcmVjdGl2ZSwgUHJvbWlzZTxNYXJrZXI+PigpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlTWFya2VyU2VydmljZS5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbnN0YW5jZS5cclxuICAgICAqIFRoZSBjb25jcmV0ZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyU2VydmljZSAtIHtAbGluayBMYXllclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBHb29nbGVMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF9jbHVzdGVyU2VydmljZSAtIHtAbGluayBDbHVzdGVyU2VydmljZX0gaW5zdGFuY2UuXHJcbiAgICAgKiBUaGUgY29uY3JldGUge0BsaW5rIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBpcyBleHBlY3RlZC5cclxuICAgICAqIEBwYXJhbSBfem9uZSAtIE5nWm9uZSBpbnN0YW5jZSB0byBzdXBwb3J0IHpvbmUgYXdhcmUgcHJvbWlzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF9sYXllclNlcnZpY2U6IExheWVyU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF9jbHVzdGVyU2VydmljZTogQ2x1c3RlclNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbWFya2VyLiBEZXBlbmRpbmcgb24gdGhlIG1hcmtlciBjb250ZXh0LCB0aGUgbWFya2VyIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYSBjb3JyZWNzcG9uZGluZyBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZE1hcmtlcihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IElNYXJrZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBhbmNob3I6IG1hcmtlci5BbmNob3IsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IGxhdGl0dWRlOiBtYXJrZXIuTGF0aXR1ZGUsIGxvbmdpdHVkZTogbWFya2VyLkxvbmdpdHVkZSB9LFxyXG4gICAgICAgICAgICB0aXRsZTogbWFya2VyLlRpdGxlLFxyXG4gICAgICAgICAgICBsYWJlbDogbWFya2VyLkxhYmVsLFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IG1hcmtlci5EcmFnZ2FibGUsXHJcbiAgICAgICAgICAgIGljb246IG1hcmtlci5JY29uVXJsLFxyXG4gICAgICAgICAgICBpY29uSW5mbzogbWFya2VyLkljb25JbmZvLFxyXG4gICAgICAgICAgICB3aWR0aDogbWFya2VyLldpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IG1hcmtlci5IZWlnaHQsXHJcbiAgICAgICAgICAgIGlzRmlyc3Q6IG1hcmtlci5Jc0ZpcnN0SW5TZXQsXHJcbiAgICAgICAgICAgIGlzTGFzdDogbWFya2VyLklzTGFzdEluU2V0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIG1hcmtlciB2aWEgcHJvbWlzZS5cclxuICAgICAgICBsZXQgbWFya2VyUHJvbWlzZTogUHJvbWlzZTxNYXJrZXI+ID0gbnVsbDtcclxuICAgICAgICBpZiAobWFya2VyLkluQ2x1c3RlckxheWVyKSB7XHJcbiAgICAgICAgICAgIG1hcmtlclByb21pc2UgPSB0aGlzLl9jbHVzdGVyU2VydmljZS5DcmVhdGVNYXJrZXIobWFya2VyLkxheWVySWQsIG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXJrZXIuSW5DdXN0b21MYXllcikge1xyXG4gICAgICAgICAgICBtYXJrZXJQcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkNyZWF0ZU1hcmtlcihtYXJrZXIuTGF5ZXJJZCwgbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtYXJrZXJQcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVNYXJrZXIobyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9tYXJrZXJzLnNldChtYXJrZXIsIG1hcmtlclByb21pc2UpO1xyXG4gICAgICAgIGlmIChtYXJrZXIuSWNvbkluZm8pIHtcclxuICAgICAgICAgICAgbWFya2VyUHJvbWlzZS50aGVuKChtOiBNYXJrZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBpY29uSW5mbyB0byBwcm92aWRlIGhvb2sgdG8gZG8gcG9zdCBpY29uIGNyZWF0aW9uIGFjdGl2aXRpZXMgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBhbHNvIHJlLWFuY2hvciB0aGUgbWFya2VyXHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuRHluYW1pY01hcmtlckNyZWF0ZWQuZW1pdChvLmljb25JbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHA6IElQb2ludCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiAoby5pY29uSW5mby5zaXplICYmIG8uaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8pID8gKG8uaWNvbkluZm8uc2l6ZS53aWR0aCAqIG8uaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8ueCkgOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IChvLmljb25JbmZvLnNpemUgJiYgby5pY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoby5pY29uSW5mby5zaXplLmhlaWdodCAqIG8uaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8ueSkgOiAwLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIG0uU2V0QW5jaG9yKHApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgZGVsZWdhdGUgZm9yIGEgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IE9ic2VydmFibGU8VD4ge1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBtLkFkZExpc3RlbmVyKGV2ZW50TmFtZSwgKGU6IFQpID0+IHRoaXMuX3pvbmUucnVuKCgpID0+IG9ic2VydmVyLm5leHQoZSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGEgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSB0byBiZSBkZWxldGVkLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBtYXJrZXIgaGFzIGJlZW4gZGVsZXRlZC5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVNYXJrZXIobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKTtcclxuICAgICAgICBpZiAobSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG0udGhlbigobWE6IE1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWFya2VyLkluQ2x1c3RlckxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbHVzdGVyU2VydmljZS5HZXROYXRpdmVMYXllcihtYXJrZXIuTGF5ZXJJZCkudGhlbihsID0+IHsgbC5SZW1vdmVFbnRpdHkobWEpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFya2VyLkluQ3VzdG9tTGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyU2VydmljZS5HZXROYXRpdmVMYXllcihtYXJrZXIuTGF5ZXJJZCkudGhlbihsID0+IHsgbC5SZW1vdmVFbnRpdHkobWEpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbWEuRGVsZXRlTWFya2VyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJzLmRlbGV0ZShtYXJrZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgZ2VvIGNvb3JkaW5hdGVzIGZvciB0aGUgbWFya2VyIG9uIHRoZSBjbGljayBsb2NhdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBtYXJrZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZTogTW91c2VFdmVudCB8IGFueSk6IElMYXRMb25nIHtcclxuICAgICAgICBpZiAoIWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZS5sYXRMbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZS5sYXRMbmcubGF0IHx8ICFlLmxhdExuZy5sbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiBlLmxhdExuZy5sYXQoKSwgbG9uZ2l0dWRlOiBlLmxhdExuZy5sbmcoKSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgbWFya2VyIG1vZGVsIGZvciB0aGUgbWFya2VyIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcmtlciAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gb2J0YWluIHRoZSBtYXJrZXIgbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIE1hcmtlcn0gaW1wbGVtZW50YXRpb24gb2YgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm0uXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TmF0aXZlTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTxNYXJrZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIG1hcmtlciBwaXhlbCBsb2NhdGlvbiBmb3IgdGhlIG1hcmtlciBvbiB0aGUgY2xpY2sgbG9jYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElMYXRMb25nfSBjb250YWluaW5nIHRoZSBwaXhlbHMgb2YgdGhlIG1hcmtlciBvbiB0aGUgbWFwIGNhbnZhcy5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRQaXhlbHNGcm9tQ2xpY2soZTogTW91c2VFdmVudCB8IGFueSk6IElQb2ludCB7XHJcbiAgICAgICAgaWYgKCFlIHx8ICFlLmxhdExuZyB8fCAhZS5sYXRMbmcubGF0IHx8ICFlLmxhdExuZy5sbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9tYXBTZXJ2aWNlLk1hcEluc3RhbmNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY3Jvc3Nlc0RhdGVMaW5lOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX21hcFNlcnZpY2UuTWFwSW5zdGFuY2U7XHJcbiAgICAgICAgY29uc3QgcCA9IG0uZ2V0UHJvamVjdGlvbigpO1xyXG4gICAgICAgIGNvbnN0IHM6IG51bWJlciA9IE1hdGgucG93KDIsIG0uZ2V0Wm9vbSgpKTtcclxuICAgICAgICBjb25zdCBiOiBHb29nbGVNYXBUeXBlcy5MYXRMbmdCb3VuZHMgPSBtLmdldEJvdW5kcygpO1xyXG4gICAgICAgIGlmIChiLmdldENlbnRlcigpLmxuZygpIDwgYi5nZXRTb3V0aFdlc3QoKS5sbmcoKSAgfHxcclxuICAgICAgICAgICAgYi5nZXRDZW50ZXIoKS5sbmcoKSA+IGIuZ2V0Tm9ydGhFYXN0KCkubG5nKCkpIHsgY3Jvc3Nlc0RhdGVMaW5lID0gdHJ1ZTsgfVxyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXRZOiBudW1iZXIgPSBwLmZyb21MYXRMbmdUb1BvaW50KGIuZ2V0Tm9ydGhFYXN0KCkpLnk7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0WDogbnVtYmVyID0gcC5mcm9tTGF0TG5nVG9Qb2ludChiLmdldFNvdXRoV2VzdCgpKS54O1xyXG4gICAgICAgIGNvbnN0IHBvaW50OiBHb29nbGVNYXBUeXBlcy5Qb2ludCA9IHAuZnJvbUxhdExuZ1RvUG9pbnQoZS5sYXRMbmcpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3IoKHBvaW50LnggLSBvZmZzZXRYICsgKChjcm9zc2VzRGF0ZUxpbmUgJiYgcG9pbnQueCA8IG9mZnNldFgpID8gMjU2IDogMCkpICogcyksXHJcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoKHBvaW50LnkgLSBvZmZzZXRZKSAqIHMpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgZ2VvIGxvY2F0aW9uIHRvIGEgcGl4ZWwgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIG1hcCBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCAtIEVpdGhlciBhIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9XHJcbiAgICAgKiBvciBhIHtAbGluayBJTGF0TG9uZ30gZm9yIHRoZSBiYXNpcyBvZiB0cmFuc2xhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIGEge0BsaW5rIElQb2ludH1cclxuICAgICAqIHdpdGggdGhlIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSBNYXBNYXJrZXIgb3IgSUxhdExvbmcgcmVsYXRpdmUgdG8gdGhlIG1hcCBjYW52YXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgTG9jYXRpb25Ub1BvaW50KHRhcmdldDogTWFwTWFya2VyRGlyZWN0aXZlIHwgSUxhdExvbmcpOiBQcm9taXNlPElQb2ludD4ge1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwTWFya2VyRGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldCh0YXJnZXQpLnRoZW4oKG06IE1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbDogSUxhdExvbmcgPSBtLkxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDogUHJvbWlzZTxJUG9pbnQ+ID0gdGhpcy5fbWFwU2VydmljZS5Mb2NhdGlvblRvUG9pbnQobCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBTZXJ2aWNlLkxvY2F0aW9uVG9Qb2ludCh0YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYW5jaG9yIHBvc2l0aW9uIGZvciB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBhbmNob3IuXHJcbiAgICAgKiBBbmNob3IgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgYW5jaG9yIHBvc2l0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVXBkYXRlQW5jaG9yKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgIG0uU2V0QW5jaG9yKG1hcmtlci5BbmNob3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB3aGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIGRyYWdhYmlsaXR5LlxyXG4gICAgICogRHJhZ2FiaWxpdHkgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbWFya2VyIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVXBkYXRlRHJhZ2dhYmxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiBtLlNldERyYWdnYWJsZShtYXJrZXIuRHJhZ2dhYmxlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBJY29uIG9uIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIGljb24uIEljb24gaW5mb3JtYXRpb24gaXMgcHJlc2VudFxyXG4gICAgICogaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGljb24gaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVJY29uKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtYXJrZXIuSWNvbkluZm8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHg6IElNYXJrZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IGxhdGl0dWRlOiBtYXJrZXIuTGF0aXR1ZGUsIGxvbmdpdHVkZTogbWFya2VyLkxvbmdpdHVkZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGljb25JbmZvOiBtYXJrZXIuSWNvbkluZm9cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFya2VyT3B0aW9ucyh4KTtcclxuICAgICAgICAgICAgICAgIG0uU2V0SWNvbihvLmljb24pO1xyXG4gICAgICAgICAgICAgICAgbWFya2VyLkR5bmFtaWNNYXJrZXJDcmVhdGVkLmVtaXQoeC5pY29uSW5mbyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtLlNldEljb24obWFya2VyLkljb25VcmwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgbGFiZWwgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgbGFiZWwuXHJcbiAgICAgKiBMYWJlbCBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBsYWJlbCBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFVwZGF0ZUxhYmVsKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiB7IG0uU2V0TGFiZWwobWFya2VyLkxhYmVsKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQ29vcmRpbmF0ZSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBwb3NpdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFVwZGF0ZU1hcmtlclBvc2l0aW9uKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihcclxuICAgICAgICAgICAgKG06IE1hcmtlcikgPT4gbS5TZXRQb3NpdGlvbih7XHJcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogbWFya2VyLkxhdGl0dWRlLFxyXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBtYXJrZXIuTG9uZ2l0dWRlXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHRpdGxlIG9uIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIHRpdGxlLlxyXG4gICAgICogVGl0bGUgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgdGl0bGUgaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVUaXRsZShtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4gbS5TZXRUaXRsZShtYXJrZXIuVGl0bGUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZpc2liaWxpdHkgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgdGl0bGUuXHJcbiAgICAgKiBUaXRsZSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSB0aXRsZSBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFVwZGF0ZVZpc2libGUobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IG0uU2V0VmlzaWJsZShtYXJrZXIuVmlzaWJsZSkpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBHb29nbGVNYXJrZXIgfSBmcm9tICcuL2dvb2dsZS1tYXJrZXInO1xyXG5pbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2xheWVyJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbWFya2VyJztcclxuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgQ2x1c3RlclBsYWNlbWVudE1vZGUgfSBmcm9tICcuLi9jbHVzdGVyLXBsYWNlbWVudC1tb2RlJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5pbXBvcnQgeyB0aW1lciB9IGZyb20gJ3J4anMnO1xyXG5cclxuLyoqXHJcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIGEgY2x1c3RlcmluZyBsYXllciBmb3IgdGhlIEdvb2dsZSBNYXAgUHJvdmlkZXIuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXJrZXJDbHVzdGVyZXIgaW1wbGVtZW50cyBMYXllciB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2lzQ2x1c3RlcmluZyA9IHRydWU7XHJcbiAgICBwcml2YXRlIF9tYXJrZXJMb29rdXA6IE1hcDxHb29nbGVNYXBUeXBlcy5NYXJrZXIsIE1hcmtlcj4gPSBuZXcgTWFwPEdvb2dsZU1hcFR5cGVzLk1hcmtlciwgTWFya2VyPigpO1xyXG4gICAgcHJpdmF0ZSBfbWFya2VyczogQXJyYXk8TWFya2VyPiA9IG5ldyBBcnJheTxNYXJrZXI+KCk7XHJcbiAgICBwcml2YXRlIF9wZW5kaW5nTWFya2VyczogQXJyYXk8TWFya2VyPiA9IG5ldyBBcnJheTxNYXJrZXI+KCk7XHJcbiAgICBwcml2YXRlIF9tYXBjbGlja3M6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIF9jdXJyZW50Wm9vbTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgX3Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbmF0aXZlIHByaW1pdGl2ZSB1bmRlcm5lYXRoIHRoZSBhYnN0cmFjdGlvbiBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBHb29nbGVNYXBUeXBlcy5NYXJrZXJDbHVzdGVyZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlckNsdXN0ZXJlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IEdvb2dsZU1hcFR5cGVzLk1hcmtlckNsdXN0ZXJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEdvb2dsZU1hcmtlckNsdXN0ZXJlciBjbGFzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyIEdvb2dsZU1hcFR5cGVzLk1hcmtlckNsdXN0ZXJlci4gTmF0aXZlIEdvb2dsZSBNYXBzIE1hcmtlciBDbHVzdGVyZXIgc3VwcG9ydGluZyB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqIEBwYXJhbSBfbWFwcyBNYXBTZXJ2aWNlLiBNYXBTZXJ2aWNlIGltcGxlbWVudGF0aW9uIHRvIGxldmVyYWdlIGZvciB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlckNsdXN0ZXJlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sYXllcjogR29vZ2xlTWFwVHlwZXMuTWFya2VyQ2x1c3RlcmVyKSB7IH1cclxuXHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHMsIExheWVyIGludGVyZmFjZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSBzdHJpbmcuIFR5cGUgb2YgZXZlbnQgdG8gYWRkIChjbGljaywgbW91c2VvdmVyLCBldGMpLiBZb3UgY2FuIHVzZSBhbnkgZXZlbnQgdGhhdCB0aGUgdW5kZXJseWluZyBuYXRpdmVcclxuICAgICAqIGxheWVyIHN1cHBvcnRzLlxyXG4gICAgICogQHBhcmFtIGZuIGZ1bmN0aW9uLiBIYW5kbGVyIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdFdmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gR29vZ2xlIENsdXN0ZXIgTGF5ZXJzLiBZb3UgY2FuIHN0aWxsIGFkZCBldmVudHMgdG8gaW5kaXZpZHVhbCBtYXJrZXJzLicpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZW50aXR5IHRvIHRoZSBsYXllci4gVXNlIHRoaXMgbWV0aG9kIHdpdGggY2F1dGlvbiBhcyBpdCB3aWxsXHJcbiAgICAgKiB0cmlnZ2VyIGEgcmVjYWx1YXRpb24gb2YgdGhlIGNsdXN0ZXJzIChhbmQgYXNzb2NpYXRlZCBtYXJrZXJzIGlmIGFwcHJvcHJpdGUpIGZvclxyXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBJZiB5b3UgdXNlIHRoaXMgbWV0aG9kIHRvIGFkZCBtYW55IG1hcmtlcnMgdG8gdGhlIGNsdXN0ZXIsIHVzZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyLiBFbnRpdHkgdG8gYWRkIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRFbnRpdHkoZW50aXR5OiBNYXJrZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaXNNYXJrZXI6IGJvb2xlYW4gPSBlbnRpdHkgaW5zdGFuY2VvZiBNYXJrZXI7XHJcbiAgICAgICAgaXNNYXJrZXIgPSBlbnRpdHkgaW5zdGFuY2VvZiBHb29nbGVNYXJrZXIgfHwgaXNNYXJrZXI7XHJcbiAgICAgICAgaWYgKGlzTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGVudGl0eS5OYXRpdmVQcmltaXR2ZS5zZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBtYXAgYXMgdGhlIGNsdXN0ZXJlciB3aWxsIGNvbnRyb2wgbWFya2VyIHZpc2liaWxpdHkuXHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkuSXNGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5TdG9wQ2x1c3RlcmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbnRpdHkuTmF0aXZlUHJpbWl0dmUgJiYgZW50aXR5LkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NsdXN0ZXJpbmcgJiYgdGhpcy5fdmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuYWRkTWFya2VyKGVudGl0eS5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJzLnB1c2goZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdNYXJrZXJzLnB1c2goZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJMb29rdXAuc2V0KGVudGl0eS5OYXRpdmVQcmltaXR2ZSwgZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkuSXNMYXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXJ0Q2x1c3RlcmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG51bWJlciBvZiBtYXJrZXJzIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyPi4gRW50aXRpZXMgdG8gYWRkIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRFbnRpdGllcyhlbnRpdGllczogQXJyYXk8TWFya2VyPik6IHZvaWQge1xyXG4gICAgICAgIGlmIChlbnRpdGllcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoZW50aXRpZXMpICYmIGVudGl0aWVzLmxlbmd0aCAhPT0gMCApIHtcclxuICAgICAgICAgICAgY29uc3QgZTogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTWFya2VyPiA9IGVudGl0aWVzLm1hcChwID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlckxvb2t1cC5zZXQocC5OYXRpdmVQcmltaXR2ZSwgcCk7XHJcbiAgICAgICAgICAgICAgICBwLk5hdGl2ZVByaW1pdHZlLnNldE1hcChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBtYXAgYXMgdGhlIGNsdXN0ZXJlciB3aWxsIGNvbnRyb2wgbWFya2VyIHZpc2liaWxpdHkuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5OYXRpdmVQcmltaXR2ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NsdXN0ZXJpbmcgJiYgdGhpcy5fdmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuYWRkTWFya2VycyhlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaCguLi5lbnRpdGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBsYXllciBpcyBub3QgdmlzaWJsZSwgYWx3YXlzIGFkZCB0byBwZW5kaW5nTWFya2Vycy4gU2V0dGluZyB0aGUgbGF5ZXIgdG8gdmlzaWJsZSBsYXRlclxyXG4gICAgICAgICAgICAgICAgLy8gd2lsbCByZW5kZXIgdGhlIG1hcmtlcnMgYXBwcm9wcmlhdGVseVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMucHVzaCguLi5lbnRpdGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSBjbHVzdGVyaW5nIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9sYXllci5nZXRNYXJrZXJzKCkuZm9yRWFjaChtID0+IHtcclxuICAgICAgICAgICAgbS5zZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBtYXAgYXMgdGhlIGNsdXN0ZXJlciB3aWxsIGNvbnRyb2wgbWFya2VyIHZpc2liaWxpdHkuXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXIuY2xlYXJNYXJrZXJzKCk7XHJcbiAgICAgICAgdGhpcy5fbWFya2Vycy5zcGxpY2UoMCk7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMuc3BsaWNlKDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYWJzdHJhY3QgbWFya2VyIHVzZWQgdG8gd3JhcCB0aGUgR29vZ2xlIE1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBNYXJrZXIuIFRoZSBhYnN0cmFjdCBtYXJrZXIgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcHVzaHBpbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRNYXJrZXJGcm9tR29vZ2xlTWFya2VyKHBpbjogR29vZ2xlTWFwVHlwZXMuTWFya2VyKTogTWFya2VyIHtcclxuICAgICAgICBjb25zdCBtOiBNYXJrZXIgPSB0aGlzLl9tYXJrZXJMb29rdXAuZ2V0KHBpbik7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIGdvdmVybmluZyB0aGUgYmVoYXZpb3Igb2YgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIElDbHVzdGVyT3B0aW9ucy4gVGhlIGxheWVyIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlckNsdXN0ZXJlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0T3B0aW9ucygpOiBJQ2x1c3Rlck9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IElDbHVzdGVyT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgaWQ6IDAsXHJcbiAgICAgICAgICAgIGdyaWRTaXplOiB0aGlzLl9sYXllci5nZXRHcmlkU2l6ZSgpLFxyXG4gICAgICAgICAgICBjbHVzdGVyaW5nRW5hYmxlZDogdGhpcy5fbGF5ZXIuZ2V0R3JpZFNpemUoKSA9PT0gMCxcclxuICAgICAgICAgICAgbWF4Wm9vbTogdGhpcy5fbGF5ZXIuZ2V0TWF4Wm9vbSgpLFxyXG4gICAgICAgICAgICBtaW5pbXVtQ2x1c3RlclNpemU6IHRoaXMuX2xheWVyLmdldE1pbkNsdXN0ZXJTaXplKCksXHJcbiAgICAgICAgICAgIHBsYWNlbWVudE1vZGU6IHRoaXMuX2xheWVyLmlzQXZlcmFnZUNlbnRlcigpID8gQ2x1c3RlclBsYWNlbWVudE1vZGUuTWVhblZhbHVlIDogQ2x1c3RlclBsYWNlbWVudE1vZGUuRmlyc3RQaW4sXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRoaXMuX3Zpc2libGUsXHJcbiAgICAgICAgICAgIHpvb21PbkNsaWNrOiB0aGlzLl9sYXllci5pc1pvb21PbkNsaWNrKCksXHJcbiAgICAgICAgICAgIHN0eWxlczogdGhpcy5fbGF5ZXIuZ2V0U3R5bGVzKClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQm9vbGVhbi4gVHJ1ZSBpcyB0aGUgbGF5ZXIgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGVudGl0eSBmcm9tIHRoZSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyIEVudGl0eSB0byBiZSByZW1vdmVkIGZyb20gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFJlbW92ZUVudGl0eShlbnRpdHk6IE1hcmtlcik6IHZvaWQge1xyXG4gICAgICAgIGlmIChlbnRpdHkuTmF0aXZlUHJpbWl0dmUgJiYgZW50aXR5LkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGo6IG51bWJlciA9IHRoaXMuX21hcmtlcnMuaW5kZXhPZihlbnRpdHkpO1xyXG4gICAgICAgICAgICBjb25zdCBrOiBudW1iZXIgPSB0aGlzLl9wZW5kaW5nTWFya2Vycy5pbmRleE9mKGVudGl0eSk7XHJcbiAgICAgICAgICAgIGlmIChqID4gLTEpIHsgdGhpcy5fbWFya2Vycy5zcGxpY2UoaiwgMSk7IH1cclxuICAgICAgICAgICAgaWYgKGsgPiAtMSkgeyB0aGlzLl9wZW5kaW5nTWFya2Vycy5zcGxpY2UoaywgMSk7IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ2x1c3RlcmluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVtb3ZlTWFya2VyKGVudGl0eS5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLmRlbGV0ZShlbnRpdHkuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVudGl0aWVzIGZvciB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyPiBjb250YWluaW5nXHJcbiAgICAgKiB0aGUgZW50aXRpZXMgdG8gYWRkIHRvIHRoZSBjbHVzdGVyLiBUaGlzIHJlcGxhY2VzIGFueSBleGlzdGluZyBlbnRpdGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRFbnRpdGllcyhlbnRpdGllczogQXJyYXk8TWFya2VyPik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2xheWVyLmdldE1hcmtlcnMoKS5mb3JFYWNoKG0gPT4ge1xyXG4gICAgICAgICAgICBtLnNldE1hcChudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9sYXllci5jbGVhck1hcmtlcnMoKTtcclxuICAgICAgICB0aGlzLl9tYXJrZXJzLnNwbGljZSgwKTtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nTWFya2Vycy5zcGxpY2UoMCk7XHJcbiAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PEdvb2dsZU1hcFR5cGVzLk1hcmtlcj4gPSBuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTWFya2VyPigpO1xyXG4gICAgICAgIGVudGl0aWVzLmZvckVhY2goKGU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5OYXRpdmVQcmltaXR2ZSAmJiBlLkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBlLk5hdGl2ZVByaW1pdHZlLnNldE1hcChudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlckxvb2t1cC5zZXQoZS5OYXRpdmVQcmltaXR2ZSwgZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICBwLnB1c2goZS5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nTWFya2Vycy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXIuYWRkTWFya2VycyhwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wdGlvbnMgZm9yIHRoZSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIElDbHVzdGVyT3B0aW9ucyBjb250YWluaW5nIHRoZSBvcHRpb25zIGVudW1lcmF0aW9uIGNvbnRyb2xsaW5nIHRoZSBsYXllciBiZWhhdmlvci4gVGhlIHN1cHBsaWVkIG9wdGlvbnNcclxuICAgICAqIGFyZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdC9leGlzdGluZyBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSUNsdXN0ZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucGxhY2VtZW50TW9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcignR29vZ2xlTWFya2VyQ2x1c3RlcmVyOiBQbGFjZW1lbnRNb2RlIG9wdGlvbiBjYW5ub3QgYmUgc2V0IGFmdGVyIGluaXRpYWwgY3JlYXRpb24uJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy56b29tT25DbGljayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcignR29vZ2xlTWFya2VyQ2x1c3RlcmVyOiBab29tT25DbGljayBvcHRpb24gY2Fubm90IGJlIHNldCBhZnRlciBpbml0aWFsIGNyZWF0aW9uLicpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgIT0gbnVsbCkge31cclxuICAgICAgICBpZiAob3B0aW9ucy5jbHVzdGVyaW5nRW5hYmxlZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnNldE1pbkNsdXN0ZXJTaXplKG9wdGlvbnMuY2x1c3RlcmluZ0VuYWJsZWQgPyAxIDogMTAwMDAwMDApO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllci5yZXNldFZpZXdwb3J0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnJlZHJhdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5ncmlkU2l6ZSAhPSBudWxsICYmIChvcHRpb25zLmNsdXN0ZXJpbmdFbmFibGVkID09IG51bGwgfHwgb3B0aW9ucy5jbHVzdGVyaW5nRW5hYmxlZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIuc2V0R3JpZFNpemUob3B0aW9ucy5ncmlkU2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnJlc2V0Vmlld3BvcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVkcmF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLm1heFpvb20gIT0gbnVsbCkgeyB0aGlzLl9sYXllci5zZXRNYXhab29tKG9wdGlvbnMubWF4Wm9vbSk7IH1cclxuICAgICAgICBpZiAob3B0aW9ucy5taW5pbXVtQ2x1c3RlclNpemUgIT0gbnVsbCkgeyB0aGlzLl9sYXllci5zZXRNaW5DbHVzdGVyU2l6ZShvcHRpb25zLm1pbmltdW1DbHVzdGVyU2l6ZSk7IH1cclxuICAgICAgICBpZiAob3B0aW9ucy5zdHlsZXMgIT0gbnVsbCkgeyB0aGlzLl9sYXllci5zZXRTdHlsZXMob3B0aW9ucy5zdHlsZXMpOyB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmlzaWJsZSAhPSBudWxsKSB7IHRoaXMuU2V0VmlzaWJsZShvcHRpb25zLnZpc2libGUpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUb2dnbGVzIHRoZSBjbHVzdGVyIGxheWVyIHZpc2liaWxpdHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZpc2libGUgQm9vbGVhbiB0cnVlIHRvIG1ha2UgdGhlIGxheWVyIHZpc2libGUsIGZhbHNlIHRvIGhpZGUgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwID0gdmlzaWJsZSA/IHRoaXMuX2xheWVyLmdldE1hcCgpIDogbnVsbDtcclxuICAgICAgICBpZiAoIXZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVzZXRWaWV3cG9ydCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHA6IEFycmF5PEdvb2dsZU1hcFR5cGVzLk1hcmtlcj4gPSBuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTWFya2VyPigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ01hcmtlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMuZm9yRWFjaChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5OYXRpdmVQcmltaXR2ZSAmJiBlLkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAucHVzaCg8R29vZ2xlTWFwVHlwZXMuTWFya2VyPmUuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuYWRkTWFya2VycyhwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMgPSB0aGlzLl9tYXJrZXJzLmNvbmNhdCh0aGlzLl9wZW5kaW5nTWFya2Vycy5zcGxpY2UoMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVkcmF3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCB0byBhY3R1YWxseSBjbHVzdGVyIHRoZSBlbnRpdGllcyBpbiBhIGNsdXN0ZXIgbGF5ZXIuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGluaXRpYWwgc2V0IG9mIGVudGl0aWVzXHJcbiAgICAgKiBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNsdXN0ZXIuIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgYXMgYWRkaW5nIGFuIGVudGl0aXkgd2lsbCByZWNhbGN1bGF0ZSBhbGwgY2x1c3RlcnMuXHJcbiAgICAgKiBBcyBzdWNoLCBTdG9wQ2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgbWFueSBlbnRpdGllcyBhbmQgU3RhcnRDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgb25jZSBhZGRpbmcgaXNcclxuICAgICAqIGNvbXBsZXRlIHRvIHJlY2FsY3VsYXRlIHRoZSBjbHVzdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTdGFydENsdXN0ZXJpbmcoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2x1c3RlcmluZykgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTWFya2VyPiA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5NYXJrZXI+KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtlcnMuZm9yRWFjaChlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlLk5hdGl2ZVByaW1pdHZlICYmIGUuTG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBwLnB1c2goPEdvb2dsZU1hcFR5cGVzLk1hcmtlcj5lLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdNYXJrZXJzLmZvckVhY2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5OYXRpdmVQcmltaXR2ZSAmJiBlLkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKDxHb29nbGVNYXBUeXBlcy5NYXJrZXI+ZS5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllci5hZGRNYXJrZXJzKHApO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJzID0gdGhpcy5fbWFya2Vycy5jb25jYXQodGhpcy5fcGVuZGluZ01hcmtlcnMuc3BsaWNlKDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fdmlzaWJsZSkge1xyXG4gICAgICAgICAgICAvLyBvbmx5IGFkZCB0aGUgbWFya2VycyBpZiB0aGUgbGF5ZXIgaXMgdmlzaWJsZS4gT3RoZXJ3aXNlLCBrZWVwIHRoZW0gcGVuZGluZy4gVGhleSB3b3VsZCBiZSBhZGRlZCBvbmNlIHRoZVxyXG4gICAgICAgICAgICAvLyBsYXllciBpcyBzZXQgdG8gdmlzaWJsZS5cclxuICAgICAgICAgICAgdGltZXIoMCkuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyLnJlc2V0Vmlld3BvcnQodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc0NsdXN0ZXJpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcCB0byBhY3R1YWxseSBjbHVzdGVyIHRoZSBlbnRpdGllcyBpbiBhIGNsdXN0ZXIgbGF5ZXIuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIGFzIGFkZGluZyBhbiBlbnRpdGl5IHdpbGwgcmVjYWxjdWxhdGUgYWxsIGNsdXN0ZXJzLlxyXG4gICAgICogQXMgc3VjaCwgU3RvcENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgYWRkaW5nIG1hbnkgZW50aXRpZXMgYW5kIFN0YXJ0Q2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIG9uY2UgYWRkaW5nIGlzXHJcbiAgICAgKiBjb21wbGV0ZSB0byByZWNhbGN1bGF0ZSB0aGUgY2x1c3RlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTdG9wQ2x1c3RlcmluZygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzQ2x1c3RlcmluZykgeyByZXR1cm47IH1cclxuICAgICAgICB0aGlzLl9pc0NsdXN0ZXJpbmcgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBHb29nbGVNYXJrZXJDbHVzdGVyZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1tYXJrZXItY2x1c3RlcmVyJztcclxuaW1wb3J0IHsgR29vZ2xlSW5mb1dpbmRvdyB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWluZm8td2luZG93JztcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcEFQSUxvYWRlciB9IGZyb20gJy4uL21hcGFwaWxvYWRlcic7XHJcbmltcG9ydCB7IEdvb2dsZU1hcEFQSUxvYWRlciwgR29vZ2xlTWFwQVBJTG9hZGVyQ29uZmlnIH0gZnJvbSAnLi9nb29nbGUtbWFwLWFwaS1sb2FkZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUNsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9nb29nbGUtY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTWFwT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcC1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xyXG5pbXBvcnQgeyBJU2l6ZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXNpemUnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSU1hcmtlckljb25JbmZvIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcclxuaW1wb3J0IHsgSUluZm9XaW5kb3dPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctb3B0aW9ucyc7XHJcbmltcG9ydCB7IE1hcFR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXAtdHlwZS1pZCc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IE1peGluTWFwTGFiZWxXaXRoT3ZlcmxheVZpZXcgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1sYWJlbCc7XHJcbmltcG9ydCB7IE1peGluQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWNhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgR29vZ2xlQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWNhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uLy4uL21vZGVscy9jYW52YXMtb3ZlcmxheSc7XHJcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2xheWVyJztcclxuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uLy4uL21vZGVscy9pbmZvLXdpbmRvdyc7XHJcbmltcG9ydCB7IEdvb2dsZVBvbHlnb24gfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1wb2x5Z29uJztcclxuaW1wb3J0IHsgR29vZ2xlUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1wb2x5bGluZSc7XHJcbmltcG9ydCB7IEdvb2dsZUNvbnZlcnNpb25zIH0gZnJvbSAnLi9nb29nbGUtY29udmVyc2lvbnMnO1xyXG5pbXBvcnQgeyBHb29nbGVNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1tYXJrZXInO1xyXG5pbXBvcnQgeyBHb29nbGVMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWxheWVyJztcclxuaW1wb3J0IHsgSUJveCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWJveCc7XHJcbmltcG9ydCB7IEdvb2dsZU1hcEV2ZW50c0xvb2t1cCB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWV2ZW50cy1sb29rdXAnO1xyXG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5cclxuZGVjbGFyZSBjb25zdCBnb29nbGU6IGFueTtcclxuZGVjbGFyZSBjb25zdCBNYXJrZXJDbHVzdGVyZXI6IGFueTtcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTWFwU2VydmljZSBhYnN0cmFjdCBpbXBsZW1lbnRpbmcgYSBHb29nbGUgTWFwcyBwcm92aWRlclxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBTZXJ2aWNlIGltcGxlbWVudHMgTWFwU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgRGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICBwcml2YXRlIF9tYXA6IFByb21pc2U8R29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwPjtcclxuICAgIHByaXZhdGUgX21hcEluc3RhbmNlOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXA7XHJcbiAgICBwcml2YXRlIF9tYXBSZXNvbHZlcjogKHZhbHVlPzogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB2b2lkO1xyXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBHb29nbGVNYXBBUElMb2FkZXJDb25maWc7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgRGVmaW5pdGlvbnNcclxuICAgIC8vL1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIEdvb2dsZSBNYXAgY29udHJvbCBpbnN0YW5jZSB1bmRlcmx5aW5nIHRoZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBNYXBJbnN0YW5jZSgpOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXAgeyByZXR1cm4gdGhpcy5fbWFwSW5zdGFuY2U7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBQcm9taXNlIGZvciBhIEdvb2dsZSBNYXAgY29udHJvbCBpbnN0YW5jZSB1bmRlcmx5aW5nIHRoZSBpbXBsZW1lbnRhdGlvbi4gVXNlIHRoaXMgaW5zdGVhZCBvZiB7QGxpbmsgTWFwSW5zdGFuY2V9IGlmIHlvdVxyXG4gICAgICogYXJlIG5vdCBzdXJlIGlmIGFuZCB3aGVuIHRoZSBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTWFwUHJvbWlzZSgpOiBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4geyByZXR1cm4gdGhpcy5fbWFwOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXBzIHBoeXNpY2FsIHNpemUuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE1hcFNpemUoKTogSVNpemUge1xyXG4gICAgICAgIGlmICh0aGlzLk1hcEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsOiBIVE1MRGl2RWxlbWVudCA9IHRoaXMuTWFwSW5zdGFuY2UuZ2V0RGl2KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHM6IElTaXplID0geyB3aWR0aDogZWwub2Zmc2V0V2lkdGgsIGhlaWdodDogZWwub2Zmc2V0SGVpZ2h0IH07XHJcbiAgICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZU1hcFNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX2xvYWRlciBNYXBBUElMb2FkZXIgaW5zdGFuY2UgaW1wbGVtZW50ZWQgZm9yIEdvb2dsZSBNYXBzLiBUaGlzIGluc3RhbmNlIHdpbGwgZ2VuZXJhbGx5IGJlIGluamVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIE5nWm9uZSBvYmplY3QgdG8gZW5hYmxlIHpvbmUgYXdhcmUgcHJvbWlzZXMuIFRoaXMgd2lsbCBnZW5lcmFsbHkgYmUgaW5qZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbG9hZGVyOiBNYXBBUElMb2FkZXIsIHByaXZhdGUgX3pvbmU6IE5nWm9uZSkge1xyXG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4oXHJcbiAgICAgICAgICAgIChyZXNvbHZlOiAobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHZvaWQpID0+IHsgdGhpcy5fbWFwUmVzb2x2ZXIgPSByZXNvbHZlOyB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLl9jb25maWcgPSAoPEdvb2dsZU1hcEFQSUxvYWRlcj50aGlzLl9sb2FkZXIpLkNvbmZpZztcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kcyBhbmQgTWFwU2VydmljZSBpbnRlcmZhY2UgaW1wbGVtZW50YXRpb25cclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNhbnZhcyBvdmVybGF5IGxheWVyIHRvIHBlcmZvcm0gY3VzdG9tIGRyYXdpbmcgb3ZlciB0aGUgbWFwIHdpdGggb3V0XHJcbiAgICAgKiBzb21lIG9mIHRoZSBvdmVyaGVhZCBhc3NvY2lhdGVkIHdpdGggZ29pbmcgdGhyb3VnaCB0aGUgTWFwIG9iamVjdHMuXHJcbiAgICAgKiBAcGFyYW0gZHJhd0NhbGxiYWNrIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlYWR5IHRvIGJlXHJcbiAgICAgKiByZW5kZXJlZCBmb3IgdGhlIGN1cnJlbnQgbWFwIHZpZXcuXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgQ2FudmFzT3ZlcmxheX0gb2JqZWN0LlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZUNhbnZhc092ZXJsYXkoZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZCk6IFByb21pc2U8Q2FudmFzT3ZlcmxheT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheTogR29vZ2xlQ2FudmFzT3ZlcmxheSA9IG5ldyBHb29nbGVDYW52YXNPdmVybGF5KGRyYXdDYWxsYmFjayk7XHJcbiAgICAgICAgICAgIG92ZXJsYXkuU2V0TWFwKG1hcCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdmVybGF5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDcmVhdGVzIGEgR29vZ2xlIG1hcCBjbHVzdGVyIGxheWVyIHdpdGhpbiB0aGUgbWFwIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBsYXllci4gU2VlIHtAbGluayBJQ2x1c3Rlck9wdGlvbnN9LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIExheWVyfSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyTGF5ZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVDbHVzdGVyTGF5ZXIob3B0aW9uczogSUNsdXN0ZXJPcHRpb25zKTogUHJvbWlzZTxMYXllcj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgbGV0IHVwZGF0ZU9wdGlvbnM6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgbWFya2VyQ2x1c3RlcmVyOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJDbHVzdGVyZXIgPSBuZXcgTWFya2VyQ2x1c3RlcmVyKG1hcCwgW10sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBjbHVzdGVyTGF5ZXIgPSBuZXcgR29vZ2xlTWFya2VyQ2x1c3RlcmVyKG1hcmtlckNsdXN0ZXJlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IElDbHVzdGVyT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIGlkOiBvcHRpb25zLmlkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBvLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZU9wdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jbHVzdGVyaW5nRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgby5jbHVzdGVyaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlT3B0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVwZGF0ZU9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNsdXN0ZXJMYXllci5TZXRPcHRpb25zKG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjbHVzdGVyTGF5ZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluZm9ybWF0aW9uIHdpbmRvdyBmb3IgYSBtYXAgcG9zaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIC0gSW5mb3dpbmRvdyBvcHRpb25zLiBTZWUge0BsaW5rIElJbmZvV2luZG93T3B0aW9uc31cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBJbmZvV2luZG93fSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBNaWNyb3NvZnQuTWFwcy5JbmZvYm94IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlSW5mb1dpbmRvdyhvcHRpb25zPzogSUluZm9XaW5kb3dPcHRpb25zKTogUHJvbWlzZTxHb29nbGVJbmZvV2luZG93PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93T3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUluZm9XaW5kb3dPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmZvV2luZG93OiBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93ID0gbmV3IGdvb2dsZS5tYXBzLkluZm9XaW5kb3cobyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgR29vZ2xlSW5mb1dpbmRvdyhpbmZvV2luZG93LCB0aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXAgbGF5ZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLiBTZWUge0BsaW5rIElMYXllck9wdGlvbnN9XHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTGF5ZXJ9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIE1pY3Jvc29mdC5NYXBzLkxheWVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlTGF5ZXIob3B0aW9uczogSUxheWVyT3B0aW9ucyk6IFByb21pc2U8TGF5ZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB7XHJcbiAgICAgICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUxheWVyKG1hcCwgdGhpcywgb3B0aW9ucy5pZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVsIC0gSFRNTCBlbGVtZW50IHRvIGhvc3QgdGhlIG1hcC5cclxuICAgICAqIEBwYXJhbSBtYXBPcHRpb25zIC0gTWFwIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIG1hcCBoYXMgYmVlbiBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVNYXAoZWw6IEhUTUxFbGVtZW50LCBtYXBPcHRpb25zOiBJTWFwT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZXIuTG9hZCgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBhcHBseSBtaXhpbnNcclxuICAgICAgICAgICAgTWl4aW5NYXBMYWJlbFdpdGhPdmVybGF5VmlldygpO1xyXG4gICAgICAgICAgICBNaXhpbkNhbnZhc092ZXJsYXkoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgbWFwIHN0YXJ0dXBcclxuICAgICAgICAgICAgaWYgKCFtYXBPcHRpb25zLm1hcFR5cGVJZCA9PSBudWxsKSB7IG1hcE9wdGlvbnMubWFwVHlwZUlkID0gTWFwVHlwZUlkLmh5YnJpZDsgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwSW5zdGFuY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5EaXNwb3NlTWFwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFwT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU9wdGlvbnMobWFwT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChlbCwgbyk7XHJcbiAgICAgICAgICAgIGlmIChtYXBPcHRpb25zLmJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgbWFwLmZpdEJvdW5kcyhHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVCb3VuZHMobWFwT3B0aW9ucy5ib3VuZHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG1hcDtcclxuICAgICAgICAgICAgdGhpcy5fbWFwUmVzb2x2ZXIobWFwKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEdvb2dsZSBtYXAgbWFya2VyIHdpdGhpbiB0aGUgbWFwIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW29wdGlvbnM9PElNYXJrZXJPcHRpb25zPnt9XSAtIE9wdGlvbnMgZm9yIHRoZSBtYXJrZXIuIFNlZSB7QGxpbmsgSU1hcmtlck9wdGlvbnN9LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIE1hcmtlcn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgTWljcm9zb2Z0Lk1hcHMuUHVzaFBpbiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZU1hcmtlcihvcHRpb25zOiBJTWFya2VyT3B0aW9ucyA9IDxJTWFya2VyT3B0aW9ucz57fSk6IFByb21pc2U8TWFya2VyPiB7XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9ICh4OiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zLCBtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCk6IEdvb2dsZU1hcmtlciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoeCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgR29vZ2xlTWFya2VyKG1hcmtlcik7XHJcbiAgICAgICAgICAgIG0uSXNGaXJzdCA9IG9wdGlvbnMuaXNGaXJzdDtcclxuICAgICAgICAgICAgbS5Jc0xhc3QgPSBvcHRpb25zLmlzTGFzdDtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2YWw6IGFueSwga2V5OiBzdHJpbmcpID0+IG0uTWV0YWRhdGEuc2V0KGtleSwgdmFsKSk7IH1cclxuICAgICAgICAgICAgbWFya2VyLnNldE1hcChtYXApO1xyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFya2VyT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU1hcmtlck9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmljb25JbmZvICYmIG9wdGlvbnMuaWNvbkluZm8ubWFya2VyVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IE1hcmtlci5DcmVhdGVNYXJrZXIob3B0aW9ucy5pY29uSW5mbyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHMpID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uaWNvbiA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQobywgbWFwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnRoZW4oeCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uaWNvbiA9IHguaWNvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQobywgbWFwKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkKG8sIG1hcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBwb2x5Z29uIHdpdGhpbiB0aGUgR29vZ2xlIE1hcCBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcG9seWdvbi4gU2VlIHtAbGluayBJUG9seWdvbk9wdGlvbnN9LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIFBvbHlnb259IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBwb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVQb2x5Z29uKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8UG9seWdvbj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuUG9seWdvbk9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5Z29uT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgcG9seWdvbjogR29vZ2xlTWFwVHlwZXMuUG9seWdvbiA9IG5ldyBnb29nbGUubWFwcy5Qb2x5Z29uKG8pO1xyXG4gICAgICAgICAgICBwb2x5Z29uLnNldE1hcChtYXApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcDogR29vZ2xlUG9seWdvbiA9IG5ldyBHb29nbGVQb2x5Z29uKHBvbHlnb24pO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHZhbDogYW55LCBrZXk6IHN0cmluZykgPT4gcC5NZXRhZGF0YS5zZXQoa2V5LCB2YWwpKTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykgeyBwLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93TGFiZWwgIT0gbnVsbCkgeyBwLlNob3dMYWJlbCA9IG9wdGlvbnMuc2hvd0xhYmVsOyB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dUb29sdGlwICE9IG51bGwpIHsgcC5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGFiZWxNYXhab29tICE9IG51bGwpIHsgcC5MYWJlbE1heFpvb20gPSBvcHRpb25zLmxhYmVsTWF4Wm9vbTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sYWJlbE1pblpvb20gIT0gbnVsbCkgeyBwLkxhYmVsTWluWm9vbSA9IG9wdGlvbnMubGFiZWxNaW5ab29tOyB9XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHBvbHlsaW5lIHdpdGhpbiB0aGUgR29vZ2xlIE1hcCBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcG9seWxpbmUuIFNlZSB7QGxpbmsgSVBvbHlsaW5lT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgUG9seWxpbmV9IG9iamVjdCAob3IgYW4gYXJyYXkgdGhlcmVmb3JlIGZvciBjb21wbGV4IHBhdGhzKVxyXG4gICAgICogd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBwb2x5bGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWxpbmUob3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiB7XHJcbiAgICAgICAgbGV0IHBvbHlsaW5lOiBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLlBvbHlsaW5lT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlsaW5lT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGF0aCAmJiBvcHRpb25zLnBhdGgubGVuZ3RoID4gMCAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGhbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICBvLnBhdGggPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQYXRocyhvcHRpb25zLnBhdGgpWzBdO1xyXG4gICAgICAgICAgICAgICAgcG9seWxpbmUgPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWxpbmUobyk7XHJcbiAgICAgICAgICAgICAgICBwb2x5bGluZS5zZXRNYXAobWFwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbCA9IG5ldyBHb29nbGVQb2x5bGluZShwb2x5bGluZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHZhbDogYW55LCBrZXk6IHN0cmluZykgPT4gcGwuTWV0YWRhdGEuc2V0KGtleSwgdmFsKSk7IH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlICYmIG9wdGlvbnMudGl0bGUgIT09ICcnKSB7IHBsLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Rvb2x0aXAgIT0gbnVsbCkgeyBwbC5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhzOiBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+PiA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZVBhdGhzKG9wdGlvbnMucGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lczogQXJyYXk8UG9seWxpbmU+ID0gbmV3IEFycmF5PFBvbHlsaW5lPigpO1xyXG4gICAgICAgICAgICAgICAgcGF0aHMuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvLnBhdGggPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lLnNldE1hcChtYXApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbCA9IG5ldyBHb29nbGVQb2x5bGluZShwb2x5bGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2YWw6IGFueSwga2V5OiBzdHJpbmcpID0+IHBsLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgJiYgb3B0aW9ucy50aXRsZSAhPT0gJycpIHsgcGwuVGl0bGUgPSBvcHRpb25zLnRpdGxlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Rvb2x0aXAgIT0gbnVsbCkgeyBwbC5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cclxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHBsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGEgbGF5ZXIgZnJvbSB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIExheWVyIHRvIGRlbGV0ZS4gU2VlIHtAbGluayBMYXllcn0uIFRoaXMgbWV0aG9kIGV4cGVjdHMgdGhlIEdvb2dsZSBzcGVjaWZpYyBMYXllciBtb2RlbCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBmdWxsZmlsbGVkIHdoZW4gdGhlIGxheWVyIGhhcyBiZWVuIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZUxheWVyKGxheWVyOiBMYXllcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIC8vIHJldHVybiByZXNvbHZlZCBwcm9taXNlIGFzIHRoZXJlIGlzIG5vIGNvbmVwdCBvZiBhIGN1c3RvbSBsYXllciBpbiBHb29nbGUuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGFvc2UgdGhlIG1hcCBhbmQgYXNzb2NpYXRlZCByZXNvdXJlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGlzcG9zZU1hcCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fbWFwID09IG51bGwgJiYgdGhpcy5fbWFwSW5zdGFuY2UgPT0gbnVsbCkgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAodGhpcy5fbWFwSW5zdGFuY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcCA9IG5ldyBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4oKHJlc29sdmU6ICgpID0+IHZvaWQpID0+IHsgdGhpcy5fbWFwUmVzb2x2ZXIgPSByZXNvbHZlOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIG1hcCBjZW50ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgZ29lIGxvY2F0aW9uIG9mIHRoZSBjZW50ZXIuIFNlZSB7QGxpbmsgSUxhdExvbmd9LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRDZW50ZXIoKTogUHJvbWlzZTxJTGF0TG9uZz4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyOiBHb29nbGVNYXBUeXBlcy5MYXRMbmcgPSBtYXAuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiA8SUxhdExvbmc+e1xyXG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IGNlbnRlci5sYXQoKSxcclxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogY2VudGVyLmxuZygpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIG1hcCBib3VuZGluZyBib3hcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgZ2VvIGxvY2F0aW9uIG9mIHRoZSBib3VuZGluZyBib3guIFNlZSB7QGxpbmsgSUJveH0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldEJvdW5kcygpOiBQcm9taXNlPElCb3g+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IG1hcC5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIDxJQm94PntcclxuICAgICAgICAgICAgICAgIG1heExhdGl0dWRlOiBib3guZ2V0Tm9ydGhFYXN0KCkubGF0KCksXHJcbiAgICAgICAgICAgICAgICBtYXhMb25naXR1ZGU6IE1hdGgubWF4KGJveC5nZXROb3J0aEVhc3QoKS5sbmcoKSwgYm94LmdldFNvdXRoV2VzdCgpLmxuZygpKSxcclxuICAgICAgICAgICAgICAgIG1pbkxhdGl0dWRlOiBib3guZ2V0U291dGhXZXN0KCkubGF0KCksXHJcbiAgICAgICAgICAgICAgICBtaW5Mb25naXR1ZGU6IE1hdGgubWluKGJveC5nZXROb3J0aEVhc3QoKS5sbmcoKSwgYm94LmdldFNvdXRoV2VzdCgpLmxuZygpKSxcclxuICAgICAgICAgICAgICAgIGNlbnRlcjogeyBsYXRpdHVkZTogYm94LmdldENlbnRlcigpLmxhdCgpLCBsb25naXR1ZGU6IGJveC5nZXRDZW50ZXIoKS5sbmcoKSB9LFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHpvb20gbGV2ZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFpvb20oKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiBtYXAuZ2V0Wm9vbSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIGEgY29udmVyc2lvbiBvZiBnZW8gY29vcmRpbmF0ZXMgdG8gcGl4ZWxzIG9uIHRoZSBtYXAgY29udHJvbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9jIC0gVGhlIGdlbyBjb29yZGluYXRlcyB0byB0cmFuc2xhdGUuXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYW4ge0BsaW5rIElQb2ludH0gaW50ZXJmYWNlIHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzLiBUaGlzIHByb21pc2UgcmVzb2x2ZXMgdG8gbnVsbFxyXG4gICAgICogaWYgdGhlIGdvZSBjb29yZGluYXRlcyBhcmUgbm90IGluIHRoZSB2aWV3IHBvcnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIExvY2F0aW9uVG9Qb2ludChsb2M6IElMYXRMb25nKTogUHJvbWlzZTxJUG9pbnQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG06IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY3Jvc3Nlc0RhdGVMaW5lOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGw6IEdvb2dsZU1hcFR5cGVzLkxhdExuZyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0KGxvYyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBtLmdldFByb2plY3Rpb24oKTtcclxuICAgICAgICAgICAgY29uc3QgczogbnVtYmVyID0gTWF0aC5wb3coMiwgbS5nZXRab29tKCkpO1xyXG4gICAgICAgICAgICBjb25zdCBiOiBHb29nbGVNYXBUeXBlcy5MYXRMbmdCb3VuZHMgPSBtLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICBpZiAoYi5nZXRDZW50ZXIoKS5sbmcoKSA8IGIuZ2V0U291dGhXZXN0KCkubG5nKCkgIHx8XHJcbiAgICAgICAgICAgICAgICBiLmdldENlbnRlcigpLmxuZygpID4gYi5nZXROb3J0aEVhc3QoKS5sbmcoKSkgeyBjcm9zc2VzRGF0ZUxpbmUgPSB0cnVlOyB9XHJcblxyXG5cclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WTogbnVtYmVyID0gcC5mcm9tTGF0TG5nVG9Qb2ludChiLmdldE5vcnRoRWFzdCgpKS55O1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRYOiBudW1iZXIgPSBwLmZyb21MYXRMbmdUb1BvaW50KGIuZ2V0U291dGhXZXN0KCkpLng7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50OiBHb29nbGVNYXBUeXBlcy5Qb2ludCA9IHAuZnJvbUxhdExuZ1RvUG9pbnQobCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBNYXRoLmZsb29yKChwb2ludC54IC0gb2Zmc2V0WCArICgoY3Jvc3Nlc0RhdGVMaW5lICYmIHBvaW50LnggPCBvZmZzZXRYKSA/IDI1NiA6IDApKSAqIHMpLFxyXG4gICAgICAgICAgICAgICAgeTogTWF0aC5mbG9vcigocG9pbnQueSAtIG9mZnNldFkpICogcylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIGEgY29udmVyc2lvbiBvZiBnZW8gY29vcmRpbmF0ZXMgdG8gcGl4ZWxzIG9uIHRoZSBtYXAgY29udHJvbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9jIC0gVGhlIGdlbyBjb29yZGluYXRlcyB0byB0cmFuc2xhdGUuXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYW4ge0BsaW5rIElQb2ludH0gaW50ZXJmYWNlIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgTG9jYXRpb25zVG9Qb2ludHMobG9jczogQXJyYXk8SUxhdExvbmc+KTogUHJvbWlzZTxBcnJheTxJUG9pbnQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgbGV0IGNyb3NzZXNEYXRlTGluZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBwID0gbS5nZXRQcm9qZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHM6IG51bWJlciA9IE1hdGgucG93KDIsIG0uZ2V0Wm9vbSgpKTtcclxuICAgICAgICAgICAgY29uc3QgYjogR29vZ2xlTWFwVHlwZXMuTGF0TG5nQm91bmRzID0gbS5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgaWYgKGIuZ2V0Q2VudGVyKCkubG5nKCkgPCBiLmdldFNvdXRoV2VzdCgpLmxuZygpICB8fFxyXG4gICAgICAgICAgICAgICAgYi5nZXRDZW50ZXIoKS5sbmcoKSA+IGIuZ2V0Tm9ydGhFYXN0KCkubG5nKCkpIHsgY3Jvc3Nlc0RhdGVMaW5lID0gdHJ1ZTsgfVxyXG5cclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WDogbnVtYmVyID0gcC5mcm9tTGF0TG5nVG9Qb2ludChiLmdldFNvdXRoV2VzdCgpKS54O1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRZOiBudW1iZXIgPSBwLmZyb21MYXRMbmdUb1BvaW50KGIuZ2V0Tm9ydGhFYXN0KCkpLnk7XHJcbiAgICAgICAgICAgIGNvbnN0IGwgPSBsb2NzLm1hcChsbCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsMTogR29vZ2xlTWFwVHlwZXMuTGF0TG5nID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb25PYmplY3QobGwpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQ6IEdvb2dsZU1hcFR5cGVzLlBvaW50ID0gcC5mcm9tTGF0TG5nVG9Qb2ludChsMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IE1hdGguZmxvb3IoKHBvaW50LnggLSBvZmZzZXRYICsgKChjcm9zc2VzRGF0ZUxpbmUgJiYgcG9pbnQueCA8IG9mZnNldFgpID8gMjU2IDogMCkpICogcyksXHJcbiAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5mbG9vcigocG9pbnQueSAtIG9mZnNldFkpICogcylcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENlbnRlcnMgdGhlIG1hcCBvbiBhIGdlbyBsb2NhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF0TG5nIC0gR2VvQ29vcmRpbmF0ZXMgYXJvdW5kIHdoaWNoIHRvIGNlbnRlciB0aGUgbWFwLiBTZWUge0BsaW5rIElMYXRMb25nfVxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBjZW50ZXIgb3BlcmF0aW9ucyBoYXMgYmVlbiBjb21wbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldENlbnRlcihsYXRMbmc6IElMYXRMb25nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjZW50ZXI6IEdvb2dsZU1hcFR5cGVzLkxhdExuZyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0KGxhdExuZyk7XHJcbiAgICAgICAgICAgIG1hcC5zZXRDZW50ZXIoY2VudGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGdlbmVyaWMgbWFwIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0TWFwT3B0aW9ucyhvcHRpb25zOiBJTWFwT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX21hcC50aGVuKChtOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFwT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIG0uc2V0T3B0aW9ucyhvKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZpZXcgb3B0aW9ucyBvZiB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFZpZXdPcHRpb25zKG9wdGlvbnM6IElNYXBPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwLnRoZW4oKG06IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ib3VuZHMpIHtcclxuICAgICAgICAgICAgICAgIG0uZml0Qm91bmRzKEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUJvdW5kcyhvcHRpb25zLmJvdW5kcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLk1hcE9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBtLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHpvb20gLSBab29tIGxldmVsIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBQcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCBvbmNlIHRoZSB6b29tIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0Wm9vbSh6b29tOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiBtYXAuc2V0Wm9vbSh6b29tKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGV2ZW50IHN1YnNjcmlwdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKGUuZy4gJ2NsaWNrJylcclxuICAgICAqIEByZXR1cm5zIC0gQW4gb2JzZXJ2YWJsZSBvZiB0eXBlIEUgdGhhdCBmaXJlcyB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFN1YnNjcmliZVRvTWFwRXZlbnQ8RT4oZXZlbnROYW1lOiBzdHJpbmcpOiBPYnNlcnZhYmxlPEU+IHtcclxuICAgICAgICBjb25zdCBnb29nbGVFdmVudE5hbWU6IHN0cmluZyA9IEdvb2dsZU1hcEV2ZW50c0xvb2t1cFtldmVudE5hbWVdO1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPEU+KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcC50aGVuKChtOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgICAgIG0uYWRkTGlzdGVuZXIoZ29vZ2xlRXZlbnROYW1lLCAoZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIubmV4dChlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyB0aGUgZ2l2ZW4gZXZlbnQgbmFtZSBvbiB0aGUgbWFwIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBFdmVudCB0byB0cmlnZ2VyLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIG9uY2UgdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVHJpZ2dlck1hcEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtKSA9PiBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKG0sIGV2ZW50TmFtZSwgbnVsbCkpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgTWFwUG9seWdvbkRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLXBvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5Z29uU2VydmljZSB9IGZyb20gJy4uL3BvbHlnb24uc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL2xheWVyLnNlcnZpY2UnO1xyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIFBvbHlnb24gU2VydmljZSBhYnN0cmFjdCBjbGFzcyBmb3IgR29vZ2xlIE1hcHMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEdvb2dsZVBvbHlnb25TZXJ2aWNlIGltcGxlbWVudHMgUG9seWdvblNlcnZpY2Uge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9wb2x5Z29uczogTWFwPE1hcFBvbHlnb25EaXJlY3RpdmUsIFByb21pc2U8UG9seWdvbj4+ID0gbmV3IE1hcDxNYXBQb2x5Z29uRGlyZWN0aXZlLCBQcm9taXNlPFBvbHlnb24+PigpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlUG9seWdvblNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuIFRoZSBjb25jcmV0ZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyU2VydmljZSAtIHtAbGluayBHb29nbGVMYXllclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBHb29nbGVMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHN1cHBvcnQgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF9sYXllclNlcnZpY2U6IExheWVyU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWVtYmVycyBhbmQgTWFya2VyU2VydmljZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWdvbiB0byBhIG1hcC4gRGVwZW5kaW5nIG9uIHRoZSBwb2x5Z29uIGNvbnRleHQsIHRoZSBwb2x5Z29uIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxyXG4gICAgICogY29ycmVjc3BvbmRpbmcgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogSVBvbHlnb25PcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogcG9seWdvbi5JZCxcclxuICAgICAgICAgICAgY2xpY2thYmxlOiBwb2x5Z29uLkNsaWNrYWJsZSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBwb2x5Z29uLkRyYWdnYWJsZSxcclxuICAgICAgICAgICAgZWRpdGFibGU6IHBvbHlnb24uRWRpdGFibGUsXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogcG9seWdvbi5GaWxsQ29sb3IsXHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBwb2x5Z29uLkZpbGxPcGFjaXR5LFxyXG4gICAgICAgICAgICBnZW9kZXNpYzogcG9seWdvbi5HZW9kZXNpYyxcclxuICAgICAgICAgICAgbGFiZWxNYXhab29tOiBwb2x5Z29uLkxhYmVsTWF4Wm9vbSxcclxuICAgICAgICAgICAgbGFiZWxNaW5ab29tOiBwb2x5Z29uLkxhYmVsTWluWm9vbSxcclxuICAgICAgICAgICAgcGF0aHM6IHBvbHlnb24uUGF0aHMsXHJcbiAgICAgICAgICAgIHNob3dMYWJlbDogcG9seWdvbi5TaG93TGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dUb29sdGlwOiBwb2x5Z29uLlNob3dUb29sdGlwLFxyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogcG9seWdvbi5TdHJva2VDb2xvcixcclxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogcG9seWdvbi5TdHJva2VPcGFjaXR5LFxyXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IHBvbHlnb24uU3Ryb2tlV2VpZ2h0LFxyXG4gICAgICAgICAgICB0aXRsZTogcG9seWdvbi5UaXRsZSxcclxuICAgICAgICAgICAgdmlzaWJsZTogcG9seWdvbi5WaXNpYmxlLFxyXG4gICAgICAgICAgICB6SW5kZXg6IHBvbHlnb24uekluZGV4LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcG9seWdvblByb21pc2U6IFByb21pc2U8UG9seWdvbj4gPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZVBvbHlnb24obyk7XHJcbiAgICAgICAgdGhpcy5fcG9seWdvbnMuc2V0KHBvbHlnb24sIHBvbHlnb25Qcm9taXNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgZGVsZWdhdGUgZm9yIGEgcG9seWdvbi5cclxuICAgICAgKlxyXG4gICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcclxuICAgICAgKiBAcGFyYW0gcG9seWdvbiAtIFRoZSB7QGxpbmsgTWFwUG9seWdvbkRpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cclxuICAgICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICAqXHJcbiAgICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25TZXJ2aWNlXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pLnRoZW4oKHA6IFBvbHlnb24pID0+IHtcclxuICAgICAgICAgICAgICAgIHAuQWRkTGlzdGVuZXIoZXZlbnROYW1lLCAoZTogVCkgPT4gdGhpcy5fem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIubmV4dChlKSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBEZWxldGVzIGEgcG9seWdvbi5cclxuICAgICAgKlxyXG4gICAgICAqIEBwYXJhbSBwb2x5Z29uIC0ge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIGhhcyBiZWVuIGRlbGV0ZWQuXHJcbiAgICAgICpcclxuICAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblNlcnZpY2VcclxuICAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pO1xyXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbS50aGVuKChsOiBQb2x5Z29uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsLkRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWdvbnMuZGVsZXRlKHBvbHlnb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIHBvbHlnb24gb24gdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElMYXRMb25nfSBjb250YWluaW5nIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIGNsaWNrZWQgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZTogTW91c2VFdmVudCB8IGFueSk6IElMYXRMb25nIHtcclxuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogZS5sYXRMbmcubGF0KCksIGxvbmdpdHVkZTogZS5sYXRMbmcubG5nKCkgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIHBvbHlnb24gbW9kZWwgZm9yIHRoZSBwb2x5Z29uIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IGZvciB3aGljaCB0byBvYnRhaW4gdGhlIHBvbHlnb24gbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIFBvbHlnb259IGltcGxlbWVudGF0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIHBsYXRmb3JtLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TmF0aXZlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5Z29uPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25zLmdldChwb2x5Z29uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcG9seWdvbiBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2x5Z29uIC0ge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJUG9seWdvbk9wdGlvbnN9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zLiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlXHJcbiAgICAgKiBvcHRpb25zIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIG9wdGlvbnMgaGF2ZSBiZWVuIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMocG9seWdvbjogTWFwUG9seWdvbkRpcmVjdGl2ZSwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25zLmdldChwb2x5Z29uKS50aGVuKChsOiBQb2x5Z29uKSA9PiB7IGwuU2V0T3B0aW9ucyhvcHRpb25zKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBQb2x5Z29uIHBhdGhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9seWdvbiAtIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25TZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pO1xyXG4gICAgICAgIGlmIChtID09IG51bGwgfHwgcG9seWdvbi5QYXRocyA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHBvbHlnb24uUGF0aHMpIHx8IHBvbHlnb24uUGF0aHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG0udGhlbigobDogUG9seWdvbikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2x5Z29uLlBhdGhzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgbC5TZXRQYXRocyhwb2x5Z29uLlBhdGhzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGwuU2V0UGF0aCg8QXJyYXk8SUxhdExvbmc+PnBvbHlnb24uUGF0aHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlsaW5lJztcclxuaW1wb3J0IHsgTWFwUG9seWxpbmVEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL21hcC1wb2x5bGluZSc7XHJcbmltcG9ydCB7IFBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4uL3BvbHlsaW5lLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9sYXllci5zZXJ2aWNlJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUG9seWxpbmUgU2VydmljZSBhYnN0cmFjdCBjbGFzcyBmb3IgR29vZ2xlIE1hcHMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEdvb2dsZVBvbHlsaW5lU2VydmljZSBpbXBsZW1lbnRzIFBvbHlsaW5lU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX3BvbHlsaW5lczogTWFwPE1hcFBvbHlsaW5lRGlyZWN0aXZlLCBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+ID1cclxuICAgICAgICBuZXcgTWFwPE1hcFBvbHlsaW5lRGlyZWN0aXZlLCBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVQb2x5bGluZVNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuIFRoZSBjb25jcmV0ZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyU2VydmljZSAtIHtAbGluayBMYXllclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBHb29nbGVMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHN1cHBvcnQgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfbGF5ZXJTZXJ2aWNlOiBMYXllclNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWVtYmVycyBhbmQgTWFya2VyU2VydmljZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gYSBtYXAuIERlcGVuZGluZyBvbiB0aGUgcG9seWxpbmUgY29udGV4dCwgdGhlIHBvbHlsaW5lIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxyXG4gICAgICogY29ycmVjc3BvbmRpbmcgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlsaW5lU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogSVBvbHlsaW5lT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgaWQ6IHBvbHlsaW5lLklkLFxyXG4gICAgICAgICAgICBjbGlja2FibGU6IHBvbHlsaW5lLkNsaWNrYWJsZSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBwb2x5bGluZS5EcmFnZ2FibGUsXHJcbiAgICAgICAgICAgIGVkaXRhYmxlOiBwb2x5bGluZS5FZGl0YWJsZSxcclxuICAgICAgICAgICAgZ2VvZGVzaWM6IHBvbHlsaW5lLkdlb2Rlc2ljLFxyXG4gICAgICAgICAgICBwYXRoOiBwb2x5bGluZS5QYXRoLFxyXG4gICAgICAgICAgICBzaG93VG9vbHRpcDogcG9seWxpbmUuU2hvd1Rvb2x0aXAsXHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBwb2x5bGluZS5TdHJva2VDb2xvcixcclxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogcG9seWxpbmUuU3Ryb2tlT3BhY2l0eSxcclxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiBwb2x5bGluZS5TdHJva2VXZWlnaHQsXHJcbiAgICAgICAgICAgIHRpdGxlOiBwb2x5bGluZS5UaXRsZSxcclxuICAgICAgICAgICAgdmlzaWJsZTogcG9seWxpbmUuVmlzaWJsZSxcclxuICAgICAgICAgICAgekluZGV4OiBwb2x5bGluZS56SW5kZXgsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwb2x5bGluZVByb21pc2U6IFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiA9IHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlUG9seWxpbmUobyk7XHJcbiAgICAgICAgdGhpcy5fcG9seWxpbmVzLnNldChwb2x5bGluZSwgcG9seWxpbmVQcm9taXNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgZGVsZWdhdGUgZm9yIGEgbGluZS5cclxuICAgICAgKlxyXG4gICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcclxuICAgICAgKiBAcGFyYW0gcG9seWxpbmUgLSBUaGUge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxyXG4gICAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgICpcclxuICAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5bGluZXMuZ2V0KHBvbHlsaW5lKS50aGVuKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeDogQXJyYXk8UG9seWxpbmU+ID0gQXJyYXkuaXNBcnJheShwKSA/IHAgOiBbcF07XHJcbiAgICAgICAgICAgICAgICB4LmZvckVhY2gobGluZSA9PiBsaW5lLkFkZExpc3RlbmVyKGV2ZW50TmFtZSwgKGU6IFQpID0+IHRoaXMuX3pvbmUucnVuKCgpID0+IG9ic2VydmVyLm5leHQoZSkpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIERlbGV0ZXMgYSBwb2x5bGluZS5cclxuICAgICAgKlxyXG4gICAgICAqIEBwYXJhbSBwb2x5bGluZSAtIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cclxuICAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlsaW5lIGhhcyBiZWVuIGRlbGV0ZWQuXHJcbiAgICAgICpcclxuICAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX3BvbHlsaW5lcy5nZXQocG9seWxpbmUpO1xyXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbS50aGVuKGwgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeDogQXJyYXk8UG9seWxpbmU+ID0gQXJyYXkuaXNBcnJheShsKSA/IGwgOiBbbF07XHJcbiAgICAgICAgICAgICAgICB4LmZvckVhY2gobGluZSA9PiAgbGluZS5EZWxldGUoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2x5bGluZXMuZGVsZXRlKHBvbHlsaW5lKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBsaW5lIG9uIHRoZSBjbGljayBsb2NhdGlvblxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlsaW5lU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZTogTW91c2VFdmVudCB8IGFueSk6IElMYXRMb25nIHtcclxuICAgICAgICBpZiAoIWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZS5sYXRMbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZS5sYXRMbmcubGF0IHx8ICFlLmxhdExuZy5sbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiBlLmxhdExuZy5sYXQoKSwgbG9uZ2l0dWRlOiBlLmxhdExuZy5sbmcoKSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgcG9seWxpbmUgbW9kZWwgZm9yIHRoZSBsaW5lIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgcG9seWxpbmUgbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIFBvbHlsaW5lfVxyXG4gICAgICogaW1wbGVtZW50YXRpb24gb2YgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm0uIEZvciBjb21wbGV4IHBhdGhzLCByZXR1cm5zIGFuIGFycmF5IG9mIHBvbHlsaW5lcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXROYXRpdmVQb2x5bGluZShwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5bGluZXMuZ2V0KHBvbHlsaW5lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcG9seWxpbmUgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9seWxpbmUgLSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJUG9seWxpbmVPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxyXG4gICAgICogb3B0aW9ucyBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgb3B0aW9ucyBoYXZlIGJlZW4gc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5bGluZVNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlLCBvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lcy5nZXQocG9seWxpbmUpLnRoZW4obCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHg6IEFycmF5PFBvbHlsaW5lPiA9IEFycmF5LmlzQXJyYXkobCkgPyBsIDogW2xdO1xyXG4gICAgICAgICAgICB4LmZvckVhY2gobGluZSA9PiBsaW5lLlNldE9wdGlvbnMob3B0aW9ucykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgUG9seWxpbmUgcGF0aFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2x5bGluZSAtIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgdXBkYXRlZC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVQb2x5bGluZShwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSk7XHJcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtLnRoZW4obCA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHg6IEFycmF5PFBvbHlsaW5lPiA9IEFycmF5LmlzQXJyYXkobCkgPyBsIDogW2xdO1xyXG4gICAgICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID1cclxuICAgICAgICAgICAgICAgIHBvbHlsaW5lLlBhdGgubGVuZ3RoID4gMCAmJiBBcnJheS5pc0FycmF5KHBvbHlsaW5lLlBhdGhbMF0pID8gPEFycmF5PEFycmF5PElMYXRMb25nPj4+cG9seWxpbmUuUGF0aCA6XHJcbiAgICAgICAgICAgICAgICA8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5bcG9seWxpbmUuUGF0aF07XHJcbiAgICAgICAgICAgIHguZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IGluZGV4KSB7IGxpbmUuU2V0UGF0aChwW2luZGV4XSk7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGwpICYmIGwubGVuZ3RoID4gcC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGwuc3BsaWNlKHAubGVuZ3RoIC0gMSkuZm9yRWFjaChsaW5lID0+IGxpbmUuRGVsZXRlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlRmFjdG9yeSB9IGZyb20gJy4uL21hcHNlcnZpY2VmYWN0b3J5JztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwQVBJTG9hZGVyLCBXaW5kb3dSZWYsIERvY3VtZW50UmVmIH0gZnJvbSAnLi4vbWFwYXBpbG9hZGVyJztcclxuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4uL21hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuLi9pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQ2x1c3RlclNlcnZpY2UgfSBmcm9tICcuLi9jbHVzdGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBQb2x5Z29uU2VydmljZSB9IGZyb20gJy4uL3BvbHlnb24uc2VydmljZSc7XHJcbmltcG9ydCB7IFBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4uL3BvbHlsaW5lLnNlcnZpY2UnO1xyXG5cclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi9nb29nbGUtbWFwLXR5cGVzJztcclxuXHJcbmltcG9ydCB7IEdvb2dsZU1hcEFQSUxvYWRlciwgR29vZ2xlTWFwQVBJTG9hZGVyQ29uZmlnIH0gZnJvbSAnLi9nb29nbGUtbWFwLWFwaS1sb2FkZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUluZm9Cb3hTZXJ2aWNlIH0gZnJvbSAnLi9nb29nbGUtaW5mb2JveC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlTWFya2VyU2VydmljZSB9IGZyb20gJy4vZ29vZ2xlLW1hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlTWFwU2VydmljZSB9IGZyb20gJy4vZ29vZ2xlLW1hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi9nb29nbGUtbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUNsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9nb29nbGUtY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlUG9seWdvblNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHb29nbGVQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1wb2x5bGluZS5zZXJ2aWNlJztcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGEgZmFjdG9yeSB0byBjcmVhdGUgdGhyZWUgbmVjZXNzYXJ5IEdvb2dsZSBNYXBzIHNwZWNpZmljIHNlcnZpY2UgaW5zdGFuY2VzLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeSBpbXBsZW1lbnRzIE1hcFNlcnZpY2VGYWN0b3J5IHtcclxuICAgIHByaXZhdGUgX21hcDogUHJvbWlzZTxHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXA+O1xyXG4gICAgcHJpdmF0ZSBfbWFwUmVzb2x2ZXI6ICh2YWx1ZT86IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4gdm9pZDtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5LlxyXG4gICAgICogQHBhcmFtIF9sb2FkZXIgLSB7QGxpbmsgTWFwQVBJTG9hZGVyfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIEdvb2dsZSBNYXAgcHJvdmlkZXIuXHJcbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgb2JqZWN0IHRvIGltcGxlbWVudCB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sb2FkZXI6IE1hcEFQSUxvYWRlciwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwID1cclxuICAgICAgICAgICAgbmV3IFByb21pc2U8R29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwPigocmVzb2x2ZTogKCkgPT4gdm9pZCkgPT4geyB0aGlzLl9tYXBSZXNvbHZlciA9IHJlc29sdmU7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzIGFuZCBNYXBTZXJ2aWNlRmFjdG9yeSBpbXBsZW1lbnRhdGlvbi5cclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgbWFwIHNlcnZpY2UgZm9yIHRoZSBHb29nbGUgTWFwcyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBNYXBTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBHb29nbGVNYXBTZXJ2aWNlfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZUZhY3RvcnlcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZSgpOiBNYXBTZXJ2aWNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZU1hcFNlcnZpY2UodGhpcy5fbG9hZGVyLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIGNsdXN0ZXIgc2VydmljZSBmb3IgdGhlIEdvb2dsZSBNYXBzIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBDbHVzdGVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlQ2x1c3RlclNlcnZpY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlQ2x1c3RlclNlcnZpY2UoX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UpOiBDbHVzdGVyU2VydmljZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVDbHVzdGVyU2VydmljZShfbWFwU2VydmljZSwgdGhpcy5fem9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoaCBpbmZvIGJveCBzZXJ2aWNlIGZvciB0aGUgR29vZ2xlIE1hcHMgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBHb29nbGVNYXBTZXJ2aWNlfS5cclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFya2VyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTWFya2VyU2VydmljZX0uXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJbmZvQm94U2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlSW5mb0JveFNlcnZpY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlSW5mb0JveFNlcnZpY2UoX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsIF9tYXJrZXJTZXJ2aWNlOiBNYXJrZXJTZXJ2aWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVJbmZvQm94U2VydmljZShfbWFwU2VydmljZSwgX21hcmtlclNlcnZpY2UsIHRoaXMuX3pvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgbGF5ZXIgc2VydmljZSBmb3IgdGhlIEdvb2dsZSBNYXBzIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBMYXllclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZUxheWVyU2VydmljZX0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVMYXllclNlcnZpY2UoX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUxheWVyU2VydmljZShfbWFwU2VydmljZSwgdGhpcy5fem9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBtYXJrZXIgc2VydmljZSBmb3IgdGhlIEdvb2dsZSBNYXBzIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXJzIC0ge0BsaW5rIExheWVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTGF5ZXJTZXJ2aWNlfS5cclxuICAgICAqIEBwYXJhbSBjbHVzdGVycyAgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlfS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIE1hcmtlclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZU1hcmtlclNlcnZpY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlTWFya2VyU2VydmljZShfbWFwU2VydmljZTogTWFwU2VydmljZSwgX2xheWVyU2VydmljZTogR29vZ2xlTGF5ZXJTZXJ2aWNlLCBfY2x1c3RlclNlcnZpY2U6IEdvb2dsZUNsdXN0ZXJTZXJ2aWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVNYXJrZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlLCBfbGF5ZXJTZXJ2aWNlLCBfY2x1c3RlclNlcnZpY2UsIHRoaXMuX3pvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgcG9seWdvbiBzZXJ2aWNlIGZvciB0aGUgR29vZ2xlIE1hcHMgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFwIGFyY2h0aWN0dXJlLlxyXG4gICAgICogQHBhcmFtIGxheWVycyAtIHtAbGluayBMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgUG9seWdvblNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWdvblNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSk6IFBvbHlnb25TZXJ2aWNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZVBvbHlnb25TZXJ2aWNlKG1hcCwgbGF5ZXJzLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIHBvbHlsaW5lIHNlcnZpY2UgZm9yIHRoZSBHb29nbGUgTWFwcyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwIC0ge0BsaW5rIE1hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGggdW5kZXJseWluZyBtYXAgYXJjaHRpY3R1cmUuXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXJzIC0ge0BsaW5rIExheWVyU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBQb2x5bGluZVNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWxpbmVTZXJ2aWNlKG1hcDogTWFwU2VydmljZSwgbGF5ZXJzOiBMYXllclNlcnZpY2UpOiBQb2x5bGluZVNlcnZpY2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgR29vZ2xlUG9seWxpbmVTZXJ2aWNlKG1hcCwgbGF5ZXJzLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHBsYWZvcm0gc3BlY2lmaWMgTWFwU2VydmljZUZhY3RvcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcGlMb2FkZXIgLSBBbiB7QGxpbmsgTWFwQVBJTG9hZGVyfSBpbnN0YW5jZS4gVGhpcyBpcyBleHBlY3RlZCB0byB0aGUgYSB7QGxpbmsgR29vZ2xlTWFwQVBJTG9hZGVyfS5cclxuICogQHBhcmFtIHpvbmUgLSBBbiBOZ1pvbmUgaW5zdGFuY2UgdG8gcHJvdmlkZSB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gKlxyXG4gKiBAcmV0dXJucyAtIEEge0BsaW5rIE1hcFNlcnZpY2VGYWN0b3J5fSBpbnN0YW5jZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeUZhY3RvcnkoYXBpTG9hZGVyOiBNYXBBUElMb2FkZXIsIHpvbmU6IE5nWm9uZSk6IE1hcFNlcnZpY2VGYWN0b3J5IHtcclxuICAgIHJldHVybiBuZXcgR29vZ2xlTWFwU2VydmljZUZhY3RvcnkoYXBpTG9hZGVyLCB6b25lKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBwbGFmb3JtIHNwZWNpZmljIE1hcExvYWRlckZhY3RvcnkuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHJldHVybnMgLSBBIHtAbGluayBNYXBBUElMb2FkZXJ9IGluc3RhbmNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEdvb2dsZU1hcExvYWRlckZhY3RvcnkoKTogTWFwQVBJTG9hZGVyIHtcclxuICAgIHJldHVybiBuZXcgR29vZ2xlTWFwQVBJTG9hZGVyKG5ldyBHb29nbGVNYXBBUElMb2FkZXJDb25maWcoKSwgbmV3IFdpbmRvd1JlZigpLCBuZXcgRG9jdW1lbnRSZWYoKSk7XHJcbn1cclxuIiwiaW1wb3J0IHsgTmdNb2R1bGUsIE1vZHVsZVdpdGhQcm92aWRlcnMsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgJ2JpbmdtYXBzJztcclxuXHJcbi8vL1xyXG4vLy8gaW1wb3J0IG1vZHVsZSBpbnRlcmZhY2VzXHJcbi8vL1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuaW1wb3J0IHsgSUluZm9XaW5kb3dBY3Rpb24gfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1hY3Rpb24nO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSU1hcE9wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2ltYXAtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pc2l6ZSc7XHJcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaXBvaW50JztcclxuaW1wb3J0IHsgSUJveCB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaWJveCc7XHJcbmltcG9ydCB7IElNYXJrZXJFdmVudCB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaW1hcmtlci1ldmVudCc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJTGF5ZXJPcHRpb25zIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pbGF5ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElDbHVzdGVyT3B0aW9ucyB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaWNsdXN0ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElTcGlkZXJDbHVzdGVyT3B0aW9ucyB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaXNwaWRlci1jbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGluZU9wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5Z29uRXZlbnQgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lwb2x5Z29uLWV2ZW50JztcclxuaW1wb3J0IHsgSVBvbHlsaW5lRXZlbnQgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lwb2x5bGluZS1ldmVudCc7XHJcbmltcG9ydCB7IElNYXBFdmVudExvb2t1cCB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaW1hcC1ldmVudC1sb29rdXAnO1xyXG5pbXBvcnQgeyBJTGFiZWxPcHRpb25zIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pbGFiZWwtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElDdXN0b21NYXBTdHlsZX0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pY3VzdG9tLW1hcC1zdHlsZSc7XHJcblxyXG4vLy9cclxuLy8vIGltcG9ydCBtb2R1bGUgbW9kZWxzXHJcbi8vL1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi9zcmMvbW9kZWxzL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL21hcmtlcic7XHJcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4vc3JjL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XHJcbmltcG9ydCB7IE1hcFR5cGVJZCB9IGZyb20gJy4vc3JjL21vZGVscy9tYXAtdHlwZS1pZCc7XHJcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2xheWVyJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4vc3JjL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuL3NyYy9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBTcGlkZXJDbHVzdGVyTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL3NwaWRlci1jbHVzdGVyLW1hcmtlcic7XHJcbmltcG9ydCB7IENsdXN0ZXJQbGFjZW1lbnRNb2RlIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2NsdXN0ZXItcGxhY2VtZW50LW1vZGUnO1xyXG5pbXBvcnQgeyBDbHVzdGVyQ2xpY2tBY3Rpb24gfSBmcm9tICcuL3NyYy9tb2RlbHMvY2x1c3Rlci1jbGljay1hY3Rpb24nO1xyXG5pbXBvcnQgeyBDYW52YXNPdmVybGF5fSBmcm9tICcuL3NyYy9tb2RlbHMvY2FudmFzLW92ZXJsYXknO1xyXG5pbXBvcnQgeyBCaW5nTGF5ZXIgfSBmcm9tICcuL3NyYy9tb2RlbHMvYmluZy9iaW5nLWxheWVyJztcclxuaW1wb3J0IHsgQmluZ0NsdXN0ZXJMYXllciB9IGZyb20gJy4vc3JjL21vZGVscy9iaW5nL2JpbmctY2x1c3Rlci1sYXllcic7XHJcbmltcG9ydCB7IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2JpbmcvYmluZy1zcGlkZXItY2x1c3Rlci1tYXJrZXInO1xyXG5pbXBvcnQgeyBCaW5nSW5mb1dpbmRvdyB9IGZyb20gJy4vc3JjL21vZGVscy9iaW5nL2JpbmctaW5mby13aW5kb3cnO1xyXG5pbXBvcnQgeyBCaW5nTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2JpbmcvYmluZy1tYXJrZXInO1xyXG5pbXBvcnQgeyBCaW5nUG9seWdvbiB9IGZyb20gJy4vc3JjL21vZGVscy9iaW5nL2JpbmctcG9seWdvbic7XHJcbmltcG9ydCB7IEJpbmdQb2x5bGluZSB9IGZyb20gJy4vc3JjL21vZGVscy9iaW5nL2JpbmctcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBCaW5nTWFwRXZlbnRzTG9va3VwIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2JpbmcvYmluZy1ldmVudHMtbG9va3VwJztcclxuaW1wb3J0IHsgQmluZ0NhbnZhc092ZXJsYXkgfSBmcm9tICcuL3NyYy9tb2RlbHMvYmluZy9iaW5nLWNhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgR29vZ2xlSW5mb1dpbmRvdyB9IGZyb20gJy4vc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLWluZm8td2luZG93JztcclxuaW1wb3J0IHsgR29vZ2xlTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtbWFya2VyJztcclxuaW1wb3J0IHsgR29vZ2xlUG9seWdvbiB9IGZyb20gJy4vc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLXBvbHlnb24nO1xyXG5pbXBvcnQgeyBHb29nbGVQb2x5bGluZSB9IGZyb20gJy4vc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLXBvbHlsaW5lJztcclxuaW1wb3J0IHsgR29vZ2xlTWFwRXZlbnRzTG9va3VwIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtZXZlbnRzLWxvb2t1cCc7XHJcbmltcG9ydCB7IEdvb2dsZUNhbnZhc092ZXJsYXkgfSBmcm9tICcuL3NyYy9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1jYW52YXMtb3ZlcmxheSc7XHJcblxyXG4vLy9cclxuLy8vIGltcG9ydCBtb2R1bGUgY29tcG9uZW50c1xyXG4vLy9cclxuaW1wb3J0IHsgTWFwQ29tcG9uZW50IH0gZnJvbSAnLi9zcmMvY29tcG9uZW50cy9tYXAnO1xyXG5pbXBvcnQgeyBNYXBNYXJrZXJEaXJlY3RpdmUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL21hcC1tYXJrZXInO1xyXG5pbXBvcnQgeyBJbmZvQm94Q29tcG9uZW50IH0gZnJvbSAnLi9zcmMvY29tcG9uZW50cy9pbmZvYm94JztcclxuaW1wb3J0IHsgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvaW5mb2JveC1hY3Rpb24nO1xyXG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbWFwLWxheWVyJztcclxuaW1wb3J0IHsgQ2x1c3RlckxheWVyRGlyZWN0aXZlIH0gZnJvbSAnLi9zcmMvY29tcG9uZW50cy9jbHVzdGVyLWxheWVyJztcclxuaW1wb3J0IHsgTWFwUG9seWdvbkRpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbWFwLXBvbHlnb24nO1xyXG5pbXBvcnQgeyBNYXBQb2x5bGluZURpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbWFwLXBvbHlsaW5lJztcclxuaW1wb3J0IHsgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL21hcC1tYXJrZXItbGF5ZXInO1xyXG5pbXBvcnQgeyBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL21hcC1wb2x5Z29uLWxheWVyJztcclxuaW1wb3J0IHsgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbWFwLXBvbHlsaW5lLWxheWVyJztcclxuXHJcbi8vL1xyXG4vLy8gaW1wb3J0IG1vZHVsZSBzZXJ2aWNlc1xyXG4vLy9cclxuaW1wb3J0IHsgTWFwU2VydmljZUZhY3RvcnkgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9tYXBzZXJ2aWNlZmFjdG9yeSc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcEFQSUxvYWRlciwgV2luZG93UmVmLCBEb2N1bWVudFJlZiB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL21hcGFwaWxvYWRlcic7XHJcbmltcG9ydCB7IEluZm9Cb3hTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvaW5mb2JveC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcmtlclNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9tYXJrZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUG9seWdvblNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9wb2x5bGluZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2VGYWN0b3J5LFxyXG4gICAgQmluZ01hcFNlcnZpY2VGYWN0b3J5RmFjdG9yeSwgQmluZ01hcExvYWRlckZhY3RvcnkgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UuZmFjdG9yeSc7XHJcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLW1hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ01hcEFQSUxvYWRlciwgQmluZ01hcEFQSUxvYWRlckNvbmZpZyB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1tYXAuYXBpLWxvYWRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0luZm9Cb3hTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLWluZm9ib3guc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLW1hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0xheWVyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0NsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLWNsdXN0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdQb2x5Z29uU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nUG9seWxpbmVTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLXBvbHlsaW5lLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHb29nbGVDbHVzdGVyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWluZm9ib3guc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUxheWVyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZU1hcEFQSUxvYWRlciwgR29vZ2xlTWFwQVBJTG9hZGVyQ29uZmlnIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtYXBpLWxvYWRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHtcclxuICAgIEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5LCBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeUZhY3RvcnksXHJcbiAgICBHb29nbGVNYXBMb2FkZXJGYWN0b3J5XHJcbn0gZnJvbSAnLi9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAuc2VydmljZS5mYWN0b3J5JztcclxuaW1wb3J0IHsgR29vZ2xlTWFwU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHb29nbGVNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXJrZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZVBvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHb29nbGVQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLXBvbHlsaW5lLnNlcnZpY2UnO1xyXG5cclxuLy8vXHJcbi8vLyBleHBvcnQgcHVibGljcyBjb21wb25lbnRzLCBtb2RlbHMsIGludGVyZmFjZXMgZXRjIGZvciBleHRlcm5hbCByZXVzZS5cclxuLy8vXHJcbmV4cG9ydCB7XHJcbiAgICBJTGF0TG9uZywgSUluZm9XaW5kb3dPcHRpb25zLCBJSW5mb1dpbmRvd0FjdGlvbiwgSVNpemUsIElNYXJrZXJPcHRpb25zLCBJQm94LCBJTWFwT3B0aW9ucywgSVBvaW50LCBJTWFya2VyRXZlbnQsIElQb2x5Z29uRXZlbnQsXHJcbiAgICBJUG9seWxpbmVFdmVudCwgSU1hcEV2ZW50TG9va3VwLCBJTWFya2VySWNvbkluZm8sIElMYXllck9wdGlvbnMsIElDbHVzdGVyT3B0aW9ucywgSVNwaWRlckNsdXN0ZXJPcHRpb25zLCBJTGluZU9wdGlvbnMsXHJcbiAgICBJUG9seWdvbk9wdGlvbnMsIElQb2x5bGluZU9wdGlvbnMsIElMYWJlbE9wdGlvbnMsIElDdXN0b21NYXBTdHlsZSwgTWFwQ29tcG9uZW50LCBJbmZvQm94Q29tcG9uZW50LCBNYXBNYXJrZXJEaXJlY3RpdmUsIE1hcFBvbHlnb25EaXJlY3RpdmUsXHJcbiAgICBNYXBQb2x5bGluZURpcmVjdGl2ZSwgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSwgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmUsIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZSwgTWFwTGF5ZXJEaXJlY3RpdmUsXHJcbiAgICBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUsIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmUsIE1hcFR5cGVJZCwgTWFya2VyLCBNYXJrZXJUeXBlSWQsIEluZm9XaW5kb3csIExheWVyLCBDbHVzdGVyUGxhY2VtZW50TW9kZSxcclxuICAgIENsdXN0ZXJDbGlja0FjdGlvbiwgU3BpZGVyQ2x1c3Rlck1hcmtlciwgUG9seWdvbiwgUG9seWxpbmUsIENhbnZhc092ZXJsYXksIE1hcFNlcnZpY2UsIE1hcFNlcnZpY2VGYWN0b3J5LCBNYXJrZXJTZXJ2aWNlLFxyXG4gICAgSW5mb0JveFNlcnZpY2UsIE1hcEFQSUxvYWRlciwgV2luZG93UmVmLCBEb2N1bWVudFJlZiwgTGF5ZXJTZXJ2aWNlLCBQb2x5Z29uU2VydmljZSwgUG9seWxpbmVTZXJ2aWNlLCBDbHVzdGVyU2VydmljZVxyXG59O1xyXG5leHBvcnQge1xyXG4gICAgQmluZ01hcFNlcnZpY2VGYWN0b3J5LCBCaW5nTWFwQVBJTG9hZGVyQ29uZmlnLCBCaW5nTWFwU2VydmljZSwgQmluZ0luZm9Cb3hTZXJ2aWNlLFxyXG4gICAgQmluZ01hcmtlclNlcnZpY2UsIEJpbmdQb2x5Z29uU2VydmljZSwgQmluZ1BvbHlsaW5lU2VydmljZSwgQmluZ01hcEFQSUxvYWRlcixcclxuICAgIEJpbmdMYXllclNlcnZpY2UsIEJpbmdDbHVzdGVyU2VydmljZSwgQmluZ0xheWVyLCBCaW5nTWFya2VyLCBCaW5nUG9seWxpbmUsIEJpbmdNYXBFdmVudHNMb29rdXAsIEJpbmdQb2x5Z29uLFxyXG4gICAgQmluZ0luZm9XaW5kb3csIEJpbmdDbHVzdGVyTGF5ZXIsIEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyLCBCaW5nQ2FudmFzT3ZlcmxheVxyXG59O1xyXG5leHBvcnQge1xyXG4gICAgR29vZ2xlQ2x1c3RlclNlcnZpY2UsIEdvb2dsZUluZm9Cb3hTZXJ2aWNlLCBHb29nbGVMYXllclNlcnZpY2UsIEdvb2dsZU1hcEFQSUxvYWRlciwgR29vZ2xlTWFwQVBJTG9hZGVyQ29uZmlnLFxyXG4gICAgR29vZ2xlTWFwU2VydmljZUZhY3RvcnksIEdvb2dsZU1hcFNlcnZpY2UsIEdvb2dsZU1hcmtlclNlcnZpY2UsIEdvb2dsZVBvbHlnb25TZXJ2aWNlLCBHb29nbGVQb2x5bGluZVNlcnZpY2UsXHJcbiAgICBHb29nbGVNYXJrZXIsIEdvb2dsZUluZm9XaW5kb3csIEdvb2dsZVBvbHlnb24sIEdvb2dsZVBvbHlsaW5lLCBHb29nbGVNYXBFdmVudHNMb29rdXAsIEdvb2dsZUNhbnZhc092ZXJsYXlcclxufTtcclxuXHJcbi8vL1xyXG4vLy8gZGVmaW5lIG1vZHVsZVxyXG4vLy9cclxuQE5nTW9kdWxlKHtcclxuICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgIE1hcExheWVyRGlyZWN0aXZlLFxyXG4gICAgICAgIE1hcENvbXBvbmVudCxcclxuICAgICAgICBNYXBNYXJrZXJEaXJlY3RpdmUsXHJcbiAgICAgICAgSW5mb0JveENvbXBvbmVudCxcclxuICAgICAgICBJbmZvQm94QWN0aW9uRGlyZWN0aXZlLFxyXG4gICAgICAgIE1hcFBvbHlnb25EaXJlY3RpdmUsXHJcbiAgICAgICAgTWFwUG9seWxpbmVEaXJlY3RpdmUsXHJcbiAgICAgICAgQ2x1c3RlckxheWVyRGlyZWN0aXZlLFxyXG4gICAgICAgIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlLFxyXG4gICAgICAgIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZSxcclxuICAgICAgICBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICBdLFxyXG4gICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXHJcbiAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxyXG4gICAgICAgIE1hcENvbXBvbmVudCxcclxuICAgICAgICBNYXBNYXJrZXJEaXJlY3RpdmUsXHJcbiAgICAgICAgTWFwUG9seWdvbkRpcmVjdGl2ZSxcclxuICAgICAgICBNYXBQb2x5bGluZURpcmVjdGl2ZSxcclxuICAgICAgICBJbmZvQm94Q29tcG9uZW50LFxyXG4gICAgICAgIEluZm9Cb3hBY3Rpb25EaXJlY3RpdmUsXHJcbiAgICAgICAgTWFwTGF5ZXJEaXJlY3RpdmUsXHJcbiAgICAgICAgQ2x1c3RlckxheWVyRGlyZWN0aXZlLFxyXG4gICAgICAgIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlLFxyXG4gICAgICAgIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZSxcclxuICAgICAgICBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNYXBNb2R1bGUge1xyXG5cclxuICAgIHN0YXRpYyBmb3JSb290KG1hcFNlcnZpY2VGYWN0b3J5PzogTWFwU2VydmljZUZhY3RvcnksIGxvYWRlcj86IE1hcEFQSUxvYWRlcik6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNYXBNb2R1bGUsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgICAgICAgICAgbWFwU2VydmljZUZhY3RvcnkgPyB7IHByb3ZpZGU6IE1hcFNlcnZpY2VGYWN0b3J5LCB1c2VWYWx1ZTogbWFwU2VydmljZUZhY3RvcnkgfSA6XHJcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBNYXBTZXJ2aWNlRmFjdG9yeSwgZGVwczogW01hcEFQSUxvYWRlciwgTmdab25lXSwgdXNlRmFjdG9yeTogQmluZ01hcFNlcnZpY2VGYWN0b3J5RmFjdG9yeSB9LFxyXG4gICAgICAgICAgICAgICAgbG9hZGVyID8geyBwcm92aWRlOiBNYXBBUElMb2FkZXIsIHVzZVZhbHVlOiBsb2FkZXIgfSA6IHsgcHJvdmlkZTogTWFwQVBJTG9hZGVyLCB1c2VGYWN0b3J5OiBCaW5nTWFwTG9hZGVyRmFjdG9yeSB9LFxyXG4gICAgICAgICAgICAgICAgRG9jdW1lbnRSZWYsXHJcbiAgICAgICAgICAgICAgICBXaW5kb3dSZWZcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGZvclJvb3RCaW5nKCk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNYXBNb2R1bGUsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBNYXBTZXJ2aWNlRmFjdG9yeSwgZGVwczogW01hcEFQSUxvYWRlciwgTmdab25lXSwgdXNlRmFjdG9yeTogQmluZ01hcFNlcnZpY2VGYWN0b3J5RmFjdG9yeSB9LFxyXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBNYXBBUElMb2FkZXIsIHVzZUZhY3Rvcnk6IEJpbmdNYXBMb2FkZXJGYWN0b3J5IH0sXHJcbiAgICAgICAgICAgICAgICBEb2N1bWVudFJlZixcclxuICAgICAgICAgICAgICAgIFdpbmRvd1JlZlxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZm9yUm9vdEdvb2dsZSgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZ01vZHVsZTogTWFwTW9kdWxlLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTWFwU2VydmljZUZhY3RvcnksIGRlcHM6IFtNYXBBUElMb2FkZXIsIE5nWm9uZV0sIHVzZUZhY3Rvcnk6IEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5RmFjdG9yeSB9LFxyXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBNYXBBUElMb2FkZXIsIHVzZUZhY3Rvcnk6IEdvb2dsZU1hcExvYWRlckZhY3RvcnkgfSxcclxuICAgICAgICAgICAgICAgIERvY3VtZW50UmVmLFxyXG4gICAgICAgICAgICAgICAgV2luZG93UmVmXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ0c2xpYl8xLl9fZXh0ZW5kcyIsImVhY2hTZXJpZXMiLCJuZXh0VGljayIsImlkIiwiR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkIiwiSW5qZWN0YWJsZSIsIkV2ZW50RW1pdHRlciIsIkRpcmVjdGl2ZSIsIklucHV0IiwiT3V0cHV0IiwiQ29tcG9uZW50IiwiVmlld0VuY2Fwc3VsYXRpb24iLCJWaWV3Q2hpbGQiLCJDb250ZW50Q2hpbGRyZW4iLCJ0aW1lciIsIlZpZXdDb250YWluZXJSZWYiLCJDb250ZW50Q2hpbGQiLCJDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSIsIk5nWm9uZSIsIkhvc3RCaW5kaW5nIiwibGF5ZXJJZCIsIk9wdGlvbmFsIiwiT2JzZXJ2YWJsZSIsIlN1YmplY3QiLCJ0c2xpYl8xLl9fdmFsdWVzIiwiREVGQVVMVF9DT05GSUdVUkFUSU9OIiwiU2NyaXB0UHJvdG9jb2wiLCJNaXhpbk1hcExhYmVsV2l0aE92ZXJsYXlWaWV3IiwiTWl4aW5DYW52YXNPdmVybGF5IiwiTmdNb2R1bGUiLCJDb21tb25Nb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFHQTs7UUFBQTs7O3lCQUhBO1FBaUZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1RUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQTZEa0IsbUJBQVk7Ozs7Ozs7Ozs7O3NCQUFDLFFBQXlCO2dCQUNoRCxRQUFRLFFBQVEsQ0FBQyxVQUFVO29CQUN2QixLQUFLLFlBQVksQ0FBQyxZQUFZLEVBQUUsT0FBTyxNQUFNLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBQzNFLEtBQUssWUFBWSxDQUFDLG1CQUFtQixFQUFFLE9BQU8sTUFBTSxDQUFDLHlCQUF5QixDQUFDLFFB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LEVBQUUsU0FBVSxtQkFBRSxFQUFFLFNBQVUsQ0FBQztvQkFDL0IscUJBQUksQ0FBQyxTQUFRLENBQUM7b0JBRWQsS0FBSyxxQkFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFO3dCQUMzRCxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNiLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ2IsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFFBQVEsR0FBRyxHQUFHLENBQUMsUUFBUSxLQUFLLEVBQUUsQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQzs0QkFDN0QsQ0FBQyxFQUFFLENBQUMsUUFBUSxHQUFHLEdBQUcsQ0FBQyxRQUFRLEtBQUssRUFBRSxDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7d0JBQ2xFLFNBQVMsSUFBSSxDQUFDLENBQUM7d0JBQ2YsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUMsUUFBUSxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQzt3QkFDeEQsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsU0FBUyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQztxQkFDOUQ7b0JBQ0QsSUFBSSxTQUFTLEtBQUssQ0FBQyxFQUFFO3dCQUNqQixDQUFDLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQzt3QkFDbEIsQ0FBQyxDQUFDLFFBQVEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUM7d0JBQ2xDLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENB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